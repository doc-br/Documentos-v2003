<!--
     The FreeBSD Documentation Project

     $FreeBSD: pt_BR.ISO8859-1/books/handbook/basics/chapter.sgml,v 1.1.1.1 2004/01/26 19:54:30 eksffa Exp $
-->

<chapter id="basics">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Chris</firstname>
	<surname>Shumway</surname>
	<contrib>Reescrito por </contrib>
      </author>
    </authorgroup>
    <!-- 10 Mar 2000 -->
  </chapterinfo>

  <title>UNIX B&aacute;sico</title>

  <sect1 id="basics-synopsis">
    <title>Sin&oacute;pse</title>
    <indexterm><primary>basics</primary></indexterm>


   <para>O cap&iacute;tulo a seguir cobrir&aacute; os comandos b&aacute;sicos e
	funcionalidades do sistema operacional FreeBSD.  A
	maioria deste material &eacute; relevante &agrave; qualquer sistema
	operacional baseado ou similar ao &unix;.  Sinta-se
	livre para pular este cap&iacute;tulo se voc&ecirc; for familiar
	com o conte&uacute;do deste material.  Se voc&ecirc; &eacute; um novo
	usu&aacute;rio FreeBSD, ent&atilde;o definitivamente voc&ecirc; deve
	ler todo este cap&iacute;tulo cuidadosamente.</para>

    <para>Ap&oacute;s a leitura deste cap&iacute;tulo, voc&ecirc; saber&aacute;:</para>

    <itemizedlist>
      <listitem>
	<para>Como usar os <quote>consoles virtuais</quote> do
	  FreeBSD.</para>
      </listitem>
      <listitem>
	<para>Como as permiss&otilde;es &unix; funcionam.</para>
      </listitem>
      <listitem>
	<para>A disposi&ccedil;&atilde;o padr&atilde;o dos sistemas de arquivos no &os;.</para>
      </listitem>
      <listitem>
	<para>Como montar e desmontar sistemas de arquivos.</para>
      </listitem>
      <listitem>
	<para>O que s&atilde;o <foreignphrase>daemons</foreignphrase>, processos e sinais.</para>
      </listitem>
      <listitem>
	<para>O que &eacute; uma <literal>shell</literal> (interpretador de comandos) e como
	modificar seu ambiente padr&atilde;o de <literal>login</literal>.</para>
      </listitem>
      <listitem>
	<para>Como utilizar editores de texto b&aacute;sicos.</para>
      </listitem>
      <listitem>
	<para>O que s&atilde;o dispositivos e n&oacute;s de dispositivos.</para>
      </listitem>
      <listitem>
	<para>Que formato bin&aacute;rio &eacute; usado no &os;.</para>
      </listitem>
      <listitem>
	<para>Como ler as p&aacute;ginas de manual para obter mais informa&ccedil;&otilde;es.</para>
      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 id="consoles">
    <title>Consoles virtuais e terminais</title>
    <indexterm><primary>consoles virtuais</primary></indexterm>
    <indexterm><primary>terminais</primary></indexterm>

    <para>O FreeBSD pode ser utilizado de v&aacute;rias maneiras.  Uma delas
	&eacute; atrav&eacute;s de comandos digitados em um terminal de texto.  Muito
	da flexibilidade e do poder de um sistema operacional &unix; &eacute;
	dispon&iacute;vel de imediato ao alcance de suas m&atilde;os, quando se
	utiliza o FreeBSD desta maneira.  Esta se&ccedil;&atilde;o descreve o que
	s&atilde;o <quote>terminais</quote> e <quote>consoles</quote> e como
	utiliza-los no FreeBSD.</para>

    <sect2 id="consoles-intro">
      <title>O Console</title>
      <indexterm><primary>console</primary></indexterm>

      <para>Se voc&ecirc; n&atilde;o configurou o FreeBSD para iniciar um ambiente
	gr&aacute;fico automaticamente durante sua inicializa&ccedil;&atilde;o, o sistema
	ir&aacute; apresentar a voc&ecirc; uma tela de <literal>login</literal> assim
	que for iniciado, logo depois que os <literal>scripts</literal> de
	inicializa&ccedil;&atilde;o forem executados.  Voc&ecirc; ver&aacute; algo similar a:</para>

      <screen>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:</screen>

      <para>A mensagem deve ser um pouco diferente em seu sistema, mas algo similar
	ser&aacute; apresentado.  As duas &uacute;ltimas linhas s&atilde;o as que n&oacute;s estamos
	especialmente interessandos no momento.  Na pen&uacute;ltima linha voc&ecirc;
	pode ler:</para>

      <programlisting>FreeBSD/i386 (pc3.example.org) (ttyv0)</programlisting>

      <para>Essa linha oferece algumas informa&ccedil;&ograve;es sobre o sistema
	que acabou de ser iniciado.  Voc&ecirc; est&aacute; olhando para um
	console <quote>FreeBSD</quote>, rodando em arquitetura Intel
	x86 ou compat&iacute;vel<footnote>
	  <para>&Eacute; isso que <literal>i386</literal> significa.  Note que mesmo
	   se voc&ecirc; n&atilde;o estiver executando o FreeBSD em um processador Intel 386,
	   esta informa&ccedil;&atilde;o ainda ser&aacute; apresentada como <literal>i386</literal>.
	   N&atilde;o trata-se do tipo de seu processador, mas sim a <quote>
	   arquitetura</quote> do processador, que &eacute; apresentada aqui.</para>
	</footnote>.  O nome desta m&aacute;quina (toda m&aacute;quina &unix; tem um nome)
	&eacute; <hostid>pc3.example.org</hostid>, e agora voc&ecirc; est&aacute; analisando
	seu console de sistema &mdash; o terminal <devicename>ttyv0
	</devicename>.</para>

      <para>Finalmente, a &uacute;ltima linha ser&aacute; sempre:</para>

      <programlisting>login:</programlisting>

      <para>Este &eacute; o local onde voc&ecirc; deve digitar seu nome de usu&aacute;rio
	(<quote>username</quote>) para logar-se no FreeBSD.  A pr&oacute;xima
	se&ccedil;&atilde;o descreve como faz&ecirc;-lo.</para>
    </sect2>

    <sect2 id="consoles-login">
      <title>Logando-se no FreeBSD</title>

	<para>FreeBSD &eacute; um sistema multiusu&aacute;rio e de multiprocessamento.
	  Esta &eacute; a descri&ccedil;&atilde;o formal normalmente
	  dada a um sistema que pode ser usado por pessoas diferentes,
	  que simult&acirc;neamento executam uma
	  s&eacute;rie de programas na mesma esta&ccedil;&atilde;o.</para>

      <para>Todo sistema multiusu&aacute;rio requer uma maneira para fazer
	distin&ccedil;&atilde;o entre um <quote>usu&aacute;rio</quote> e os outros.  No
	FreeBSD (e todo sistema operacional similar ou baseado em &unix;)
	isso &eacute; garantido com a obrigatoriedade de todo usu&aacute;rio <quote>
	logar-se</quote> ao sistema antes de poder executar qualquer
	programa.  Todo usu&aacute;rio tem um nome &uacute;nico (o <quote>username</quote>)
	e uma senha secreta pessoal (o <quote>password</quote>).  O FreeBSD
	solicitar&aacute; estas duas informa&ccedil;&otilde;es para permitir que um usu&aacute;rio
	se logue ao sistema e execute qualquer programa.</para>

      <indexterm><primary>scripts de inicializa&ccedil;&agrave;o</primary></indexterm>
      <para>Assim que o FreeBSD &eacute; iniciado e acaba de executar seus
	<literal>scripts</literal> de inicializa&ccedil;&atilde;o<footnote>
	  <para><literal>Scripts</literal> de inicializa&ccedil;&atilde;o s&atilde;o programas
	   executados automaticamente quando o FreeBSD &eacute; iniciado.  Sua
	   principal fun&ccedil;&atilde;o &eacute; configurar tudo que for necess&aacute;rio para
	   o resto do sistema funcionar, e iniciar todos os servi&ccedil;os que
	   voc&ecirc; configurou para serem executados em inst&acirc;ncia de fundo,
	   (em <foreignphrase>background</foreignphrase> realizado tarefas
	   &uacute;teis).</para>
	</footnote>, ser&aacute; apresentada a voc&ecirc; uma tela que solicitar&aacute;
	um usu&aacute;rio v&aacute;lido:</para>

      <screen>login:</screen>

      <para>Para compreens&atilde;o deste exemplo, vamos assumir que o seu nome de
	usu&aacute;rio &eacute; <username>john</username>.  Digite <literal>john</literal> na tela
	de <literal>login</literal> e aperte <keycap>Enter</keycap>.  Em seguida
	ser&aacute; apresentada a tela que solicita sua <quote>senha</quote> (o <quote>
	password</quote>):</para>

      <screen>login: <userinput>john</userinput>
Password:</screen>

      <para>Digite agora a senha do usu&aacute;rio <username>john</username> e aperte
	<keycap>Enter</keycap>.  A senha <emphasis>n&atilde;o &eacute;
	apresentada!</emphasis>  N&atilde;o &eacute; necess&aacute;rio se preocupar com isso agora.
	&Eacute; suficiente dizer que o comportamento &eacute; este por raz&otilde;es de
	seguran&ccedil;a.</para>

      <para>Se voc&ecirc; digitou sua senha corretamente, voc&ecirc; deve ter se logado
	no FreeBSD e est&aacute; pronto para testar todos os comandos
	dispon&iacute;veis.</para>

      <para>Voc&ecirc; deve ver a <acronym>MOTD</acronym>, a mensagem do dia,
	seguida do terminal de comandos (um caracter <literal>#</literal>,
	<literal>$</literal>, ou <literal>%</literal>).  Isso indica
	que voc&ecirc; se logou com sucesso no FreeBSD.</para>
    </sect2>

    <sect2 id="consoles-virtual">
      <title>Multiplos Consoles</title>

      <para>&Eacute; legal utilizar um console para executar comandos &unix;,
	mas o FreeBSD pode executar v&aacute;rios programas de uma vez.  Ter
	apenas um console onde os comandos s&atilde;o digitados pode ser
	considerado um leve desperd&iacute;cio, quando um sistema operacional como
	o FreeBSD pode rodar dezenas de programas ao mesmo tempo.
	&Eacute; a&iacute; que os <quote>consoles virtuais</quote> podem se mostrar
	muito &uacute;teis.</para>

      <para>O FreeBSD pode ser configurado para oferecer v&aacute;rios consoles
	virtuais diferentes.  Voc&ecirc; pode alternar de um para outro apertando
	um conjunto de teclas em seu teclado.  Cada console tem seu
	pr&oacute;prio canal de sa&iacute;da, e o FreeBSD cuida de redirecionar as
	entradas do console para cada console virtual e monitor, e tamb&eacute;m
	a sa&iacute;da padr&atilde;o quando voc&ecirc; alterna de um para o pr&oacute;ximo console
	virtual.</para>

      <para>Combina&ccedil;&otilde;es especiais de teclas foram reservada pelo FreeBSD
	para controlar a altern&acirc;ncia de consoles<footnote>
	  <para>Uma descri&ccedil;&atilde;o t&eacute;cnica e consider&aacute;velmente acurada de
	   todos detalhes sobre o console FreeBSD e dispositivos de
	   teclado pode ser encontrada nas p&aacute;ginas de manuais do &man.syscons.4;,
	   &man.atkbd.4;, &man.vidcontrol.1; e &man.kbdcontrol.1;.  N&atilde;o vamos
	   entrar nestes detalhes aqui, mas o leitor interessado pode sempre
	   consultar as p&aacute;ginas de manual para obter explica&ccedil;&otilde;es mais
	   detalhadas de como as coisas funcionam.</para>
	</footnote>.  Voc&ecirc; pode usar
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>,
	<keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo>, at&eacute;
	<keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo> para
	alternar entre diferentes consoles virtuais no FreeBSD.</para>

      <para>Conforme voc&ecirc; estiver alternando entre um console e outro, o
	FreeBSD se responsabiliza por salvar e restaurar o conte&uacute;do
	de de cada tela.  O resultado &eacute; uma <quote>ilus&atilde;o</quote> de
	m&uacute;ltiplas telas e teclados <quote>virtuais</quote> dispon&iacute;veis, de
	forma que voc&ecirc; possa digitar qualquer comando para o FreeBSD
	executar.  Os programas que s&atilde;o iniciados por voc&ecirc; em um
	console virtual n&atilde;o param de ser executados quando o console
	n&atilde;o est&aacute; vis&iacute;vel.  Eles continuam a ser processados quando
	acontece altern&acirc;ncia de console virtual.</para>
    </sect2>

    <sect2 id="consoles-ttys">
      <title>O arquivo <filename>/etc/ttys</filename></title>

      <para>A configura&ccedil;&atilde;o padr&atilde;o do FreeBSD iniciar&aacute; oito
	consoles virtuais.  Contudo, esta configura&ccedil;&atilde;o n&atilde;o &eacute;
	imut&aacute;vel e pode ser f&aacute;cilmente customizada de forma a
	possibilitar que o sistema seja iniciado com mais ou
	menos consoles virtuais.  O n&uacute;mero e defini&ccedil;&otilde;es
	para os consoles virtuais est&atilde;o configuradas no arquivo
	<filename>/etc/ttys</filename>.</para>

      <para>Voc&ecirc; pode usar o arquivo <filename>/etc/ttys</filename> para configurar
	consoles virtuais do FreeBSD.  Cada linha descomentada neste arquivo
	(linhas que n&atilde;o come&ccedil;am com o caracter <literal>#</literal>) cont&eacute;m
	ajustes para um &uacute;nico terminal ou console virtual.  A vers&atilde;o
	padr&atilde;o deste arquivo oferece com o FreeBSD nove consoles
	virtuais, e habilita oito deles.  S&atilde;o as linhas que come&ccedil;am
	com <literal>ttyv</literal>:</para>

      <programlisting># name getty			   type    status	  comments
#
ttyv0   "/usr/libexec/getty Pc"	 cons25 on secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"	 cons25 on secure
ttyv2   "/usr/libexec/getty Pc"	 cons25 on secure
ttyv3   "/usr/libexec/getty Pc"	 cons25 on secure
ttyv4   "/usr/libexec/getty Pc"	 cons25 on secure
ttyv5   "/usr/libexec/getty Pc"	 cons25 on secure
ttyv6   "/usr/libexec/getty Pc"	 cons25 on secure
ttyv7   "/usr/libexec/getty Pc"	 cons25 on secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>Para obter uma descri&ccedil;&atilde;o detalhada do significado de cada coluna
	deste arquivo e todas op&ccedil;&otilde;es dispon&iacute;veis para os consoles virtuais,
	consulte a p&aacute;gina de manual &man.ttys.5;.</para>
    </sect2>

    <sect2 id="consoles-singleuser">
      <title>Console de usu&aacute;rio em modo mono-usu&aacute;rio</title>

      <para>Uma descri&ccedil;&atilde;o detalhada sobre o que &eacute; o <quote>modo mono-usu&aacute;rio</quote>
	pode ser encontrada em <xref linkend="boot-singleuser">.  Vale a pena
	notar que existe apenas um console dispon&iacute;vel quando se est&aacute;
	operando o sistema em modo mono-usu&aacute;rio.  N&atilde;o existem consoles
	virtuais dispon&iacute;veis.  As configura&ccedil;&otilde;es do console em modo
	mono-usu&aacute;rio tamb&eacute;m podem ser definidas no arquivo
	<filename>/etc/ttys</filename>.  Olha na linha que come&ccedil;a
	com <literal>console</literal>:</para>

      <programlisting># name getty			   type    status	  comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none			    unknown off secure</programlisting>

      <note>
	<para>Como indicam os coment&aacute;rios acima da linha <literal>console</literal>,
	  voc&ecirc; pode editar esta linha e modificar a entrada <literal>secure</literal>
	  para <literal>insecure</literal>.  Se voc&ecirc; o fizer, quando o FreeBSD
	  iniciar em modo mono-usu&aacute;rio, ele continuar&aacute; pedindo a senha do
	  usu&aacute;rio <username>root</username>.</para>

	<para><emphasis>Seja cuidadoso ao modificar esta op&ccedil;&atilde;o para
	  <literal>insecure</literal></emphasis>.  Se voc&ecirc; esquecer
	  um dia a senha de <username>root</username>, entrar em modo
	  mono-usu&aacute;rio vai ser um pouco complicado.  Ainda &eacute; poss&iacute;vel,
	  mas ser&aacute; um pouco dif&iacute;cil para os usu&aacute;rios ainda n&atilde;o muito
	  confort&aacute;veis com o processo de inicializa&ccedil;&atilde;o do FreeBSD
	  e os programas envolvidos.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="permissions">
    <title>Permiss&otilde;es</title>
    <indexterm><primary>UNIX</primary></indexterm>

    <para>FreeBSD, como decendente direto do &unix; BSD, se baseia em in&uacute;meros
	conceitos chaves do &unix;.  O primeiro e mais citado, &eacute; que o FreeBSD
	&eacute; um sistema operacional multi-usu&aacute;rio.  O sistema pode gerenciar
	in&uacute;meros usu&aacute;rios, todos trabalhando simultaneamente em tarefas
	completamente distintas.  O sistema &eacute; respons&aacute;vel pelo compartilhamento,
	e gerencialmente apropriado de pedidos de acesso aos dispositivos de
	controle de equipamentos, perif&eacute;ricos, de mem&oacute;ria, e tempo de processamento,
	de forma justa entre os usu&aacute;rios.</para>

    <para>Pelo fato do sistema poder suportar m&uacute;ltiplos usu&aacute;rios, tudo que
	o sistema gerencia &eacute; composto de um conjunto de permiss&otilde;es que
	governam quem pode ler, escrever, e executar recursos.  Estas
	permiss&otilde;es s&atilde;o armazenadas como tr&ecirc;s octetos divididos em tr&ecirc;s
	partes, uma para o dono do arquivo, uma para o grupo &agrave; que o
	arquivo pertence, e uma para todos os outros usu&aacute;rios.  Sua
	representa&ccedil;&atilde;o num&eacute;rica funcionam assim:</para>

    <indexterm><primary>permiss&otilde;es</primary></indexterm>
    <indexterm>
      <primary>permiss&otilde;es de arquivos</primary>
    </indexterm>
    <informaltable frame="none">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Valor</entry>
	    <entry>Permiss&otilde;es</entry>
	    <entry>Listagem de diret&oacute;rio</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>Sem leitura, sem escrita, sem execuss&atilde;o</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>Sem leitura, sem escrita, com execuss&atilde;o</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>Sem leitura, com escrita, sem execuss&atilde;o</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>Sem leitura, com escrita, com execuss&atilde;o</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>Com leitura, sem escrita, sem execuss&atilde;o</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>Com leitura, sem escrita, com execuss&atilde;o</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>Com leitura, com escrita, sem execuss&atilde;o</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>Com leitura, com escrita, com execuss&atilde;o</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    <indexterm>
      <primary><command>ls</command></primary>
    </indexterm>
    <indexterm><primary>directories</primary></indexterm>

    <para>A op&ccedil;&atilde;o <option>-l</option> pode ser usada junto ao
	&man.ls.1; para visualizar listagem detalhada do diret&oacute;rio
	incluindo uma coluna com informa&ccedil;&otilde;es sobre as permiss&otilde;es
	de cada arquivo, para o dono, grupo, e outros.  Por exemplo,
	a sa&iacute;da do comando <command>ls -l</command> em um
	diret&oacute;rio qualquer, mostrar&aacute;:</para>

    <screen>&prompt.user; <userinput>ls -l</userinput>
total 530
-rw-r--r--  1 root wheel     512 Sep 5 12:31 myfile
-rw-r--r--  1 root wheel     512 Sep 5 12:31 otherfile
-rw-r--r--  1 root wheel    7680 Sep 5 12:31 email.txt
...</screen>

    <para>Aqui est&aacute; a forma como a primeira coluna do <command>ls -l</command>
	&eacute; dividida:</para>

    <screen>-rw-r--r--</screen>

    <para>O primeiro caracter (o mais &agrave; esquerda) indica que
	se este &eacute; um arquivo normal, se &eacute; um diret&oacute;rio, um dispositivo
	especial, um <literal>socket</literal> ou qualquer outro
	pseudo-dispositivo especial.  Nesse caso, o <literal>-</literal>
	indica que trata-se de um arquivo regular.  Os pr&oacute;ximos tr&ecirc;s
	caracteres, <literal>rw-</literal> neste exemplo, indicam as
	permiss&otilde;es para o dono do arquivo.  Os pr&oacute;ximos tr&ecirc;s caracteres,
	<literal>r--</literal>, indicam as permiss&otilde;es para o grupo
	ao qual o arquivo pertence.  Os tr&ecirc;s caracteres finais,
	<literal>r--</literal>, indicam as permissoes para o resto
	do mundo.  Um h&iacute;fen indica que a permiss&atilde;o est&aacute; desligada.
	No caso deste arquivo, o dono pode ler e escrever neste arquivo, o
	grupo pode ler o arquivo e o resto do mundo pode tamb&eacute;m apenas ler
	o arquivo.  De acordo com a tabela acima, as permiss&otilde;es para
	o arquivo seriam <literal>644</literal>, onde cada d&iacute;gito
	representa as tr&ecirc;s partes das permiss&otilde;es do arquivo.</para>

    <para>Isso &eacute; muito bonito e legal, mas como o sistema controla
	as permiss&otilde;es nos dispositivos?  FreeBSD na verdade trata
	a maioria dos dispositivos de <literal>hardware</literal>
	como arquivos onde os programas podem ler, abrir, e escrever dados,
	como se fosse qualquer outro arquivo.  Estes arquivos de dispositivos
	s&atilde;o armazenados no diret&oacute;rio <filename>/dev</filename>.</para>

    <para>Diret&oacute;rios tamb&eacute;m s&atilde;o tratados como arquivos comuns.  Eles tem
	permiss&otilde;es de leitura, escrita e execuss&atilde;o.  O <firstterm>bit</firstterm>
	de execuss&atilde;o em um diret&oacute;rio tem uma sut&iacute;l diferen&ccedil;a quando
	comparado a um arquivo.  Quando um diret&oacute;rio &eacute; definido como
	execut&aacute;vel, significa que ele pode ser explorado, ou seja, que &eacute;
	poss&iacute;vel entrar neste diret&oacute;rio (<quote>cd</quote>).  Tamb&eacute;m
	significa que dentro do diret&oacute;rio, pode-se acessar arquivos cujos
	nomes s&atilde;o conhecidos (de acordo com as permiss&otilde;es dos pr&oacute;prios
	arquivos, &eacute; claro).</para>

    <para>Em particular, para realizar a listagem de um diret&oacute;rio,
	&eacute; necess&aacute;rio ter permiss&otilde;es de leitura no mesmo, enquanto
	para apagar um arquivo cujo nome j&aacute; &eacute; conhecido, &eacute;
	necess&aacute;rio ter permiss&otilde;es de escrita <emphasis>e</emphasis>
	execuss&atilde;o no diret&oacute;rio onde est&aacute; o arquivo.</para>

    <para>Existem outros bits de permiss&otilde;es, mas eles s&atilde;o
	utilizados em circust&acirc;ncias especiais como bin&aacute;rios
	como <literal>setuid</literal> e diret&oacute;rios com
	op&ccedil;&atilde;o <literal>sticky</literal>.  Se voc&ecirc; deseja obter mais
	informa&ccedil;&otilde;es sobre as permiss&otilde;es de arquivo e como
	defini-las, d&ecirc; uma olhada na p&aacute;gina de manual
	do &man.chmod.1;.</para>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Contribu&ccedil;&atilde;o de</contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Permiss&otilde;es simb&oacute;licas</title>
      <indexterm><primary>Permiss&otilde;es</primary><secondary>simb&oacute;licas</secondary></indexterm>

      <para>Permiss&otilde;es simb&oacute;licas, as vezes se referem &agrave; express&otilde;es de permiss&otilde;es, ou
	o uso de caracteres em substitui&ccedil;&atilde;o aos valores octais que
	atribuem permiss&otilde;es aos arquivos e diret&oacute;rios.  Express&otilde;es simb&oacute;licas
	usam a sintaxe (quem) (a&ccedil;&atilde;o) (permiss&otilde;es), onde os seguintes valores
	est&atilde;o dispon&iacute;veis:</para>

      <informaltable frame="none">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Op&ccedil;&atilde;o</entry>
	      <entry>Letra</entry>
	      <entry>Representa&ccedil;&atilde;o</entry>
	    </row>
	  </thead>

	<tbody>
	  <row>
	    <entry>(quem)</entry>
	    <entry>u</entry>
	    <entry>Usu&aacute;rio</entry>
	  </row>

	  <row>
	    <entry>(quem)</entry>
	    <entry>g</entry>
	    <entry>Grupo dono</entry>
	  </row>

	  <row>
	    <entry>(quem)</entry>
	    <entry>o</entry>
	    <entry>Outros</entry>
	  </row>

	  <row>
	    <entry>(quem)</entry>
	    <entry>a</entry>
	    <entry>Todos (<quote>o mundo</quote>)</entry>
	  </row>

	  <row>
	    <entry>(a&ccedil;&atilde;o)</entry>
	    <entry>+</entry>
	    <entry>Adicionar permiss&otilde;es</entry>
	  </row>

	  <row>
	    <entry>(a&ccedil;&atilde;o)</entry>
	    <entry>-</entry>
	    <entry>Remover permiss&otilde;es</entry>
	  </row>

	  <row>
	    <entry>(a&ccedil;&atilde;o)</entry>
	    <entry>=</entry>
	    <entry>Definir permiss&otilde;es explicitamente</entry>
	  </row>

	  <row>
	    <entry>(permiss&otilde;es)</entry>
	    <entry>r</entry>
	    <entry>Leitura</entry>
	  </row>

	  <row>
	    <entry>(permiss&otilde;es)</entry>
	    <entry>w</entry>
	    <entry>Escrita</entry>
	  </row>

	  <row>
	    <entry>(permiss&otilde;es)</entry>
	    <entry>x</entry>
	    <entry>Execuss&atilde;o</entry>
	  </row>

	  <row>
	    <entry>(permiss&otilde;es)</entry>
	    <entry>t</entry>
	    <entry>Bit de <literal>sticky</literal></entry>
	  </row>

	  <row>
	    <entry>(permiss&otilde;es)</entry>
	    <entry>s</entry>
	    <entry>Define UID ou GID</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Estes valores s&atilde;o usados com o comando &man.chmod.1; exatamente
	como da forma anterior, mas sem letras.  Por exemplo, voc&ecirc;
	pode usar o seguinte comando para impedir que outros usu&aacute;rios
	deixem de acessar determinado <replaceable>ARQUIVO</replaceable>:</para>

    <screen>&prompt.user; <userinput>chmod go= ARQUIVO</userinput></screen>

    <para>Pode-se fazer uso de uma lista separado por v&iacute;rgula, quando
	se desejar que mais de uma modifica&ccedil;&atilde;o seja realizada no arquivo.
	Por exemplo, o comando &agrave; seguir remove as permiss&otilde;es de escrita
	para o grupo e <quote>todo o mundo</quote>, no <replaceable>
	ARQUIVO</replaceable>, e ent&atilde;o adiciona permiss&otilde;es de
	execuss&atilde;o &agrave; todos:</para>

    <screen>&prompt.user; <userinput>chmod go-w,a+x <replaceable>FILE</replaceable></userinput></screen>

<!--
    <para>A maioria dos usu&aacute;rios v&atilde;o perceber isso, mas &eacute; importante
	lembrar que utilizar o m&eacute;todo octal de permiss&otilde;es
	apenas definir&aacute; ou modificar&aacute; permiss&otilde;es em um
	arquivo; ele n&atilde;o os adiciona ou apaga.</para>
-->
    </sect2>
  </sect1>

  <sect1 id="dirstructure">
    <title>Estrutura de Diret&oacute;rios</title>
    <indexterm><primary>hierarquia de diret&oacute;rio</primary></indexterm>

    <para>Conhecer a hierarquia de diret&oacute;rios do FreeBSD &eacute;
	fundamental para se obter entendimento total do
	sistema.  O conceito mais importante para se assimilar
	&eacute; o conceito do diret&oacute;rio ra&iacute;z, o <quote>/</quote>.  Esse
	diret&oacute;rio &eacute; montado inicialmente no momento em que o
	sistema &eacute; carregado, e ele cont&eacute;m o sistema base necess&aacute;rio
	para preparar a entrada em modo de opera&ccedil;&atilde;o multi-usu&aacute;rio
	do sistema operacional.  O diret&oacute;rio raiz cont&eacute;m ainda
	pontos de montagem para cada outro sistema de
	arquivos que voc&ecirc; queira montar.</para>

    <para>Um ponto de montagem &eacute; um diret&oacute;rio onde sistemas de
	arquivos adicionais podem ser acoplados ao sistema de
	arquivos ra&iacute;z.  Pontos de montagem padr&atilde;o incluem
	<filename>/usr</filename>, <filename>/var</filename>,
	<filename>/mnt</filename>, e <filename>/cdrom</filename>.  Esses
	diret&oacute;rios normalmente s&atilde;o encontrados como entradas
	dispostas no arquivo <filename>/etc/fstab</filename>.  O <filename>
	/etc/fstab</filename> &eacute; uma tabela com v&aacute;rios sistemas de
	arquivos e pontos de montagem que o sistema usa como refer&ecirc;ncia.
	A maioria dos sistemas de arquivos no <filename>/etc/fstab
	</filename> s&atilde;o montados automaticamente no momento da
	inicializa&ccedil;&atilde;o, &agrave; partir do <literal>script</literal> &man.rc.8;
	a n&atilde;o ser que eles contenham a op&ccedil;&atilde;o <option>noauto</option> definida.
	Consulte a p&aacute;gina de manual do &man.fstab.5; para obter mais informa&ccedil;&otilde;es
	sobre o formato do arquivo <filename>/etc/fstab</filename> e seu
	conte&uacute;do.</para>

    <para>Uma descri&ccedil;&atilde;o completa da hierarquia do sistema de arquivos
	est&aacute; dispon&iacute;vel na p&aacute;gina de manual &man.hier.7;.  Por hora, uma
	breve descri&ccedil;&atilde;o dos diret&oacute;rios mais comuns ser&aacute; abordada:</para>

    <para>
      <informaltable frame="none">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Diret&oacute;rio</entry>
	      <entry>Descri&ccedil;&atilde;o</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><filename class="directory">/</filename></entry>
	      <entry>Diret&oacute;rio ra&iacute;z do sistema de arquivo.</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/bin/</filename></entry>
	      <entry>Utilit&aacute;rios do usu&aacute;rio, fundamentais
		para os ambientes de multi-usu&aacute;rio e mono-usu&aacute;rio.</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/boot/</filename></entry>
	      <entry>Arquivos e programas de configura&ccedil;&atilde;o que
		s&atilde;o usados durante o processo de inicializa&ccedil;&atilde;o
		do sistema operacional.</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/boot/defaults/</filename></entry>
	      <entry>Arquuivos de configura&ccedil;&atilde;o padr&atilde;o do sistema de
		inicializa&ccedil;&agrave;o, veja a p&aacute;gina de manual &man.loader.conf.5;.</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/dev/</filename></entry>
	      <entry>Dispositivos de controle; veja &man.intro.4;.</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/etc/</filename></entry>
	      <entry>Arquivos e scripts de configura&ccedil;&atilde;o do sistema.</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/etc/defaults/</filename></entry>
	      <entry>Arquivos de configura&ccedil;&atilde;o padr&atilde;o do sistema; veja &man.rc.8;.</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/etc/mail/</filename></entry>
	      <entry>Arquivos de configura&ccedil;&atilde;o para os agentes de transfer&ecirc;ncia
		de correio, como o &man.sendmail.8;.</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/etc/namedb/</filename></entry>
	      <entry>Arquivos de configura&ccedil;&atilde;o do <command>named</command>; veja
	      &man.named.8;.</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/etc/periodic/</filename></entry>
	      <entry>Scripts que s&atilde;o executados diariamente, semanalmente
		e mensalmente por meio do &man.cron.8;; veja &man.periodic.8;.</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/etc/ppp/</filename></entry>
	      <entry>Arquivos de configura&ccedil;&atilde;o do <command>ppp</command>; veja
	      &man.ppp.8;.</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/mnt/</filename></entry>
	      <entry>Diret&oacute;rio vazio normalmente utilizado pelos administradores
		de sistemas como ponto de montagem tempor&aacute;rio.</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/proc/</filename></entry>
	      <entry>Sistema de arquivos de processos; veja &man.procfs.5; e
	      &man.mount.procfs.8;.</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/root/</filename></entry>
	      <entry>Diret&oacute;rio home da conta de usu&aacute;rio
		<username>root</username>.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/sbin/</filename></entry>
	      <entry>Utilit&aacute;rios de programas e administra&ccedil;&atilde;o, fundamentais
		para os ambientes de multi-usu&aacute;rio e mono-usu&aacute;rio.</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/stand/</filename></entry>
	      <entry>Programas usados no ambiente independente.</entry>
	    </row>
	
	
	    <row>
	      <entry><filename class="directory">/tmp/</filename></entry>
	      <entry>Arquivos tempor&aacute;rios, normalmente um diret&oacute;rio
		montado em mem&oacute;ria por meio do &man.mfs.8; ( o
		conte&uacute;do do <filename class="directory">/tmp</filename> 
                normalmente <emphasis>N&Atilde;O</emphasis> &eacute; preservado
                durante uma reinicializa&ccdil;&atilde;o do sistema).</entry>
	    </row>
	
	
	    <row>
	      <entry><filename class="directory">/usr/</filename></entry>
	      <entry>A maioria dos utilit&aacute;rios e aplica&ccedil;&otilde;es de usu&aacute;rios.</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/usr/bin/</filename></entry>
	      <entry>Utilit&aacute;rios comuns, ferramentas de programa&ccedil;&atilde;o
		e aplica&ccedil;&otilde;es.</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/usr/include/</filename></entry>
	      <entry>Arquivos C padr&atilde;o de inclus&atilde;o.</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/usr/lib/</filename></entry>
	      <entry>Bibliotecas.</entry>
	    </row>
	
	
	    <row>
	      <entry><filename class="directory">/usr/libdata/</filename></entry>
	      <entry>Arquivos de dados de utilit&aacute;rios variados.</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/usr/libexec/</filename></entry>
	      <entry>Daemons & utilit&aacute;rios do sistema (executados por
		outros programas).</entry>
	    </row>
	
	    <row>
	      <entry><filename
	      class="directory">/usr/local/</filename></entry>

	      <entry>Execut&aacute;veis locais, bibliotecas, etc.  Tamb&eacute;m
		utilizado como destino padr&atilde;o para o sistema de
		Ports.  Dentro de <filename>/usr/local</filename>,
		a disposi&ccedil;&atilde;o hier&aacute;rquica geral &eacute; definida pelo
		&man.hier.7; como o definido pelo <filename>/usr</filename>.
		Exceto o diret&oacute;rio de p&aacute;ginas de manuais que s&atilde;o
		diretamente dispostas sob <filename>/usr/local</filename>
		ao inv&eacute;s de serem sobre <filename>/usr/local/share</filename>,
		e a documenta&ccedil;&atilde;o das aplica&ccedil;&otilde;es de terceiros, que ficam
		sob <filename>share/doc/<replaceable>port</replaceable></filename>.
	      </entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/usr/obj/</filename></entry>
	      <entry>Arquivo de destino dos objetos bin&aacute;rios espec&iacute;ficos
		para cada arquitetura, constribu&iacute;dos &agrave; partir da
		&aacute;rvore <filename>/usr/src</filename>.</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/usr/ports</filename></entry>
	      <entry>A Cole&ccedil;&atilde;o de Ports do FreeBSD (opcional).</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/usr/sbin/</filename></entry>
	      <entry>Daemons & utilit&aacute;rios do sistema (executados por usu&aacute;rios).</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/usr/share/</filename></entry>
	      <entry>Arquivos independentes de arquitetura.</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/usr/src/</filename></entry>
	      <entry>Arquivos de fontes locais e/ou BSD.</entry>
	    </row>
	
	    <row>
	      <entry><filename
	      class="directory">/usr/X11R6/</filename></entry>
	      <entry>Execut&aacute;veis da distribui&ccedil;&atilde;o do X11R6, bibliotecas,
		etc (opcional).</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/var/</filename></entry>
	      <entry>Arquivos de log de m&uacute;ltiplos prop&oacute;sitos, arquivos
		tempor&aacute;rios, de transi&ccedil;&atilde;o, e arquivos de bobina (spool).</entry>
	    </row>
	
	
	    <row>
	      <entry><filename class="directory">/var/log/</filename></entry>
	      <entry>Arquivos de logs variados do sistema.</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/var/mail/</filename></entry>
	      <entry>Arquivos de caixa de corr&ecirc;io dos usu&aacute;rios.</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/var/spool/</filename></entry>
	      <entry>Diret&oacute;rios de spool de impress&atilde;o e de correio.</entry>
	    </row>
	
	    <row>
	      <entry><filename class="directory">/var/tmp/</filename></entry>
	      <entry>Arquivos tempor&aacute;rios que s&atilde;o mantidos entre
		reinicializa&ccedil;&otilde;es do sistema.</entry>
	    </row>
	
	    <row>
	      <entry><filename>/var/yp</filename></entry>
	      <entry>Mapas NIS.</entry>
	    </row>

	  </tbody>
	</tgroup>
      </informaltable>
</para>

  </sect1>

  <sect1 id="disk-organization">
      <title>Organiza&ccedil;&atilde;o de disco</title>

      <para>A menor unidade organizacional que o FreeBSD utiliza
	para definir os arquivos &eacute; o nome de arquivo.  Nome de arquivos
	s&atilde;o <quote>canse-sensitive</quote>, ou seja fazem distin&ccedil;&atilde;o
	entre mai&uacute;sculas e min&uacute;scilas, o que significa que
	<filename>readme.txt</filename> e <filename>README.TXT</filename>
	s&atilde;o dois arquivos distintos.  FreeBSD n&atilde;o utiliza a extens&atilde;o
	do arquivo (<filename>.txt</filename>) para determinar se
	o arquivo &eacute; um programa ou um documento, ou ainda qualquer
	outro tipo de dado.</para>

      <para>Arquivos s&atilde;o armazenados em diret&oacute;rios.  Um diret&oacute;rio pode
	n&atilde;o conter arquivo algum, ou pode conter centenas de arquivos.  Um
	diret&oacute;rio pode ainda conter outros diret&oacute;rios, permitindo que voc&ecirc;
	construa hierarquias inteiras de diret&oacute;rios, uns dentro dos outros.
	Isso torna a organiza&ccedil;&atilde;o de seus dados muito mais f&aacute;cil.</para>

      <para>Arquivos e diret&oacute;rios s&atilde;o identificados por seu nome, seguido por
	uma barra dianteira, <literal>/</literal>, seguido de outros nomes de
	diret&oacute;rios, conforme necess&aacute;rio.  Se voc&ecirc; tem o diret&oacute;rio
	<filename>foo</filename>, e dentro dele o diret&oacute;rio
	<filename>bar</filename>, que por sua vez cont&eacute;m o arquivo
	<filename>readme.txt</filename>, ent&atilde;o o nome completo, ou
	o <firstterm>path</firstterm> para este arquivo &eacute;
	<filename>foo/bar/readme.txt</filename>.</para>

      <para>Diret&oacute;rios e arquivos s&atilde;o armazenados em um sistema de arquivos.
	Cada sistema de arquivos cont&eacute;m exatamente um diret&oacute;rio de n&iacute;vel
	hier&aacute;rquico interior, chamado de <firstterm>diret&oacute;rio raiz</firstterm>
	para o sistema de arquivos.  Este diret&oacute;rio raiz pode conter outros
	diret&oacute;rios.</para>

      <para>Certamente isso tudo &eacute; similar &agrave; qualquer outro sistema
	operacional que voc&ecirc; j&aacute; usou.  Existem algumas diferen&ccedil;as b&aacute;sicas;
	por exemplo, DOS usa a barra invertida, <literal>\</literal>, para
	separar qualquer arquivo ou nome de diret&oacute;rio, enquanto o &macos;
	utiliza o <literal>:</literal>.</para>

      <para>O FreeBSD n&atilde;o utiliza letras de dispositivos ou qualquer
	outro tipo de nome para os dispositivos do sistema de arquivos.
	Voc&ecirc; jamais escreveria <filename>c:/foo/bar/readme.txt</filename>
	no FreeBSD.</para>

      <para>Ao inv&eacute;s disso, um sistema de arquivo &eacute; definido como
	<firstterm>sistema de arquivos raiz</firstterm>.  O diret&oacute;rio
	raiz do sistema de arquivo raiz &eacute; o <literal>/</literal>.  Todo
	outro sistema de arquivos &eacute; montado (<firstterm>mounted</firstterm>)
	sob este sistema de arquivos.  N&atilde;o importa
	quantos discos existam no seu sistema FreeBSD, cada diret&oacute;rio
	&eacute; apresentado como parte do disco.</para>

      <para>Suponha que voc&ecirc; tenha tr&ecirc;s sistemas de arquivos, chamados
	<literal>A</literal>, <literal>B</literal>, e <literal>C</literal>.
	Cada sistema de arquivos tem seu pr&oacute;prio diret&oacute;rio raiz,
	que cont&eacute;m outros dois diret&oacute;rios chamados
	<literal>A1</literal>, <literal>A2</literal> (e da mesma forma
	<literal>B1</literal>, <literal>B2</literal> e
	<literal>C1</literal>, <literal>C2</literal>).</para>

      <para>Assuma <literal>A</literal> como sistema de arquivos raiz.  Se
	voc&ecirc; usou o comando <command>ls</command> para visualizar o
	conte&uacute;do deste diret&oacute;rios, voc&ecirc; veria dois subdiret&oacute;rios,
	<literal>A1</literal> e
	<literal>A2</literal>.  A &aacute;rvore de diret&oacute;rios ficaria assim:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir1" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>Todo sistema de arquivos deve ser montado em um
	diret&oacute;rio disposto em outro sistema de arquivos.
	Ent&atilde;o, suponha que voc&ecirc; tenha montado o sistema de
	arquivos  <literal>B</literal> no diret&oacute;rio <literal>A1</literal>.
	O diret&oacute;rio raiz do <literal>B</literal> substitui <literal>A1</literal>,
	e os diret&oacute;rios em <literal>B</literal> se tornam apropriadamente
	dispon&iacute;veis:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir2" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- B1
 |     |
 |     `--- B2
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>Quaisquer arquivos que estejam nos diret&oacute;rios <literal>B1</literal> ou
	<literal>B2</literal> podem ser acessados com o <literal>path</literal>
	<filename>/A1/B1</filename> ou <filename>/A1/B2</filename> conforme
	necess&aacute;rio.  Qualquer arquivo que estivesse no <filename>/A1</filename>
	foi temporariamente escondido.  Eles reaparecer&atilde;o se
	<literal>B</literal> for <firstterm>desmontado</firstterm> de
	<literal>A</literal>.</para>

      <para>Se <literal>B</literal> foi montado em <literal>A2</literal>
	ent&atilde;o o diagrama ser&aacute; parecido com:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir3" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>e os <literal>paths</literal> seriam <filename>/A2/B1</filename> e
	<filename>/A2/B2</filename> respectivamente.</para>

      <para>Os sistemas de arquivos podem ser montados em sobreposi&ccedil;&atilde;o &agrave; outros.
	Prosseguindo com o &uacute;ltimo exemplo, o sistema de arquivo <literal>C</literal>
	poderia ser montado sobre o diret&oacute;rio <literal>B1</literal> no sistema de
	arquivos  <literal>B</literal>, levando ao seguinte arranjo:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir4" format="EPS">
	</imageobject>
	
	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |     |
       |     +--- C1
       |     |
       |     `--- C2
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>Ou <literal>C</literal> poderia ser montado diretamente no
	sistema de arquivos <literal>A</literal>, sob o diret&oacute;rio
	<literal>A1</literal>:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir5" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- C1
 |     |
 |     `--- C2
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>Se voc&ecirc; tem familiaridade com o DOS, a teoria &eacute; parecida, mas n&atilde;o
	id&ecirc;ntica, ao comando <command>join</command>.</para>

      <para>Normalmente isso n&atilde;o &eacute; algo com que voc&ecirc; tenha
	que se preocupar.  Tipicamente basta criar os sistemas de
	arquivos ao instalar o FreeBSD e decidir onde monta-los, e
	depois nunca mais modifica-los, a n&atilde;o ser que voc&ecirc;
	adicione um novo disco.</para>

      <para>&Eacute; completamente poss&iacute;vel ter um sistema de arquivos raiz, e
	n&atilde;o criar mais nenhum.  Existem alguns problemas com esta abordagem
	e uma grande desvantagem.</para>

      <itemizedlist>
	<title>Benef&iacute;cios de sistemas de arquivos m&uacute;ltiplos</title>

	<listitem>
	  <para>Sistemas de arquivos distintos podem ter <firstterm>op&ccedil;&otilde;es
		de montagem</firstterm> distintas.  Por exemplo, com
		planejamento cuidadoso, o sistema de arquivos raiz
		pode ser montado como apenas-leitura, criando um ambiente
		onde ser&aacute; imposs&iacute;vel apagar ou editar arquivos cr&iacute;ticos
		inadivertidamente.  Separando sistemas de arquivos
		que podem ser escritos por todos usu&aacute;rios, como o
		<filename>/home</filename>, de outros sistemas de
		arquivos, ainda permite que eles sejam montados com
		<firstterm>nosuid</firstterm>; esta op&ccedil;&atilde;o previne
		que os bits <firstterm>suid</firstterm>/<firstterm>guid</firstterm>
		sejam atribu&iacute;dos em arquivos execut&aacute;veis, n&atilde;o tendo mais
		efeito no sistema de arquivos em quest&atilde;o, poss&iacute;velmente
		complementando a seguran&ccedil;a do ambiente.</para>
	</listitem>

	<listitem>
	  <para>O FreeBSD otimiza a disposi&ccedil;&atilde;o dos arquivos de forma
		autom&aacute;tica, dependendo de como o sistema de arquivos
		est&aacute; sendo usado.  Portanto um sistema de arquivos que
		cont&eacute;m muitos arquivos pequenos que s&atilde;o frequentemente
		escritos ter&atilde;o regras de otimiza&ccedil;&atilde;o distintas daqueles
		sistemas de arquivos com poucos, mas grandes arquivos.
		Mantendo um &uacute;nico sistema de arquivos enorme, esta
		otimiza&ccedil;&atilde;o se torna invi&aacute;vel.</para>
	</listitem>
	
	<listitem>
	  <para>Os sistemas de arquivos do FreeBSD s&atilde;o muito robustos, mesmo
		em situa&ccedil;&otilde;es de queda de energia.  Contudo, uma interrup&ccedil;&atilde;o
		de energia em um ponto cr&iacute;tico pode danificar parcialmente a
		estrutura do sistema de arquivos.  Dividir os dados em m&uacute;ltiplos
		sistemas de arquivos aumenta a possibilitado do sistema n&atilde;o
		ficar indispon&iacute;vel, tornando mais f&aacute;cil a restaura&ccedil;&atilde;o
		de c&oacute;pias de seguran&ccedil;a, caso necess&aacute;rio.</para>
	</listitem>
      </itemizedlist>

      <itemizedlist>
	<title>Benef&iacute;cios de um &uacute;nico sistema de arquivos</title>

	<listitem>
	  <para>Sistemas de arquivos tem tamanho fixo.  Se voc&ecirc; criar um
		sistema de arquivos ao instalar o FreeBSD e definir
		tamanho espec&iacute;fico, posteriormente voc&ecirc; pode descobrir
		que tem a necessidade de uma parti&ccedil;&atilde;o maior.  N&atilde;o &eacute; uma
		tarefa f&aacute;cil resolver isso, sem fazer c&oacute;pias de seguran&ccedil;a e
		recriar o sistema de arquivos com o novo tanaho e depois
		restaurar a c&oacute;pia.</para>

	  <important>
	    <para>A partir do FreeBSD&nbsp;4.4 o comando &man.growfs.8;
		passou a ser parte do sistema, o que possibilita que o tamanho
		dos sistemas de arquivos sejam incrementados na hora, acabando
		com esta limita&ccedil;&atilde;o.</para>
	  </important>
	</listitem>
      </itemizedlist>

      <para>Sistemas de arquivos s&atilde;o contidos em parti&ccedil;&otilde;es.  Isso n&atilde;o
	significa a mesma coisa do que a forma de utiliza&ccedil;&atilde;o do termo
	parti&ccedil;&atilde;o anteriormente neste cap&iacute;tulo, por causa da heran&ccedil;a
	&unix; do FreeBSD.  Cada parti&ccedil;&atilde;o &eacute; identificada com uma
	letra que varia de <literal>a</literal> &agrave; <literal>h</literal>.
	Cada parti&ccedil;&atilde;o possui um sistema de arquivos, o que significa que sistemas de
	arquivos normalmente s&atilde;o identificados ou por seu ponto
	de montagem na hierarquia do sistema de arquivos, ou pela letra
	disposta no nome de cada parti&ccedil;&atilde;o.</para>

      <para>O FreeBSD ainda usa espa&ccedil;o de disco para o <quote>espa&ccedil;o
	de troca</quote>, ou <firstterm>swap</firstterm>.  Swap oferece
	caracter&iacute;sticas de <firstterm>mem&oacute;ria virtual</firstterm> ao FreeBSD.
	Isso permite que seu computador se comporte como se tivesse
	mais mem&oacute;ria dispon&iacute;vel do que na realidade tem.  Quando o
	FreeBSD excede a mem&oacute;ria dispon&iacute;vel ele move alguns trechos de dados
	que n&atilde;o est&atilde;o sendo utilizados para o espa&ccedil;o de troca, a <literal>
	swap</literal>, e move esses dados de volta pra mem&oacute;ria (descarregando
	alguma outra coisa para liberar recursos) quando necess&aacute;rio.</para>

      <para>Algumas parti&ccedil;&otilde;es mant&eacute;m algumas conven&ccedil;&otilde;es associadas.</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <colspec colwidth="1*">
	  <colspec colwidth="5*">

	  <thead>
	    <row>
	      <entry>Parti&ccedil;&atilde;o</entry>

	      <entry>Conven&ccedil;&atilde;o</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><literal>a</literal></entry>

	      <entry>Normalmente cont&eacute;m o sistema de arquivos raiz</entry>
	    </row>

	    <row>
	      <entry><literal>b</literal></entry>

	      <entry>Normalmente cont&eacute;m a parti&ccedil;&atilde;o de swap (troca)</entry>
	    </row>

	    <row>
	      <entry><literal>c</literal></entry>

	      <entry>Normalmente tem o mesmo tamanho da parti&ccedil;&atilde;o
		inclusa.  Isso permite que alguns utilit&aacute;rios que
		precisam trabalhar na parti&ccedil;&atilde;o toda (por exemplo,
		um identificador de blocos defeituosos) funcionem
		corretamenta na parti&ccedil;&atilde;o <literal>c</literal>.  Voc&ecirc;
		n&atilde;o vai criar um sistema de arquivos de verdade
		nesta parti&ccedil;&atilde;o.</entry>
	    </row>

	    <row>
	      <entry><literal>d</literal></entry>

	      <entry>A parti&ccedil;&atilde;o <literal>d</literal> costumava ter um
		significado especial associado com ela, contudo agora
		ele desfez.  Hoje em dia algumas ferramentas podem
		continuar se comportando de forma estranha se
		indicarmos que ele trabalhe na parti&ccedil;&atilde;o
		<literal>d</literal>, de forma que o <application>sysinstall
		</application> n&atilde;o cria mais esta
		parti&ccedil;&atilde;o.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Cada parti&ccedil;&atilde;o que cont&eacute;m um sistema
	de arquivos &eacute; armazenada em um tipo especial
	de parti&ccedil;&atilde;o que o FreeBSD chama de <firstterm>slice</firstterm>.  Este
	termo &eacute; utilizado pelo FreeBSD para fazer men&ccedil;&atilde;o ao que, mais uma fez,
	costumava ser chamado de parti&ccedil;&atilde;o, e isso se deve &agrave; base &unix;
	por tr&aacute;s do sistema FreeBSD.  Estas parti&ccedil;&otilde;es (<quote>slices</quote>)
	s&atilde;o numeradas, iniciando do 1, at&eacute; o 4.</para>

	<indexterm><primary>slices</primary></indexterm>
	<indexterm><primary>parti&ccedil;&otilde;es</primary></indexterm>
	<indexterm><primary>perigosamente dedicada</primary></indexterm>

      <para>N&uacute;mero de parti&ccedil;&otilde;es seguem o nome do dispositivo
	adicionado de um prefixo com o caract&eacute;r <literal>s</literal>,
	come&ccedil;ando do 1.  Portanto <quote>da0<emphasis>s1</emphasis></quote>
	&eacute; a primeira <literal>slice</literal> de um disco, mas &eacute;
	poss&iacute;vel que existam parti&ccedil;&otilde;es l&oacute;gicas dentro de cada
	parti&ccedil;&atilde;o f&iacute;sica do tipo apropriado.  Estas parti&ccedil;&otilde;es
	extendidas s&atilde;o numeradas &agrave; partir do 5, de forma que
	<quote>ad0<emphasis>s5</emphasis></quote> seja a
	primeira parti&ccedil;&atilde;o extendida do primeiro disco IDE.
	Estes dispositivos s&atilde;o utilizados por
	sistemas de arquivos que ocupam esse tipo de
	parti&ccedil;&atilde;o.</para>

      <para>Parti&ccedil;&otilde;es, dispositivos f&iacute;sicos, <quote>perigosamente dedicados</quote>
	e outros dispositivos cont&eacute;m
	<firstterm>parti&ccedil;&otilde;es</firstterm> que costumam ser representadas como
	letras, come&ccedil;ando de <literal>a</literal> at&eacute; <literal>h</literal>.
	Estas letras s&atilde;o atribu&iacute;das ao nome dos dispositivos, de forma que
	<quote>da0<emphasis>a</emphasis></quote> indique a parti&ccedil;&atilde;o no
	primeiro dispositivo, que na realidade &eacute; <quote>perigosamente dedicado</quote>.
	<quote>ad1s3<emphasis>e</emphasis></quote> &eacute; a quinta parti&ccedil;&atilde;o
	na primeira <literal>slice</literal> do segundo dispositivo de disco IDE.<para>
	
      <para>Finalmente, cada disco no sistema esta identificado.  Um nome de disco
	come&ccedil;a com um c&oacute;digo que indica o tipo do disco em quest&atilde;o, e em seguida um n&uacute;mero,
	que indica que disco &eacute; esse.  Diferente das parti&ccedil;&otilde;es, a numera&ccedil;&atilde;o dos discos inicia
	em 0.  Informa&ccedil;&otilde;es usuais que voc&ecirc; encontrar&aacute; listados em
	<xref linkend="install-dev-codes">.</para>

      <para>Ao se referir a uma parti&ccedil;&atilde;o, o FreeBSD requer que voc&ecirc; nomeie
	cada <literal>slice</literal> e disco que contenha a parti&ccedil;&atilde;o em quest&atilde;o, e que ao se
	referir &agrave; <literal>slice</literal> voc&ecirc; tamb&eacute;m identifique o nome do disco.  Fa&ccedil;a
	isso listado o nome do disco, <literal>s</literal>, o n&uacute;mero da
	<literal>slice</literal>, e em seguida a letra da parti&ccedil;&atilde;o.  Exemplos s&atilde;o
	apresentados em <xref linkend="install-disk-slice-part">.</para>

      <para><xref linkend="install-concept-disk-model"> apresenta o modelo
	conceitual das disposi&ccedil;&otilde;es de disco, o que pode ajudar
	a tornar as coisas mais claras.</para>

      <para>Para instalar o FreeBSD, primeiro voc&ecirc; deve configurar os
	<literal>slices</literal> de disco, e depois criar as parti&ccedil;&otilde;es
	em cada <literal>slice</literal> destinada ao FreeBSD, e criar um
	sistema de arquivo (ou <literal>swap</literal>) em cada parti&ccedil;&atilde;o,
	e decidir onde o sistema de arquivos ser&aacute; montado.</para>

      <table frame="none" id="install-dev-codes">
	<title>C&oacute;digos de Dispositivos de Disco</title>

	<tgroup cols="2">
	  <colspec colwidth="1*">
	  <colspec colwidth="5*">

	  <thead>
	    <row>
	      <entry>C&oacute;digo</entry>
	
	      <entry>Significado</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><devicename>ad</devicename></entry>

	      <entry>disco ATAPI (IDE)</entry>
	    </row>

	    <row>
	      <entry><devicename>da</devicename></entry>
	
	      <entry>disco SCSI de acesso direto</entry>
	    </row>
	
	    <row>
	      <entry><devicename>acd</devicename></entry>
	
	      <entry>CDROM ATAPI (IDE)</entry>
	    </row>
	
	    <row>
	      <entry><devicename>cd</devicename></entry>
	
	      <entry>CDROM SCSI</entry>
	    </row>
	
	    <row>
	      <entry><devicename>fd</devicename></entry>
	
	      <entry>Disquete</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <example id="install-disk-slice-part">
	<title>Modelo de disco, parti&ccedil;&atilde;o e nomes</title>
	
	<informaltable frame="none">
	  <tgroup cols="2">
	    <colspec colwidth="1*">
	    <colspec colwidth="5*">

	    <thead>
	      <row>
		<entry>Nome</entry>
		
		<entry>Significado</entry>
	      </row>
	    </thead>
	
	    <tbody>
	      <row>
		<entry><literal>ad0s1a</literal></entry>
		
		<entry>Primeira parti&ccedil;&atilde;o (<literal>a</literal>) na primeira
		  fatia de disco (slice - <literal>s1</literal>) no primeiro disco IDE
		  (<literal>ad0</literal>).</entry>
	      </row>

	      <row>
		<entry><literal>da1s2e</literal></entry>
		
		<entry>Quinta parti&ccedil;&atilde;o (<literal>e</literal>) na segunda fatia
		  de disco (slice - <literal>s2</literal>) no segundo disco SCSI
		  (<literal>da1</literal>).</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </example>

      <example id="install-concept-disk-model">
	<title>Modelo conceitual de um disco</title>

	<para>Esse diagrama apresenta a abordagem do FreeBSD para o primeiro disco IDE
	  ligado ao sistema.  Assuma que o disco tem tamanho de 4&nbsp;GB e
	  cont&eacute;m duas parti&ccedil;&otilde;es de 2&nbsp;GB (parti&ccedil;&otilde;es DOS).  A primeira
	  <literal>slice</literal> cont&eacute;m um disco DOS, o <devicename>C:</devicename>,
	  e a segunda <literal>slice</literal> cont&eacute;m a instala&ccedil;&atilde;o do FreeBSD.  Esta
	  instala&ccedil;&atilde;o FreeBSD de exemplo tem tr&ecirc;s parti&ccedil;&otilde;es, e uma <literal>swap</literal>.</para>

	<para>As tr&ecirc;s parti&ccedil;&otilde;es ter&atilde;o um sistema de arquivos cada.  A parti&ccedil;&atilde;o
	  <literal>a</literal> ser&aacute; utilizada pelo sistema de arquivos raiz,
	  <literal>e</literal> ser&aacute; utilizada pela hierarquia de diret&oacute;rio
	  <filename>/var</filename>, e <literal>f</literal> pela hierarquia
	  de diret&oacute;rio <filename>/usr</filename>.</para>

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="install/disk-layout" format="EPS">
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">.-----------------.  --.
|		 |    |
|  DOS / Windows  |    |
:		 :     >  Primeira slice, ad0s1
:		 :    |
|		 |    |
:=================:  ==:			       --.
|		 |    |  Particao a, montada em  /      |
|		 |     > chamada de ad0s2a	      |
|		 |    |				 |
:-----------------:  ==:				 |
|		 |    |  Particao b, used como swap     |
|		 |     > chamada de ad0s2b	      |
|		 |    |				 |
:-----------------:  ==:				 |  Particao c, sem
|		 |    |  Particao e, usada como /var       > sistema de arquivos, toda
|		 |     > chamada de ad0s2e	      |  a particao ad0s2c do FreeBSD
|		 |    |				 |
:-----------------:  ==:				 |
|		 |    |				 |
:		 :    |  Particao f, usada como /usr    |
:		 :     > chamada de ad0s2f	      |
:		 :    |				 |
|		 |    |				 |
|		 |  --'				 |
`-----------------'				    --'</literallayout>
	  </textobject>
	</mediaobject>
      </example>
  </sect1>



  <sect1 id="mount-unmount">
    <title>Montando e desmontando sistemas de arquivos</title>

    <para>O sistema de arquivos pode ser melhor assimilado se for visualizado
	como uma &aacute;rvore, cuja raiz &eacute; <filename>/</filename>.
	<filename>/dev</filename>, <filename>/usr</filename>, e outros
	diret&oacute;rios na raiz, s&atilde;o os ramos da &aacute;rvore, que podem ainda ter seus
	pr&oacute;prios ramos, como <filename>/usr/local</filename>, e assim por diante.</para>

    <indexterm><primary>sistema de arquivos raiz</primary></indexterm>
    <para>Existem v&aacute;rios motivos para armazenar alguns destes diret&oacute;rios
	em sistemas de arquivos distintos.  <filename>/var</filename>
	cont&eacute;m os diret&oacute;rios <filename>log/</filename>,
	<filename>spool/</filename>,
	e v&aacute;rios tipos de arquivos tempor&aacute;rios, e como tal, pode
	f&aacute;cilmente encher.  Encher o sistema de arquivos raiz
	n&atilde;o &eacute; uma boa id&eacute;ia, de forma que separar o <filename>/var</filename>
	do <filename>/</filename> &eacute; sempre favor&aacute;vel.</para>

    <para>Outra raz&atilde;o usual para manter certas &aacute;rvores de diret&oacute;rios
	em outros sistemas de arquivos &eacute; que eles podem ser alojados em
	discos f&iacute;sicos separados, ou em um disco virtual separado como
	pontos de montagem <link linkend="network-nfs">NFS</link> ou dispositivos
	de CDROM.</para>

    <sect2 id="disks-fstab">
      <title>O arquivo <filename>fstab</filename></title>
      <indexterm>
	<primary>sistemas de arquivos</primary>
	<secondary>montados com fstab</secondary>
      </indexterm>

      <para>Durente o <link linkend="boot">processo de inicializa&ccedil;&atilde;o</link>,
	os sistemas de arquivos listados no <filename>/etc/fstab</filename> s&atilde;o
	automaticamente montados (a n&atilde;o ser que eles tenham a op&ccedil;&atilde;o
	<option>noauto</option> definida).</para>

      <para>O arquivo <filename>/etc/fstab</filename> cont&eacute;m uma lista de
	linhas no seguinte formato:</para>

      <programlisting><replaceable>device</replaceable>       <replaceable>/mount-point</replaceable> <replaceable>fstype</replaceable>     <replaceable>options</replaceable>      <replaceable>dumpfreq</replaceable>     <replaceable>passno</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>device</literal></term>
	  <listitem>
	    <para>Um nome de dispositivo (que deve existir), conforme
		explicado em <xref linkend="disks-naming">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>mont-point</literal></term>

	  <listitem><para>Um diret&oacute;rio (que deve existir), onde
		o sistema de arquivos &eacute; montado.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>fstype</literal></term>

	  <listitem><para>O tipo de sistema de arquivo
		que ser&aacute; passado ao &man.mount.8;.  O sistema de arquivos
		padr&atilde;o do FreeBSD &eacute; <literal>ufs</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>options</literal></term>

	  <listitem><para>Pode ser <option>rw</option> para sistemas de
		arquivos com op&ccedil;&otilde;es de leitura e escrita, ou <option>ro</option>
		para apenas leitura, seguidos de qualquer outra op&ccedil;&atilde;o
		necess&aacute;ria.  Uma op&ccedil;&atilde;o bastante usual &eacute; <option>noauto</option>
		para os sistemas de arquivos que normalmente n&atilde;o devem
		ser montados autometicamente pelo processo de inicializa&ccedil;&atilde;o.
		Outras op&ccedil;&otilde;es s&atilde;o listadas na p&aacute;gina de manual do &man.mount.8;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>dumpfreq</literal></term>

	 <listitem><para>Essa op&ccedil;&atilde;o &eacute; utilizada pelo &man.dump.8; para determinar
		que sistema de arquivos devem sofrer o processo de &man.dump.8; (o
		&man.dump.8; &eacute; uma ferramenta para c&oacute;pia de seguran&ccedil;a).  Se o campo
		n&atilde;o estiver presente, o valor zero &eacute; assumido.</para>
	 </listitem>
       </varlistentry>

       <varlistentry>
	 <term><literal>passno</literal></term>

	 <listitem>
	   <para>Determina a ordem que os sistemas de arquivos devem
		ser verificados.  Sistemas de arquivos cuja verifica&ccedil;&atilde;o
		pode ser omitida, devem ter seu <literal>passno</literal>
		definidos em zero.  O sistema de arquivos raiz (que deve ser
		verificado antes de todos os outros) deve ter seu <literal>passno</literal>
		definido como um, e os outros sistemas de arquivos podem ter esta
		op&ccedil;&atilde;o definida com um valor maior.  Se mais de um sistema de arquivos
		disporem do mesmo n&uacute;mero, o &man.fsck.8; tentar&aacute; fazer as verifica&ccedil;&otilde;es
		de forma paralela, se poss&iacute;vel.</para>
	 </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-mount">
      <title>O comando <command>mount</command></title>
      <indexterm>
	<primary>sistemas de arquivos</primary>
	<secondary>montagem</secondary>
      </indexterm>

      <para>O comando &man.mount.8; &eacute; a ferramenta usada para montar
	sistemas de arquivos.</para>

      <para>Em sua forma mais b&aacute;sica, basta usar:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount <replaceable>dispositivo</replaceable> <replaceable>ponto de montagem</replaceable></userinput></screen>
      </informalexample>

      <para>Existem in&uacute;meras op&ccedil;&otilde;es, e est&atilde;o todas dispostas na p&aacute;gina
	de manual do &man.mount.8;, mas as mais comuns s&atilde;o:</para>

      <variablelist>
	<title>Op&ccedil;&otilde;es de montagem</title>

	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
	    <para>Monta todos os sistemas de arquivos listados no
	      <filename>/etc/fstab</filename>.  Exceto aqueles
		assinalados com a op&ccedil;&atilde;o <quote>noauto</quote>, excluidos
		pala op&ccedil;&atilde;o <option>-t</option>, ou aqueles que j&aacute; estiverem
		montados.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-d</option></term>

	  <listitem>
	    <para>Faz tudo, exceto a efetiva&ccedil;&atilde;o da chamada de sistema
		para a montagem.  Essa op&ccedil;&atilde;o &eacute; muito &uacute;til, em conjunto
		com a <option>-v</option> para descobrir o que o
		&man.mount.8; est&aacute; tentando fazer.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>For&ccedil;a a montagem de um sistema de arquivos que n&atilde;o
		tem garantia de integridade (isso &eacute; perigoso), ou
		for&ccedil;a a revoga&ccedil;&atilde;o dos direitos de escrita ao alterar
		o estado de montagem de um sistema de arquivos que
		esteja em modo somente leitura, para o modo leitura
		e escrita.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-r</option></term>

	  <listitem>
	    <para>Monta o sistema de arquivos como somente leitura.  Essa op&ccedil;&atilde;o &eacute;
		id&ecirc;ntica ao argumento <option>rdonly</option> na op&ccedil;&atilde;o
	      <option>-o</option>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>tipo de sistema de arquivos</replaceable></term>

	  <listitem>
	    <para>Monta o sistema de arquivos em quest&atilde;o, como do tipo
		em atribu&iacute;do, ou monta apenas sistemas de arquivos do tipo
		atribu&iacute;do se for usado em conjunto com a
		op&ccedil;&atilde;o <option>-a</option>.</para>

	    <para><quote>ufs</quote> &eacute; o tipo padr&atilde;o de sistema de
		 arquivos.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-u</option></term>

	  <listitem>
	    <para>Atualiza op&ccedil;&otilde;es de montagem no sistema de arquivos.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>Torna-se verboso.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-w</option></term>

	  <listitem>
	    <para>Monta o sistema de arquivos como leitura e escrita.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>A op&ccedil;&atilde;o <option>-o</option> pode utilizar uma lista de op&ccedil;&otilde;es separadas
	por v&iacute;rgula, das quais, as principais s&atilde;o:</para>

      <variablelist>
	<varlistentry>
	  <term>nodev</term>

	  <listitem>
	    <para>N&atilde;o interpreta dispositivos especiais no sistema de arquivos
		em quest&atilde;o.  Esta &eacute; uma op&ccedil;&atilde;o &uacute;til para seguran&ccedil;a.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>noexec</term>

	  <listitem>
	      <para>N&atilde;o permite execuss&atilde;o de bin&aacute;rios neste sistema de arquivos.
		Tamb&eacute;m &eacute; uma op&ccedil;&atilde;o muito &uacute;til para seguran&ccedil;a.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>nosuid</term>

	  <listitem>
	    <para>N&atilde;o interpreta op&ccedil;&otilde;es de setuid ou setgid no
		sistema de arquivos.  &Eacute; uma op&ccedil;&atilde;o &uacute;til para seguran&ccedil;a.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-umount">
      <title>O comando <command>umount</command></title>
      <indexterm>
	<primary>sistemas de arquivos</primary>
	<secondary>desmontando</secondary>
      </indexterm>

      <para>O comando &man.umount.8; recebe como par&acirc;metro o
	ponto de montagem, o dispositivo, a op&ccedil;&atilde;o <option>-a</option> ou
	a op&ccedil;&atilde;o <option>-A</option>.</para>

      <para>Todas estas maneiras podem ter tamb&eacute;m as op&ccedil;&otilde;es <option>-f</option>
	para for&ccedil;ar desmontagem, e <option>-v</option> para ser verboso.  Esteja
	atento ao fato que a op&ccedil;&atilde;o <option>-f</option> geralmente n&atilde;o &eacute;
	uma boa id&eacute;ia.  Desmontar os sistemas de arquivos for&ccedil;ozamente pode
	causar dano aos dados do sistema de arquivos.</para>

      <para><option>-a</option> and <option>-A</option> s&atilde;o usadas para
	desmontar todos os sistemas de arquivos; este comportamento
	&eacute; possivelmente modificado em conjunto com a op&ccedil;&atilde;o <option>-t</option>.
	<option>-A</option>, contudo, n&atilde;o tenta desmontar o sistema de arquivos
	raiz.</para>
    </sect2>
  </sect1>

  <sect1 id="basics-processes">
    <title>Processos</title>

    <para>O FreeBSD &eacute; um sistema operacional multi-tarefa.  Isso significa que
	ele cria um ambiente onde os recursos computacionais s&atilde;o divididos
	de forma &agrave; parecer que mais de um programa &eacute; executado ao mesmo tempo.
	Cada processo sendo executado &agrave; qualquer momento, &eacute; chamado de
	um <firstterm>processo</firstterm>.  Todo comando que voc&ecirc; executar,
	iniciar&aacute; ao menos um novo processo, e existem v&aacute;rios processos do
	sistema que est&atilde;o sempre em execuss&atilde;o, mantendo a funcionalidade
	do ambiente como um todo.</para>

    <para>Cada processo &eacute; identificado de forma &uacute;nica com um n&uacute;mero, que &eacute;
	chamado de identifica&ccedil;&atilde;o do processo, ou <firstterm>process ID</firstterm>, ou
	ent&atilde;o a forma abreviada e mais comum, <firstterm>PID</firstterm>, e,
	assim como os arquivos, cada processo tamb&eacute;m tem um dono e grupo.  As
	informa&ccedil;&otilde;es sobre dono e grupo s&atilde;o utilizadas com o int&uacute;ito de
	determinar que arquivos e dispositivos o processo pode abrir, utilizando
	as permiss&otilde;es discutidas anteriormente.  A maioria dos processos tem ainda
	um processo pai.  O processo pai &eacute; o processo que o iniciou.  Por exemplo,
	quando voc&ecirc; digita um comando em uma <literal>shell</literal>, ent&atilde;o
	essa <literal>shell</literal> &eacute; um processo, e todo comando executado
	&eacute; outro processo.  Todo comando executado desta forma ter&aacute; sua
	<literal>shell</literal> como o processo pai.  A &uacute;nica excess&atilde;o
	&eacute; um processo especial chamado de &man.init.8;.  O <command>init</command>
	&eacute; sempre o primeiro processo do sistema, portanto seu PID &eacute; sempre 1.  O
	<command>init</command> &eacute; executado automaticamente pelo <literal>kernel</literal>
	quando o FreeBSD &eacute; iniciado.</para>

    <para>Dois comandos s&atilde;o particularmente &uacute;teis para verificar os processos ativos
	no sistema, o &man.ps.1; e o &man.top.1;.  O comando <command>ps</command> &eacute; usado
	para apresentar uma lista est&aacute;tica dos processos sendo executados no momento, e
	pode apresentar seu PID, quanta mem&oacute;ria o processo est&aacute; utilizando, a linha
	de comando que o iniciou, e assim por diante.  O comando <command>top</command>
	apresenta todos os processos em execuss&atilde;o, e atualiza a forma como os apresenta
	na tela a cada poucos segundos, de forma que voc&ecirc; possa acompanhar o que
	o computador est&aacute; fazendo.</para>

    <para>Por padr&atilde;o o <command>ps</command> apenas apresenta os comandos
	que est&atilde;o sendo executados por voc&ecirc;, e cuja propriedade tamb&eacute;m seja
	sua.  Por exemplo:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID TT STAT      TIME COMMAND
  298 p0 Ss     0:01.10 tcsh
 7078 p0 S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393 p0 I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630 p0 S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730 p0 IW     0:00.00 (dns helper) (navigator-linux-)
72210 p0 R+     0:00.00 ps
  390 p1 Is     0:01.14 tcsh
 7059 p2 Is+    1:36.18 /usr/local/bin/mutt -y
 6688 p3 IWs    0:00.00 tcsh
10735 p4 IWs    0:00.00 tcsh
20256 p5 IWs    0:00.00 tcsh
  262 v0 IWs    0:00.00 -tcsh (tcsh)
  270 v0 IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280 v0 IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284 v0 IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285 v0 S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>Como voc&ecirc; pode acompanhar neste exemplo, a sa&iacute;da do comando &man.ps.1;
	&eacute; organizada em v&aacute;rias colunas.  <literal>PID</literal> &eacute; a identifica&ccedil;&atilde;o
	do processo discutida anteriormente.  PIDs s&atilde;o atribu&iacute;udos &agrave; partir
	do 1, e v&atilde;o at&eacute; 99999, e reiniciam a contagem quando ultrapassa
	esse valor.  A coluna <literal>TT</literal> postra em que terminal
	o programa esta sendo executado, e pode seguramente ser ignorado
	no momento.  <literal>STAT</literal> apresenta o estado atual
	do programa, e, mais uma vez, vamos ignora-lo por hora.
	<literal>TIME</literal> indica a quantidade de tempo que o
	programa est&aacute; em execuss&atilde;o na CPU em quest&atilde;o &mdash; normalmente
	n&atilde;o &eacute; o tempo total desde que o processo foi iniciado, e sim tempo
	de execuss&atilde;o, uma vez que v&aacute;rios programas ficam um bom tempo
	esperando que algo aconte&ccedil;a para eles utilizarem tempo de
	processamento da CPU.  Finalmente, <literal>COMMAND</literal> &eacute; a linha
	de comando utilizada para executar o programa em quest&atilde;o.</para>

    <para>&man.ps.1; suporta uma s&eacute;rie de op&ccedil;&otilde;es distintas que modificam
	as informa&ccedil;&otilde;es apresentadas.  Um dos cunjuntos mais &uacute;teis de
	op&ccedil;&otilde;es &eacute; <literal>auxww</literal>.  <option>a</option> apresenta
	informa&ccedil;&otilde;es sobre todos os processos em execuss&atilde;o, n&atilde;o apenas
	os de sua propriedade.  <option>u</option> apresenta o nome do
	usu&aacute;rio que &eacute; o dono do processo, bem como o uso de mem&oacute;ria do mesmo.
	<option>x</option> apresenta informa&ccedil;&otilde;es sobre processos <literal>
	daemon</literal>, e <option>ww</option> faz o &man.ps.1; apresentar a linha
	de comando completa, ao inv&eacute;s de um trecho compactado para caber na tela.</para>

    <para>A sa&iacute;da do &man.top.1; &eacute; similar.  Uma sess&atilde;o modelo teria
	a seguinte apar&ecirc;ncia:</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33 22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0 1960K 1044K RUN      0:00 14.86%  1.42% top
 7078 nik	2   0 15280K 10960K select   2:54 0.88%  0.88% xemacs-21.1.14
  281 nik	2   0 18636K 7112K select   5:36 0.73%  0.73% XF86_SVGA
  296 nik	2   0 3240K 1644K select   0:12 0.05%  0.05% xterm
48630 nik	2   0 29816K 9148K select   3:18 0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41 0.00%  0.00% syslogd
 7059 nik	2   0 7260K 4644K poll     1:38 0.00%  0.00% mutt
...</screen>

    <para>A sa&iacute;da est&aacute; dividida em duas se&ccedil;&otilde;es.  O cabe&ccedil;alho (as primeiras
	cinco linhas) apresenta o PID do &uacute;ltimo processo executado,
	a m&eacute;dia de carga do sistema (que mede o quanto o sistema est&aacute;
	ocupado), e o tempo de atividade initerrupta do sistema (tempo desde
	a &uacute;ltima inicializa&ccedil;&atilde;o - o <foreignphrase>uptime</foreignphrase>).  As
	outras informa&ccedil;&otilde;es do cabe&ccedil;alho inidicam quantos processos (47 neste caso)
	est&atilde;o ativos, quando de mem&oacute;ria e <literal>swap</literal> foi
	utilizado, e quanto tempo o sistema est&aacute; gastando em estados
	diferentes de uso da CPI.</para>

    <para>Abaixo est&aacute; uma s&eacute;rie de colunas com informa&ccedil;&otilde;es similares
	&agrave; sa&iacute;da do &man.ps.1;.  Como antes, voc&ecirc; pode ver o PID,
	o usu&aacute;rio, o tempo de CPU utilizado, e o comando executado.
	&man.top.1; tamb&eacute;m mostra por padr&atilde;o a quantidade de mem&oacute;ria
	utilizada pelo processo.  Essa informa&ccedil;&atilde;o &eacute; dividida em dois
	grupos, uma para o tamanho total de mem&oacute;ria, e um para o
	tamanho residente &mdash; tamanho total indica quanta mem&oacute;ria
	a aplica&ccedil;&atilde;o j&aacute; precisou, e o tamanho residente &eacute; a quantidade
	em uso no momento.  Nesse exemplo voc&ecirc; pode ver que o
	<application>&netscape;</application> precisou quase de
	30&nbsp;MB de RAM, mas no momento est&aacute; usando apenas 9&nbsp;MB.</para>

    <para>&man.top.1; atualiza automaticamente as informa&ccedil;&otilde;es a cada dois seguindos,
	o que pode ser modificado com a op&ccedil;&atilde;o <option>s</option>.</para>
  </sect1>

  <sect1 id="basics-daemons">
    <title>Daemons, sinais e controle de processos</title>

    <para>Ao usar um editor, &eacute; f&aacute;cil controla-lo, indicar que ele deve
	carregar arquivos, e assim por diante.  Voc&ecirc; pode faz&ecirc;-lo pois o
	editor oferece algumas op&ccedil;&otilde;es para faz&ecirc;-lo, e por que o editor &eacute;
	diretamente interligado a um <firstterm>terminal</firstterm>.  Alguns
	programas n&atilde;o s&atilde;o projetados de forma a utilizar informa&ccedil;&otilde;es
	cont&iacute;nuas do usu&aacute;rio, e assim ele se desconecta do terminal em sua
	primeira oportunidade.  Por exemplo, um servidor HTTP passa
	o tempo todo respondendo requisi&ccedil;&otilde;es da rede, e normalmente ele
	n&atilde;o necessita interven&ccedil;&atilde;o alguma do usu&aacute;rio.  Programas que transportam
	mensagens de correio de um local para outro, s&atilde;o outro exemplo
	dessa classe de aplica&ccedil;&otilde;es.</para>

    <para>Chamamos estes programas de <firstterm>daemons</firstterm>.  Daemons s&atilde;o
	personagens da mitologia Grega; m&atilde;o s&atilde;o bons, nem maus, eram apenas
	esp&iacute;ritos assistentes que, na maior parte do tempo, realizavam
	tarefas &uacute;teis para a humanidade.  &Eacute; por isso que o mascote do BSD,
	h&aacute; um bom tempo, &eacute; aquele daemon simp&aacute;tico que usa t&ecirc;nis e
	carrega um tridente.</para>

    <para>Existe uma conven&ccedil;&atilde;o para batizar os programas que normalmente s&atilde;o
	executados como daemon, que &eacute; terminar o nome do programa com um
	<quote>d</quote>. <application>BIND</application> &eacute; o Daemon de
	Nomes Internet de Berkeley, (<foreignphrase>Berkeley Internet
	Name Daemon</foreignphrase> - o programa que o executa, &eacute; chamado
	<command>named</command>), O servidor WWW <application>Apache</application>
	&eacute; chamado de <command>httpd</command>, o daemon de impress&atilde;o em linha
	&eacute; o <command>lpd</command> e assim sucetivamente.  Esta &eacute; uma conven&ccedil;&atilde;o,
	e n&atilde;o uma regra de r&aacute;pida assimila&ccedil;&atilde;o; por exemplo, o daemon principal
	para a aplica&ccedil;&atilde;o <application>Sendmail</application> &eacute; chamado
	<command>sendmail</command>, e n&atilde;o <command>maild</command>, como voc&ecirc;
	poderia ter imaginado inicialmente.</para>

    <para>Algumas vezes ser&aacute; necess&aacute;rio se comunicar com um processo daemon.
	Essa comunica&ccedil;&atilde;o &eacute; chamada de <firstterm>sinais</firstterm>, e voc&ecirc;
	pode se comunicar com o daemon (ou qualquer outro processo em execuss&atilde;o)
	enviando-o um sinal.  Existem uma s&eacute;rie de sinais diferentes que podem ser
	enviados&mdash;alguns dos quais tem um significado espec&iacute;fico, e outros
	s&atilde;o interpretados pela aplica&ccedil;&atilde;o, e a documenta&ccedil;&atilde;o dessa aplica&ccedil;&atilde;o
	indicar&aacute; o que ela faz quando recebe este tipo de sinal.  Voc&ecirc; s&oacute; pode
	enviar um sinal para os processos que te pertencem.  Se voc&ecirc; tentar
	enviar sinais para um processo que n&atilde;o &eacute; seu, com &man.kill.1; ou &man.kill.2;
	ter&aacute; permiss&atilde;o negada.  A &uacute;nica excess&atilde;o &eacute; o usu&aacute;rio <username>root</username>,
	que pode enviar sinais para os processos de todos.</para>

    <para>O FreeBSD em certos casos tamb&eacute;m enviar&aacute; sinais &agrave;s aplica&ccedil;&otilde;es.  Se uma
	aplica&ccedil;&atilde;o for mal escrita e tentar acessar endere&ccedil;os de mem&oacute;ria que
	ele n&atilde;o deve, o FreeBSD envia o sinal de viola&ccedil;&atilde;o de segmento
	ao processo (<firstterm>Segmentation Violation</firstterm>), conhecido
	como <literal>SIGSEGV</literal>.  Se alguma aplica&ccedil;&atilde;o usou a chamada de
	sistema &man.alarm.3; para solicitar que seja alertada depois de
	certo per&iacute;odo de tempo, o sistema envia o sinal de alerta
	(<literal>SIGALRM</literal>) ao processo, e assim por diante.</para>

    <para>Dois sinais podem ser usados para interromper um processo,
      <literal>SIGTERM</literal> e <literal>SIGKILL</literal>.
      <literal>SIGTERM</literal> &eacute; uma maneira educada de matar um processo;
	o processo pode <emphasis>acatar</emphasis> o sinal, entender
	que voc&ecirc; deseja que ele deixe de ser executado, fechar qualquer arquivos
	de logs que ele tenha aberto, e geralmente terminar a tarefa que ele est&aacute;
	realizando no momento, antes de deixar de executar.  Em alguns casos um
	processo pode ignorar o <literal>SIGTERM</literal> se ele estiver
	no meio de uma tarefa que n&atilde;o pode ser interrompida.</para>

    <para><literal>SIGKILL</literal> n&atilde;o pode ser ignorado por qualquer
	processo.  Este &eacute; o sinal que diz ao processo, <quote>Eu n&atilde;o me
	importo com o que voc&ecirc; esteja fazendo, pare agora mesmo</quote>.
	Se voc&ecirc; enviar um <literal>SIGKILL</literal> a qualquer processo,
	o FreeBSD ir&aacute; interromper aquele processo<footnote>
	<para>N&atilde;o &eacute; completamente verdade&mdash;existem algumas poucas
	  tarefas que n&atilde;o podem ser interrompidas.  Por exemplo, se o processo
	  est&aacute; tentando ler um arquivo que est&aacute; em uma outra esta&ccedil;&atilde;o da rede,
	  e essa outra esta&ccedil;&atilde;o n&atilde;o est&aacute; mais dispon&iacute;vel por alguma raz&atilde;o (foi
	  desligado, ou houve falha na rede), ent&atilde;o o processo &eacute; definido como
	  um processo que n&atilde;o pode ser interrompido.  Eventualmente ele
	  ir&aacute; passar do tempo m&aacute;ximo de atividade permitida, tipicamente
	  dois minutos (o <foreignphrase>timeout</foreignphrase>).  T&atilde;o logo
	  este per&iacute;odo aconte&ccedil;a, o processo &eacute; morto.</para>
      </footnote>.</para>

    <para>Outros sinais que voc&ecirc; pode querer conhecer s&atilde;o
      <literal>SIGHUP</literal>, <literal>SIGUSR1</literal>, e
      <literal>SIGUSR2</literal>.  Estes s&atilde;o sinais de prop&oacute;sitos
	gerais, e aplica&ccedil;&otilde;es distintas ter&atilde;o comportamento distintos
	ao receber estes sinais.</para>

    <para>Suponha que voc&ecirc; modificou o arquivo de configura&ccedil;&atilde;o do
	seu servidor HTTP&mdash;voc&ecirc; deseja dizer ao daemon para ele
	reler essa configura&ccedil;&atilde;o.  Voc&ecirc; poderia parar e reiniciar o
	<command>httpd</command>, mas isso resultaria em uma breve
	interrup&ccedil;&atilde;o do servi&ccedil;o, o que pode n&atilde;o ser desej&aacute;vel.  A maioria
	dos daemons s&atilde;o escritos de forma que respondam a um
	<literal>SIGHUP</literal> com a releitura de seu arquivo de
	configura&ccedil;&atilde;o.  Ent&atilde;o, ao inv&eacute;s de matar e reiniciar o processo
	<command>httpd</command> voc&ecirc; enviaria o sinal <literal>
	SIGHUP</literal> ao processo.  Por n&atilde;o existir uma forma
	padr&atilde;o de resposta &agrave; estes sinais, cada daemon pode ter um
	comportamento diferente, de forma que voc&ecirc; deve ler a documenta&ccedil;&atilde;o
	para o programa em quest&atilde;o.</para>

    <para>Sinais s&atilde;o enviados utilizando o comando &man.kill.1;, como mostra
	o exemplo a seguir:</para>

    <procedure>
      <title>Enviando sinal aos processos</title>

      <para>Esse exemplo mostra como enviar sinais ao &man.inetd.8;.  O arquivo
	de configura&ccedil;&atilde;o do <command>inetd</command> &eacute; o <filename>
	/etc/inetd.conf</filename>, e o <command>inetd</command> ir&aacute; reler
	sua configura&ccedil;&atilde;o, quando receber o sinal
	<literal>SIGHUP</literal>.</para>

      <step>
	<para>Encontre o ID do processo que voc&ecirc; quer enviar o sinal.
	 Fa&ccedil;a isso com o &man.ps.1; em conjunto com &man.grep.1;.  O &man.grep.1;
	 &eacute; usado para procurar por uma cadeia de caracteres na sa&iacute;da desejada.
	 O comando &eacute; executado como usu&aacute;rio normal, e o &man.inetd.8; &eacute; executado
	 como <username>root</username>, ent&atilde;o as op&ccedil;&otilde;es <option>ax</option> devem
	 ser usadas com o &man.ps.1;.</para>

	<screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

	<para>Portando o PIDO do &man.inetd.8; &eacute; 198.  Em alguns casos o comando
	  <literal>grep inetd</literal> poder&aacute; estar incluso tamb&eacute;m na sa&iacute;da
	  desses comandos.  Isso se deve &agrave; maneira como o &man.ps.1; procura
	  na lista de processos em execuss&atilde;o.</para>
      </step>

      <step>
	<para>Use &man.kill.1; para enviar sinais.  Pelo fato do &man.inetd.8;
	  estar sendo executado pelo <username>root</username> voc&ecirc; deve usar
	  o &man.su.1; antes, para se tornar <username>root</username>.</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

	<para>Como de costume com a maioria dos comandos &unix;, o
	  &man.kill.1; n&atilde;o apresentar&aacute; qualquer mensagem se o resultado
	  da a&ccedil;&atilde;o for bem sucedido.  Se voc&ecirc; enviou um processo que n&atilde;o &eacute;
	  seu, voc&ecirc; ver&aacute; uma mensagem parecida com <errorname>kill:
	    <replaceable>PID</replaceable>: Operation not
	    permitted</errorname>.  Se voc&ecirc; digitar o PID err&ocirc;neamente,
	    ou voc&ecirc; vai enviar o sinal ao processo errado, o que pode ser
	    bem ruin, ou, se voc&ecirc; tiver sorte, ter&aacute; enviado o sinal a
	    um processo que n&atilde;o est&aacute; ativo, e ver&aacute; algo como <errorname>kill:
	    <replaceable>PID</replaceable>: No such process</errorname>.</para>

	<note>
	  <title>Por que usar o <command>/bin/kill</command>?</title>

	  <para>Muitos interpretadores de comandos oferecem o comando
	    <command>kill</command> embutido; ou seja, o interpretador
	    enviar&aacute; o sinal diretamente, ao inv&eacute;s de executar o
	    <filename>/bin/kill</filename>.  Isso pode ser muito &uacute;til, mas
	    interpretadores de comandos distintos podem ter sintaxe
	    distinta.  Ao inv&eacute;s de aprender a usar cada uma, &eacute; bem mais f&aacute;cil
	    aprender usar o comando <command>/bin/kill <replaceable>...</replaceable></command>
	    diretamente.</para>
	</note>
      </step>
    </procedure>

    <para>Enviar outros sinais &eacute; muito parecido, basta substituir o
	<literal>TERM</literal> ou <literal>KILL</literal> na linha de
	comando, conforme for necess&aacute;rio.</para>

    <important>
      <para>Matar processos aleat&oacute;rios no sistema pode ser uma m&aacute; id&eacute;ia.  Em especial o
	processo cujo ID &eacute; 1, o &man.init.8;, que &eacute; bem particular.  Enviar um
	<command>/bin/kill -s KILL 1</command> &eacute; uma forma singela de desligar
	seu sistema.  <emphasis>Sempre</emphasis> verifique duas vezes os argumentos
	do &man.kill.1; <emphasis>antes</emphasis> de apertar
	<keycap>Enter</keycap>.</para>
    </important>
  </sect1>

  <sect1 id="shells">
    <title>Shells</title>
    <indexterm><primary>shells</primary></indexterm>
    <indexterm><primary>linha de comando</primary></indexterm>

    <para>No FreeBSD, uma grande parte do trabalho do dia a dia &eacute; feito
	por interface de linha de comando, chamada de interpretador
	de comandos, ou <foreignphrase>shell</foreignphrase>.  A
	principal fun&ccedil;&atilde;o de uma <foreignphrase>shell</foreignphrase> &eacute;
	receber comandos por um canal de entrada e execut&aacute;-los.  Uma
	s&eacute;rie de <foreignphrase>shells</foreignphrase> ainda possuem
	fun&ccedil;&otilde;es embutidas, o que ajuda a facilitar a realiza&ccedil;&atilde;o de
	tarefas do dia-a-dia, como gerenciamente de arquivos,
	edi&ccedil;&atilde;o de linha de comando, macros de comandos e vari&aacute;veis
	de ambiente.  O FreeBSD vem com uma s&eacute;rie de interpretadores
	de comandos, como o <command>sh</command>, chamado de
	<foreignphrase>Bourne Shell</foreignphrase>, e <command>tcsh</command>,
	A <quote>C-shell</quote> melhorada.  Muitos outros interpretadores
	de comandos est&atilde;o dispon&iacute;veis na Cole&ccedil;&atilde;o de Ports do FreeBSD,
	como o <command>zsh</command> e o <command>bash</command>.</para>

    <para>Que <foreignphrase>shell</foreignphrase> utilizar?  Trata-se meramente
	de uma quest&atilde;o de gosto.  Se voc&ecirc; &eacute; um programador C, se sentir&aacute; mais
	confort&aacute;vel com um interpretador de comandos similar &agrave; linguagem C,
	como o <command>tcsh</command>.  Se voc&ecirc; teve suas origens
	no Linux, ou &eacute; novo ao &unix;, tenta experimentar o
	<command>bash</command>.  O ponto &eacute; que cada interpretador
	de comandos possui propriedades &uacute;nicas, que pode ou n&atilde;o
	funcionar corretamente em seu ambiente de trabalho, e
	tamb&eacute;m, outro ponto importante &eacute; sua liberdade de escolha
	para decidir qual e quando interpretador utilizar.</para>

    <para>Uma das caracter&iacute;sticas mais comuns em interpretadores de
	comandos &eacute; completar nome de arquivos.  Ao digitar as primeiras
	letras de um comando ou de um arquivo, voc&ecirc; normalmente pode
	fazer com que a <foreignphrase>shell</foreignphrase> automaticamente
	complete o restante do comando ou arquivo, pressionando a tecla
	<keycap>Tab</keycap> no teclado.  Aqui est&aacute; um exemplo.  Suponha que
	voc&ecirc; tenha dois arquivos chamados <filename>foobar</filename> e
	<filename>foo.bar</filename>.  Voc&ecirc; quer apagar o <filename>foo.bar</filename>.
	Ent&atilde;o o que voc&ecirc; faria no teclado
	&eacute;: <command>rm fo[<keycap>Tab</keycap>].[<keycap>Tab</keycap>]</command>.</para>

    <para>O interpretador de comandos apresentaria como resultado algo similar &agrave; <command>rm
      foo[BEEP].bar</command>.</para>

    <para>O [BEEP] &eacute; o sino do console, que indica que o interpretador de
	comandos n&atilde;o foi capaz de completar totalmente o nome do arquivo
	porque existe mais do que uma op&ccedil;&otilde;es que coincide.  Ambos,
	<filename>foobar</filename> e <filename>foo.bar</filename> come&ccedil;am com <literal>fo</literal>,
	mas a <foreignphrase>shell</foreignphrase> pode completar o nome
	do arquivo at&eacute; <literal>foo</literal>.  Se neste momento voc&ecirc; digitar
	<literal>.</literal>, e pressionar <keycap>Tab</keycap> mais uma vez, a
	<foreignphrase>shell</foreignphrase> deve ser capaz de
	completar o restante do nome do arquivo para voc&ecirc;.</para>

    <indexterm><primary>vari&aacute;veis de ambiente</primary></indexterm>

    <para>Outra funcionalidade de um interpretador de comandos
	&eacute; o uso de vari&aacute;veis de ambiente.  Vari&aacute;veis de ambiente s&atilde;o duplas
	vari&aacute;veis de valores armazenados no espa&ccedil;o de ambiente da
	<foreignphrase>shell</foreignphrase>.  Esse espa&ccedil;o de ambiente
	pode ser lido por qualquer programa chamado pelo intepretador,
	de forma que contenha uma s&eacute;rie de configura&ccedil;&otilde;es interpretadas
	pelo mesmo.  Segue aqui uma lista de vari&aacute;veis de ambiente
	comuns, e seus respectivos significados:</para>
    <indexterm><primary>vari&aacute;veis de ambiente</primary></indexterm>

    <informaltable frame="none">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Vari&aacute;vel</entry>
	    <entry>Descri&ccedil;&atilde;o</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>Nome do usu&aacute;rio logado no momento.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>Lista de diret&oacute;rios, divididos por v&iacute;rgula,
		indincando onde deve-se procurar por
		bin&aacute;rios.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>Nome de rede do terminal gr&aacute;fico do X11 onde
		o mesmo deve se conectar, caso esteja dispon&iacute;vel.</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>O interpretador de comandos atual.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>Nome do terminal do usu&aacute;rio.  &Eacute; usado para
		determinar as caracter&iacute;sticas do termina.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>Entrada com a base de dados de c&oacute;digos de terminal, que
		realizam v&aacute;rias fun&ccedil;&otilde;es do console.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>A esp&eacute;cie do sistema operacional em quest&atilde;o, por exemplo, FreeBSD.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>A arquitetura de CPU onde o sistema est&aacute;
		sendo executado.</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>Editor de texto padr&atilde;o para o usu&aacute;rio.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>O paginador de texto padr&atilde;o para o usu&aacute;rio.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>Lista de diret&oacute;rios separadaos por v&iacute;rgulas que indicam
		onde as p&aacute;ginas de manuais devem ser buscadas.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary>Bourne shells</primary></indexterm>
    <para>Ajustar as vari&aacute;veis de ambiente &eacute; tarefa que se
	difere de algumas formas entre as v&aacute;rias <foreignphrase>shells</foreignphrase>
	dispon&iacute;veis.  Por exemplo, nas <foreignphrase>shells</foreignphrase>
	baseadas nalinguagem C, como o <command>tcsh</command> e
	o <command>csh</command>, voc&ecirc; usaria o <command>setenv</command>
	para justar as vari&aacute;veis de ambiente.  Sobre um interpretador
	estilo <foreignphrase>Bourne shell</foreignphrase> como o
	pr&oacute;prio <command>sh</command> e o conhecido <command>bash</command>,
	voc&ecirc; usaria o <command>export</command> para definir a vari&aacute;vel
	de ambiente.  Por exemplo, para definir ou modificar o valor da
	vari&aacute;vel de ambiente <envar>EDITOR</envar>, sob <command>csh</command> ou
	<command>tcsh</command>, para definir a vari&aacute;vel
	<envar>EDITOR</envar> com o valor
	<filename>/usr/local/bin/emacs</filename>, voc&ecirc; faria
	algo como:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Enquanto sob uma <foreignphrase>Bourne shell</foreignphrase> seria:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>Ainda &eacute; poss&iacute;vel fazer a maioria dos interpretadores expandirem
	a vari&aacute;vel, simplesmente adicionado o car&aacute;cter
	<literal>$</literal> na frente da pr&oacute;pria vari&aacute;vel.  Por exemplo,
	<command>echo $TERM</command> imprimiria todo o conte&uacute;do da vari&aacute;vel
	<envar>$TERM</envar>, por qu&ecirc; o interpretador interpreta a vari&aacute;vel
	<envar>$TERM</envar> como seu valor, e o passa para o <command>echo</command>.</para>

    <para>Os interpretadores de comandos cuidam ainda de uma s&eacute;rie
	de caracteres especiais, chamados de meta-caracteres,
	como representa&ccedil;&otilde;es especiais de dados.  O caracter mais comum
	&eacute; o <literal>*</literal>, que representa qualquer conjunto de caracteres
	em um nome de arquivo.  Os meta-caract&eacute;res especiais podem
	ser usados como substitui&ccedil;&atilde;o de arquivos.  Por exemplo,
	o comando <command>echo *</command> tem resultado similar &agrave; sa&iacute;da
	de um <command>ls</command> pois o interpretador de comandos pega
	todos os arquivos que batem com <literal>*</literal> e os coloca na
	linha de comando de forma que o <command>echo</command> possa
	encherga-los.</para>

    <para>Para evitar que a <foreignphrase>shell</foreignphrase>
	interprete estes caracteres especiais, pode-se utiliza-los
	como exclus&atilde;o, inserindo uma barra invertinda (<literal>\</literal>)
	na frente deles. <command>echo $TERM</command> imprime em que
	terminal voc&ecirc; est&aacute;, enquanto <command>echo \$TERM</command>
	imprime <envar>$TERM</envar> exatamente.</para>

    <sect2 id="changing-shells">
      <title>Modificando sua <foreignphrase>Shell</foreignphrase></title>

      <para>A forma mais f&aacute;cil de modificar seu interpretador de
	comandos &eacute; usar o comando <command>chsh</command>.  Executar o
	<command>chsh</command> te colocar&aacute; no editor definido
	na vari&aacute;vel de ambiente <envar>EDITOR</envar>; se esta vari&aacute;vel
	n&atilde;o estiver definida, voc&ecirc; ser&aacute; colocado no <command>vi</command>.
	Modifique a linha <quote>Shell:</quote> de acordo
	com suas necessidades.</para>

      <para>Voc&ecirc; pode ainda usar o <command>chsh</command> com
	a op&ccedil;&atilde;o <option>-s</option>; assim voc&ecirc; pode ajustar sua
	<foreignphrase>shell</foreignphrase> sem entrar no editor.
	Por exemplo, se a inten&ccedil;&atilde;o era modificar
	seu interpretador para usar o <command>bash</command>,
	o truqye pode ser feito da seguinte forma:</para>
	
      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <para>Utilizar o <command>chsh</command> sem par&acirc;metros e editar a
	<foreignphrase>shell</foreignphrase> tamb&eacute;m funcionaria.</para>

      <note>
	<para>O interpretador de comandos que voc&ecirc; deseja
	utilizar <emphasis>deve</emphasis> estar listado no
	arquivo <filename>/etc/shells</filename>.  Se voc&ecirc;
	instalou o interpretador &agrave; partir da
	<link linkend="ports">Cole&ccedil;&atilde;o de Ports</link>, isso j&aacute; foi
	feito.  Se voc&ecirc; instalou na m&atilde;o, voc&ecirc; mesmo deve faze-lo.</para>

      <para>Por exemplo, se voc&ecirc; instalou o <command>bash</command>
	manualmente e o colocou no <filename>/usr/local/bin</filename>,
	voc&ecirc; vai querer fazer o seguinte:</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>Em seguida, execute novamente o <command>chsh</command>.</para>
     </note>
   </sect2>
  </sect1>

  <sect1 id="editors">
    <title>Editores de Texto</title>
    <indexterm><primary>editores de texto</primary></indexterm>
    <indexterm><primary>editores</primary></indexterm>

    <para>Uma s&eacute;rie de configura&ccedil;&otilde;es no FreeBSD s&atilde;o feitas &agrave; partir
	da edi&ccedil;&atilde;o de arquivos de texto.  Por tal motivo, seria uma boa
	id&eacute;ia se tornar familiar com algum editor de texto.  FreeBSD
	vem com alguns editores, como parte de seu sistema base, e muitos	
	outros editores est&atilde;o dispon&iacute;veis na cole&ccedil;&atilde;o de
	<literal>ports</literal>.</para>

    <indexterm>
      <primary><command>ee</command></primary>
    </indexterm>
    <para>O editor mais simples e mais f&aacute;cil para de aprender, &eacute; um editor chamado
	<application>ee</application>, que significa <foreignphrase>easy
	editor</foreignphrase> (<quote>editor f&aacute;cil</quote>).  Para iniciar o
	<application>ee</application>, basta digitar na minha de comando
	<command>ee <replaceable>nomedoarquivo</replaceable></command> onde
	<replaceable>nomedoarquivo</replaceable> &eacute; o nome do arquivo que deve
	ser editado.  Por exemplo, para editar o <filename>/etc/rc.conf</filename>,
	digite <command>ee /etc/rc.conf</command>.  Uma vez dentro do
	<command>ee</command>, todos os comandos para manipular as fun&ccedil;&otilde;es do
	editor est&atilde;o listadas no topo da tela.  O caracter <literal>^</literal> representa
	a tecla <keycap>Ctrl</keycap> do teclado, de forma que <literal>^e</literal>
	implica na combina&ccedil;&atilde;o de teclas <keycombo action="simul"><keycap>Ctrl</keycap><keycap>e</keycap></keycombo>.
	Para sair do <application>ee</application>, aperte a tecla <keycap>Esc</keycap>, depois
	escolha <foreignphrase>leave editor</foreignphrase> (sair do editor).  O editor
	ir&aacute; perguntar se voc&ecirc; deseja salvar as modifica&ccedil;&otilde;es no arquivo, caso ele tenha sido
	alterado.</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>editores</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>
    <para>FreeBSD tamb&eacute;m oferece editores de texto mais poderosos, como o
	<command>vi</command>, como parte da base do sistema, enquanto
	outros editores como <command>emacs</command> e <command>vim</command>,
	est&atilde;o dispon&iacute;vels na Cole&ccedil;&atilde;o de <literal>Ports</literal> do FreeBSD.
	Estes editores oferecem muitas funcionalidades e s&atilde;o extramente
	poderosos, ao custo de serem um pouco mais dif&iacute;ceis de aprender.  Contudo
	se voc&ecirc; planeja editar muitos textos, aprender algum editor de texto
	mais poderoso como <command>vim</command> ou <command>emacs</command>
	economizar&aacute; a voc&ecirc; mais tempo, &agrave; longo prazo.</para>
  </sect1>

  <sect1 id="basics-devices">
    <title>Dispositivos e N&oacute;s de Dispositivos</title>

    <para>Um dispositivo &eacute; um termo usado em sua maioria para
	fazer men&ccedil;&atilde;o &agrave; atividades relacionadas &agrave; equipamentos
	f&iacute;sicos no sistema, incluindo discos, impressoras,
	placas de v&iacute;deo e teclados.  Quando o FreeBSD &eacute; iniciado,
	a maioria dos dados que o sistema apresenta s&atilde;o referentes
	&agrave; detec&ccedil;&atilde;o de dispositivos.  &Eacute; poss&iacute;vel reavaliar as
	mensagens de inicializa&ccedil;&atilde;o, analisando o arquivo
	<filename>/var/run/dmesg.boot</filename>.</para>

    <para>Por exemplo, o dispositivo <devicename>acd0</devicename> &eacute; o
	primeiro CDROM IDE dispon&iacute;vel, enquanto <devicename>kbd0</devicename>
	representa o teclado.</para>

    <para>A maioria destes dispositivos em um sistema operacional
	&unix; devem ser acessados por interm&eacute;dio de arquivos especiais,
	chamados n&oacute;s de dispositivos, ou <foreignphrase>device nodes</foreignphrase>,
	que est&atilde;o dispostos sob o diret&oacute;rio <filename>/dev</filename>.</para>

    <sect2>
      <title>Criando N&oacute;s de Dispositivos</title>
      <para>Ao adicionar um novo dispositivo em seu sistema, ou compilar
	suporte &agrave; dispositivos adicionais, pode ser necess&aacute;rio criar um ou mais
	n&oacute;s de dispositivos para controlar os rec&eacute;m adicionados.</para>

      <sect3>
	<title>MAKEDEV Script</title>
	<para>Em sistemas sem <literal>DEVFS</literal> (isso diz respeito &agrave; todas vers&otilde;es do
	FreeBSD antes da 5.0), n&oacute;s de dispositivos s&atilde;o criados utilizando a rotina
	&man.MAKEDEV.8; como apresentado &agrave; seguir:</para>

	<screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV ad1</userinput>
	</screen>

	<para>Este exemplo cria os n&oacute;s de dispositivos apropriados para
	o segundo dispositivo IDE, quando o mesmo for instalado.</para>
      </sect3>

      <sect3>
	<title><literal>DEVFS</literal> (DEVice File System)</title>

	<para>O sistema de arquivo de dispositivos, ou simplesmente
	  <literal>DEVFS</literal>, oferece acesso ao espa&ccedil;o em kernel
	  para os dados referentes aos nomes de dispositivos, no
	  sistema de arquivos global.  Ao inv&eacute;s de ter que criar e modificar
	  os n&oacute;s de dispositivos, <literal>DEVFS</literal> mant&eacute;m este
	  sistema de arquivos particular.</para>

	<para>Veja a p&aacute;gina de manual do &man.devfs.5; para
	  obter mais informa&ccedil;&otilde;es.</para>

	<para><literal>DEVFS</literal> &eacute; utilizado por padr&atilde;o no FreeBSD&nbsp;5.0 e posteriores.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="binary-formats">
    <title>Formatos de bin&aacute;rios</title>

    <para>Para entender o motivo pelo qual o FreeBSD usa o formato <acronym>ELF</acronym>
	voc&ecirc; deve saber primeiro um pouco mais sobre os tr&ecirc;s formados
	atualmente <quote>dominantes</quote> de arquivos execut&aacute;veis &unix;:</para>

    <itemizedlist>
      <listitem>
	<para>&man.a.out.5;</para>

	<para>O mais antigo e <quote>cl&aacute;ssico</quote> formato de
	  objetos &unix;.  Utiliza um cabe&ccedil;alho curto e compacto
	  com um n&uacute;mero m&aacute;gico (<foreignphrase>magic number</foreignphrase>)
	  no in&iacute;cio do mesmo, que geralmente &eacute; usado para caracterizar
	  seu formato (veja &man.a.out.5; para mais detalhes).  Cont&eacute;m
	  tr&ecirc;s segmentos carregados: .text, .data e .bss, acrecidos de
	  uma tabela de s&iacute;mbolos e uma tabela de conjunto caracteres.</para>
      </listitem>

      <listitem>
	<para><acronym>COFF</acronym></para>

	<para>O formato de objetivos SVR3.  Seu cabe&ccedil;alho compreende
	  uma tabela de se&ccedil;&otilde;es, de forma que &eacute; poss&iacute;vel ter mais
	  se&ccedil;&otilde;es do que apenas .text, .data e .bss.</para>
      </listitem>

      <listitem>
	<para><acronym>ELF</acronym></para>

	<para>O sucessor direto do <acronym>COFF</acronym>, oferecendo
	  m&uacute;ltiplas se&ccedil;&otilde;es e valores poss&iacute;veis de 32-bit ou 64-bit.
	  Uma grande desvantagem: <acronym>ELF</acronym> foi
	  projetado assumindo-se que haveria possilvemente apenas
	  uma ABI por arquitetura de sistema.  Essa considera&ccedil;&atilde;o
	  contudo &eacute; levemanete incorreta hoje em dia, e nem mesmo no
	  mundo comercial do SYSV (onde existem ao penos tr&ecirc;s
	  ABIs: SVR4, Solaris e SCO) ela &eacute; real.</para>

	<para>FreeBSD tenta amenizar este problema por meio de um
	  utilit&aacute;rio que reconhece um execut&aacute;vel <acronym>ELF</acronym>
	  e obt&eacute;m informa&ccedil;&otilde;es sobre a ABI compilada neste.  O utilit&aacute;rio
	  em quest&atilde;o &eacute; o <command>brandelf</command>.  Veja a p&aacute;gina de
	  manual do &man.brandelf.1; para obter mais informa&ccedil;&otilde;es.</para>
      </listitem>
    </itemizedlist>

    <para>FreeBSD vem do campo <quote>cl&aacute;ssico</quote> e durate muito
	tempo usou o formato &man.a.out.5;, uma tecnologia utilizada
	e aprovada por muitos gera&ccedil;&otilde;es de vers&otilde;es de sistemas BSD,
	at&eacute; o ramo 3.X do FreeBSD.  Apesar de ser poss&iacute;vel gerar
	bin&aacute;rios (e mesmo o kernel) no formato <acronym>ELF</acronym>
	bem antes do FreeBSD 3.X, o sistema inicialmente resistiu
	&agrave; <quote>press&atilde;o</quote> de mudar para o formato
	<acronym>ELF</acronym> como formato padr&atilde;o.  Por qu&ecirc;?  Bem,
	quando o pessoal do campo Linux fez sua dolorosa transi&ccedil;&atilde;o
	para <acronym>ELF</acronym>, os execut&aacute;veis <filename>a.out</filename>
	n&atilde;o podiam ser utilizados pois sua tabela de salto era consideradavelmente
	inflex&iacute;vel, e a constru&ccedil;&atilde;o de bibliotecas compartilhadas parecia
	ser complexa demais no novo formato, para os fabricantes e
	desenvolvedores em geral.  Depois que algumas ferramentas
	<acronym>ELF</acronym> ofereceram solu&ccedil;&otilde;es ao problema de
	bibliotecas compartilhadas, o formato passou a ser visto
	como <quote>o caminho a ser seguido</quote>, os custos de
	migra&ccedil;&atilde;o para este formato j&aacute; eram ent&atilde;o aceit&aacute;veis, e a
	transi&ccedil;&atilde;o foi feita.  O mecanismo de bibliotecas
	compartilhadas do FreeBSD &eacute; baseado com maior proximidade
	ao estilo de bibliotecas compartilhadas do &sunos; da Sun,
	e como tal, &eacute; muito f&aacute;cil de ser utilizado.</para>

    <para>Ent&atilde;o, por que existem tantos formatos distintos?</para>

    <para>De voltao ao sombrio, g&eacute;lido e distante passado, existiam
	apenas equipamentos simples de computa&ccedil;&atilde;o.  Estes equipamentos
	simples, suportavam sistemas simples e pequenos.
	O formato <filename>a.out</filename> era completamente adequado
	&agrave;s tarefas apresentadas pelos bin&aacute;rios nestes sistemas simplistas
	(como PDP-11).  Conforme o &unix; passou a ser convertido
	com base nestes sistemas simples, mantiveram o formado <filename>a.out</filename>
	pois era suficiente para as primeiras convers&otilde;es do &unix;, para
	arquiteturas como Motorola 68k, VAXen, etc.</para>

    <para>Depois algum engenheiro de <literal>hardware</literal> iluminado
	decidiu que ele poderia for&ccedil;ar os programas a realizarem algumas
	tarefas mais simples, de forma que ele poderia retirar alguns
	&iacute;tens de seu projeto de equipamento e permitir que o n&uacute;cleo
	de sua CPU processasse de forma mais r&aacute;pida.  Mesmo tendo sido
	projetado para funcionar com este novo tipo de hardware
	(conhecido hoje em dia como <acronym>RISC</acronym>),
	o formato <filename>a.out</filename> n&atilde;o se encaixava
	funcionalmente para o novo equipamento, ent&atilde;o v&aacute;rios formatos foram
	desenvolvedores para tentar garantir melhor performance deste
	novo equipamento, quando comparado ao que o limitado formato
	<filename>a.out</filename> poderia oferecer.  Algumas coisas como
	<acronym>COFF</acronym>, <acronym>ECOFF</acronym>, e alguns
	outros formatos obscuros foram inventados e suas limita&ccedil;&ograve;es
	exploradas antes que as coisas pudessem se estabilizar
	no formato <acronym>ELF</acronym>.</para>

    <para>Em adi&ccedil;&atilde;o, o tamanho dos programas estavam se tornando
	grandes, e os discos (bem como mem&oacute;ria f&iacute;sica) continuavam
	relativamente pequenos, ent&atilde;o o conceito de bibliotecas
	compartilhadas nasceu.  O sistema de mem&oacute;ria virtual tamb&eacute;m se
	tornou mais sofisticado.  Enquanto cada um desses avan&ccedil;os
	foram feitos utilizando o formato <filename>a.out</filename>,
	sua usabilidade foi se tornando cada vez mais duvidosa, na
	propor&ccedil;&atilde;o que novas caracter&iacute;sticas eram adicionadas.  Em
	adi&ccedil;&atilde;o, as pessoas queriam poder carregar as coisas de forma
	din&acirc;mica, no momento de execuss&atilde;o do sistema, ou ent&atilde;o
	dispensar trechos de seus programas depois que o c&oacute;digo
	inicial tivesse sido executado, para economizar mem&oacute;ria
	e espa&ccedil;o de troca (<foreignphrase>swap</foreignphrase>)
	As linguagens se tornaram mais sofisticadas, e as pessoas queriam
	que c&oacute;digos fossem carregados antes do programa principal de
	forma autom&aacute;tica.  Uma s&eacute;rie de modifica&ccedil;&otilde;es foram feitas
	no formato <filename>a.out</filename> para permitir que esse
	tipo de coisa pudesse acontecer, e basicamente tudo funcionou
	bem por um tempo.  Em determinado momento, o <filename>a.out</filename>
	n&atilde;o podia mais contornar estes problemas sem sobrecarregar seu
	c&oacute;digo e aumentar sua complexidade.  O formato <acronym>ELF</acronym>
	resolvia a maioria desses problemas, mas seria doloroso migrar
	de um sistema que, basicamente, funcionava.  Ent&atilde;o o formato
	<acronym>ELF</acronym> teve que esperar at&eacute; que fosse mais
	penoso continuar com o <filename>a.out</filename>, do que migrar
	para o <acronym>ELF</acronym>.</para>

    <para>Contudo, com o passar do tempo, as ferramentas de constru&ccedil;&atilde;o
	de onde o FreeBSD derivou suas pr&oacute;prias ferramentas de constru&ccedil;&atilde;o
	(o montador <foreignphrase>assembly</foreignphrase> e o
	carregador, especialmente) se envolveram em duas &aacute;rvores
	paralelas.  A &aacute;rvore FreeBSD adicionou bibliotecas compartilhadas
	e corrigiu algumas falhas.  O pessoal GNU que originalmente
	escreviam esses programas, rescreveram os mesmos de adicionaram
	suporte simples &agrave; compila&ccedil;&atilde;o cruzada, podendo adicionar formatos
	diferentes &agrave; bel prazer, e assim por diante.  Partindo do princ&iacute;pio
	que muitas pessoas desejavam criar compiladores cruzados para
	o FreeBSD, tiveram problemas pois os fontes antigos do FreeBSD
	faziam chamadas ao <application>as</application> e <application>ld</application>
	o que n&atilde;o possibilitava tal tarefa.  A nova corrente de ferramentas GNU
	(<application>binutils</application>) suporta compila&ccedil;&atilde;o cruzada,
	<acronym>ELF</acronym>, bibliotecas compartilhadas, extens&otilde;es C++, etc.
	Al&eacute;m disso, muitos fabricantes passaram a lan&ccedil;ar bin&aacute;rios
	<acronym>ELF</acronym>, e era bom que o FreeBSD pudesse rod&aacute;-los.</para>

    <para><acronym>ELF</acronym> &eacute; mais expressivo que <filename>a.out</filename> e
	oferece mais extensibilidade no sistema base.  As ferramentas
	<acronym>ELF</acronym> s&atilde;o melhor mantidas, e oferecem suporte
	&agrave; compila&ccedil;&atilde;o cruzada, que &eacute; importante para muita gente.
	O formato <acronym>ELF</acronym> pode ser um pouco mais lento do que
	<filename>a.out</filename>, mas tentar medir esta diferen&ccedil;a &eacute;
	bem dif&iacute;cil.  Existem ainda v&aacute;rios detalhes distintos entre ambos, em
	rela&ccedil;&atilde;o &agrave; como eles mapeiam p&aacute;ginas, tratam c&oacute;digo de inicializa&ccedil;&atilde;o,
	carregamento das instru&ccedil;&otilde;es, etc.  Nenhum destes fatores s&atilde;o
	muito relevantes, mas s&atilde;o diferentes.  Futuramente, o suporte
	&agrave; <filename>a.out</filename> ser&aacute; retirado do kernel <filename>GENERIC</filename>,
	e eventualmente removido do sistema quando a necessidade de executar
	programas <filename>a.out</filename> for passado.</para>
  </sect1>

  <sect1 id="basics-more-information">
    <title>Para mais informa&ccedil;&otilde;es</title>

    <sect2 id="basics-man">
      <title>P&aacute;ginas de Manuais</title>
      <indexterm><primary>p&aacute;ginas de manual</primary></indexterm>

      <para>A documenta&ccedil;&atilde;o mais compreensiva do FreeBSD &eacute; em forma de
	p&aacute;ginas de manuais.  Quase todo programa no sistema &eacute; acompanhado
	com um breve manual de refer&ecirc;ncia que explica a opera&ccedil;&atilde;o b&aacute;sica
	e os v&aacute;rios argumentos do programa.  Estes manuais podem ser visualizados
	com o comando <command>man</command>.  A utliza&ccedil;&atilde;o do comando
	<command>man</command> &eacute; simples:</para>

      <screen>&prompt.user; <userinput>man <replaceable>comando</replaceable></userinput></screen>

      <para><literal>comando</literal> &eacute; o nome do comando sobre o qual
	voc&ecirc; deseja aprender.  Por exemplo, para aprender sobre o
	comando <command>ls</command>, digite:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>O manual <quote>online</quote> &eacute; dividido em se&ccedil;&otilde;es numeradas:</para>

      <orderedlist>
	<listitem>
	  <para>Comandos de usu&aacute;rio.</para>
	</listitem>

	<listitem>
	  <para>Chamadas de sistema e n&uacute;mero de erros.</para>
	</listitem>

	<listitem>
	  <para>Fun&ccedil;&otilde;es de bibliotecas C.</para>
	</listitem>

	<listitem>
	  <para>Controladores de dispositivos.</para>
	</listitem>

	<listitem>
	  <para>Formato de arquivos.</para>
	</listitem>

	<listitem>
	  <para>Jogos e outras divers&otilde;es.</para>
	</listitem>

	<listitem>
	  <para>Informa&ccedil;&otilde;es gerais.</para>
	</listitem>

	<listitem>
	  <para>Comandos de manuten&ccedil;&atilde;o e opera&ccedil;&atilde;o do sistema.</para>
	</listitem>

	<listitem>
	  <para>Desenvolvedores do kernel.</para>
	</listitem>
      </orderedlist>

      <para>Em alguns casos, o mesmo t&oacute;pico pode aparecer em mais de uma
	se&ccedil;&atilde;o do manual online.  Por exemplo, se houver um comando
	<command>chmod</command> para o usu&aacute;rio, e se houver uma chamada
	de sistema denominada <function>chmod()</function>, voc&ecirc; pode
	informar ao comando <command>man</command> qual delas voc&ecirc; quer,
	especificando a se&ccedil;&atilde;o:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>Esse comando apresentar&aacute; a p&aacute;gina de manual para o comando
	do usu&aacute;rio, <command>chmod</command>.  Referencias para uma se&ccedil;&atilde;o
	particular do manual online normalmente s&atilde;o apresentadas entre
	par&ecirc;nteses, nos documentos escritos, de forma que
	&man.chmod.1; se refere ao comando de usu&aacute;rio para
	<command>chmod</command>, e &man.chmod.2; se refere &agrave;
	chamada de sistema.</para>

      <para>&Eacute; bem facil utilizar essa ferramenta, quando voc&ecirc; sabe o nome
	do comando sobre o qual quer obter mais informa&ccedil;&otilde;es, mas e se
	voc&ecirc; n&atilde;o puder lembrar o nome do comando?  Pode usar o
	<command>man</command> para procurar por palavras
	chaves nas descri&ccedil;&otilde;es do comando, usando
	op&ccedil;&atilde;o <option>-k</option>:</para>

      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para>Com esse comando, uma lista de programas ser&aacute; apresentada, contendo
	em sua descri&ccedil;&atilde;o a express&atilde;o <quote>mail</quote>.  Na verdade
	esse comando tem a mesma funcionalidade de se utilizar o comando
	<command>apropos</command>.</para>

      <para>Ent&atilde;o, voc&ecirc; est&aacute; dando uma olhada em todos esses simp&aacute;ticos
	programas que voc&ecirc; encontrou sob <filename>/usr/bin</filename>
	mas n&atilde;o tem a menor id&eacute;ia do que quer que cada um deles fa&ccedil;a?
	Simplesmente digite:</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

	<para>ou</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

	<para>que fazem a mesma coisa.</para>
    </sect2>

    <sect2 id="basics-info">
      <title>Arquivos de Informa&ccedil;&otilde;es GNU</title>
      <indexterm><primary>Funda&ccedil;&atilde;o do Software Livre</primary></indexterm>

      <para>O FreeBSD inclui v&aacute;rias aplica&ccedil;&otilde;es e utilit&aacute;rios
	mantidos pela Funda&ccedil;&atilde;o do Software Livre (<acronym>FSF</acronym>).
	Em complemento &agrave;s p&aacute;ginas de manual, estes programas vem ainda com
	um documento hipertexto extenso, chamado arquivo <literal>info</literal>
	que pode ser visualizado com o comando <command>info</command> ou, se
	voc&ecirc; disp&otilde;e do <application>emacs</application> instalado, o modo
	<quote>info</quote> do <application>emacs</application> tem essa fun&ccedil;&atilde;o.</para>

      <para>Para usar o comando &man.info.1;, simplesmente digite:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>Para uma breve introdu&ccedil;&atilde;o, digite <literal>h</literal>.  Para uma
	r&aacute;pida refer&ecirc;ncia aos comandos, digite <literal>?</literal>.</para>
    </sect2>
  </sect1>
</chapter>
<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

