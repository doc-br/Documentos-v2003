<!--
     The FreeBSD Documentation Project

     $FreeBSD: pt_BR.ISO8859-1/books/handbook/basics/chapter.sgml,v 1.1.1.1 2003/11/28 01:13:14 eksffa Exp $
-->

<chapter id="basics">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Chris</firstname>
	<surname>Shumway</surname>
	<contrib>Reescrito por </contrib>
      </author>
    </authorgroup>
    <!-- 10 Mar 2000 -->
  </chapterinfo>

  <title>UNIX Básico</title>
  
  <sect1 id="basics-synopsis">
    <title>Sinópse</title>
    <indexterm><primary>basics</primary></indexterm>


   <para>O capítulo a seguir cobrirá os comandos básicos e
	funcionalidades do sistema operacional FreeBSD.  A
	maioria deste material é relevante à qualquer sistema
	operacional baseado ou similar ao &unix;.  Sinta-se
	livre para pular este capítulo se você for familiar
	com o conteúdo deste material.  Se você é um novo
	usuário FreeBSD, então definitivamente você deve
	ler todo este capítulo cuidadosamente.</para>

    <para>Após a leitura deste capítulo, você saberá:</para>

    <itemizedlist>
      <listitem>
        <para>Como usar os <quote>consoles virtuais</quote> do
	  FreeBSD.</para>
      </listitem>
      <listitem>
	<para>Como as permissões &unix; funcionam.</para>
      </listitem>
      <listitem>
	<para>A disposição padrão dos sistemas de arquivos no &os;.</para>
      </listitem>
      <listitem>
	<para>Como montar e desmontar sistemas de arquivos.</para>
      </listitem>
      <listitem>
	<para>O que são <foreignphrase>daemons</foreignphrase>, processos e sinais.</para>
      </listitem>
      <listitem>
	<para>O que é uma <literal>shell</literal> (interpretador de comandos) e como
	modificar seu ambiente padrão de <literal>login</literal>.</para>
      </listitem>
      <listitem>
	<para>Como utilizar editores de texto básicos.</para>
      </listitem>
      <listitem>
	<para>O que são dispositivos e nós de dispositivos.</para>
      </listitem>
      <listitem>
	<para>Que formato binário é usado no &os;.</para>
      </listitem>
      <listitem>
	<para>Como ler as páginas de manual para obter mais informações.</para>
      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 id="consoles">
    <title>Consoles virtuais e terminais</title>
    <indexterm><primary>consoles virtuais</primary></indexterm>
    <indexterm><primary>terminais</primary></indexterm>

    <para>O FreeBSD pode ser utilizado de várias maneiras.  Uma delas
	é através de comandos digitados em um terminal de texto.  Muito
	da flexibilidade e do poder de um sistema operacional &unix; é
	disponível de imediato ao alcance de suas mãos, quando se
	utiliza o FreeBSD desta maneira.  Esta seção descreve o que
	são <quote>terminais</quote> e <quote>consoles</quote> e como
	utiliza-los no FreeBSD.</para>

    <sect2 id="consoles-intro">
      <title>O Console</title>
      <indexterm><primary>console</primary></indexterm>

      <para>Se você não configurou o FreeBSD para iniciar um ambiente
	gráfico automaticamente durante sua inicialização, o sistema
	irá apresentar a você uma tela de <literal>login</literal> assim
	que for iniciado, logo depois que os <literal>scripts</literal> de
	inicialização forem executados.  Você verá algo similar a:</para>

      <screen>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:</screen>

      <para>A mensagem deve ser um pouco diferente em seu sistema, mas algo similar
	será apresentado.  As duas últimas linhas são as que nós estamos
	especialmente interessandos no momento.  Na penúltima linha você
	pode ler:</para>

      <programlisting>FreeBSD/i386 (pc3.example.org) (ttyv0)</programlisting>

      <para>Essa linha oferece algumas informaçòes sobre o sistema
	que acabou de ser iniciado.  Você está olhando para um
	console <quote>FreeBSD</quote>, rodando em arquitetura Intel
	x86 ou compatível<footnote>
	  <para>É isso que <literal>i386</literal> significa.  Note que mesmo
	   se você não estiver executando o FreeBSD em um processador Intel 386,
	   esta informação ainda será apresentada como <literal>i386</literal>.
	   Não trata-se do tipo de seu processador, mas sim a <quote>
	   arquitetura</quote> do processador, que é apresentada aqui.</para>
	</footnote>.  O nome desta maquina (toda maquina &unix; tem um nome)
	é <hostid>pc3.example.org</hostid>, e agora você está analisando
	seu console de sistema &mdash; o terminal <devicename>ttyv0
	</devicename>.</para>

      <para>Finalmente, a última linha será sempre:</para>

      <programlisting>login:</programlisting>

      <para>Este é o local onde você deve digitar seu nome de usuário
	(<quote>username</quote>) para logar-se no FreeBSD.  A próxima
	seção descreve como fazê-lo.</para>
    </sect2>

    <sect2 id="consoles-login">
      <title>Logando-se no FreeBSD</title>

	<para>FreeBSD é um sistema multiusuário e de multiprocessamento.
	  Esta é a descrição formal normalmente
	  dada a um sistema que pode ser usado por pessoas diferentes,
	  que simultâneamento executam uma
	  série de programas na mesma estação.</para>

      <para>Todo sistema multiusuário requer uma maneira para fazer
	distinção entre um <quote>usuário</quote> e os outros.  No
	FreeBSD (e todo sistema operacional similar ou baseado em &unix;)
	isso é garantido com a obrigatoriedade de todo usuário <quote>
	logar-se</quote> ao sistema antes de poder executar qualquer
	programa.  Todo usuário tem um nome único (o <quote>username</quote>)
	e uma senha secreta pessoal (o <quote>password</quote>).  O FreeBSD
	solicitará estas duas informações para permitir que um usuário
	se logue ao sistema e execute qualquer programa.</para>

      <indexterm><primary>scripts de inicializaçào</primary></indexterm>
      <para>Assim que o FreeBSD é iniciado e acaba de executar seus
	<literal>scripts</literal> de inicialização<footnote>
	  <para><literal>Scripts</literal> de inicialização são programas
	   executados automaticamente quando o FreeBSD é iniciado.  Sua
	   principal função é configurar tudo que for necessário para
	   o resto do sistema funcionar, e iniciar todos os serviços que
	   você configurou para serem executados em instância de fundo,
	   (em <foreignphrase>background</foreignphrase> realizado tarefas
	   úteis.</para>
	</footnote>, será apresentada a você uma tela que solicitará
	um usuário válido:</para>

      <screen>login:</screen>

      <para>Para compreensão deste exemplo, vamos assumir que o seu nome de
	usuário é <username>john</username>.  Digite <literal>john</literal> na tela
	de <literal>login</literal> e aperte <keycap>Enter</keycap>.  Em seguida
	será apresentada a tela que solicita sua <quote>senha</quote> (o <quote>
	password</quote>):</para>

      <screen>login: <userinput>john</userinput>
Password:</screen>

      <para>Digite agora a senha do usuário <username>john</username> e aperte
	<keycap>Enter</keycap>.  A senha <emphasis>não é
	apresentada!</emphasis>  Não é necessário se preocupar com isso agora.
	É suficiente dizer que o comportamento é este por razões de
	segurança.</para>

      <para>Se você digitou sua senha corretamente, você deve ter se logado
	no FreeBSD e está pronto para testar todos os comandos
	disponíveis.</para>

      <para>Você deve ver a <acronym>MOTD</acronym>, a mensagem do dia,
	seguida do terminal de comandos (um caracter <literal>#</literal>,
	<literal>$</literal>, ou <literal>%</literal>).  Isso indica
	que você se logou com sucesso no FreeBSD.</para>
    </sect2>

    <sect2 id="consoles-virtual">
      <title>Multiplos Consoles</title>

      <para>É legal utilizar um console para executar comandos &unix;,
	mas o FreeBSD pode executar vários programas de uma vez.  Ter
	apenas um console onde os comandos são digitados pode ser 
	considerado um leve desperdício, quando um sistema operacional como
	o FreeBSD pode rodar dezenas de programas ao mesmo tempo.
	É aí que os <quote>consoles virtuais</quote> podem se mostrar
	muito úteis.</para>

      <para>O FreeBSD pode ser configurado para oferecer vários consoles
	virtuais diferentes.  Você pode alternar de um para outro apertando
	um conjunto de teclas em seu teclado.  Cada console tem seu
	próprio canal de saída, e o FreeBSD cuida de redirecionar as
	entradas do console para cada console virtual e monitor, e também
	a saída padrão quando você alterna de um para o próximo console
	virtual.</para>

      <para>Combinações especiais de teclas foram reservada pelo FreeBSD
	para controlar a alternância de consoles<footnote>
	  <para>Uma descrição técnica e considerávelmente acurada de
	   todos detalhes sobre o console FreeBSD e dispositivos de
	   teclado pode ser encontrada nas páginas de manuais do &man.syscons.4;, 
	   &man.atkbd.4;, &man.vidcontrol.1; e &man.kbdcontrol.1;.  Não vamos
	   entrar nestes detalhes aqui, mas o leitor interessado pode sempre
	   consultar as páginas de manual para obter explicações mais
	   detalhadas de como as coisas funcionam.</para>
	</footnote>.  Você pode usar
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>,
	<keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo>, até
	<keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo> para 
	alternar entre diferentes consoles virtuais no FreeBSD.</para>

      <para>Conforme você estiver alternando entre um console e outro, o
	FreeBSD se responsabiliza por salvar e restaurar o conteúdo
	de de cada tela.  O resultado é uma <quote>ilusão</quote> de 
	múltiplas telas e teclados <quote>virtuais</quote> disponíveis, de
	forma que você possa digitar qualquer comando para o FreeBSD
	executar.  Os programas que são iniciados por você em um
	console virtual não param de ser executados quando o console
	não está visível.  Eles continuam a ser processados quando
	acontece alternância de console virtual.</para>
    </sect2>

    <sect2 id="consoles-ttys">
      <title>O arquivo <filename>/etc/ttys</filename></title>

      <para>A configuração padrão do FreeBSD iniciará oito
	consoles virtuais.  Contudo, esta configuração não é
	imutável e pode ser fácilmente customizada de forma a
	possibilitar que o sistema seja iniciado com mais ou
	menos consoles virtuais.  O número e definições
	para os consoles virtuais estão configuradas no arquivo
        <filename>/etc/ttys</filename>.</para>

      <para>Você pode usar o arquivo <filename>/etc/ttys</filename> para configurar
	consoles virtuais do FreeBSD.  Cada linha descomentada neste arquivo
	(linhas que não começam com o caracter <literal>#</literal>) contém
	ajustes para um único terminal ou console virtual.  A versão
	padrão deste arquivo oferece com o FreeBSD nove consoles
	virtuais, e habilita oito deles.  São as linhas que começam
	com <literal>ttyv</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>Para obter uma descrição detalhada do significado de cada coluna 
	deste arquivo e todas opções disponíveis para os consoles virtuais,
	consulte a página de manual &man.ttys.5;.</para>
    </sect2>

    <sect2 id="consoles-singleuser">
      <title>Console de usuário em modo mono-usuário</title>

      <para>Uma descrição detalhada sobre o que é o <quote>modo mono-usuário</quote>
	pode ser encontrada em <xref linkend="boot-singleuser">.  Vale a pena
	notar que existe apenas um console disponível quando se está
	operando o sistema em modo mono-usuário.  Não existem consoles
	virtuais disponíveis.  As configurações do console em modo
	mono-usuário também podem ser definidas no arquivo
	<filename>/etc/ttys</filename>.  Olha na linha que começa
	com <literal>console</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off secure</programlisting>

      <note>
        <para>Como indicam os comentários acima da linha <literal>console</literal>,
	  você pode editar esta linha e modificar a entrada <literal>secure</literal>
	  para <literal>insecure</literal>.  Se você o fizer, quando o FreeBSD
	  iniciar em modo mono-usuário, ele continuará pedindo a senha do
	  usuário <username>root</username>.</para>

	<para><emphasis>Seja cuidadoso ao modificar esta opção para
	  <literal>insecure</literal></emphasis>.  Se você esquecer
	  um dia a senha de <username>root</username>, entrar em modo
	  mono-usuário vai ser um pouco complicado.  Ainda é possível,
	  mas será um pouco difícil para os usuários ainda não muito
	  confortáveis com o processo de inicialização do FreeBSD
	  e os programas envolvidos.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="permissions">
    <title>Permissões</title>
    <indexterm><primary>UNIX</primary></indexterm>

    <para>FreeBSD, como decendente direto do &unix; BSD, se baseia em inúmeros
	conceitos chaves do &unix;.  O primeiro e mais citado, é que o FreeBSD
	é um sistema operacional multi-usuário.  O sistema pode gerenciar
	inúmeros usuários, todos trabalhando simultaneamente em tarefas
	completamente distintaso.  O sistema é responsável pelo compartilhamento,
	e gerencialmente apropriado de pedidos de acesso aos dispositivos de
	controle de equipamentos, periféricos, de memória, e tempo de processamento,
	de forma justa entre os usuários.</para>

    <para>Pelo fato do sistema poder suportar múltiplos usuários, tudo que
	o sistema gerencia é composto de um conjunto de permissões que
	governam quem pode ler, escrever, e executar recursos.  Estas 
	permissões são armazenadas como três octetos divididos em três
	partes, uma para o dono do arquivo, uma para o grupo à que o
	arquivo pertence, e uma para todos os outros usuários.  Sua
	representação numérica funcionam assim:</para>

    <indexterm><primary>permissões</primary></indexterm>
    <indexterm>
      <primary>permissões de arquivos</primary>
    </indexterm>
    <informaltable frame="none">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Valor</entry>
	    <entry>Permissões</entry>
	    <entry>Listagem de diretório</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>Sem leitura, sem escrita, sem execussão</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>Sem leitura, sem escrita, com execussão</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>Sem leitura, com escrita, sem execussão</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>Sem leitura, com escrita, com execussão</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>Com leitura, sem escrita, sem execussão</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>Com leitura, sem escrita, com execussão</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>Com leitura, com escrita, sem execussão</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>Com leitura, com escrita, com execussão</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    <indexterm>
      <primary><command>ls</command></primary>
    </indexterm>
    <indexterm><primary>directories</primary></indexterm>

    <para>A opção <option>-l</option> pode ser usada junto ao
	&man.ls.1; para visualizar listagem detalhada do diretório
	incluindo uma coluna com informações sobre as permissões
	de cada arquivo, para o dono, grupo, e outros.  Por exemplo,
	a saída do comando <command>ls -l</command> em um
	diretório qualquer, mostrará:</para>

    <screen>&prompt.user; <userinput>ls -l</userinput>
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...</screen>

    <para>Aqui está a forma como a primeira coluna do <command>ls -l</command> 
	é dividida:</para>

    <screen>-rw-r--r--</screen>

    <para>O primeiro caracter (o mais à esquerda) indica que
	se este é um arquivo normal, se é um diretório, um dispositivo
	especial, um <literal>socket</literal> ou qualquer outro
	pseudo-dispositivo especial.  Nesse caso, o <literal>-</literal>
	indica que trata-se de um arquivo regular.  Os próximos três
	caracteres, <literal>rw-</literal> neste exemplo, indicam as
	permissões para o dono do arquivo.  Os próximos três caracteres,
	<literal>r--</literal>, indicam as permissões para o grupo 
	ao qual o arquivo pertence.  Os três caracteres finais,
	<literal>r--</literal>, indicam as permissoes para o resto
	do mundo.  Um hífen indica que a permissão está desligada.
	No caso deste arquivo, dono ler e escrever neste arquivo, o
	grupo pode ler o arquivo e o resto do mundo pode também apenas ler
	o arquivo.  De acordo com a tabela acima, as permissões para
	o arquivo seriam <literal>644</literal>, onde cada dígito
	representa as três partes das permissões do arquivo.</para>

    <para>Isso é muito bonito e legal, mas como o sistema controla
	as permissões nos dispositivos?  FreeBSD na verdade trata
	a maioria dos dispositivos de <literal>hardware</literal>
	como arquivos onde os programas podem ler, abrir, e escrever dados,
	como se fosse qualquer outro arquivo.  Estes arquivos de dispositivos
	são armazenados no diretório <filename>/dev</filename>.</para>

    <para>Diretórios também são tratados como arquivos comuns.  Eles tem
	permissões de leitura, escrita e execussão.  O <firstterm>bit</firstterm>
	de execussão em um diretório tem uma sútil diferença quando
	comparado a um arquivo.  Quando um diretório é definido como
	executável, significa que ele pode ser explorado, ou seja, que é
	possível entrar neste diretório (<quote>cd</quote>).  Também
	significa que dentro do diretório, pode-se acessar arquivos cujos
	nomes são conhecidos (de acordo com as permissões dos próprios
	arquivos, é claro).</para>

    <para>Em particular, para realizar a listagem de um diretório,
	é necessário ter permissões de leitura no mesmo, enquanto
	para apagar um arquivo cujo nome já é conhecido, é
	necessário ter permissões de escrita <emphasis>e</emphasis>
	execussão no diretório onde está o arquivo.</para>

    <para>Existem outros bits de permissões, mas eles são
	utilizados em circustâncias especiais como binários
	como <literal>setuid</literal> e diretórios com
	opção <literal>sticky</literal>.  Se você deseja obter mais
	informações sobre as permissões de arquivo e como
	defini-las, dê uma olhada na página de manual
	do &man.chmod.1;.</para>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Contribução de</contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Permissões simbólicas</title>
      <indexterm><primary>Permissões</primary><secondary>simbólicas</secondary></indexterm>

      <para>Permissões simbólicas, as vezes se referem à expressões de permissões, ou
	o uso de caracteres em substituição aos valores octais que
	atribuem permissões aos arquivos e diretórios.  Expressões simbólicas
	usam a sintaxe (quem) (ação) (permissões), onde os seguintes valores
	estão disponíveis:</para>

      <informaltable frame="none">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Opção</entry>
	      <entry>Letra</entry>
	      <entry>Representação</entry>
	    </row>
	  </thead>

	<tbody>
	  <row>
	    <entry>(quem)</entry>
	    <entry>u</entry>
	    <entry>Usuário</entry>
	  </row>

	  <row>
	    <entry>(quem)</entry>
	    <entry>g</entry>
	    <entry>Grupo dono</entry>
	  </row>

	  <row>
	    <entry>(quem)</entry>
	    <entry>o</entry>
	    <entry>Outros</entry>
	  </row>

	  <row>
	    <entry>(quem)</entry>
	    <entry>a</entry>
	    <entry>Todos (<quote>o mundo</quote>)</entry>
	  </row>

	  <row>
	    <entry>(ação)</entry>
	    <entry>+</entry>
	    <entry>Adicionar permissões</entry>
	  </row>

	  <row>
	    <entry>(ação)</entry>
	    <entry>-</entry>
	    <entry>Remover permissões</entry>
	  </row>

	  <row>
	    <entry>(ação)</entry>
	    <entry>=</entry>
	    <entry>Definir permissões explicitamente</entry>
	  </row>

	  <row>
	    <entry>(permissões)</entry>
	    <entry>r</entry>
	    <entry>Leitura</entry>
	  </row>

	  <row>
	    <entry>(permissões)</entry>
	    <entry>w</entry>
	    <entry>Escrita</entry>
	  </row>

	  <row>
	    <entry>(permissões)</entry>
	    <entry>x</entry>
	    <entry>Execussão</entry>
	  </row>

	  <row>
	    <entry>(permissões)</entry>
	    <entry>t</entry>
	    <entry>Bit de <literal>sticky</literal></entry>
	  </row>

	  <row>
	    <entry>(permissões)</entry>
	    <entry>s</entry>
	    <entry>Define UID ou GID</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Estes valores são usados com o comando &man.chmod.1; exatamente
	como da forma anterior, mas sem letras.  Por exemplo, você
	pode usar o seguinte comando para impedir que outros usuários
	deixem de acessar determinado <replaceable>ARQUIVO</replaceable>:</para>

    <screen>&prompt.user; <userinput>chmod go= ARQUIVO</userinput></screen>

    <para>Pode-se fazer uso de uma lista separado por vírgula, quando
	se desejar que mais de uma modificação seja realizada no arquivo.
	Por exemplo, o comando à seguir remove as permissões de escrita
	para o grupo e <quote>todo o mundo</quote>, no <replaceable>
	ARQUIVO</replaceable>, e então adiciona permissões de
	execussão à todos:</para>

    <screen>&prompt.user; <userinput>chmod go-w,a+x <replaceable>FILE</replaceable></userinput></screen>

<!--
    <para>A maioria dos usuários vão perceber isso, mas é importante
	lembrar que utilizar o método octal de permissões
	apenas definirá ou modificará permissões em um
	arquivo; ele não os adiciona ou apaga.</para>
-->
    </sect2>
  </sect1>
  
  <sect1 id="dirstructure">
    <title>Estrutura de Diretórios</title>
    <indexterm><primary>hierarquia de diretório</primary></indexterm>

    <para>Conhecer a hierarquia de diretórios do FreeBSD é
	fundamental para se obter entendimento total do
	sistema.  O conceito mais importante para se assimilar
	é o conceito do diretório raiz, o <quote>/</quote>.  Esse
	diretório é montado inicialmente no momento em que o
	sistema é carregado, e ele contém o sistema base necessário
	para preparar o a entrada em modo de operação multi-usuário
	do sistema operacional.  O diretório raiz contém ainda
	pontos de montagem para cada outro sistema de
	arquivos que você queira montar.</para>

    <para>Um ponto de montagem é um diretório onde sistemas de
	arquivos adicionais podem ser acoplados ao sistema de
	arquivos raiz.  Pontos de montagem padrão incluem
	<filename>/usr</filename>, <filename>/var</filename>,
	<filename>/mnt</filename>, e <filename>/cdrom</filename>.  Esses
	diretórios normalmente são encontrados como entradas
	dispostas no arquivo <filename>/etc/fstab</filename>.  O <filename>
	/etc/fstab</filename> é uma tabela com vários sistemas de
	arquivos e pontos de montagem que o sistema usa como referência.
	A maioria dos sistemas de arquivos no <filename>/etc/fstab
	</filename> são montados automaticamente no momento da 
	inicialização, à partir do <literal>script</literal> &man.rc.8;
	a não se que eles contenham a opção <option>noauto</option> definida.
	Consulte a página de manual do &man.fstab.5; para obter mais informações
	sobre o formato do arquivo <filename>/etc/fstab</filename> e seu
	conteúdo.</para>

    <para>Uma descrição completa da hierarquia do sistema de arquivos
	está disponível na página de manual &man.hier.7;.  Por hora, uma
	breve descrição dos diretórios mais comuns será abordada:</para>

    <para>
      <informaltable frame="none">
        <tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Diretório</entry>
	      <entry>Descrição</entry>
	    </row>
	  </thead>
	  <tbody>
            <row>
	      <entry><filename class="directory">/</filename></entry>
	      <entry>Diretório raiz do sistema de arquivo.</entry>
            </row>
	    
	    <row>
	      <entry><filename class="directory">/bin/</filename></entry>
	      <entry>Utilitários do usuário, fundamentais
		para os ambientes de multi-usuário e mono-usuário.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/boot/</filename></entry>
	      <entry>Arquivos e programas de configuração que
		são usados durante o processo de inicialização
		do sistema operacional.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/boot/defaults/</filename></entry>
	      <entry>Arquuivos de configuração padrão do sistema de
		inicializaçào, veja a página de manual &man.loader.conf.5;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/dev/</filename></entry>
	      <entry>Dispositivos de controle; veja &man.intro.4;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/</filename></entry>
	      <entry>Arquivos e scripts de configuração do sistema.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/defaults/</filename></entry>
	      <entry>Arquivos de configuração padrão do sistema; veja &man.rc.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/mail/</filename></entry>
	      <entry>Arquivos de configuração para os agentes de transferência
		de correio, como o &man.sendmail.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/namedb/</filename></entry>
	      <entry>Arquivos de configuração do <command>named</command>; veja
	      &man.named.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/periodic/</filename></entry>
	      <entry>Scripts que são executados diariamente, semanalmente
		e mensalmente por meio do &man.cron.8;; veja &man.periodic.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/ppp/</filename></entry>
	      <entry>Arquivos de configuração do <command>ppp</command>; veja
	      &man.ppp.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/mnt/</filename></entry>
	      <entry>Diretório vazio normalmente utilizado pelos administradores
		de sistemas como ponto de montagem temporário.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/proc/</filename></entry>
	      <entry>Sistema de arquivos de processos; veja &man.procfs.5; e
	      &man.mount.procfs.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/root/</filename></entry>
	      <entry>Diretório home da conta de usuário
		<username>root</username>.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/sbin/</filename></entry>
	      <entry>Utilitários de programas e administração, fundamentais
		para os ambientes de multi-usuário e mono-usuário.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/stand/</filename></entry>
	      <entry>Programas usados no ambiente independente.</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/tmp/</filename></entry>
	      <entry>Arquivos temporários, normalmente um diretório
		montado em memória com ti ti ti arrumar isso &man.mfs.8; (
		memory-based file system (the contents of <filename
		class="directory">/tmp</filename> are usually NOT
		preserved across a system reboot).</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/usr/</filename></entry>
	      <entry>A maioria dos utilitários e aplicações de usuários.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/bin/</filename></entry>
	      <entry>Utilitários comuns, ferramentas de programação
		e aplicações.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/include/</filename></entry>
	      <entry>Arquivos C padrão de inclusão.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/lib/</filename></entry>
	      <entry>Bibliotecas.</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/usr/libdata/</filename></entry>
	      <entry>Arquivos de dados de utilitários variados.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/libexec/</filename></entry>
	      <entry>Daemons & utilitários do sistema (executados por
		outros programas).</entry>
	    </row>
	    
	    <row>
	      <entry><filename
	      class="directory">/usr/local/</filename></entry>

	      <entry>Executáveis locais, bibliotecas, etc.  Também
		utilizado como destino padrão para o sistema de
		Ports.  Dentro de <filename>/usr/local</filename>,
	        a disposição hierárquica geral é definida pelo
		&man.hier.7; como o definido pelo <filename>/usr</filename>.
		Exceto o diretório de páginas de manuais que são
		diretamente dispostas sob <filename>/usr/local</filename>
		ao invés de serem sobre <filename>/usr/local/share</filename>,
		e a documentação das aplicações de terceiros, que ficam
		sob <filename>share/doc/<replaceable>port</replaceable></filename>.
	      </entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/obj/</filename></entry>
	      <entry>Arquivo de destino dos objetos binários específicos
		para cada arquitetura, constribuídos à partir da
		árvore <filename>/usr/src</filename>.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/ports</filename></entry>
	      <entry>A Coleção de Ports do FreeBSDn (opcional).</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/sbin/</filename></entry>
	      <entry>Daemons & utilitários do sistema (executados por usuários).</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/share/</filename></entry>
	      <entry>Arquivos independentes de arquitetura.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/src/</filename></entry>
	      <entry>Arquivos de fontes locais e/ou BSD.</entry>
	    </row>
	    
	    <row>
	      <entry><filename
	      class="directory">/usr/X11R6/</filename></entry>
	      <entry>Executáveis da distribuição do X11R6, bibliotecas,
		etc (opcional).</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/</filename></entry>
	      <entry>Arquivos de log de múltiplos propósitos, arquivos
		temporários, de transição, e arquivos de bobina (spool).</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/var/log/</filename></entry>
	      <entry>Arquivos de logs variados do sistema.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/mail/</filename></entry>
	      <entry>Arquivos de caixa de corrêio dos usuários.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/spool/</filename></entry>
	      <entry>Diretórios de spool de impressão e de correio.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/tmp/</filename></entry>
	      <entry>Arquivos temporários que são mantidos entre
		reinicializações do sistema.</entry>
	    </row>
	    
	    <row>
	      <entry><filename>/var/yp</filename></entry>
	      <entry>Mapas NIS.</entry>
	    </row>

	  </tbody>
	</tgroup>
      </informaltable>
    </para>

  </sect1>

  <sect1 id="disk-organization">
      <title>Organização de disco</title>

      <para>A menor unidade organizacional que o FreeBSD utiliza
	para definir os arquivos é o nome de arquivo.  Nome de arquivos
	são <quote>canse-sensitive</quote>, ou seja fazem distinção
	entre maiúsculas e minúscilas, o que significa que
	<filename>readme.txt</filename> e <filename>README.TXT</filename>
	são dois arquivos distintos.  FreeBSD não utiliza a extensão
	do arquivo (<filename>.txt</filename>) para determinar se
	o arquivo é um programa ou um documento, ou ainda qualquer
	outro tipo de dado.</para>

      <para>Arquivos são armazenados em diretórios.  Um diretório pode
	não conter arquivo algum, ou pode conter centenas de arquivos.  Um
	diretório pode ainda conter outros diretórios, permitindo que você
	construa hierarquias inteiras de diretórios, uns dentro dos outros.
	Isso torna a organização de seus dados muito mais fácil.</para>

      <para>Arquivos e diretórios são identificados por seu nome, seguido por
	uma barra dianteira, <literal>/</literal>, seguido de outros nomes de
	diretórios, conforme necessário.  Se você tem o diretório
	<filename>foo</filename>, e dentro dele o diretório 
	<filename>bar</filename>, que por sua vez contém o arquivo
	<filename>readme.txt</filename>, então o nome completo, ou
	o <firstterm>path</firstterm> para este arquivo é
	<filename>foo/bar/readme.txt</filename>.</para>

      <para>Diretórios e arquivos são armazenados em um sistema de arquivos.
	Cada sistema de arquivos contém exatamente um diretório de nível
	hierárquico interior, chamado de <firstterm>diretório raiz</firstterm>
	para o sistema de arquivos.  Este diretório raiz pode conter outros
	diretórios.</para>

      <para>Certamente isso tudo é similar à qualquer outro sistema
	operacional que você já usou.  Existem algumas diferenças básicas;
	por exemplo, DOS usa a barra invertida, <literal>\</literal>, para
	separar qualquer arquivo ou nome de diretório, enquanto o &macos;
	utiliza o <literal>:</literal>.</para>

      <para>O FreeBSD não utiliza letras de dispositivos ou qualquer
	outro tipo de nome para os dispositivos do sistema de arquivos.
	Você jamais escreveria <filename>c:/foo/bar/readme.txt</filename>
	no FreeBSD.</para>

      <para>Ao invés disso, um sistema de arquivo é definido como
	<firstterm>sistema de arquivos raiz</firstterm>.  O diretório
	raiz do sistema de arquivo raiz é o <literal>/</literal>.  Todo
	outro sistema de arquivos é montado (<firstterm>mounted</firstterm>)
	sob este sistema de arquivos.  Não importa
	quantos discos existam no seu sistema FreeBSD, cada diretório
	é apresentado como parte do disco.</para>

      <para>Suponha que você tenha três sistemas de arquivos, chamados
	<literal>A</literal>, <literal>B</literal>, e <literal>C</literal>.
	Cada sistema de arquivos tem seu próprio diretório raiz,
	que contém outros dois diretórios chamados
	<literal>A1</literal>, <literal>A2</literal> (e da mesma forma
	<literal>B1</literal>, <literal>B2</literal> e
	<literal>C1</literal>, <literal>C2</literal>).</para>

      <para>Assuma <literal>A</literal> como sistema de arquivos raiz.  Se
	você usou o comando <command>ls</command> para visualizar o
	conteúdo deste diretórios, você veria dois subdiretórios, 
	<literal>A1</literal> e
	<literal>A2</literal>.  A árvore de diretórios ficaria assim:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir1" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>Todo sistema de arquivos deve ser montado em um
	diretório disposto em outro sistema de arquivos.
	Então, suponha que você tenha montado o sistema de
	arquivos  <literal>B</literal> no diretório <literal>A1</literal>.
	O diretório raiz do <literal>B</literal> substitui <literal>A1</literal>,
	e os diretórios em <literal>B</literal> se tornam apropriadamente
	disponíveis:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir2" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 | 
 +--- A1
 |     |
 |     +--- B1
 |     |
 |     `--- B2
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>Quaisquer arquivos que estejam nos diretórios <literal>B1</literal> ou
	<literal>B2</literal> podem ser acessados com o <literal>path</literal>
	<filename>/A1/B1</filename> ou <filename>/A1/B2</filename> conforme
	necessário.  Qualquer arquivo que estivesse no <filename>/A1</filename>
	foi temporariamente escondido.  Eles reaparecerão se 
	<literal>B</literal> for <firstterm>desmontado</firstterm> de 
	<literal>A</literal>.</para>

      <para>Se <literal>B</literal> foi montado em <literal>A2</literal>
	então o diagrama será parecido com:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir3" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>e os <literal>paths</literal> seriam <filename>/A2/B1</filename> e
	<filename>/A2/B2</filename> respectivamente.</para>

      <para>Os sistemas de arquivos podem ser montados em sobreposição à outros.
	Prosseguindo com o último exemplo, o sistema de arquivo <literal>C</literal>
	poderia ser montado sobre o diretório <literal>B1</literal> no sistema de
	arquivos  <literal>B</literal>, levando ao seguinte arranjo:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir4" format="EPS">
	</imageobject>
	
	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |     |
       |     +--- C1
       |     |
       |     `--- C2
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>Ou <literal>C</literal> poderia ser montado diretamente no
	sistema de arquivos <literal>A</literal>, sob o diretório
	<literal>A1</literal>:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir5" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- C1
 |     |
 |     `--- C2
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>Se você tem familiaridade com o DOS, a teoria é parecida, mas não
	idêntica, ao comando <command>join</command>.</para>

      <para>Normalmente isso não é algo com que você tenha
	que se preocupar.  Tipicamente basta criar os sistemas de
	arquivos ao instalar o FreeBSD e decidir onde monta-los, e 
	depois nunca mais modifica-los, a não ser que você
	adicione um novo disco.</para>

      <para>É completamente possível ter um sistema de arquivos raiz, e
	não criar mais nenhum.  Existem alguns problemas com esta abordagem
	e uma grande desvantagem.</para>

      <itemizedlist>
	<title>Benefícios de sistemas de arquivos múltiplos</title>
      
	<listitem>
	  <para>Sistemas de arquivos distintos podem ter <firstterm>opções
		de montagem</firstterm> distintas.  Por exemplo, com
		planejamento cuidadoso, o sistema de arquivos raiz
		pode ser montado como apenas-leitura, criando um ambiente
		onde será impossível apagar ou editar arquivos críticos
		inadivertidamente.  Separando sistemas de arquivos
		que podem ser escritos por todos usuários, como o
		<filename>/home</filename>, de outros sistemas de
		arquivos, ainda permite que eles sejam montados com
		<firstterm>nosuid</firstterm>; esta opção previne
		que os bits <firstterm>suid</firstterm>/<firstterm>guid</firstterm>
		sejam atribuídos em arquivos executáveis, não tendo mais
		efeito no sistema de arquivos em questão, possívelmente
		complementando a segurança do ambiente.</para>
	</listitem>

	<listitem>
	  <para>O FreeBSD otimiza a disposição dos arquivos de forma
		automática, dependendo de como o sistema de arquivos
		está sendo usado.  Portanto um sistema de arquivos que
		contém muitos arquivos pequenos que são frequentemente
		escritos terão regras de otimização distintas daqueles
		sistemas de arquivos com poucos, mas grandes arquivos.
		Mantendo um único sistema de arquivos enorme, esta
		otimização se torna inviável.</para>
	</listitem>
	
	<listitem>
	  <para>Os sistemas de arquivos do FreeBSD são muito robustos, mesmo
		em situações de queda de energia.  Contudo, uma interrupção
		de energia em um ponto crítico pode danificar parcialmente a
		estrutura do sistema de arquivos.  Dividir os dados em múltiplos
		sistemas de arquivos aumenta a possibilitado do sistema não
		ficar indisponível, tornando mais fácil a restauração
		de cópias de segurança, caso necessário.</para>
	</listitem>
      </itemizedlist>

      <itemizedlist>
	<title>Benefícios de um único sistema de arquivos</title>

	<listitem>
	  <para>Sistemas de arquivos tem tamanho fixo.  Se você criar um
		sistema de arquivos ao instalar o FreeBSD e definir
		tamanho específico, posteriormente você pode descobrir
		que tem a necessidade de uma partição maior.  Não é uma
		tarefa fácil resolver isso, sem fazer cópias de segurança e
		recriar o sistema de arquivos com o novo tanaho e depois
		restaurar a cópia.</para>

	  <important>
	    <para>A partir do FreeBSD&nbsp;4.4 o comando &man.growfs.8;
		passou a ser parte do sistema, o que possibilita que o tamanho
		dos sistemas de arquivos sejam incrementados na hora, acabando
		com esta limitação.</para>
	  </important>
	</listitem>
      </itemizedlist>
    
      <para>Sistemas de arquivos são contidos em partições.  Isso não
	significa a mesma coisa do que a forma de utilização do termo
	partição anteriormente neste capítulo, por causa da herança
	&unix; do FreeBSD.  Cada partição é identificada com uma
	letra que varia de <literal>a</literal> à <literal>h</literal>.
	Cada partição possui um sistema de arquivos, o que significa que sistemas de
	arquivos normalmente são identificados ou por seu ponto
	de montagem na hierarquia do sistema de arquivos, ou pela letra
	disposta no nome de cada partição.</para>

      <para>O FreeBSD ainda usa espaço de disco para o <quote>espaço
	de troca</quote>, ou <firstterm>swap</firstterm>.  Swap oferece
	características de <firstterm>memória virtual</firstterm> ao FreeBSD.
	Isso permite que seu computador se comporte como se tivesse
	mais memória disponível do que na realidade tem.  Quando o
	FreeBSD excede a memória disponível ele move alguns trechos de dados
	que não estão sendo utilizados para o espaço de troca, a <litera>
	swap</literal>, e move esses dados de volta pra memória (descarregando
	alguma outra coisa para liberar recursos) quando necessário.</para>

      <para>Algumas partições mantém algumas convenções associadas.</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <colspec colwidth="1*">
	  <colspec colwidth="5*">

	  <thead>
	    <row>
	      <entry>Partição</entry>

	      <entry>Convenção</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><literal>a</literal></entry>

	      <entry>Normalmente contém o sistema de arquivos raiz</entry>
	    </row>

	    <row>
	      <entry><literal>b</literal></entry>

	      <entry>Normalmente contém a partição de swap (troca)</entry>
	    </row>

	    <row>
	      <entry><literal>c</literal></entry>

	      <entry>Normalmente tem o mesmo tamanho da partição
		inclusa.  Isso permite que alguns utilitários que
		precisam trabalhar na partição toda (por exemplo,
		um identificador de blocos defeituosos) funcionem
		corretamenta na partição <literal>c</literal>.  Você
		não vai criar um sistema de arquivos de verdade
		nesta partição.</entry>
	    </row>

	    <row>
	      <entry><literal>d</literal></entry>

	      <entry>A partição <literal>d</literal> costumava ter um
		significado especial associado com ela, contudo agora
		ele desfez.  Hoje em dia algumas ferramentas podem
		continuar se comportando de forma estranha se
		indicarmos que ele trabalhe na partição
		<literal>d</literal>, de forma que o <application>sysinstall
		</application> não cria mais esta
		partição.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Cada partição que contém um sistema
	de arquivos é armazenada em um tipo especial
	de partição que o FreeBSD chama de <firstterm>slice</firstterm>.  Este
	termo é utilizado pelo FreeBSD para fazer menção ao que, mais uma fez,
	costumava ser chamado de partição, e isso se deve à base &unix;
	por trás do sistema FreeBSD.  Estas partições (<quote>slices</quote>)
	são numeradas, iniciando do 1, até o 4.</para>

	<indexterm><primary>slices</primary></indexterm>
	<indexterm><primary>partições</primary></indexterm>
	<indexterm><primary>perigosamente dedicada</primary></indexterm>

      <para>Número de partições seguem o nome do dispositivo
	adicionado de um prefixo com o caractér <literal>s</literal>,
	começando do 1.  Portanto <quote>da0<emphasis>s1</emphasis></quote>
	é a primeira <literal>slice</literal> de um disco, mas é
	possível que existam partições lógicas dentro de cada
	partição física do tipo apropriado.  Estas partições
	extendidas são numeradas à partir do 5, de forma que
	<quote>ad0<emphasis>s5</emphasis></quote> seja a 
	primeira partição extendida do primeiro disco IDE.
	Estes dispositivos são utilizados por
	sistemas de arquivos que ocupam esse tipo de
	partição.</para>

      <para>Partições, dispositivos físicos, <quote>perigosamente dedicados</quote>
	e outros dispositivos contém
	<firstterm>partições</firstterm> que costumam ser representadas como
	letras, começando de <literal>a</literal> até <literal>h</literal>.
	Estas letras são atribuídas ao nome dos dispositivos, de forma que
	<quote>da0<emphasis>a</emphasis></quote> indique a partição no
	primeiro dispositivo, que na realidade é <quote>perigosamente dedicado</quote>.
	<quote>ad1s3<emphasis>e</emphasis></quote> é a quinta partição
	na primeira <literal>slice</literal> do segundo dispositivo de disco IDE.<para>
	
      <para>Finalmente, cada disco no sistema esta identificado.  Um nome de disco
	começa com um código que indica o tipo do disco em questão, e em seguida um número,
	que indica que disco é esse.  Diferente das partições, a numeração dos discos inicia
	em 0.  Informações usuais que você encontrará listados em 
	<xref linkend="install-dev-codes">.</para>

      <para>Ao se referir a uma partição, o FreeBSD requer que você nomeie
	cada <literal>slice</literal> e disco que contenha a partição em questão, e que ao se
	referir à <literal>slice</literal> você também identifique o nome do disco. Faça
	isso listado o nome do disco, <literal>s</literal>, o número da
	<literal>slice</literal>, e em seguida a letra da partição. Exemplos são
	apresentados em <xref linkend="install-disk-slice-part">.</para>

      <para><xref linkend="install-concept-disk-model"> apresenta o modelo
	conceitual das disposições de disco, o que pode ajudar
	a tornar as coisas mais claras.</para>

      <para>Para instalar o FreeBSD, primeiro você deve configurar os
	<literal>slices</literal> de disco, e depois criar as partições
	em cada <literal>slice</literal> destinada ao FreeBSD, e criar um
	sistema de arquivo (ou <literal>swap</literal>) em cada partição,
	e decidir onde o sistema de arquivos será montado.</para>

      <table frame="none" id="install-dev-codes">
	<title>Códigos de Dispositivos de Disco</title>

	<tgroup cols="2">
          <colspec colwidth="1*">
          <colspec colwidth="5*">

	  <thead>
	    <row>
	      <entry>Código</entry>
	    
	      <entry>Significado</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><devicename>ad</devicename></entry>

	      <entry>disco ATAPI (IDE)</entry>
	    </row>

	    <row>
	      <entry><devicename>da</devicename></entry>
	      
	      <entry>disco SCSI de acesso direto</entry>
	    </row>
	    
	    <row>
	      <entry><devicename>acd</devicename></entry>
	      
	      <entry>CDROM ATAPI (IDE)</entry>
	    </row>
	    
	    <row>
	      <entry><devicename>cd</devicename></entry>
	      
	      <entry>CDROM SCSI</entry>
	    </row>
	    
	    <row>
	      <entry><devicename>fd</devicename></entry>
	      
	      <entry>Disquete</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
      
      <example id="install-disk-slice-part">
	<title>Modelo de disco, partição e nomes</title>
	
	<informaltable frame="none">
	  <tgroup cols="2">
            <colspec colwidth="1*">
            <colspec colwidth="5*">

	    <thead>
	      <row>
		<entry>Nome</entry>
		
		<entry>Significado</entry>
	      </row>
	    </thead>
	    
	    <tbody>
	      <row>
		<entry><literal>ad0s1a</literal></entry>
		
		<entry>Primeira partição (<literal>a</literal>) na primeira
		  fatia de disco (slice - <literal>s1</literal>) no primeiro disco IDE
		  (<literal>ad0</literal>).</entry>
	      </row>

	      <row>
		<entry><literal>da1s2e</literal></entry>
		
		<entry>Quinta partição (<literal>e</literal>) na segunda fatia
		  de disco (slice - <literal>s2</literal>) no segundo disco SCSI
		  (<literal>da1</literal>).</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </example>

      <example id="install-concept-disk-model">
	<title>Modelo conceitual de um disco</title>

	<para>Esse diagrama apresenta a abordagem do FreeBSD para o primeiro disco IDE
	  ligado ao sistema.  Assuma que o disco tem tamanho de 4&nbsp;GB e
	  contém duas partições de 2&nbsp;GB (partições DOS).  A primeira 
	  <literal>slice</literal> contém um disco DOS, o <devicename>C:</devicename>,
	  e a segunda <literal>slice</literal> contém a instalação do FreeBSD. Esta
	  instalação FreeBSD de exemplo tem três partições, e uma <literal>swap</literal>.</para>

	<para>As três partições terão um sistema de arquivos cada.  A partição
	  <literal>a</literal> será utilizada pelo sistema de arquivos raiz,
	  <literal>e</literal> será utilizada pela hierarquia de  diretório
	  <filename>/var</filename>, e <literal>f</literal> pela hierarquia
	  de diretório <filename>/usr</filename>.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="install/disk-layout" format="EPS">
          </imageobject>
 
          <textobject>
	    <literallayout class="monospaced">.-----------------.  --.
|                 |    |
|  DOS / Windows  |    |
:                 :     >  Primeira slice, ad0s1
:                 :    |
|                 |    |
:=================:  ==:                               --.
|                 |    |  Particao a, montada em  /      |
|                 |     > chamada de ad0s2a              |
|                 |    |                                 |
:-----------------:  ==:                                 |
|                 |    |  Particao b, used como swap     |
|                 |     > chamada de ad0s2b              |
|                 |    |                                 |
:-----------------:  ==:                                 |  Particao c, sem
|                 |    |  Particao e, usada como /var       > sistema de arquivos, toda 
|                 |     > chamada de ad0s2e              |  a particao ad0s2c do FreeBSD
|                 |    |                                 | 
:-----------------:  ==:                                 |
|                 |    |                                 |
:                 :    |  Particao f, usada como /usr    |
:                 :     > chamada de ad0s2f              |
:                 :    |                                 |
|                 |    |                                 |
|                 |  --'                                 |
`-----------------'                                    --'</literallayout>
          </textobject>
        </mediaobject>
      </example>
  </sect1>



  <sect1 id="mount-unmount">
    <title>Montando e desmontando sistemas de arquivos</title>

    <para>O sistema de arquivos pode ser melhor assimilado se for visualizado
	como uma árvore, cuja raiz é <filename>/</filename>.
	<filename>/dev</filename>, <filename>/usr</filename>, e outros
	diretórios na raiz, são os ramos da árvore, que podem ainda ter seus
	próprios ramos, como <filename>/usr/local</filename>, e assim por diante.</para>

    <indexterm><primary>sistema de arquivos raiz</primary></indexterm>
    <para>Existem vários motivos para armazenar alguns destes diretórios
	em sistemas de arquivos distintos.  <filename>/var</filename>
	contém os diretórios <filename>log/</filename>,
	<filename>spool/</filename>,
	e vários tipos de arquivos temporários, e como tal, pode
	fácilmente encher.  Encher o sistema de arquivos raiz
	não é uma boa idéia, de forma que separar o <filename>/var</filename>
	do <filename>/</filename> é sempre favorável.</para>

    <para>Outra razão usual para manter certas árvores de diretórios
	em outros sistemas de arquivos é que eles podem ser alojados em
	discos físicos separados, ou em um disco virtual separado como
	pontos de montagem <link linkend="network-nfs">NFS</link> ou dispositivos
	de CDROM.</para>

    <sect2 id="disks-fstab">
      <title>O arquivo <filename>fstab</filename></title>
      <indexterm>
	<primary>sistemas de arquivos</primary>
	<secondary>montados com fstab</secondary>
      </indexterm>

      <para>Durente o <link linkend="boot">processo de inicialização</link>,
	os sistemas de arquivos listados no <filename>/etc/fstab</filename> são
	automaticamente montados (a não ser que eles tenham a opção
	<option>noauto</option> definida).</para>

      <para>O arquivo <filename>/etc/fstab</filename> contém uma lista de
	linhas no seguinte formato:</para>

      <programlisting><replaceable>device</replaceable>       <replaceable>/mount-point</replaceable> <replaceable>fstype</replaceable>     <replaceable>options</replaceable>      <replaceable>dumpfreq</replaceable>     <replaceable>passno</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>device</literal></term>
	  <listitem>
	    <para>Um nome de dispositivo (que deve existir), conforme
		explicado em <xref linkend="disks-naming">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>mont-point</literal></term>
            
	  <listitem><para>Um diretório (que deve existir), onde
		o sistema de arquivos é montado.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><literal>fstype</literal></term>
            
	  <listitem><para>O tipo de sistema de arquivo
		que será passado ao &man.mount.8;.  O sistema de arquivos
		padrão do FreeBSD é <literal>ufs</literal>.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><literal>options</literal></term>
            
	  <listitem><para>Pode ser <option>rw</option> para sistemas de
		arquivos com opções de leitura e escrita, ou <option>ro</option>
		para apenas leitura, seguidos de qualquer outra opção
		necessária.  Uma opção bastante usual é <option>noauto</option>
		para os sistemas de arquivos que normalmente não devem
		ser montados autometicamente pelo processo de inicialização.
		Outras opções são listadas na página de manual do &man.mount.8;.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><literal>dumpfreq</literal></term>
          
         <listitem><para>Essa opção é utilizada pelo &man.dump.8; para determinar
		que sistema de arquivos devem sofrer o processo de &man.dump.8; (o
		&man.dump.8; é uma ferramenta para cópia de segurança).  Se o campo
		não estiver presente, o valor zero é assumido.</para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>passno</literal></term>

         <listitem>
           <para>Determina a ordem que os sistemas de arquivos devem
		ser verificados.  Sistemas de arquivos cuja verificação
		pode ser omitida, devem ter seu <literal>passno</literal>
		definidos em zero.  O sistema de arquivos raiz (que deve ser
		verificado antes de todos os outros) deve ter seu <literal>passno</literal>
		definido como um, e os outros sistemas de arquivos podem ter esta
		opção definida com um valor maior.  Se mais de um sistema de arquivos
		disporem do mesmo número, o &man.fsck.8; tentará fazer as verificações
		de forma paralela, se possível.</para>
         </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-mount">
      <title>O comando <command>mount</command></title>
      <indexterm>
	<primary>sistemas de arquivos</primary>
	<secondary>montagem</secondary>
      </indexterm>
        
      <para>O comando &man.mount.8; é a ferramenta usada para montar
	sistemas de arquivos.</para>
        
      <para>Em sua forma mais básica, basta usar:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount <replaceable>dispositivo</replaceable> <replaceable>ponto de montagem</replaceable></userinput></screen>
      </informalexample>

      <para>Existem inúmeras opções, e estão todas dispostas na página
	de manual do &man.mount.8;, mas as mais comuns são:</para>

      <variablelist>
	<title>Opções de montagem</title>

	<varlistentry>
	  <term><option>-a</option></term>
            
	  <listitem>
	    <para>Monta todos os sistemas de arquivos listados no
	      <filename>/etc/fstab</filename>. Exceto aqueles
		assinalados com a opção <quote>noauto</quote>, excluidos
		pala opção <option>-t</option>, ou aqueles que já estiverem
		montados.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-d</option></term>
            
	  <listitem>
	    <para>Faz tudo, exceto a efetivação da chamada de sistema
		para a montagem.  Essa opção é muito útil, em conjunto
		com a <option>-v</option> para descobrir o que o
		&man.mount.8; está tentando fazer.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Força a montagem de um sistema de arquivos que não
		tem garantia de integridade (isso é perigoso), ou
		força a revogação dos direitos de escrita ao alterar
		o estado de montagem de um sistema de arquivos que
		esteja em modo somente leitura, para o modo leitura
		e escrita.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
          <term><option>-r</option></term>
            
	  <listitem>
	    <para>Monta o sistema de arquivos como somente leitura.  Essa opção é
		idêntica ao argumento <option>rdonly</option> na opção
	      <option>-o</option>.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>tipo de sistema de arquivos</replaceable></term>

	  <listitem>
	    <para>Monta o sistema de arquivos em questão, como do tipo
		em atribuído, ou monta apenas sistemas de arquivos do tipo
		atribuído se for usado em conjunto com a
		opção <option>-a</option>.</para>
              
	    <para><quote>ufs</quote> é o tipo padrão de sistema de
		 arquivos.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-u</option></term>
            
	  <listitem>
	    <para>Atualiza opções de montagem no sistema de arquivos.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-v</option></term>
            
	  <listitem>
	    <para>Torna-se verboso.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-w</option></term>
            
	  <listitem>
	    <para>Monta o sistema de arquivos como leitura e escrita.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
        
      <para>A opção <option>-o</option> pode utilizar uma lista de opções separadas
	por vírgula, das quais, as principais são:</para>
        
      <variablelist>
	<varlistentry>
	  <term>nodev</term>
            
	  <listitem>
	    <para>Não interpreta dispositivos especiais no sistema de arquivos
		em questão.  Esta é uma opção útil para segurança.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term>noexec</term>
            
	  <listitem>
              <para>Não permite execussão de binários neste sistema de arquivos.
		Também é uma opção muito útil para segurança.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term>nosuid</term>
            
	  <listitem>
	    <para>Não interpreta opções de setuid ou setgid no
		sistema de arquivos.  É uma opção útil para segurança.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-umount">
      <title>O comando <command>umount</command></title>
      <indexterm>
	<primary>sistemas de arquivos</primary>
	<secondary>desmontando</secondary>
      </indexterm>
        
      <para>O comando &man.umount.8; recebe como parâmetro o
	ponto de montagem, o dispositivo, a opção <option>-a</option> ou
	a opção <option>-A</option>.</para>
        
      <para>Todas estas maneiras podem ter também as opções <option>-f</option>
	para forçar desmontagem, e <option>-v</option> para ser verboso.  Esteja
	atento ao fato que a opção <option>-f</option> geralmente não é
	uma boa idéia.  Desmontar os sistemas de arquivos forçozamente pode
	causar dano aos dados do sistema de arquivos.</para>
        
      <para><option>-a</option> and <option>-A</option> são usadas para
	desmontar todos os sistemas de arquivos; este comportamento
	é possivelmente modificado em conjunto com a opção <option>-t</option>.
	<option>-A</option>, contudo, não tenta desmontar o sistema de arquivos
	raiz.</para>
    </sect2>
  </sect1>

  <sect1 id="basics-processes">
    <title>Processos</title>

    <para>O FreeBSD é um sistema operacional multi-tarefa.  Isso significa que
	ele cria um ambiente onde os recursos computacionais são divididos
	de forma à parecer que mais de um programa é executado ao mesmo tempo.
	Cada processo sendo executado à qualquer momento, é chamado de
	um <firstterm>processo</firstterm>.  Todo comando que você executar,
	iniciará ao menos um novo processo, e existem vários processos do
	sistema que estão sempre em execussão, mantendo a funcionalidade
	do ambiente como um todo.</para>

    <para>Cada processo é identificado de forma única com um número, que é
	chamado de identificação do processo, ou <firstterm>process ID</firstterm>, ou
	então a forma abreviada e mais comum, <firstterm>PID</firstterm>, e,
	assim como os arquivos, cada processo também tem um dono e grupo.  As
	informações sobre dono e grupo são utilizadas com o intúito de
	determinar que arquivos e dispositivos o processo pode abrir, utilizando
	as permissões discutidas anteriormente.  A maioria dos processos tem ainda
	um processo pai.  O processo pai é o processo que o iniciou.  Por exemplo,
	quando você digita um comando em uma <literal>shell</literal>, então
	essa <literal>shell</literal> é um processo, e todo comando executado
	é outro processo.  Todo comando executado desta forma terá sua
	<literal>shell</literal> como o processo pai.  A única excessão
	é um processo especial chamado de &man.init.8;.  O <command>init</command>
	é sempre o primeiro processo do sistema, portanto seu PID é sempre 1.  O
	<command>init</command> é executado automaticamente pelo <literal>kernel</literal>
	quando o FreeBSD é iniciado.</para>

    <para>Dois comandos são particularmente úteis para verificar os processos ativos 
	no sistema, o &man.ps.1; e o &man.top.1;.  O comando <command>ps</command> é usado
	para apresentar uma lista estática dos processos sendo executados no momento, e
	pode apresentar seu PID, quanta memória o processo está utilizando, a linha
	de comando que o iniciou, e assim por diante.  O comando <command>top</command>
	apresenta todos os processos em execussão, e atualiza a forma como os apresenta
	na tela a cada poucos segundos, de forma que você possa acompanhar o que
	o computador está fazendo.</para>

    <para>Por padrão o <command>ps</command> apenas apresenta os comandos
	que estão sendo executados por você, e cuja propriedade também seja
	sua. Por exemplo:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>Como você pode acompanhar neste exemplo, a saída do comando &man.ps.1;
	é organizada em várias colunas.  <literal>PID</literal> é a identificação
	do processo discutida anteriormente.  PIDs são atribuíudos à partir
	do 1, e vão até 99999, e reiniciam a contagem quando ultrapassa
	esse valor.  A coluna <literal>TT</literal> postra em que terminal
	o programa esta sendo executado, e pode seguramente ser ignorado
	no momento.  <literal>STAT</literal> apresenta o estado atual
	do programa, e, mais uma vez, vamos ignora-lo por hora.
	<literal>TIME</literal> indica a quantidade de tempo que o
	programa está em execussão na CPU em questão &mdash; normalmente
	não é o tempo total desde que o processo foi iniciado, e sim tempo
	de execussão, uma vez que vários programas ficam um bom tempo
	esperando que algo aconteça para eles utilizarem tempo de
	processamento da CPU.  Finalmente, <literal>COMMAND</literal> é a linha
	de comando utilizada para executar o programa em questão.</para>

    <para>&man.ps.1; suporta uma série de opções distintas que modificam
	as informações apresentadas.  Um dos cunjuntos mais úteis de
	opções é <literal>auxww</literal>.  <option>a</option> apresenta
	informações sobre todos os processos em execussão, não apenas
	os de sua propriedade.  <option>u</option> apresenta o nome do
	usuário que é o dono do processo, bem como o uso de memória do mesmo.
	<option>x</option> apresenta informações sobre processos <literal>
	daemon</literal>, e <option>ww</option> faz o &man.ps.1; apresentar a linha
	de comando completa, ao invés de um trecho compactado para caber na tela.</para>

    <para>A saída do &man.top.1; é similar.  Uma sessão modelo teria
	a seguinte aparência:</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>A saída está dividida em duas seções.  O cabeçalho (as primeiras
	cinco linhas) apresenta o PID do último processo executado,
	a média de carga do sistema (que mede o quanto o sistema está
	ocupado), e o tempo de atividade initerrupta do sistema (tempo desde
	a última inicialização - o <foreignphrase>uptime</foreignphrase>).  As
	outras informações do cabeçalho inidicam quantos processos (47 neste caso)
	estão ativos, quando de memória e <literal>swap</literal> foi
	utilizado, e quanto tempo o sistema está gastando em estados
	diferentes de uso da CPI.</para>

    <para>Abaixo está uma série de colunas com informações similares
	à saída do &man.ps.1;.  Como antes, você pode ver o PID,
	o usuário, o tempo de CPU utilizado, e o comando executado.
	&man.top.1; também mostra por padrão a quantidade de memória
	utilizada pelo processo.  Essa informação é dividida em dois
	grupos, uma para o tamanho total de memória, e um para o
	tamanho residente &mdash; tamanho total indica quanta memória
	a aplicação já precisou, e o tamanho residente é a quantidade
	em uso no momento.  Nesse exemplo você pode ver que o
	<application>&netscape;</application> precisou quase de
	30&nbsp;MB de RAM, mas no momento está usando apenas 9&nbsp;MB.</para>

    <para>&man.top.1; atualiza automaticamente as informações a cada dois seguindos,
	o que pode ser modificado com a opção <option>s</option>.</para>
  </sect1>

  <sect1 id="basics-daemons">
    <title>Daemons, sinais e controle de processos</title>

    <para>Ao usar um editor, é fácil controla-lo, indicar que ele deve
	carregar arquivos, e assim por diante.  Você pode fazê-lo pois o
	editor oferece algumas opções para fazê-lo, e por que o editor é
	diretamente interligado a um <firstterm>terminal</firstterm>.  Alguns
	programas não são projetados de forma a utilizar informações 
	contínuas do usuário, e assim ele se desconecta do terminal em sua
	primeira oportunidade.  Por exemplo, um servidor HTTP passa
	o tempo todo respondendo requisições da rede, e normalmente ele
	não necessita intervenção alguma do usuário.  Programas que transportam
	mensagens de correio de um local para outro, são outro exemplo
	dessa classe de aplicações.</para>

    <para>Chamamos estes programas de <firstterm>daemons</firstterm>.  Daemons são
	personagens da mitologia Grega; mão são bons, nem maus, eram apenas
	espíritos assistentes que, na maior parte do tempo, realizavam
	tarefas úteis para a humanidade.  É por isso que o mascote do BSD,
	há um bom tempo, é aquele daemon simpático que usa tênis e
	carrega um tridente.</para>

    <para>Existe uma convenção para batizar os programas que normalmente são
	executados como daemon, que é terminar o nome do programa com um
	<quote>d</quote>. <application>BIND</application> é o Daemon de
	Nomes Internet de Berkeley, (<foreignphrase>Berkeley Internet
	Name Daemon</foreignphrase> - o programa que o executa, é chamado
	<command>named</command>), O servidor WWW <application>Apache</application>
	é chamado de <command>httpd</command>, o daemon de impressão em linha
	é o <command>lpd</command> e assim sucetivamente.  Esta é uma convenção,
	e não uma regra de rápida assimilação; por exemplo, o daemon principal
	para a aplicação <application>Sendmail</application> é chamado
	<command>sendmail</command>, e não <command>maild</command>, como você
	poderia ter imaginado inicialmente.</para>

    <para>Algumas vezes será necessário se comunicar com um processo daemon.
	Essa comunicação é chamada de <firstterm>sinais</firstterm>, e você
	pode se comunicar com o daemon (ou qualquer outro processo em execussão)
	enviando-o um sinal.  Existem uma série de sinais diferentes que podem ser
	enviados&mdash;alguns dos quais tem um significado específico, e outros
	são interpretados pela aplicação, e a documentação dessa aplicação
	indicará o que ela faz quando recebe este tipo de sinal.  Você só pode
	enviar um sinal para os processos que te pertencem.  Se você tentar
	enviar sinais para um processo que não é seu, com &man.kill.1; ou &man.kill.2;
	terá permissão negada.  A única excessão é o usuário <username>root</username>,
	que pode enviar sinais para os processos de todos.</para>

    <para>O FreeBSD em certos casos também enviará sinais às aplicações.  Se uma
	aplicação for mal escrita e tentar acessar endereços de memória que
	ele não deve, o FreeBSD envia o sinal de violação de segmento
	ao processo (<firstterm>Segmentation Violation</firstterm>), conhecido
	como <literal>SIGSEGV</literal>.  Se alguma aplicação usou a chamada de
	sistema &man.alarm.3; para solicitar que seja alertada depois de
	certo período de tempo, o sistema envia o sinal de alerta 
	(<literal>SIGALRM</literal>) ao processo, e assim por diante.</para>

    <para>Dois sinais podem ser usados para interromper um processo,
      <literal>SIGTERM</literal> e <literal>SIGKILL</literal>.
      <literal>SIGTERM</literal> é uma maneira educada de matar um processo;
	o processo pode <emphasis>acatar</emphasis> o sinal, entender
	que você deseja que ele deixe de ser executado, fechar qualquer arquivos
	de logs que ele tenha aberto, e geralmente terminar a tarefa que ele está
	realizando no momento, antes de deixar de executar.  Em alguns casos um
	processo pode ignorar o <literal>SIGTERM</literal> se ele estiver
	no meio de uma tarefa que não pode ser interrompida.</para>

    <para><literal>SIGKILL</literal> não pode ser ignorado por qualquer
	processo.  Este é o sinal que diz ao processo, <quote>Eu não me
	importo com o que você esteja fazendo, pare agora mesmo</quote>.
	Se você enviar um <literal>SIGKILL</literal> a qualquer processo,
	o FreeBSD irá interromper aquele processo<footnote>
	<para>Não é completamente verdade&mdash;existem algumas poucas
	  tarefas que não podem ser interrompidas.  Por exemplo, se o processo
	  está tentando ler um arquivo que está em uma outra estação da rede,
	  e essa outra estação não está mais disponível por alguma razão (foi
	  desligado, ou houve falha na rede), então o processo é definido como
	  um processo que não pode ser interrompido.  Eventualmente ele
	  irá passar do tempo máximo de atividade permitida, tipicamente
	  dois minutos (o <foreignphrase>timeout</foreignphrase>).  Tão logo
	  este período aconteça, o processo é morto.</para>
      </footnote>.</para>

    <para>Outros sinais que você pode querer conhecer são
      <literal>SIGHUP</literal>, <literal>SIGUSR1</literal>, e
      <literal>SIGUSR2</literal>.  Estes são sinais de propósitos
	gerais, e aplicações distintas terão comportamento distintos
	ao receber estes sinais.</para>

    <para>Suponha que você modificou o arquivo de configuração do
	seu servidor HTTP&mdash;você deseja dizer ao daemon para ele
	reler essa configuração.  Você poderia parar e reiniciar o
	<command>httpd</command>, mas isso resultaria em uma breve
	interrupção do serviço, o que pode não ser desejável.  A maioria
	dos daemons são escritos de forma que respondam a um
	<literal>SIGHUP</literal> com a releitura de seu arquivo de
	configuração.  Então, ao invés de matar e reiniciar o processo
	<command>httpd</command> você enviaria o sinal <literal>
	SIGHUP</literal> ao processo.  Por não existir uma forma
	padrão de resposta à estes sinais, cada daemon pode ter um
	comportamento diferente, de forma que você deve ler a documentação
	para o programa em questão.</para>
    
    <para>Sinais são enviados utilizando o comando &man.kill.1;, como mostra
	o exemplo a seguir:</para>

    <procedure>
      <title>Enviando sinal aos processos</title>

      <para>Esse exemplo mostra como enviar sinais ao &man.inetd.8;.  O arquivo
	de configuração do <command>inetd</command> é o <filename>
	/etc/inetd.conf</filename>, e o <command>inetd</command> irá reler
	sua configuração, quando receber o sinal
	<literal>SIGHUP</literal>.</para>

      <step>
	<para>Encontre o ID do processo que você quer enviar o sinal.
	 Faça isso com o &man.ps.1; em conjunto com &man.grep.1;.  O &man.grep.1;
	 é usado para procurar por uma cadeia de caracteres na saída desejada.
	 O comando é executado como usuário normal, e o &man.inetd.8; é executado
	 como <username>root</username>, então as opções <option>ax</option> devem
	 ser usadas com o &man.ps.1;.</para>

	<screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

	<para>Portando o PIDO do &man.inetd.8; é 198.  Em alguns casos o comando
	  <literal>grep inetd</literal> poderá estar incluso também na saída
	  desses comandos.  Isso se deve à maneira como o &man.ps.1; procura
	  na lista de processos em execussão.</para>
      </step>

      <step>
	<para>Use &man.kill.1; para enviar sinais.  Pelo fato do &man.inetd.8;
	  estar sendo executado pelo <username>root</username> você deve usar
	  o &man.su.1; antes, para se tornar <username>root</username>.</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

	<para>Como de costume com a maioria dos comandos &unix;, o
	  &man.kill.1; não apresentará qualquer mensagem se o resultado
	  da ação for bem sucedido.  Se você enviou um processo que não é
	  seu, você verá uma mensagem parecida com <errorname>kill:
	    <replaceable>PID</replaceable>: Operation not
	    permitted</errorname>.  Se você digitar o PID errôneamente,
	    ou você vai enviar o sinal ao processo errado, o que pode ser
	    bem ruin, ou, se você tiver sorte, terá enviado o sinal a
	    um processo que não está ativo, e verá algo como <errorname>kill:
	    <replaceable>PID</replaceable>: No such process</errorname>.</para>

	<note>
	  <title>Por que usar o <command>/bin/kill</command>?</title>

	  <para>Muitos interpretadores de comandos oferecem o comando
	    <command>kill</command> embutido; ou seja, o interpretador
	    enviará o sinal diretamente, ao invés de executar o
	    <filename>/bin/kill</filename>.  Isso pode ser muito útil, mas
	    interpretadores de comandos distintos podem ter sintaxe
	    distinta.  Ao invés de aprender a usar cada uma, é bem mais fácil
	    aprender usar o comando <command>/bin/kill <replaceable>...</replaceable></command>
	    diretamente.</para>
	</note>
      </step>
    </procedure>

    <para>Enviar outros sinais é muito parecido, basta substituir o
	<literal>TERM</literal> ou <literal>KILL</literal> na linha de
	comando, conforme for necessário.</para>

    <important>
      <para>Matar processos aleatórios no sistema pode ser uma má idéia.  Em especial o
	processo cujo ID é 1, o &man.init.8;, que é bem particular.  Enviar um
	<command>/bin/kill -s KILL 1</command> é uma forma singela de desligar
	seu sistema.  <emphasis>Sempre</emphasis> verifique duas vezes os argumentos
	do &man.kill.1; <emphasis>antes</emphasis> de apertar
	<keycap>Enter</keycap>.</para>
    </important>
  </sect1>

  <sect1 id="shells">
    <title>Shells</title>
    <indexterm><primary>shells</primary></indexterm>
    <indexterm><primary>linha de comando</primary></indexterm>

    <para>In FreeBSD, a lot of everyday work is done in a command line
      interface called a shell.  A shell's main job is to take commands
      from the input channel and execute them.  A lot of shells also have
      built in functions to help everyday tasks such as file management,
      file globbing, command line editing, command macros, and environment
      variables.  FreeBSD comes with a set of shells, such as 
      <command>sh</command>, the Bourne Shell, and <command>tcsh</command>, 
      the improved C-shell.  Many other shells are available
      from the FreeBSD Ports Collection, such as
      <command>zsh</command> and <command>bash</command>.</para>

    <para>Which shell do you use?  It is really a matter of taste.  If you
      are a C programmer you might feel more comfortable with a C-like shell
      such as <command>tcsh</command>.  If you have come from Linux or are new 
      to a &unix; command line interface you might try <command>bash</command>.  
      The point is that each
      shell has unique properties that may or may not work with your
      preferred working environment, and that you have a choice of what
      shell to use.</para>

    <para>One common feature in a shell is filename completion.  Given
      the typing of the first few letters of a command or filename, you
      can usually have the shell automatically complete the rest of the
      command or filename by hitting the <keycap>Tab</keycap> key on the keyboard.  Here is
      an example.  Suppose you have two files called
      <filename>foobar</filename> and <filename>foo.bar</filename>.  You
      want to delete <filename>foo.bar</filename>.  So what you would type
      on the keyboard is: <command>rm fo[<keycap>Tab</keycap>].[<keycap>Tab</keycap>]</command>.</para>

    <para>The shell would print out <command>rm
      foo[BEEP].bar</command>.</para>

    <para>The [BEEP] is the console bell, which is the shell telling me it
      was unable to totally complete the filename because there is more
      than one match.  Both <filename>foobar</filename> and
      <filename>foo.bar</filename> start with <literal>fo</literal>, but
      it was able to complete to <literal>foo</literal>.  If you type in
      <literal>.</literal>, then hit <keycap>Tab</keycap> again, the shell would be able to
      fill in the rest of the filename for you.</para>
    <indexterm><primary>environment variables</primary></indexterm>

    <para>Another feature of the shell is the use of environment variables.
      Environment variables are a variable key pair stored in the shell's
      environment space.  This space can be read by any program invoked by
      the shell, and thus contains a lot of program configuration.  Here
      is a list of common environment variables and what they mean:</para>
    <indexterm><primary>environment variables</primary></indexterm>

    <informaltable frame="none">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Variable</entry>
	    <entry>Description</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>Current logged in user's name.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>Colon separated list of directories to search for
	      binaries.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>Network name of the X11 display to connect to, if
	      available.</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>The current shell.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>The name of the user's terminal.  Used to determine the
	      capabilities of the terminal.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>Database entry of the terminal escape codes to perform
	      various terminal functions.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>Type of operating system.  e.g., FreeBSD.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>The CPU architecture that the system is running
	      on.</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>The user's preferred text editor.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>The user's preferred text pager.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>Colon separated list of directories to search for
	      manual pages.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary>Bourne shells</primary></indexterm>
    <para>Setting an environment variable differs somewhat from
      shell to shell.  For example, in the C-Style shells such as
      <command>tcsh</command> and <command>csh</command>, you would use
      <command>setenv</command> to set environment variables.
      Under Bourne shells such as <command>sh</command> and
      <command>bash</command>, you would use
      <command>export</command> to set your current environment
      variables.  For example, to set or modify the
      <envar>EDITOR</envar> environment variable, under <command>csh</command> or 
      <command>tcsh</command> a
      command like this would set <envar>EDITOR</envar> to
      <filename>/usr/local/bin/emacs</filename>:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Under Bourne shells:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>You can also make most shells expand the environment variable by
      placing a <literal>$</literal> character in front of it on the
      command line.  For example, <command>echo $TERM</command> would
      print out whatever <envar>$TERM</envar> is set to, because the shell
      expands <envar>$TERM</envar> and passes it on to <command>echo</command>.</para>

    <para>Shells treat a lot of special characters, called meta-characters
      as special representations of data.  The most common one is the
      <literal>*</literal> character, which represents any number of
      characters in a filename.  These special meta-characters can be used
      to do filename globbing.  For example, typing in
      <command>echo *</command> is almost the same as typing in
      <command>ls</command> because the shell takes all the files that
      match <literal>*</literal> and puts them on the command line for
      <command>echo</command> to see.</para>

    <para>To prevent the shell from interpreting these special characters,
      they can be escaped from the shell by putting a backslash
      (<literal>\</literal>) character in front of them.  <command>echo
      $TERM</command> prints whatever your terminal is set to.
      <command>echo \$TERM</command> prints <envar>$TERM</envar> as
      is.</para>

    <sect2 id="changing-shells">
      <title>Changing Your Shell</title>

      <para>The easiest way to change your shell is to use the
	<command>chsh</command> command.  Running <command>chsh</command> will
	place you into the editor that is in your <envar>EDITOR</envar>
	environment variable; if it is not set, you will be placed in
	<command>vi</command>.  Change the <quote>Shell:</quote> line
	accordingly.</para>

      <para>You can also give <command>chsh</command> the
	<option>-s</option> option; this will set your shell for you,
	without requiring you to enter an editor.  
	For example, if you wanted to
	change your shell to <command>bash</command>, the following should do the
	trick:</para>
	
      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <para>Running <command>chsh</command> with no parameters and editing
	the shell from there would work also.</para>

      <note>
	<para>The shell that you wish to use <emphasis>must</emphasis> be
	  present in the <filename>/etc/shells</filename> file.  If you
	  have installed a shell from the <link linkend="ports">ports
	  collection</link>, then this should have been done for you
	  already.  If you installed the shell by hand, you must do
	  this.</para>
     
      <para>For example, if you installed <command>bash</command> by hand
	and placed it into <filename>/usr/local/bin</filename>, you would
	want to:</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>Then rerun <command>chsh</command>.</para>
     </note>
   </sect2>
  </sect1>

  <sect1 id="editors">
    <title>Text Editors</title>
    <indexterm><primary>text editors</primary></indexterm>
    <indexterm><primary>editors</primary></indexterm>

    <para>A lot of configuration in FreeBSD is done by editing text files.
      Because of this, it would be a good idea to become familiar
      with a text editor.  FreeBSD comes with a few as part of the base
      system, and many more are available in the ports collection.</para>

    <indexterm>
      <primary><command>ee</command></primary>
    </indexterm>
    <para>The easiest and simplest editor to learn is an editor called
      <application>ee</application>, which stands for easy editor.  To
      start <application>ee</application>, one would type at the command
      line <command>ee <replaceable>filename</replaceable></command> where
      <replaceable>filename</replaceable> is the name of the file to be edited.
      For example, to edit <filename>/etc/rc.conf</filename>, type in
      <command>ee /etc/rc.conf</command>.  Once inside of 
      <command>ee</command>, all of the
      commands for manipulating the editor's functions are listed at the
      top of the display. The caret <literal>^</literal> character represents
      the <keycap>Ctrl</keycap> key on the keyboard, so <literal>^e</literal> expands to the key combination
      <keycombo action="simul"><keycap>Ctrl</keycap><keycap>e</keycap></keycombo>.  To leave
      <application>ee</application>, hit the <keycap>Esc</keycap> key, then choose leave
      editor.  The editor will prompt you to save any changes if the file
      has been modified.</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>
    <para>FreeBSD also comes with more powerful text editors such as
      <command>vi</command> as part of the base system, while other editors, like
      <command>emacs</command> and <command>vim</command>,
      are part of the FreeBSD Ports Collection.  These editors offer much
      more functionality and power at the expense of being a little more
      complicated to learn.  However if you plan on doing a lot of text
      editing, learning a more powerful editor such as
      <command>vim</command> or <command>emacs</command>
      will save you much more time in the long run.</para>
  </sect1>

  <sect1 id="basics-devices">
    <title>Devices and Device Nodes</title>

    <para>A device is a term used mostly for hardware-related
      activities in a system, including disks, printers, graphics
      cards, and keyboards.  When FreeBSD boots, the majority
      of what FreeBSD displays are devices being detected.
      You can look through the boot messages again by viewing
      <filename>/var/run/dmesg.boot</filename>.</para>

    <para>For example, <devicename>acd0</devicename> is the
      first IDE CDROM drive, while <devicename>kbd0</devicename>
      represents the keyboard.</para>

    <para>Most of these devices in a &unix; operating system must be
      accessed through special files called device nodes, which are
      located in the <filename>/dev</filename> directory.</para>

    <sect2>
      <title>Creating Device Nodes</title>
      <para>When adding a new device to your system, or compiling
	in support for additional devices, you may need to create one or
	more device nodes for the new devices.</para>

      <sect3>
	<title>MAKEDEV Script</title>
	<para>On systems without <literal>DEVFS</literal> (this concerns all FreeBSD versions before 5.0), device nodes are created
	  using the &man.MAKEDEV.8; script as shown below:</para>

	<screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV ad1</userinput>
	</screen>

	<para>This example would make the proper device nodes
	  for the second IDE drive when installed.</para>
      </sect3>

      <sect3>
	<title><literal>DEVFS</literal> (DEVice File System)</title>

	<para> The device file system, or <literal>DEVFS</literal>, provides access to
	  kernel's device namespace in the global file system namespace.
	  Instead of having to create and modify device nodes,
	  <literal>DEVFS</literal> maintains this particular file system for you.</para>

	<para>See the &man.devfs.5; manual page for more
	  information.</para>

	<para><literal>DEVFS</literal> is used by default in FreeBSD&nbsp;5.0 and above.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="binary-formats">
    <title>Binary Formats</title>

    <para>To understand why FreeBSD uses the <acronym>ELF</acronym>
      format, you must first know a little about the three currently
      <quote>dominant</quote> executable formats for &unix;:</para>

    <itemizedlist>
      <listitem>
        <para>&man.a.out.5;</para>

        <para>The oldest and <quote>classic</quote> &unix; object
          format.  It uses a short and compact header with a magic
          number at the beginning that is often used to characterize
          the format (see &man.a.out.5; for more details).  It
          contains three loaded segments: .text, .data, and .bss plus
          a symbol table and a string table.</para>
      </listitem>

      <listitem>
        <para><acronym>COFF</acronym></para>

        <para>The SVR3 object format.  The header now comprises a
          section table, so you can have more than just .text, .data,
          and .bss sections.</para>
      </listitem>

      <listitem>
        <para><acronym>ELF</acronym></para>

        <para>The successor to <acronym>COFF</acronym>, featuring
          multiple sections and 32-bit or 64-bit possible values.  One
          major drawback: <acronym>ELF</acronym> was also designed
          with the assumption that there would be only one ABI per
          system architecture.  That assumption is actually quite
          incorrect, and not even in the commercial SYSV world (which
          has at least three ABIs: SVR4, Solaris, SCO) does it hold
          true.</para>

        <para>FreeBSD tries to work around this problem somewhat by
          providing a utility for <emphasis>branding</emphasis> a
          known <acronym>ELF</acronym> executable with information
          about the ABI it is compliant with.  See the manual page for
          &man.brandelf.1; for more information.</para>
      </listitem>
    </itemizedlist>

    <para>FreeBSD comes from the <quote>classic</quote> camp and used
      the &man.a.out.5; format, a technology tried and proven through
      many generations of BSD releases, until the beginning of the 3.X
      branch. Though it was possible to build and run native
      <acronym>ELF</acronym> binaries (and kernels) on a FreeBSD
      system for some time before that, FreeBSD initially resisted the
      <quote>push</quote> to switch to <acronym>ELF</acronym> as the
      default format. Why?  Well, when the Linux camp made their
      painful transition to <acronym>ELF</acronym>, it was not so much
      to flee the <filename>a.out</filename> executable format as it
      was their inflexible jump-table based shared library mechanism,
      which made the construction of shared libraries very difficult
      for vendors and developers alike. Since the
      <acronym>ELF</acronym> tools available offered a solution to the
      shared library problem and were generally seen as <quote>the way
      forward</quote> anyway, the migration cost was accepted as
      necessary and the transition made.  FreeBSD's shared library
      mechanism is based more closely on Sun's
      &sunos; style shared library mechanism
      and, as such, is very easy to use.</para>

    <para>So, why are there so many different formats?</para>

    <para>Back in the dim, dark past, there was simple hardware.  This
      simple hardware supported a simple, small system. <filename>a.out</filename> was
      completely adequate for the job of representing binaries on this
      simple system (a PDP-11). As people ported &unix; from this simple
      system, they retained the <filename>a.out</filename> format because it was sufficient
      for the early ports of &unix; to architectures like the Motorola
      68k, VAXen, etc.</para>

    <para>Then some bright hardware engineer decided that if he could
      force software to do some sleazy tricks, then he would be able
      to shave a few gates off the design and allow his CPU core to
      run faster. While it was made to work with this new kind of
      hardware (known these days as <acronym>RISC</acronym>), <filename>a.out</filename>
      was ill-suited for this hardware, so many formats were developed
      to get to a better performance from this hardware than the
      limited, simple <filename>a.out</filename> format could
      offer. Things like <acronym>COFF</acronym>,
      <acronym>ECOFF</acronym>, and a few obscure others were invented
      and their limitations explored before things seemed to settle on
      <acronym>ELF</acronym>.</para>

    <para>In addition, program sizes were getting huge and disks (and
      physical memory) were still relatively small so the concept of a
      shared library was born. The VM system also became more
      sophisticated. While each one of these advancements was done
      using the <filename>a.out</filename> format, its usefulness was
      stretched more and more with each new feature.  In addition,
      people wanted to dynamically load things at run time, or to junk
      parts of their program after the init code had run to save in
      core memory and swap space. Languages became more sophisticated
      and people wanted code called before main automatically. Lots of
      hacks were done to the <filename>a.out</filename> format to
      allow all of these things to happen, and they basically worked
      for a time. In time, <filename>a.out</filename> was not up to
      handling all these problems without an ever increasing overhead
      in code and complexity. While <acronym>ELF</acronym> solved many
      of these problems, it would be painful to switch from the system
      that basically worked. So <acronym>ELF</acronym> had to wait
      until it was more painful to remain with
      <filename>a.out</filename> than it was to migrate to
      <acronym>ELF</acronym>.</para>

    <para>However, as time passed, the build tools that FreeBSD
      derived their build tools from (the assembler and loader
      especially) evolved in two parallel trees. The FreeBSD tree
      added shared libraries and fixed some bugs. The GNU folks that
      originally write these programs rewrote them and added simpler
      support for building cross compilers, plugging in different
      formats at will, and so on. Since many people wanted to build cross
      compilers targeting FreeBSD, they were out of luck since the
      older sources that FreeBSD had for <application>as</application> and <application>ld</application> were not up to the
      task. The new GNU tools chain (<application>binutils</application>) does support cross
      compiling, <acronym>ELF</acronym>, shared libraries, C++
      extensions, etc. In addition, many vendors are releasing
      <acronym>ELF</acronym> binaries, and it is a good thing for
      FreeBSD to run them.</para>

    <para><acronym>ELF</acronym> is more expressive than <filename>a.out</filename> and
      allows more extensibility in the base system. The
      <acronym>ELF</acronym> tools are better maintained, and offer
      cross compilation support, which is important to many people.
      <acronym>ELF</acronym> may be a little slower than <filename>a.out</filename>, but
      trying to measure it can be difficult. There are also numerous
      details that are different between the two in how they map
      pages, handle init code, etc. None of these are very important,
      but they are differences. In time support for
      <filename>a.out</filename> will be moved out of the <filename>GENERIC</filename>
      kernel, and eventually removed from the kernel once the need to
      run legacy <filename>a.out</filename> programs is past.</para>
  </sect1>

  <sect1 id="basics-more-information">
    <title>For More Information</title>

    <sect2 id="basics-man">
      <title>Manual Pages</title>
      <indexterm><primary>manual pages</primary></indexterm>

      <para>The most comprehensive documentation on FreeBSD is in the form
	of manual pages. Nearly every program on the system comes with a
	short reference manual explaining the basic operation and various
	arguments. These manuals can be viewed with the <command>man</command> command.  Use
	of the <command>man</command> command is simple:</para>

      <screen>&prompt.user; <userinput>man <replaceable>command</replaceable></userinput></screen>

      <para><literal>command</literal> is the name of the command you
        wish to learn about.  For example, to learn more about
	<command>ls</command> command type:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>The online manual is divided up into numbered sections:</para>

      <orderedlist>
	<listitem>
	  <para>User commands.</para>
	</listitem>

	<listitem>
	  <para>System calls and error numbers.</para>
	</listitem>

	<listitem>
	  <para>Functions in the C libraries.</para>
	</listitem>

	<listitem>
	  <para>Device drivers.</para>
	</listitem>

	<listitem>
	  <para>File formats.</para>
	</listitem>

	<listitem>
	  <para>Games and other diversions.</para>
	</listitem>

	<listitem>
	  <para>Miscellaneous information.</para>
	</listitem>

	<listitem>
	  <para>System maintenance and operation commands.</para>
	</listitem>

	<listitem>
	  <para>Kernel developers.</para>
	</listitem>
      </orderedlist>

      <para>In some cases, the same topic may appear in more than one
	section of the online manual.  For example, there is a
	<command>chmod</command> user command and a
	<function>chmod()</function> system call.  In this case, you can
	tell the <command>man</command> command which one you want by specifying the
	section:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>This will display the manual page for the user command
        <command>chmod</command>. References to a particular section of
	the online manual are traditionally placed in parenthesis in
	written documentation, so &man.chmod.1; refers to the
	<command>chmod</command> user command and &man.chmod.2; refers to
	the system call.</para>

      <para>This is fine if you know the name of the command and simply
	wish to know how to use it, but what if you cannot recall the
	command name?  You can use <command>man</command> to search for keywords in the
	command descriptions by using the <option>-k</option>
	switch:</para>

      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para>With this command you will be presented with a list of
        commands that have the keyword <quote>mail</quote> in their
	descriptions.  This is actually functionally equivalent to using
	the <command>apropos</command> command.</para>

      <para>So, you are looking at all those fancy commands in
	<filename>/usr/bin</filename> but do not have the faintest idea
	what most of them actually do?  Simply do:</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

	<para>or</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

	<para>which does the same thing.</para>
    </sect2>

    <sect2 id="basics-info">
      <title>GNU Info Files</title>
      <indexterm><primary>Free Software Foundation</primary></indexterm>

      <para>FreeBSD includes many applications and utilities produced by
	the Free Software Foundation (FSF).  In addition to manual pages,
	these programs come with more extensive hypertext documents called
	<literal>info</literal> files which can be viewed with the
	<command>info</command> command or, if you installed
	<application>emacs</application>, the info mode of
	<application>emacs</application>.</para>

      <para>To use the &man.info.1; command, simply type:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>For a brief introduction, type <literal>h</literal>.  For a
	quick command reference, type <literal>?</literal>.</para>
    </sect2>
  </sect1>
</chapter>
<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

