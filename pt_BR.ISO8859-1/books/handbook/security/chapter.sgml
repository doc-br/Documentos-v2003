<!--
     The FreeBSD Brazilian Portuguese Documentation Project

     $FreeBSD$
     Original Revision: 1.193
     
-->

<chapter id="security">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Matthew</firstname>
	<surname>Dillon</surname>
	<contrib>Muito deste capítulo foi obtido da página
	  de manual security(7) </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Segurança</title>
  <indexterm><primary>segurança</primary></indexterm>

  <sect1 id="security-synopsis">
    <title>Sinopse</title>

    <para>Este capítulo irá fornecer uma instrução básica sobre os 
      conceitos de segurança do sistema, Algumas regras comuns de 
      manuseio, e alguns tópicos avançados sobre &os;.  Uma boa 
      quantidade dos tópicos abordados aqui pode ser aplicada a 
      segurança do sistema e da Internet de um modo geral.  A Internet
      não é mais o local <quote>amigável</quote> no qual todos querem 
      ser seus bons vizinhos.  Garantir a segurança do seu sistema 
      tornou-se imperativo para proteger seus dados, propridade 
      intelectual, tempo, e muito mais das mãos de 
      <acronym>hackers</acronym> e afins.</para>

    <para>FreeBSD dispõe de uma estrutura de utilitários e mecanismos 
      para assegurar a integridade e a segurança do seu sistema e de 
      sua rede.</para>

    <para>Lendo este este capítulo, você irá aprender sobre:</para>

    <itemizedlist>
      <listitem>
	<para>Conceitos básicos de segurança do sistema, relacionados 
	  ao &os;.</para>
      </listitem>

      <listitem>
	<para>Diversos mecanismos de criptografia, disponíveis no &os;, 
	  como o <acronym>DES</acronym> e o <acronym>MD5</acronym>.</para>
      </listitem>

      <listitem>
	<para>Como configurar autenticação com senha de uso único.</para>
      </listitem>

      <listitem>
	<para>Como configurar <application>KerberosIV</application> no &os; 
	  em versões anteriores a 5.0.</para>
      </listitem>

      <listitem>
	<para>Como configurar <application>Kerberos5</application> em 
	  versões posteriores a 5.0.</para>
      </listitem>

      <listitem>
	<para>Como criar firewalls usando <acronym>IPFW</acronym>.</para>
      </listitem>

      <listitem>
	<para>Como configurar IPsec e criar uma <acronym>VPN</acronym> 
	  entre maquinas &os;/&windows;.</para>
      </listitem>
     
      <listitem>
	<para>Como configurar e usar <application>OpenSSH</application>,
	  a implementa&ccedil;ão do <acronym>SSH</acronym> no &os;.</para>
      </listitem>

      <listitem>
	<para>Como configurar e carregar módulos de extensão de 
	  controle de acesso usando o Sistema <acronym>MAC</acronym>
	  do TrustedBSD.</para>
      </listitem>

      <listitem>
	<para>O que é uma Lista de Controle de Acesso do sistema de 
	  arquivos e como usa-la.</para>
      </listitem>

      <listitem>
	<para>Como utilizar as publicações do Conselho de Segurança 
	  do &os;.</para>
      </listitem>

    </itemizedlist>

    <para>Antes de ler este capítulo você precisa:</para>

    <itemizedlist>
      <listitem>
	<para>Entender os conceitos básicos de &os; e Internet.</para>
      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 id="security-intro">
    <title>Introdução</title>

    <para>Segurança é uma função que começa e termina com o administrador 
      do sistema.  Enquanto todo sistema BSD &unix; multi-usuário tem 
      alguma segurança nativa, o trabalho de criar e manter mecanismos 
      adicionais de segurança para controlar aqueles usuários 
      <quote>honestos</quote> é provavelmente uma das grandes e 
      solitárias tarefas do <quote>sysadmin-Administrador do sistema</quote>.

      Maquinas estão seguras sómente quando voce as faz assim, e o 
      interesse por segurança está sempre competindo com a necessidade
      humana por conveniência. Sistemas &unix;, em geral, são capazes
      de executar um grande numero de processos simultaneos e muitos
      destes processos operam como servidores &ndash; Significando que
      entidades externas podem conectar e conversar com eles.  A medida
      que os mini-computadores e <foreignphrase>mainframes</foreignphrase>
      de ontem tornaram-se os micro-computadores de hoje, e a medida
      que os computadores foram se conectando em redes e as redes se
      conectaram entre elas, segurança passou a ser um assunto sempre
      mais importante.</para>

    <para>A melhor maneira de implementar segurança é através de 
      camadas, como se fosse uma <quote>cebola</quote>.  Em resumo,
      o que você precisa fazer é tantas camadas de proteção quanto lhe
      for convêniente e então monitorar cuidadosamente o systemas contra
      criar invasões.  Você não precisa exagerar em suas configuraões
      de proteção, ou irá interferir com a possibilidade de detecção,
      e a detecção é isoladamente um dos aspectos mais importantes de
      qualquer mecanismo de segurança.  Por exemplo, faria pouco sentido
      definir o flag <literal>schg</literal> (veja &man.chflags.1;) em
      cada binário do sistema, porque enquanto isto pode temporariamente
      proteger os binários, irá impedir que um intruso que obteve acesso 
      ao seu sistema faça um alteração que seria facilmente detectada e
      levar seus mecanismos de segurança a nunca detectarem o intruso ou
      e a falha que foi explorada.</para>

    <para>Segurança de sistema tambem está relacionada com várias formas 
      de ataque, incluindo ataques que tentam travar, ou de alguma forma 
      impedir o uso ou funcionamento do sistema, mas que não tentam 
      comprometer a conta <username>root</username> 
      (<quote>break root</quote>). 
      Preocupações com segurança
      podem ser divididas em diversas categorias:</para>

    <orderedlist>
      <listitem>
	<para>Ataque de negação de serviços (<foreignphrase>DoS-Denial of service attacks</foreignphrase>).</para>
      </listitem>

      <listitem>
	<para>Comprometimento de contas de usuário.</para>
      </listitem>

      <listitem>
	<para>Comprometimento do <username>root</username> através de servidores acessíveis.</para>
      </listitem>

      <listitem>
	<para>Comprometimento do <username>root</username> via contas de usuários.</para>
      </listitem>

      <listitem>
	<para>Criação de portas de acesso clandestinas(<foreignphrase>Backdoor</foreignphrase>.</para>
      </listitem>
    </orderedlist>

    <indexterm>
      <primary>Ataques DoS</primary>
      <see>Negação de Serviço-Denial of Service (DoS)</see>
    </indexterm>
    <indexterm>
      <primary>segurança</primary>
      <secondary>Ataques DoS</secondary>
      <see>Negação de Serviço-Denial of Service (DoS)</see>
    </indexterm>
    <indexterm><primary>Negação de Serviço-Denial of Service (DoS)</primary></indexterm>

    <para>Um ataque de negação de serviço é uma ação que torna 
      indisponíveis à máquina os recursos necessários.  Tipicamente,
      um ataque DoS é um mecanismo de força bruta que tenta travar ou 
      então tornar a maquina temporariamente inutilizável entupindo um
      serviço ou a capacidade da rede.  Alguns ataques DoS tentam tirar
      vantagem de falhas na camada de rede para travar a máquina com um 
      único pacote.  Este último somente pode ser corrigido aplicando
      a correção da falha ao kernel.  Ataques a servidores frequentemente
      podem ser corrigidos por uma configuração adequada dos limites da 
      carga que os servidores impõe ao sistema sob condições adversas. 
      Ataques de força Bruta por rede são muito difíceis de tratar. Um
      ataque por pacote falsificado-<foreignphrase>spoofed-packet</foreignphrase>, 
      por exemplo, é quase impossível de parar, colocando seu sistema 
      repentinamente fora da internet.  Ele pode não ser capaz de colocar
      seu equipamento fora de operação, mas ele pode saturar sua conexão
      com a internet.</para>

    <indexterm>
      <primary>segurança</primary>
      <secondary>Comprometimento de contas de usuário</secondary>
    </indexterm>

    <para>Um ataque às contas de usuário é até mais comum que um ataque 
      DoS. Muitos administradores de sistema ainda executam servidores 
      padrão de
      <application>telnetd</application>, <application>rlogind</application>,
      <application>rshd</application>,
      and <application>ftpd</application> em suas máquinas.  Estes 
      Servidores, por padrão, não operam dentro de conexões encriptadas. 
      o resultado é que se você tem qualquer base de usuários de tamanho
      moderado, um ou mais dos seus usuários que conectam em seu sistema 
      de um local remoto (o qual é o mais comum e conveniente meio de 
      conectar a um sistema) terão a sua senha descoberta. O administrador
      de sistema atencioso irá analizar seus logs de acesso remoto
      buscando por endereços de origem suspeita mesmo para autenticações
      bem sucedidas.</para>

    <para>Deve-se sempre assumir que uma vez o intruso tem acesso a
      conta de usuário, ele pode tomar a conta de <username>root</username>. 
      De qualquer forma, a realidade é que em um sistema bem seguro e
      com boa manutenção, acessar uma conta e usuário não irá 
      necesáriamente dar ao intruso acesso ao <username>root</username>. 
      Esta distinção é importante porque sem o acesso a conta de 
      <username>root</username> o intruso geralmente não poderá esconder 
      suas pistas e talvez, melhor ainda, esteja apto somente a nada
      mais que bagunçar os arquivos do usuário, ou travar a maquina. 
      o Comprometimento da conta de usuário é muito comum porque usuários 
      tendem a não tomar as precauções que um administrador de sistema
      toma.</para>
      
    <indexterm>
      <primary>segurança</primary>
      <secondary>Criação de portas de acesso clandestinas(<foreignphrase>Backdoors</foreignphrase>)</secondary>
    </indexterm>

    <para>Administradores de sistema precisam ter em mente que ali 
      existem potencialmente muitas maneiras de violar uma conta 
      <username>root</username> em uma maquina.  O intruso pode conhecer 
      a senha de <username>root</username>, o intruso pode encontrar uma
      falha em um servidor rodando com o usuário <username>root</username>
      e obter acesso através de uma conexão de rede para este servidor, 
      ou o intruso pode conhecer uma falha em um programa com provilégios
      de <username>root</username> que permite ao intruso violar a conta
      <username>root</username> uma vez que ele tenha invadido o sistema
      através de uma contra de usuário. Se um intruso encontrou uma 
      maneira de violar a conta de <username>root</username> em uma 
      maquina, ele pode não ter a necessidade de instalar uma porta de 
      acesso clandestina-<foreignphrase>backdoor</foreignphrase>. 
      Muitas das falhas em contas <username>root</username> encontradas 
      e corrigidas até hoje envolveram um considerável esforço do intruso 
      par limpar suas pistas, então a maioria dos intrusos instala uma 
      porta de acesso clandestina-<foreignphrase>backdoor</foreignphrase>. 
      Uma porta de acesso clandestina-<foreignphrase>backdoor</foreignphrase>
      fornece ao intruso uma maneira fácil e conveniente retomar o acesso
      pela conta de <username>root</username> do sistema, mas isto permite
      ao administrador de sistema uma maneira conveniente para detectar
      a intrusão.
      


      Making it impossible for an attacker to install a backdoor may
      actually be detrimental to your security, because it will not
      close off the hole the attacker found to break in the first
      place.</para>


    <para>Security remedies should always be implemented with a
      multi-layered <quote>onion peel</quote> approach and can be
      categorized as follows:</para>

    <orderedlist>
      <listitem>
	<para>Securing <username>root</username> and staff accounts.</para>
      </listitem>

      <listitem>
	<para>Securing <username>root</username> &ndash; root-run servers
	  and suid/sgid binaries.</para>
      </listitem>

      <listitem>
	<para>Securing user accounts.</para>
      </listitem>

      <listitem>
	<para>Securing the password file.</para>
      </listitem>

      <listitem>
	<para>Securing the kernel core, raw devices, and
	  filesystems.</para>
      </listitem>

      <listitem>
	<para>Quick detection of inappropriate changes made to the
	  system.</para>
      </listitem>

      <listitem>
	<para>Paranoia.</para>
      </listitem>
    </orderedlist>

    <para>The next section of this chapter will cover the above bullet
      items in greater depth.</para>
  </sect1>

  <sect1 id="securing-freebsd">
    <title>Protegendo FreeBSD</title>
    <indexterm>
      <primary>Segurança</primary>
      <secondary>protegendo FreeBSD</secondary>
    </indexterm>

    <note>
      <title>Comando vs. Protocolo</title>
      <para>Durante todo este documento, nós vamos usar o texto em
       <application>negrito</application> para referenciar a um 
       comando ou aplicação.  Será usado para exemplos como ssh, desde
       que seja um protocolo bem como um comando.</para>
    </note>

    <para>As seções que seguem vão cobrir os métodos para proteger
      seu sistema FreeBSD que foram mencionadas na <link
        linkend="security-intro">última seção</link> deste capítulo.</para>

    <sect2 id="securing-root-and-staff">
      <title>Protegendo a conta <username>root</username> e contas do
	sistema</title>
      <indexterm>
        <primary><command>su</command></primary>
      </indexterm>

      <para>Primeiramente, não perca tempo protegendo as contas do
	sistema se você não protegeu a conta <username>root</username>.
	A maioria dos sistemas tem uma senha atribuída a conta 
	<username>root</username>.  A primeira coisa que você faz é 
	assumir que a senha está <emphasis>sempre</emphasis> 
	comprometida.  Isso não siginifica que você deve remover a 
	senha.  A senha é quase sempre necessária para o acesso ao
	console da máquina.  O que isso significa é que você não deve
	possibilitar o uso da senha fora do console ou possivelmente
	com o comando &man.su.1;.  Por exemplo, certifique-se de que
	seus terminais <literal>pty</literal> estão especificados 
	como sendo <literal>insecure</literal> no arquivo <filename>
	/etc/ttys</filename> de modo que logins diretos como 
	<username>root</username> via <command>telnet</command> ou 
	<command>rlogin</command> serão rejeitados.  Se estiver 
	usando outros serviços de login tais como <application>sshd
	</application>, certifique-se de que logins diretos como 
	<username>root</username> estão desabilitados também.  
	Você pode fazer isso editando seu arquivo <filename>
	/etc/ssh/sshd_config</filename>, e certificando-se de que 
	<literal>PermitRootLogin</literal> está ajustada para 
	<literal>NO</literal>.  Considere cada método de acesso 
	&ndash; serviços tais como <acronym>FTP
	</acronym> often fall through the cracks.
	Logins diretos como <username>root</username> somente devem
	ser permitidos através do console do sistema.</para>
      <indexterm>
        <primary><groupname>wheel</groupname></primary>
      </indexterm>

      <para>Certamente, como um administrador do sistema você tem 
	que ser capaz de pegar <username>root</username>, assim nós 
	abrimos alguns furos. Mas nos certificamos que estes furos 
	exigam uma senha adicional para operar.  Uma maneira para 
	fazer o <username>root</username> acessível é adicionar 
	contas apropriadas ao grupo <groupname>wheel</groupname> (em
	<filename>/etc/group</filename>).  Os membros colocados no 
	grupo <groupname>wheel</groupname> são permitidos usar 
	<command>su</command> para <username>root</username>.
	Você nunca deve dar aos membros do sistema acesso nativo ao 
	<groupname>wheel</groupname> colocando-os no grupo 
	<groupname>wheel</groupname> em sua entrada no arquivo de 
	senhas.  Contas do sistema devem ser colocadas em um grupo 
	<groupname>staff</groupname>, e então ser adicionados ao 
	grupo <groupname>wheel</groupname> através do arquivo 
	<filename>/etc/group</filename>.  Somente aqueles membros que
	realmente necessitam ter acesso <username>root</username> 
	devem ser colocados no grupo <groupname>wheel</groupname>.  
	É possivel também, quando usar um método de autenticação tal
	como Kerberos, usar o arquivo <filename>.k5login</filename> 
	do Kerberos na conta <username>root</username> para permitir
	um &man.ksu.1; para <username>root</username> sem ter que 
	colocar qualquer um no grupo <groupname>wheel</groupname>.  
	Esta pode ser a melhor solução visto que o mecanismo 
	<groupname>wheel</groupname> ainda permite que um intruso
	viole o <username>root</username> se conseguir seu arquivo de
	senhas e invadir uma conta do sistema.  Enquanto ter o
	mecanismo <groupname>wheel</groupname> é melhor do que nada,
	esta não é necessariamente a opção mais segura.</para>

      <para>Uma maneira indireta de proteger contas do sistema, e
	finalmente acesso <username>root</username> é usar um método 
	de login de acesso alternativo e fazer o que é conhecido
	como <quote>colocar estrela</quote> em senhas criptografadas para
	as contas do sistema.  Usando o comando &man.vipw.8;, pode
	substituir cada instância de uma senha criptografada com
	um único carácter <quote><literal>*</literal></quote>.
	Este comando atualizará o arquivo <filename>/etc/master.passwd
	</filename> e a base de dados de usuários/senhas para
	desabilitar logins autenticados por senha.</para>

      <para>Uma entrada de contas do sistema como:</para>

      <programlisting>foobar:R9DT/Fa1/LV9U:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</programlisting>

      <para>Deveria ser trocada para:</para>

      <programlisting>foobar:*:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</programlisting>

      <para>Esta mudança impedirá que logins normais ocorram,
        visto que que a senha criptografada nunca combina com 
        <quote><literal>*</literal></quote>.  Com isto feito,
	membros do sistema devem usar um outro mecanismo para
        se autenticar tais como &man.kerberos.1; ou &man.ssh.1; 
	usando um par de chaves pública/privada.  Quando usar algo
	como o Kerberos, geralmente deve proteger as máquinas
	que executam os servidores Kerberos e sua estação de trabalho
	<foreignphrase>desktop</foreignphrase>.  Quando usar um par 
	de chaves pública/privada com ssh, geralmente deve proteger
        a máquina usada para fazer login <emphasis>de</emphasis> 
	(tipicamente uma estação de trabalho).  Uma camada adicional
	de proteção pode ser adicionada ao par de chaves pela senha
	que protege o par de chaves ao criá-las com 
	&man.ssh-keygen.1;.  Sendo capaz de
        <quote>colocar estrela</quote> nas senhas para contas também
	garantem que os membros do sistema podem apenas fazer login
	através de métodos de acesso seguros que você criou.  Isto
	força todos os membros do sistema a usar conexões seguras, 
	criptografadas para todas as seções, que fecham um furo 
	importante usado por muitos invasores: <foreignphrase>sniffing
	</foreignphrase> na rede de uma máquina menos segura.</para>

      <para>Os mecanismos mais indiretos de proteção também assumem que
	você esta logando de um servidor mais restritivo para um servidor
	menos restritivo.  Por exemplo, se sua máquina principal esta
	executando todos os tipos de serviços, sua estação de trabalho
	não deve executar algum.  Para que sua estação de trabalho
	seja razoalvelmente segura você deve executar o mínimo de 
	serviços possíveis, incluindo até nenhum serviço, e
	você deve executar uma proteção de tela protegida por senha.  
	Naturalmente, dando acesso físico a uma estação de trabalho
	para um atacante pode quebrar qualquer tipo de segurança
	que você colocou.  Isto é definitivamente um problema que você
	deve considerar, mas você também deve considerar o fato de que
	a grande maioira da violações ocorrem remotamente, através da
	rede, de pessoas que não tem acesso físico a sua estação de
	trabalho ou servidores.</para>
      <indexterm><primary>KerberosIV</primary></indexterm>

      <para>Usando algo como o Kerberos também te da a abilidade de
	desativar ou trocar a senha para as contas do sistema em um
	lugar, e ter efeito imediatamente em todas as máquinas em que
	os membros do sistema podem ter uma conta.  Se uma conta de
	um membro do sistema for comprometida, a abilidade de trocar
	imediatamente sua senha em todas as máquinas não deve ser 
	desconsiderada.  Com senhas separadas, trocar a senha em N 
	máquinas pode ser um problema.  Você também pode impor
	restrições de troca de senha com Kerberos:  não somente um
	ticket Kerberos pode ser feito para timeout após um tempo, mas
	o sistema Kerberos pode exigir que o usuário escolha uma nova
	senha após um certo período de tempo (digamos, uma vez ao mês).</para>
    </sect2>

    <sect2>
      <title>Protegendo serviços que executam como root e Binários SUID/SGID</title>

      <indexterm>
        <primary><command>ntalk</command></primary>
      </indexterm>
      <indexterm>
        <primary><command>comsat</command></primary>
      </indexterm>
      <indexterm>
        <primary><command>finger</command></primary>
      </indexterm>
      <indexterm>
        <primary>sandboxes</primary>
      </indexterm>
      <indexterm>
        <primary><application>sshd</application></primary>
      </indexterm>
      <indexterm>
        <primary><application>telnetd</application></primary>
      </indexterm>
      <indexterm>
        <primary><application>rshd</application></primary>
      </indexterm>
      <indexterm>
        <primary><application>rlogind</application></primary>
      </indexterm>

      <para>O administrador de sistemas prudente somente executa serviços
	que necessita, nem mais, nem menos.  Esteja previnido que serviços
	de terçeiros são frequentemente os mais sujeitos a falhas.  Por 
	exemplo, executando uma versão antiga do <application>imapd
	</application> ou <application>popper</application> é como dar
	um ticket <username>root</username> universal para o mundo inteiro.
	Nunca execute um serviço que você não verificou com cuidado.
	Muitos serviços não precisam ser executados como  <username>root
	</username>.
	Por exemplo, os daemons <application>ntalk</application>,
	<application>comsat</application>, e
	<application>finger</application> poden ser executados em 
	<firstterm>sandboxes</firstterm> especiais de usuário.  Um sandbox
	não é perfeito, a menos que você atravesse por uma quantidade 
	grande de problemas, mas a aproximação da cebola à segurança
	ainda permanece: Se alguém puder entrar através de um servidor
	executando em um sandbox, ele ainda tem que quebrar o sandbox.  
	Quanto mais camadas o atacante deve quebrar, mais baixa
	a probabilidade de seu sucesso.  Furos envolvendo root foram
	encontrados historicamente em todos os serviços que sempre 
	executam como <username>root</username>, incluindo serviços 
	básicos do sistema.
	Se você esta usando uma máquina através da qual pessoas
	somente fazem login via <application>sshd</application> 
	e nunca via <application>telnetd</application> ou
	<application>rshd</application> ou
	<application>rlogind</application>, então desligue estes
	serviços!</para>
      
      <para>FreeBSD agora por padrão executa 
	<application>ntalkd</application>,
	<application>comsat</application>, e
	<application>finger</application> em um sandbox.  Um outro
	programa que pode ser candidato para executar em um sandbox
	é &man.named.8;.
	<filename>/etc/defaults/rc.conf</filename> inclui os argumentos
	necessários para executar <application>named</application> em um
	sandbox em um formulário comentado.  Dependendo se você esta
	instalando um sistema novo ou atualizando um sistema existente,
	contas especiais de usuário usadas por estes sandboxes podem 
	não estar instaladas.  O administrador de sistemas prudente
	pesquisa e implementa sandboxes para serviços sempre que
	possível.</para>
      <indexterm>
        <primary><application>sendmail</application></primary>
      </indexterm>

      <para>Há um número de outros serviços que tipicamente não executam
	em sandboxes: <application>sendmail</application>,
	<application>popper</application>,
	<application>imapd</application>, <application>ftpd</application>,
	e outros.  Há alternativas para alguns destes, mas
	instalá-las pode exigir mais trabalho do que você está disposto
	a executar (o fator conveniência ataca outra vez).  Você pode ter
	que executar estes serviços como <username>root</username> e 
	confiar em outros mecanismos para detectar violações que podem
	ocorrer através deles.</para>

      <para>Os outros furos com grande potencial <username>root</username>
	em um sistema são os binários suid-root e sgid instalados no 
	sistema.  A maioria destes binários, tais como 
	<application>rlogin</application>, residem em
	<filename>/bin</filename>, <filename>/sbin</filename>,
	<filename>/usr/bin</filename>, ou <filename>/usr/sbin</filename>.
	Enquanto nada é 100% seguro, os binários suid e sgid padrões
	do sistema podem ser considerados razoalvelmente seguros.  
	Apesar disso, furos <username>root</username> são encontrados
	ocasionalmente nestes binários.  Um furo <username>root</username>
	foi encontrado no <literal>Xlib</literal> em 1998 que fez o
	<application>xterm</application> (que é tipicamente suid)
	vulnerável.  É melhor estar seguro do que lamentar-se e o
	administrador de sistemas prudente restringirá binários suid,
	somente aqueles que usuários do sistema devem executar, a um
	grupo especial que somente estes usuários podem acessar, e
	começa a se livrar (<command>chmod 000</command>) de todos os 
	binários suid que ninguém usa.
	Um servidor sem monitor geralmente não necessita um binário 
	<application>xterm</application>.  Binários sgid podem ser
	quase sempre perigosos.  Se um intruso puder violar um 
	binário sgid-kmem, o intruso provavelmente será capaz de
	ler o <filename>/dev/kmem</filename> e assim ler o arquivo
	de senhas criptografadas, comprometendo potencialmente
	qualquer conta com senha.  Alternativamente um intruso que
	viole o grupo <literal>kmem</literal> pode monitorar keystrokes 
	enviadas através dos terminais <literal>pty</literal>, incluindo
	<literal>pty's</literal> usados por usuários que fazem login 
	através de métodos seguros.  Um intruso que viole o grupo 
	<groupname>tty</groupname> pode escrever para quase todos os
	tty de usuário.  Se um usuário estiver executando um programa ou 
	emulador no terminal com característica de simulação de teclado, 
	o intruso pode gerar potencialmente um data stream que ocasiona
	o terminal do usuário a executar um comando, que é então executado
	como esse usuário.</para>
    </sect2>

    <sect2 id="secure-users">
      <title>Protegendo Contas de Usuários</title>

      <para>Contas de usuário geralmente são as mais difíceis de 
	proteger.  Enquanto você pode impor restrições de acesso 
	Draconianas em contas do sistema e colocar 
	<quote>estrela</quote> nas suas senhas, você não pode
	ser capaz de fazer algo assim com todas as contas gerais de 
	usuário que você pode ter.  Se você tiver controle suficiente,
	então você pode	conseguir e ser capaz de proteger as contas
	de usuário corretamente.  Se não, você simplesmente tem que
	ser mais vigilante na sua monitoração daquelas contas.  O uso
	do ssh e Kerberos para contas de usuário é mais problematica,
	devido a administração extra e suporte técnico requeridos, 
	mas ainda uma solução muito boa comparada a um arquivo de senhas
	criptografadas.</para>
    </sect2>

    <sect2>
      <title>Protegendo o Arquivo de Senhas</title>

      <para>The only sure fire way is to <literal>*</literal> out 
	em quantas senhas você puder e usar ssh ou Kerberos para
	o acesso daquelas contas.  Mesmo que o arquivo de senhas
	criptografadas (<filename>/etc/spwd.db</filename>) possa
	somente ser lido pelo <username>root</username>, pode ser
	possível para um intruso obter acesso de leitura a esse
	arquivo mesmo se o atacante não pode obter acesso de escrita
	root.</para>

      <para>Seus scripts de segurança devem sempre verificar e relatar
	mudanças ao arquivo de senhas (veja a seção <link
	  linkend="security-integrity">Verificando integridade de 
	  arquivos</link> abaixo).</para>
    </sect2>

    <sect2>
      <title>Protegendo o Kernel Core, Raw Devices, e sistemas de arquivos</title>

      <para>Se um atacante violar o <username>root</username> ele pode
	fazer quase que qualquer coisa, mas há certas conveniências.
	Por exemplo, a maioria dos <literal>kernels</literal> modernos
	tem um controlador de dispositivo de farejar
	(<foreignphrase>sniffing</foreignphrase>) pacotes embutido.  
	Sob FreeBSD é chamado dispositivo <devicename>bpf</devicename>.  
	Um intruso tentará geralmente executar um farejador 
	(<foreignphrase>sniffer</foreignphrase>) de pacotes em
	uma máquina comprometida.  Você não necessita dar ao intruso
	esta capacidade e a maioria dos sistemas não tem a necessidade
	para o dispositivo <devicename>bpf</devicename> compilado.</para>

      <indexterm>
        <primary><command>sysctl</command></primary>
      </indexterm>
      <para>Mas mesmo se você desligar o dispositivo 
	<devicename>bpf</devicename>, você ainda tem  
	<devicename>/dev/mem</devicename> e 
	<devicename>/dev/kmem</devicename> para preocupar-se.  
	De qualquer forma, o intruso pode ainda escrever em
	raw disk devices.  Também, há outra característica no 
	<literal>kernel</literal> chamada carregador de módulo, 
	&man.kldload.8;.  Um intruso ousado pode usar um módulo
	KLD para instalar seu próprio dispositivo 
	<devicename>bpf</devicename>, ou outro dispositivo de
	farejar (<foreignphrase>sniffing</foreignphrase>), em um
	<literal>kernel</literal> funcionando.  Para evitar estes
	problemas você tem que executar o kernel em um nível
	de segurança elevado, pelo menos 
	<literal>securelevel</literal> 1.
	O <literal>securelevel</literal> pode ser ajustado com 
	<command>sysctl</command> na
	variável <varname>kern.securelevel</varname>.  Uma vez
	que você ajustou o <literal>securelevel</literal> para 1, 
	acesso de escrita a raw devices estarão negados e 
	flags especiais <command>chflags</command>, tais 
	como <literal>schg</literal>,
	serão reforçadas.  Você deve também assegurar que a
	flag <literal>schg</literal> eseja ajustada em binários
	criticos de inicialização, diretórios, e arquivos 
	<literal>script</literal> &ndash; tudo que começa a executar
	até o ponto onde o <literal>securelevel</literal> é ajustado.  
	Isto pode ser um exagero, e atualizar o sistema é muito mais
	difícil quando você opera em um nível de segurança elevado.  
	Você pode acertar e executar o sistema em um nível de
	segurança elevado mas não ajustar a flag
	<literal>schg</literal> para cada arquivo e diretório do sistema
	under the sun.  Outra possibilidade é  simplesmente
	montar o <filename>/</filename> e <filename>/usr</filename> apenas
	leitura.
	Deve ser notado que ser Draconiano demais no que você tenta
	proteger pode impedir toda importante detecção de uma invasão.</para>
    </sect2>

    <sect2 id="security-integrity">
      <title>Verificando Integridade de Arquivo: Binários, Arquivos de Configuração, Etc.</title>

      <para>Quando comes right down to it, você pode somente proteger
 	sua configuração core do sistema e arquivos de controle
	muito antes do fator conveniência elevar-se a sua cabeça.  Por
	exemplo, usando <command>chflags</command> para ajustar o 
	bit <literal>schg</literal> na maioria dos arquivos em 
	<filename>/</filename> e <filename>/usr</filename> é provavelmente
	improdutivo, porque enquanto pode proteger os arquivos, 
	fecha também uma janela de detecção.
	A última camada de sua cebola de segurança é talvez a mais
	importante &ndash; detecção.  O rest da sua segurança
	é pretty much inútil (ou, pior, oferece a você um falso
	senso de segurança) se você nao puder detectar invasões potenciais.  
	A metade do trabalho da cebola é atrasar o atacante, 
	preferêncialmente do que para-lo, a fim de dar ao lado
	da detecção da equação uma oportunidade de pegá-lo no ato.</para>

      <para>A melhor maneira de detectar uma invasão é procurar por
	arquivos modificados, perdidos ou inesperados.  A melhor maneira
	de procurar por arquivos modificados é de outro sistema 
	(frequentemente centralizado) com acesso limitado.
	Escrevendo seus scripts de segurança no sistema com acesso 
	limitado extra-seguro fá-los na maioria das vezes invisíveis 
	para atacantes potenciais, e isto é importante.  A fim de
	conseguir vantagem máxima você geralmente tem que dar a máquina 
	com acesso limitado, acesso significante as outras
	máquinas no local, geralmente fazendo a exportação NFS
	apenas leitura das outras máquinas para a máquina com acesso limitado, 
	ou criando o par de chaves ssh para permitir a máquina com acesso
	limitado fazer ssh para outras máquinas.  A exceção do seu 
	tráfego de rede, o NFS é o método menos visível &ndash; 
	permitindo que você monitore o sistema de arquivos em cada
	máquina cliente não detectada virtualmente.  Se seu
	servidor com acesso limitado esta conectado as máquinas clientes
	através de um <literal>switch</literal>, o método NFS é
	frequentemente a melhor escolha.  Se seu servidor com acesso
	limitado esta conectado as máquinas clientes através de um
	<literal>hub</literal>, ou atrevés de diversas camadas de roteamento, 
	o método NFS pode ser inseguro demais (network-wise) e usar
	ssh pode ser a melhor escolha mesmo com	audit-trail tracks 
	que o ssh coloca.</para>

      <para>Uma vez que você da a máquina com acesso limitado, 
	ao menos acesso leitura aos sistemas clientes supostos a
	monitorar, você deve escrever scripts para fazer a monitoração
	real.  Dado uma montagem NFS, você pode escrever scripts 
	de simples utilitários do sistema tais como &man.find.1; e
	&man.md5.1;.  É melhor fazer fisicamente o md5 dos arquivos
	da máquina cliente ao menos uma vez por dia, e para testar
	arquivos de controle tais como aqueles encontradas em
	<filename>/etc</filename> e <filename>/usr/local/etc</filename> 
	até mais frequentemente.  Quando mismatches são encontradas, 
	relativo a base de informação md5 a máquina com acesso
	limitado machine knows is valid, deve mostrar para um
	administrador do sistema para verificar isso.  Um com script
	de segurança verificará também por binários suid inapropriados
	e por arquivos novos ou deletados em partições do sistema
	tais como <filename>/</filename> e
	<filename>/usr</filename>.</para>

      <para>Quanto usar ssh em vez do NFS,
	escrever o script de segurança é muito mais difícil.  Você
	essencialmente tem que copiar com <command>scp</command> os
	scripts para a máquina clientea fim de executar eles, fazendo-os
	visíveis, e por segurança você necessita também de copiar com
	<command>scp</command> os binários (tais como find) que aqueles
	scripts usam.  O cliente <application>ssh</application> 
	na máquina cliente pode já estar comprometido.  De modo geral, 
	usar o ssh pode ser necessario quando estiver usando links inseguros,
	mas ele é também muito difícil de se lidar.</para>

      <para>Um bom script de segurança verificará também por mudanças
	aos arquivos de configuração de acesso dos usuários e membros
	do sistema: <filename>.rhosts</filename>, 
	<filename>.shosts</filename>,
	<filename>.ssh/authorized_keys</filename> e assim por diante&hellip;
	arquivos que puderam ficar fora do alcançe da verificação 
	<literal>MD5</literal>.</para>

      <para>Se você tiver uma grande quantidade de espaço em disco, 
	isto pode demorar muito para executar através em cada
	arquivo naquela partição.  Neste caso, ajustando as
	flags do montagem para desabilitar binários
	suid e dispositivos naquelas partições são uma boa idéia.  
	As opções <literal>nodev</literal> e
	<literal>nosuid</literal> (veja &man.mount.8;) são as que
	você precisa procurar.  Você deve provavelmente fazer a 
	varredura de qualquer maneira, ao menos uma vez por semana, 
	desde que o objeto desta camada detecte uma invasão
	se a invasão for eficaz ou não.</para>

      <para>Contabilidade de processos (veja &man.accton.8;) é 
	uma característica relativamente de baixo overhead  do
	sistema operacional que pode ajudar como um mecanismo
	de avaliação post-break-in.  É especialmente útil
	em rastrear como um intruso violou realmente um sistema, 
	assumindo que o arquivo ainda esteja intacto depois 
	que a invasão ocorrer.</para>

      <para>Finalmente, scripts de segurança devem processar os
	arquivos de log, e os logs deles mesmos devem ser gerados
	em maneira tão segura como for possível &ndash; syslog remoto 
	pode ser muito útil.  Um intruso tenta cobrir seus rastros, e
	o arquivos de log são críticos ao administrador do sistema
	que tentat rastrear a hora e método da invasão inicial.  
	Uma maneira de manter um registro permanente do arquivo de
	log é excecutar o console do sistema em uma porta serial
	e coletar as informações em uma base continua através
	de uma máquina segura monitorando os consoles.</para>
    </sect2>

    <sect2>
      <title>Paranoia</title>

      <para>Um pouco de paranoia nunca machuca.  Em geral, um
	administrador do sistema pode adicionar qualquer número de
	características de segurança, as long as they do not effect
	convenience, and can add security features that
	<emphasis>do</emphasis> effect convenience with some added thought.
	Até mais importante, um administrador de segurança deve misturar
	uma parte &ndash; se você usar recomendações tais como
	aquelas dadas por este documento literalmente, você da
	suas metodologias para a perspectiva do atacante que  
	também tem acesso a este documento.</para>
    </sect2>

    <sect2>
      <title>Ataques de Negação de Serviço</title>
      <indexterm><primary>Negação de Serviço (DoS)</primary></indexterm>

      <para>Esta seção cobre Ataques de Negação de Serviço.  Um ataque
	DoS é tipicamente um ataque de pacote.  Enquanto não há
	muito o que você pode fazer sobre ataques modernos de pacotes 
	falsificados <foreignphrase>spoofed</foreignphrase>
	que saturam sua rede, você pode geralmente limitar os danos
	assegurando que os ataques não possam derrubar seus servidores.</para>

      <orderedlist>
	<listitem>
	  <para>Limitando server forks.</para>
	</listitem>

	<listitem>
	  <para>Limitando ataques springboard (ataques de resposta ICMP, 
	ping broadcast, etc.).</para>
	</listitem>

	<listitem>
	  <para>Kernel Route Cache.</para>
	</listitem>
      </orderedlist>

      <para>Um ataque DoS comum é contra a forking server que tenta
	fazer com que o servidor coma processos, descritores de
	arquivos e memória, até que a máquina morra.  O  
	<application>inetd</application>
	(veja &man.inetd.8;) tem diversas opções para limitar este
	tipo de ataque.  Deve-se notar que enquanto é possível
	impedir que uma máquina caia, não é geralmente possível impedir
	que um serviço seja interrompido pelo ataque.  Leia a página de 
	manual <application>inetd</application> cuidadosamente e
	preste atenção específica para as opções <option>-c</option>, 
	<option>-C</option>, e <option>-R</option>.  Note que
	ataques de IP falsificados <foreignphrase>spoofed</foreignphrase> 
	vão enganar a opção <option>-C</option> para o 
	<application>inetd</application>, assim tipicamente uma
	combinação de opções deve ser usada.  Alguns serviços 
	standalone tem parâmetros self-fork-limitation.</para>

      <para>O <application>sendmail</application> tem sua opção
	<option>-OMaxDaemonChildren</option>, que tende a funcionar
	muito melhor do que tentando usar opções de limite de carga do 
	sendmail devido ao atraso de carga.  Você deve especificar
	um parâmetro <literal>MaxDaemonChildren</literal>, quando
	você inicia o <application>sendmail</application>, 
	alto o bastante para segurar sua carga esperada, mas não tão
	alto que o computador não pode segurar esse número de 
	<application>sendmails</application> sem cair.  É também
	prudente executar o sendmail no modo de fila
	(<option>-ODeliveryMode=queued</option>) e executar o daemon
	(<command>sendmail -bd</command>) separado da execução de filas
	(<command>sendmail -q15m</command>).  Se você ainda quiser 
	entrega em tempo real você pode executar a fila em um intervalo
	mais baixo, como <option>-q1m</option>, mas esteja certo 
	de especificar uma opção <literal>MaxDaemonChildren</literal> 
	razoável para <emphasis>esse</emphasis> sendmail para impedir
	falhas em cascata.</para>

      <para>O <application>syslogd</application> pode ser atacado
	diretamente e recomenda-se fortemente que você use a opção
	<option>-s</option> sempre que possível, e a opção 
	<option>-a</option> de qualquer forma.</para>

      <para>Você deve também ser bastante cauteloso com serviços 
	connect-back tais como o identd reverso do 
	<application>tcpwrapper</application>, que pode ser atacado
	diretamente.  Você geralmente não precisa usar a característica
	indent reverso do <application>tcpwrappers</application> por
	esta razão.</para>

      <para>É uma idéia muito boa proteger serviços internos do acesso
	externo por firewalling mantendo-os fora em seus roteadores de borda.
	A idéia aqui é impedir ataques de saturação de fora da sua LAN,
	não para proteger serviços internos de um comprometimento 
	<username>root</username> baseado em rede.
	Configure sempre um firewall exclusivo, isto é,
	<quote>firewall em tudo <emphasis>exceto</emphasis> nas 
	portas A, B, C, D, e M-Z</quote>.  Esta maneira você pode
	firewall em todas as suas portas baixas exceto para determinados
	serviços específicos tais como <application>named</application> 
	(se você é primario para uma zona),
	<application>ntalkd</application>,
	<application>sendmail</application>, e outros serviços acessíveis
	via Internet.  Se você tentar configurar o firewall de outra
	maneira &ndash; como um firewall inclusivo ou permissivo, 
	há uma boa possibilidade que você esqueça de <quote>fechar</quote> 
	um par de serviços, ou que você adicioine um novo serviço interno
	e esqueça de atualizar o firewall.  Você pode ainda abrir
	um range de portas altas no firewall, para permitir 
	operações como permissivas, sem comprometer suas portas baixas.  
	Também tome nota que o FreeBSD permit você controlar o range de
	portas usado por conexões dinâmicas, através de varios 
	<varname>net.inet.ip.portrange</varname> do
 	<command>sysctl</command>
	(<command>sysctl -a | fgrep
	portrange</command>), que pode também facilitar a complexidade
	da configuração do seu firewall.  Por exemplo, você pode
	usar um range normal first/last de 4000 a 5000, e
	um range hiport de 49152 a 65535, e bloquear tudo abaixo de 4000
	no seu firewall (exceto para determinados portas de acesso 
	específicas a Internet, naturalmente).</para>

      <indexterm><primary>ICMP_BANDLIM</primary></indexterm>

      <para>Um outro ataque DoS comum é chamado um ataque springboard
	&ndash; para atacar um servidor de uma maneira que faça o
	servidor gerar respostas que sobrecarregue o servidor, a
	rede local, ou alguma outra máquina.  O ataque mais comum
	desta natureza é o <emphasis>ICMP ping broadcast attack</emphasis>.
	O atacante falsifica <foreignphrase>spoofs</foreignphrase> 
	pacotes ping enviados para o endereço de broadcast da sua LAN com o 
	endereço IP de origem atribuido a máquina real que ele deseja atacar.  
	Se seus roteadores de borda não estiverem configurados para
	parar ping para endereços de broadcast, sua LAN enrosca
	gerando respostas suficientes ao endereço de origem falsificado 
	<foreignphrase>spoofed</foreignphrase> para saturar a vítima, 
	especialmente quando o atacante usa o mesmo truque em
	diferentes dúzias de endereços broadcast em cima de diferentes
	dúzias de redes de uma vez.  Ataques de broadcast sobre cento
	e vinte megabits foram medidos.  Um segundo ataque springboard 
	comum é contra os sistemas de relátorios de erro do ICMP.
	construindo pacotes que geram respostas de erro ICMP, um
	atacante pode saturar a rede de entrada do servidor e fazer 
	com que o servidor sature sua rede de saída com respostas ICMP.  
	Este tipo de ataque pode também derrubar o servidor executando
	mbuf's, especialmente se o servidor não pode tratar as respostas
	ICMP geradas rápidas o bastante.  O kernel do FreeBSD kernel tem
	uma nova opção de compilação chamada <option>ICMP_BANDLIM</option>
	que limita a eficácia destes tipos de ataques.  A última 
	classe principal de ataques springboard esta relacionada a
	certos serviços <application>inetd</application> internos
	tais como o serviço echo udp.  Um atacante simplesmente 
	falsifica <foreignphrase>spoofs</foreignphrase> um pacote
	UDP com o endereço de origem sendo a porta echo do servidor A, 
	e o endereço de destino sendo a porta acho do servidor B, 
	onde o servidor A e B estão ambos em sua LAN.  Os dois
	servidores então lançam este pacote para frente e para 
	trás entre si.  O atacante pode sobrecarregar ambos os
	servidores e suas LANs simplesmente injetando alguns
	pacotes nesta maneira.
	Problemas silimares existem com a porta 
	<application>chargen</application> interna.  Um administrador
	de sistemas competente desligará todos estes serviços internos de
	teste do inetd.</para>

      <para>Ataques de pacotes falsificados 
	<foreignphrase>spoofed</foreignphrase> podem também ser usados
	para sobrecarregar o cache de rotas do kernel.  Consulte os
	parâmetros <varname>net.inet.ip.rtexpire</varname>,
	<varname>rtminexpire</varname> e <varname>rtmaxcache</varname>
	do <command>sysctl</command>.  Um ataque de pacotes falsificados
	que usa uma origem IP aleatório fara o kernel gerar
	um cache de rotas temporário na tabela de rotas, visível com
	<command>netstat -rna | fgrep W3</command>.  Estas rotas
	tipicamente terminam em 1600 segundos ou menos.  Se o kernel 
	detectar que a tabela de rotas cacheadas começou a crescer 
	ele dinâmicamente reduz o <varname>rtexpire</varname> 
	mas nunca diminui menos do que o <varname>rtminexpire</varname>.  
	Há dois problemas:</para>
	
      <orderedlist>
	<listitem>
	  <para>O kernel não reage rápido o suficiente quando um
	     servidor levemente carregado é atacado repentinamente.</para>
	</listitem>
	
	<listitem>
	  <para>O <varname>rtminexpire</varname> não é baixo o bastante
	    para o kernel sobreviver a um ataque prolongado.</para>
	</listitem>
      </orderedlist>
      
      <para>Se seus servidores estiveram conectados a Internet via um T3 ou
        melhor, pode ser prudente cancelar manualmente o 
	<varname>rtexpire</varname> e <varname>rtminexpire</varname>
	via &man.sysctl.8;.  Nunce ajuste o parâmetro de um dos dois
	para zero (a menos que você queira derrubar a máquina).  Ajustar
	ambos os parâmetros para 2 segundos deve ser suficiente para
	proteger a tabela de rotas de um ataque.</para>
    </sect2>

    <sect2>
      <title>Casos de Acesso com Kerberos e SSH</title>
      <indexterm><primary><command>ssh</command></primary></indexterm>
      <indexterm><primary>KerberosIV</primary></indexterm>

      <para>Há alguns casos com Kerberos e ssh que precisam ser 
	dirigidos se você pretente usa-los.  Kerberos V é um 
	protocolo excelente de autenticação, mas há falhas nas 
	aplicações kerberizadas	<application>telnet</application> e
	<application>rlogin</application> que as fazem inadequadas
	para relacionamento com streams binários.  Também, por
	padrão o Kerberos não criptografa uma sessão a menos que
	você use a opção <option>-x</option>.  O <application>ssh</application>
	criptografa tudo por padrão.</para>

      <para>O ssh funciona perfeitamente bem em cada respect exceto que
	ele envia chaves criptografadas por padrão.  O que
	isto significa é que se você tiver uma estação de trabalho segura
	guardando chaves que lhe dão acesso ao resto do sistema, e você
	faz ssh para uma máquina insegura, suas chaves são aproveitadas.  
	As chaves reais não são expostas, mas o ssh instala uma porta
	de envio para o duração do seu login, e se um atacante violar o
	<username>root</username> na máquina insegura ele pode utilizar
	essa porta para usar suas chaves para ganhar acesso a qualquer
	outra máquina que suas chaves abrem.</para>

      <para>Nós recomendamos que você use o ssh em combinação com
	Kerberos sempre que for possível para logins do sistema.
	O <application>ssh</application> pode ser compilado com suporte a
	Kerberos.  Isto reduz sua segurança em chaves ssh potênciamente 
	expostas enquanto ao mesmo tempo protege senhas via Kerberos.  
	Chaves ssh devem somente ser usadas para tarefas automatizadas
	de máquinas seguras (algo que o Kerberos é adequado a fazer).  
	Nós também recomendamos que você desligue o envio de chaves
	na configuração do ssh, ou que você faça uso da opção
	<literal>from=IP/DOMAIN</literal> que o ssh permite em seu
	arquivo <filename>authorized_keys</filename> fazer a chave
	somente	aproveitaveis a entidades que fazem login de
	máquinas específicas.</para>
    </sect2>
  </sect1>

  <sect1 id="crypt">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Bill</firstname>
	  <surname>Swingle</surname>
	  <contrib>Parcialmente reescrito e atualizado por </contrib>
	</author>
      </authorgroup>
      <!-- 21 Mar 2000 -->
    </sect1info>

    <title>DES, MD5, e Crypt</title>
    <indexterm>
      <primary>segurança</primary>
      <secondary>crypt</secondary>
    </indexterm>

    <indexterm><primary>crypt</primary></indexterm>
    <indexterm><primary>DES</primary></indexterm>
    <indexterm><primary>MD5</primary></indexterm>

    <para>Every user on a &unix; system has a password associated with
      their account.  It seems obvious that these passwords need to be
      known only to the user and the actual operating system.  In
      order to keep these passwords secret, they are encrypted with
      what is known as a <quote>one-way hash</quote>, that is, they can
      only be easily encrypted but not decrypted.  In other words, what
      we told you a moment ago was obvious is not even true:  the
      operating system itself does not <emphasis>really</emphasis> know
      the password.  It only knows the <emphasis>encrypted</emphasis>
      form of the password.  The only way to get the
      <quote>plain-text</quote> password is by a brute force search of the
      space of possible passwords.</para>

    <para>Unfortunately the only secure way to encrypt passwords when
      &unix; came into being was based on DES, the Data Encryption
      Standard.  This was not such a problem for users resident in
      the US, but since the source code for DES could not be exported
      outside the US, FreeBSD had to find a way to both comply with
      US law and retain compatibility with all the other &unix;
      variants that still used DES.</para>

    <para>The solution was to divide up the encryption libraries 
      so that US users could install the DES libraries and use
      DES but international users still had an encryption method
      that could be exported abroad.  This is how FreeBSD came to
      use MD5 as its default encryption method.  MD5 is believed to
      be more secure than DES, so installing DES is offered primarily
      for compatibility reasons.</para>

    <sect2>
      <title>Recognizing Your Crypt Mechanism</title>

      <para>Before FreeBSD&nbsp;4.4 <filename>libcrypt.a</filename> was a
	symbolic link pointing to the library which was used for
	encryption.  FreeBSD&nbsp;4.4 changed <filename>libcrypt.a</filename> to
	provide a configurable password authentication hash library.
	Currently the library supports DES, MD5 and Blowfish hash
	functions.  By default FreeBSD uses MD5 to encrypt
	passwords.</para>

      <para>It is pretty easy to identify which encryption method 
	FreeBSD is set up to use.  Examining the encrypted passwords in
	the <filename>/etc/master.passwd</filename> file is one way.
	Passwords encrypted with the MD5 hash are longer than those
	encrypted with the DES hash and also begin with the characters
	<literal>&dollar;1&dollar;</literal>.  Passwords starting with
	<literal>&dollar;2&dollar;</literal> are encrypted with the
	Blowfish hash function.  DES password strings do not
	have any particular identifying characteristics, but they are
	shorter than MD5 passwords, and are coded in a 64-character
	alphabet which does not include the <literal>&dollar;</literal>
	character, so a relatively short string which does not begin with
	a dollar sign is very likely a DES password.</para>

      <para>The password format used for new passwords is controlled
	by the <literal>passwd_format</literal> login capability in
	<filename>/etc/login.conf</filename>, which takes values of
	<literal>des</literal>, <literal>md5</literal> or
	<literal>blf</literal>.  See the &man.login.conf.5; manual page
	for more information about login capabilities.</para>

    </sect2>
  </sect1>

  <sect1 id="one-time-passwords">
    <title>Senhas de uso único</title>
    <indexterm><primary>senhas de uso único</primary></indexterm>
    <indexterm>
      <primary>Segurança</primary>
      <secondary>senhas de uso único</secondary>
    </indexterm>

    <para>S/Key is a one-time password scheme based on a one-way hash
      function.  FreeBSD uses the MD4 hash for compatibility but other
      systems have used MD5 and DES-MAC.  S/Key has been part of the
      FreeBSD base system since version 1.1.5 and is also used on a
      growing number of other operating systems.  S/Key is a registered
      trademark of Bell Communications Research, Inc.</para>

    <para>From version 5.0 of FreeBSD, S/Key has been replaced with
      the functionally equivalent OPIE (One-time Passwords In
      Everything).  OPIE uses the MD5 hash by default.</para>

    <para>There are three different sorts of passwords which we will discuss
      below.  The first is your usual &unix; style or
      Kerberos password; we will call this a <quote>&unix; password</quote>.
      The second sort is the one-time password which is generated by the
      S/Key <command>key</command> program or the OPIE
      &man.opiekey.1; program and accepted by the
      <command>keyinit</command> or &man.opiepasswd.1; programs
      and the login prompt; we will
      call this a <quote>one-time password</quote>.  The final sort of
      password is the secret password which you give to the
      <command>key</command>/<command>opiekey</command> programs (and
      sometimes the
      <command>keyinit</command>/<command>opiepasswd</command> programs)
      which it uses to generate
      one-time passwords; we will call it a <quote>secret password</quote>
      or just unqualified <quote>password</quote>.</para>

    <para>The secret password does not have anything to do with your &unix;
      password; they can be the same but this is not recommended.  S/Key
      and OPIE secret passwords are not limited to 8 characters like old
      &unix; passwords<footnote><para>Under &os; the standard login
      password may be up to 128 characters in length.</para></footnote>,
      they can be as long as you like.  Passwords of six or
      seven word long phrases are fairly common.  For the most part, the
      S/Key or OPIE system operates completely independently of the &unix;
      password system.</para>

    <para>Besides the password, there are two other pieces of data that
      are important to S/Key and OPIE.  One is what is known as the
      <quote>seed</quote> or <quote>key</quote>, consisting of two letters
      and five digits.  The other is what is called the <quote>iteration
      count</quote>, a number between 1 and 100.  S/Key creates the
      one-time password by concatenating the seed and the secret password,
      then applying the MD4/MD5 hash as many times as specified by the
      iteration count and turning the result into six short English words.
      These six English words are your one-time password.  The
      authentication system (primarily PAM) keeps
      track of the last one-time password used, and the user is
      authenticated if the hash of the user-provided password is equal to
      the previous password.  Because a one-way hash is used it is
      impossible to generate future one-time passwords if a successfully
      used password is captured; the iteration count is decremented after
      each successful login to keep the user and the login program in
      sync.  When the iteration count gets down to 1, S/Key and OPIE must be
      reinitialized.</para>

    <para>There are three programs involved in each system
      which we will discuss below.  The <command>key</command> and
      <command>opiekey</command> programs accept an iteration
      count, a seed, and a secret password, and generate a one-time
      password or a consecutive list of one-time passwords.  The
      <command>keyinit</command> and <command>opiepasswd</command>
      programs are used to initialize S/Key and OPIE respectively,
      and to change passwords, iteration counts, or seeds; they
      take either a secret passphrase, or an iteration count,
      seed, and one-time password.  The <command>keyinfo</command>
      and <command>opieinfo</command> programs examine the
      relevant credentials files (<filename>/etc/skeykeys</filename> or
      <filename>/etc/opiekeys</filename>) and print out the invoking user's
      current iteration count and seed.</para>

    <para>There are four different sorts of operations we will cover.  The
      first is using <command>keyinit</command> or
      <command>opiepasswd</command> over a secure connection to set up
      one-time-passwords for the first time,  or to change your password
      or seed.  The second operation is using <command>keyinit</command>
      or <command>opiepasswd</command> over an insecure connection, in
      conjunction with <command>key</command> or <command>opiekey</command>
      over a secure connection,  to do the same.  The third is using
      <command>key</command>/<command>opiekey</command> to log in over
      an insecure connection.  The fourth is using <command>key</command>
      or <command>opiekey</command> to generate a number of keys which
      can be written down or printed out to carry with you when going to
      some location without secure connections to anywhere.</para>

    <sect2>
      <title>Secure Connection Initialization</title>

      <para>To initialize S/Key for the first time, change your password,
	or change your seed while logged in over a secure connection
	(e.g., on the console of a machine or via <application>ssh</application>), use the
	<command>keyinit</command> command without any parameters while
	logged in as yourself:</para>

      <screen>&prompt.user; <userinput>keyinit</userinput>
Adding unfurl:
Reminder - Only use this method if you are directly connected.
If you are using telnet or rlogin exit with no password and use keyinit -s.
Enter secret password: 
Again secret password: 

ID unfurl s/key is 99 to17757
DEFY CLUB PRO NASH LACE SOFT</screen>

      <para>For OPIE, <command>opiepasswd</command> is used instead:</para>

      <screen>&prompt.user; <userinput>opiepasswd -c</userinput>
[grimreaper] ~ $ opiepasswd -f -c
Adding unfurl:
Only use this method from the console; NEVER from remote. If you are using
telnet, xterm, or a dial-in, type ^C now or exit with no password.
Then run opiepasswd without the -c parameter.
Using MD5 to compute responses.
Enter new secret pass phrase:
Again new secret pass phrase:
ID unfurl OTP key is 499 to4268
MOS MALL GOAT ARM AVID COED
</screen>

      <para>At the <prompt>Enter new secret pass phrase:</prompt> or
        <prompt>Enter secret password:</prompt> prompts, you
	should enter a password or phrase.  Remember, this is not the
	password that you will use to login with, this is used to generate
	your one-time login keys.  The <quote>ID</quote> line gives the
	parameters of your particular instance: your login name, the
        iteration count, and seed.  When logging in the system
	will remember these parameters and present them back to you so you
	do not have to remember them.  The last line gives the particular
	one-time password which corresponds to those parameters and your
	secret password; if you were to re-login immediately, this
	one-time password is the one you would use.</para>
    </sect2>

    <sect2>
      <title>Insecure Connection Initialization</title>
      
      <para>To initialize or change your secret password over an
	insecure connection, you will need to already have a secure
	connection to some place where you can run <command>key</command>
        or <command>opiekey</command>; this might be in the form of a
	desk accessory on a &macintosh;, or a shell prompt on a machine you
	trust.  You will also need to make up an iteration count (100 is
	probably a good value), and you may make up your own seed or use a
	randomly-generated one.  Over on the insecure connection (to the
	machine you are initializing), use the <command>keyinit
	-s</command> command:</para>

      <screen>&prompt.user; <userinput>keyinit -s</userinput>
Updating unfurl:
Old key: to17758
Reminder you need the 6 English words from the key command.
Enter sequence count from 1 to 9999: <userinput>100</userinput>
Enter new key [default to17759]: 
s/key 100 to 17759
s/key access password:
s/key access password:<userinput>CURE MIKE BANE HIM RACY GORE</userinput>
</screen>

      <para>For OPIE, you need to use <command>opiepasswd</command>:</para>

      <screen>&prompt.user; <userinput>opiepasswd</userinput>

Updating unfurl:
You need the response from an OTP generator.
Old secret pass phrase:
        otp-md5 498 to4268 ext
        Response: GAME GAG WELT OUT DOWN CHAT
New secret pass phrase:
        otp-md5 499 to4269
        Response: LINE PAP MILK NELL BUOY TROY

ID mark OTP key is 499 gr4269
LINE PAP MILK NELL BUOY TROY
</screen>

      <para>To accept the default seed (which the
	<command>keyinit</command> program confusingly calls a
	<literal>key</literal>), press <keycap>Return</keycap>.
	Then before entering an
	access password, move over to your secure connection or S/Key desk
	accessory, and give it the same parameters:</para>

      <screen>&prompt.user; <userinput>key 100 to17759</userinput>
Reminder - Do not use this program while logged in via telnet or rlogin.
Enter secret password: <userinput>&lt;secret password&gt;</userinput>
CURE MIKE BANE HIM RACY GORE</screen>

      <para>Or for OPIE:</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT
</screen>

      <para>Now switch back over to the insecure connection, and copy the
	one-time password generated over to the relevant program.</para>
    </sect2>

    <sect2>
      <title>Generating a Single One-time Password</title>

      <para>Once you have initialized S/Key or OPIE, when you login you will be 
	presented with a prompt like this:</para>

<screen>&prompt.user; <userinput>telnet example.com</userinput>
Trying 10.0.0.1...
Connected to example.com
Escape character is '^]'.

FreeBSD/i386 (example.com) (ttypa)

login: <userinput>&lt;username&gt;</userinput>
s/key 97 fw13894
Password: </screen>

      <para>Or for OPIE:</para>

<screen>&prompt.user; <userinput>telnet example.com</userinput>
Trying 10.0.0.1...
Connected to example.com
Escape character is '^]'.

FreeBSD/i386 (example.com) (ttypa)

login: <userinput>&lt;username&gt;</userinput>
otp-md5 498 gr4269 ext
Password: </screen>

      <para>As a side note, the S/Key and OPIE prompts have a useful feature
	(not shown here): if you press <keycap>Return</keycap>
	at the password prompt, the
	prompter will turn echo on, so you can see what you are
	typing.  This can be extremely useful if you are attempting to
	type in a password by hand, such as from a printout.</para>

      <indexterm><primary>MS-DOS</primary></indexterm>
      <indexterm><primary>Windows</primary></indexterm>
      <indexterm><primary>MacOS</primary></indexterm>

      <para>At this point you need to generate your one-time password to
	answer this login prompt.  This must be done on a trusted system
	that you can run <command>key</command> or
        <command>opiekey</command> on.  (There are versions of these for DOS,
	&windows; and &macos; as well.) They need both the iteration count and
	the seed as command line options.  You can cut-and-paste these
        right from the login prompt on the machine that you are logging
        in to.</para>

      <para>On the trusted system:</para>

      <screen>&prompt.user; <userinput>key 97 fw13894</userinput>
Reminder - Do not use this program while logged in via telnet or rlogin.
Enter secret password: 
WELD LIP ACTS ENDS ME HAAG</screen>

      <para>For OPIE:</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</screen>

      <para>Now that you have your one-time password you can continue
	logging in:</para>

      <screen>login: <userinput>&lt;username&gt;</userinput>
s/key 97 fw13894
Password: <userinput>&lt;return to enable echo&gt;</userinput>
s/key 97 fw13894
Password [echo on]: WELD LIP ACTS ENDS ME HAAG
Last login: Tue Mar 21 11:56:41 from 10.0.0.2 ... </screen>

    </sect2>

    <sect2>
      <title>Generating Multiple One-time Passwords</title>

      <para>Sometimes you have to go places where you do not have
	access to a trusted machine or secure connection.  In this case,
	it is possible to use the <command>key</command> and
	<command>opiekey</command> commands to
	generate a number of one-time passwords beforehand to be printed
	out and taken with you.  For example:</para>

      <screen>&prompt.user; <userinput>key -n 5 30 zz99999</userinput>
Reminder - Do not use this program while logged in via telnet or rlogin.
Enter secret password: <userinput>&lt;secret password&gt;</userinput>
26: SODA RUDE LEA LIND BUDD SILT 
27: JILT SPY DUTY GLOW COWL ROT  
28: THEM OW COLA RUNT BONG SCOT  
29: COT MASH BARR BRIM NAN FLAG  
30: CAN KNEE CAST NAME FOLK BILK</screen>

      <para>Or for OPIE:</para>

      <screen>&prompt.user; <userinput>opiekey -n 5 30 zz99999</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase: <userinput>&lt;secret password&gt;</userinput>
26: JOAN BORE FOSS DES NAY QUIT
27: LATE BIAS SLAY FOLK MUCH TRIG
28: SALT TIN ANTI LOON NEAL USE
29: RIO ODIN GO BYE FURY TIC
30: GREW JIVE SAN GIRD BOIL PHI</screen>

      <para>The <option>-n 5</option> requests five keys in sequence, the
	<option>30</option> specifies what the last iteration number
	should be.  Note that these are printed out in
	<emphasis>reverse</emphasis> order of eventual use.  If you are
	really paranoid, you might want to write the results down by hand;
	otherwise you can cut-and-paste into <command>lpr</command>.  Note
	that each line shows both the iteration count and the one-time
	password; you may still find it handy to scratch off passwords as
	you use them.</para>
    </sect2>

    <sect2>
      <title>Restricting Use of &unix; Passwords</title>

      <para>S/Key can place restrictions on the use of &unix; passwords based
	on the host name, user name, terminal port, or IP address of a
	login session.  These restrictions can be found in the
	configuration file <filename>/etc/skey.access</filename>.  The
	&man.skey.access.5; manual page has more information on the complete
	format of the file and also details some security cautions to be
	aware of before depending on this file for security.</para>

      <para>If there is no <filename>/etc/skey.access</filename> file
	(this is the default on FreeBSD 4.X systems), then all users will
	be allowed to use &unix; passwords.  If the file exists, however,
	then all users will be required to use S/Key unless explicitly
	permitted to do otherwise by configuration statements in the
	<filename>skey.access</filename> file.  In all cases, &unix;
	passwords are permitted on the console.</para>

      <para>Here is a sample <filename>skey.access</filename> configuration
	file which illustrates the three most common sorts of configuration
	statements:</para>

      <programlisting>permit internet 192.168.0.0 255.255.0.0
permit user fnord
permit port ttyd0</programlisting>

      <para>The first line (<literal>permit internet</literal>) allows
	users whose IP source address (which is vulnerable to spoofing)
	matches the specified value and mask, to use &unix; passwords.  This
	should not be considered a security mechanism, but rather, a means
	to remind authorized users that they are using an insecure network
	and need to use S/Key for authentication.</para>

      <para>The second line (<literal>permit user</literal>) allows the
	specified username, in this case <username>fnord</username>, to use
	&unix; passwords at any time.  Generally speaking, this should only
	be used for people who are either unable to use the
	<command>key</command> program, like those with dumb terminals, or
	those who are uneducable.</para>

      <para>The third line (<literal>permit port</literal>) allows all
	users logging in on the specified terminal line to use &unix;
	passwords; this would be used for dial-ups.</para>

      <para>OPIE can restrict the use of &unix; passwords based on the IP
	address of a login session just like S/Key does.  The relevant file
	is <filename>/etc/opieaccess</filename>, which is present by default
	on FreeBSD 5.0 and newer systems.  Please check &man.opieaccess.5;
	for more information on this file and which security considerations
	you should be aware of when using it.</para>
	
      <para>Here is a sample <filename>opieaccess</filename> file:</para>

      <programlisting>permit 192.168.0.0 255.255.0.0</programlisting>

      <para>This line allows users whose IP source address (which is
	vulnerable to spoofing) matches the specified value and mask,
	to use &unix; passwords at any time.</para>
	
      <para>If no rules in <filename>opieaccess</filename> are matched,
	the default is to deny non-OPIE logins.</para>

    </sect2>
  </sect1>

  <sect1 id="kerberosIV">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Mark</firstname>
	  <surname>Murray</surname>
	  <contrib>Contribuição de </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Mark</firstname>
	  <surname>Dapoz</surname>
	  <contrib>Baseado em uma contribuição de </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>KerberosIV</title>

    <para>Kerberos is a network add-on system/protocol that allows users to
      authenticate themselves through the services of a secure server.
      Services such as remote login, remote copy, secure inter-system file
      copying and other high-risk tasks are made considerably safer and more
      controllable.</para>

    <para>The following instructions can be used as a guide on how to set up
      Kerberos as distributed for FreeBSD.  However, you should refer to the
      relevant manual pages for a complete description.</para>

    <sect2>
      <title>Installing KerberosIV</title>

      <indexterm><primary>MIT</primary></indexterm>
      <indexterm>
	<primary>KerberosIV</primary>
	<secondary>Installing</secondary>
      </indexterm>
      <para>Kerberos is an optional component of &os;.  The easiest
        way to install this software is by selecting the <literal>krb4</literal> or
        <literal>krb5</literal> distribution in <application>sysinstall</application>
        during the initial installation of FreeBSD.  This will install
        the <quote>eBones</quote> (KerberosIV) or <quote>Heimdal</quote> (Kerberos5)
        implementation of Kerberos.  These implementations are
        included because they are developed outside the USA/Canada and
        were thus available to system owners outside those countries
        during the era of restrictive export controls on cryptographic
        code from the USA.</para>

      <para>Alternatively, the MIT implementation of Kerberos is
        available from the ports collection as
        <filename role="package">security/krb5</filename>.</para>
    </sect2>

    <sect2>
      <title>Creating the Initial Database</title>
      
      <para>This is done on the Kerberos server only.  First make sure that
	you do not have any old Kerberos databases around.  You should change
	to the directory <filename>/etc/kerberosIV</filename> and check that
	only the following files are present:</para>
	  
      <screen>&prompt.root; <userinput>cd /etc/kerberosIV</userinput>
&prompt.root; <userinput>ls</userinput>
README		krb.conf        krb.realms</screen>
	  
      <para>If any additional files (such as <filename>principal.*</filename>
	or <filename>master_key</filename>) exist, then use the
	<command>kdb_destroy</command> command to destroy the old Kerberos
	database, or if Kerberos is not running, simply delete the extra
	files.</para>
	  
      <para>You should now edit the <filename>krb.conf</filename> and
	<filename>krb.realms</filename> files to define your Kerberos realm.
	In this case the realm will be <literal>EXAMPLE.COM</literal> and the
	server is <hostid role="fqdn">grunt.example.com</hostid>.  We edit
	or create the <filename>krb.conf</filename> file:</para>
	  
      <screen>&prompt.root; <userinput>cat krb.conf</userinput>
EXAMPLE.COM
EXAMPLE.COM grunt.example.com admin server
CS.BERKELEY.EDU okeeffe.berkeley.edu
ATHENA.MIT.EDU kerberos.mit.edu
ATHENA.MIT.EDU kerberos-1.mit.edu
ATHENA.MIT.EDU kerberos-2.mit.edu
ATHENA.MIT.EDU kerberos-3.mit.edu
LCS.MIT.EDU kerberos.lcs.mit.edu
TELECOM.MIT.EDU bitsy.mit.edu
ARC.NASA.GOV trident.arc.nasa.gov</screen>
	  
      <para>In this case, the other realms do not need to be there.  They are
	here as an example of how a machine may be made aware of multiple
	realms.  You may wish to not include them for simplicity.</para>
	  
      <para>The first line names the realm in which this system works.  The
	other lines contain realm/host entries.  The first item on a line is a
	realm, and the second is a host in that realm that is acting as a
	<quote>key distribution center</quote>.  The words <literal>admin
	  server</literal> following a host's name means that host also
	provides an administrative database server.  For further explanation
	of these terms, please consult the Kerberos manual pages.</para>
	  
      <para>Now we have to add <hostid role="fqdn">grunt.example.com</hostid>
	to the <literal>EXAMPLE.COM</literal> realm and also add an entry to
	put all hosts in the <hostid role="domainname">.example.com</hostid>
	domain in the <literal>EXAMPLE.COM</literal> realm.  The
	<filename>krb.realms</filename> file would be updated as
	follows:</para>
	  
      <screen>&prompt.root; <userinput>cat krb.realms</userinput>
grunt.example.com EXAMPLE.COM
.example.com EXAMPLE.COM
.berkeley.edu CS.BERKELEY.EDU
.MIT.EDU ATHENA.MIT.EDU
.mit.edu ATHENA.MIT.EDU</screen>
	  
      <para>Again, the other realms do not need to be there.  They are here as
	an example of how a machine may be made aware of multiple realms.  You
	may wish to remove them to simplify things.</para>
	  
      <para>The first line puts the <emphasis>specific</emphasis> system into
	the named realm.  The rest of the lines show how to default systems of
	a particular subdomain to a named realm.</para>
	  
      <para>Now we are ready to create the database.  This only needs to run
	on the Kerberos server (or Key Distribution Center).  Issue the
	<command>kdb_init</command> command to do this:</para>
	  
      <screen>&prompt.root; <userinput>kdb_init</userinput>
<prompt>Realm name [default  ATHENA.MIT.EDU ]:</prompt> <userinput>EXAMPLE.COM</userinput>
You will be prompted for the database Master Password.
It is important that you NOT FORGET this password.
		
<prompt>Enter Kerberos master key:</prompt> </screen>
	  
      <para>Now we have to save the key so that servers on the local machine
	can pick it up.  Use the <command>kstash</command> command to do
	this:</para>
	
      <screen>&prompt.root; <userinput>kstash</userinput>
	      
<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered. BEWARE!</screen>
	
      <para>This saves the encrypted master password in
	<filename>/etc/kerberosIV/master_key</filename>.</para>
    </sect2>
    
    <sect2>
      <title>Making It All Run</title>
	
      <indexterm>
	<primary>KerberosIV</primary>
	<secondary>Inital Startup</secondary>
      </indexterm>

      <para>Two principals need to be added to the database for
	<emphasis>each</emphasis> system that will be secured with Kerberos.
	Their names are <literal>kpasswd</literal> and <literal>rcmd</literal>.
	These two principals are made for each system, with the instance being
	the name of the individual system.</para>
	  
      <para>These daemons, <application>kpasswd</application> and
	<application>rcmd</application> allow other systems to change Kerberos
	passwords and run commands like &man.rcp.1;,
	&man.rlogin.1; and &man.rsh.1;.</para>
	  
      <para>Now let us add these entries:</para>
	    
      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>passwd</userinput>
<prompt>Instance:</prompt> <userinput>grunt</userinput>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt> <userinput>y</userinput>

Principal: passwd, Instance: grunt, kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- enter RANDOM here
Verifying password

<prompt>New Password:</prompt> &lt;---- enter RANDOM here

<prompt>Random password [y] ?</prompt> <userinput>y</userinput>

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt>
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt> <userinput>rcmd</userinput>
<prompt>Instance:</prompt> <userinput>grunt</userinput>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt>

Principal: rcmd, Instance: grunt, kdc_key_ver: 1
<prompt>New Password:</prompt>		&lt;---- enter RANDOM here
Verifying password

<prompt>New Password:</prompt>           &lt;---- enter RANDOM here

<prompt>Random password [y] ?</prompt>

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt>
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt>         &lt;---- null entry here will cause an exit</screen>
    </sect2>

    <sect2>
      <title>Creating the Server File</title>
      
      <para>We now have to extract all the instances which define the
	services on each machine.  For this we use the
	<command>ext_srvtab</command> command.  This will create a file
	which must be copied or moved <emphasis>by secure
	  means</emphasis> to each Kerberos client's
	<filename>/etc/kerberosIV</filename> directory.  This file must
	be present on each server and client, and is crucial to the
	operation of Kerberos.</para>
	  
	  
      <screen>&prompt.root; <userinput>ext_srvtab grunt</userinput>
<prompt>Enter Kerberos master key:</prompt>
		
Current Kerberos master key version is 1.

Master key entered. BEWARE!
Generating 'grunt-new-srvtab'....</screen>
	  
      <para>Now, this command only generates a temporary file which must be
	renamed to <filename>srvtab</filename> so that all the servers can pick
	it up.  Use the &man.mv.1; command to move it into place on
	the original system:</para>
	  
      <screen>&prompt.root; <userinput>mv grunt-new-srvtab srvtab</userinput></screen>
	  
      <para>If the file is for a client system, and the network is not deemed
	safe, then copy the
	<filename><replaceable>client</replaceable>-new-srvtab</filename> to
	removable media and transport it by secure physical means.  Be sure to
	rename it to <filename>srvtab</filename> in the client's
	<filename>/etc/kerberosIV</filename> directory, and make sure it is
	mode 600:</para>
	  
      <screen>&prompt.root; <userinput>mv grumble-new-srvtab srvtab</userinput>
&prompt.root; <userinput>chmod 600 srvtab</userinput></screen>
    </sect2>
    
    <sect2>
      <title>Populating the Database</title>
      
      <para>We now have to add some user entries into the database.  First
	let us create an entry for the user <username>jane</username>.  Use the
	<command>kdb_edit</command> command to do this:</para>
	  
      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>jane</userinput>
<prompt>Instance:</prompt>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt> <userinput>y</userinput>

Principal: jane, Instance: , kdc_key_ver: 1
<prompt>New Password:</prompt>                &lt;---- enter a secure password here
Verifying password

<prompt>New Password:</prompt>                &lt;---- re-enter the password here
Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt>
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt>		   &lt;---- null entry here will cause an exit</screen>
    </sect2>

    <sect2>
      <title>Testing It All Out</title>
      
      <para>First we have to start the Kerberos daemons.  Note that if you
	have correctly edited your <filename>/etc/rc.conf</filename> then this
	will happen automatically when you reboot.  This is only necessary on
	the Kerberos server.  Kerberos clients will automatically get what
	they need from the <filename>/etc/kerberosIV</filename>
	directory.</para>
	  
      <screen>&prompt.root; <userinput>kerberos &amp;</userinput>
Kerberos server starting
Sleep forever on error
Log file is /var/log/kerberos.log
Current Kerberos master key version is 1.

Master key entered. BEWARE!

Current Kerberos master key version is 1
Local realm: EXAMPLE.COM
&prompt.root; <userinput>kadmind -n &amp;</userinput>
KADM Server KADM0.0A initializing
Please do not use 'kill -9' to kill this job, use a
regular kill instead

Current Kerberos master key version is 1.

Master key entered.  BEWARE!</screen>
	  
      <para>Now we can try using the <command>kinit</command> command to get a
	ticket for the ID <username>jane</username> that we created
	above:</para>
	  
      <screen>&prompt.user; <userinput>kinit jane</userinput>
MIT Project Athena (grunt.example.com)
Kerberos Initialization for "jane"
<prompt>Password:</prompt> </screen>
	  
      <para>Try listing the tokens using <command>klist</command> to see if we
	really have them:</para>
	  
      <screen>&prompt.user; <userinput>klist</userinput>
Ticket file:    /tmp/tkt245
Principal:      jane@EXAMPLE.COM

  Issued           Expires          Principal
Apr 30 11:23:22  Apr 30 19:23:22  krbtgt.EXAMPLE.COM@EXAMPLE.COM</screen>
	  
      <para>Now try changing the password using &man.passwd.1; to
	check if the <application>kpasswd</application> daemon can get 
	authorization to the Kerberos database:</para>
	  
      <screen>&prompt.user; <userinput>passwd</userinput>
realm EXAMPLE.COM
<prompt>Old password for jane:</prompt>
<prompt>New Password for jane:</prompt>
Verifying password
<prompt>New Password for jane:</prompt>
Password changed.</screen>
    </sect2>

    <sect2>
      <title>Adding <command>su</command> Privileges</title>
      
      <para>Kerberos allows us to give <emphasis>each</emphasis> user
	who needs <username>root</username> privileges their own
	<emphasis>separate</emphasis> &man.su.1; password.
	We could now add an ID which is authorized to
	&man.su.1; to <username>root</username>.  This is
	controlled by having an instance of <username>root</username>
	associated with a principal.  Using <command>kdb_edit</command>
	we can create the entry <literal>jane.root</literal> in the
	Kerberos database:</para>
	  
      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>jane</userinput>
<prompt>Instance:</prompt> <userinput>root</userinput>

&lt;Not found&gt;, Create [y] ? y

Principal: jane, Instance: root, kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- enter a SECURE password here
Verifying password

<prompt>New Password:</prompt>    	 	 &lt;---- re-enter the password here

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt> <userinput>12</userinput> &lt;--- Keep this short!
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt>		         &lt;---- null entry here will cause an exit</screen>
	  
      <para>Now try getting tokens for it to make sure it works:</para>
      
      <screen>&prompt.root; <userinput>kinit jane.root</userinput>
MIT Project Athena (grunt.example.com)
Kerberos Initialization for "jane.root"
<prompt>Password:</prompt></screen>
	  
      <para>Now we need to add the user to <username>root</username>'s
	  <filename>.klogin</filename> file:</para>
	  
      <screen>&prompt.root; <userinput>cat /root/.klogin</userinput>
jane.root@EXAMPLE.COM</screen>
	  
      <para>Now try doing the &man.su.1;:</para>
	  
      <screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt></screen>
	  
      <para>and take a look at what tokens we have:</para>
	  
      <screen>&prompt.root; <userinput>klist</userinput>
Ticket file:	/tmp/tkt_root_245
Principal:      jane.root@EXAMPLE.COM

  Issued           Expires          Principal
May  2 20:43:12  May  3 04:43:12  krbtgt.EXAMPLE.COM@EXAMPLE.COM</screen>
    </sect2>

    <sect2>
      <title>Using Other Commands</title>
      
      <para>In an earlier example, we created a principal called
	<literal>jane</literal> with an instance <literal>root</literal>.
	This was based on a user with the same name as the principal, and this
	is a Kerberos default; that a
	<literal>&lt;principal&gt;.&lt;instance&gt;</literal> of the form
	<literal>&lt;username&gt;.</literal><username>root</username> will allow
	that <literal>&lt;username&gt;</literal> to &man.su.1; to
	<username>root</username> if the necessary entries are in the
	<filename>.klogin</filename> file in <username>root</username>'s
	home directory:</para>
	  
      <screen>&prompt.root; <userinput>cat /root/.klogin</userinput>
jane.root@EXAMPLE.COM</screen>
      
      <para>Likewise, if a user has in their own home directory lines of the
	form:</para>
      
      <screen>&prompt.user; <userinput>cat ~/.klogin</userinput>
jane@EXAMPLE.COM
jack@EXAMPLE.COM</screen>
	  
      <para>This allows anyone in the <literal>EXAMPLE.COM</literal> realm
	who has authenticated themselves as <username>jane</username> or
	<username>jack</username> (via <command>kinit</command>, see above)
	to access to <username>jane</username>'s
	account or files on this system (<hostid>grunt</hostid>) via
	&man.rlogin.1;, &man.rsh.1; or
	&man.rcp.1;.</para>
	  
      <para>For example, <username>jane</username> now logs into another system using
	Kerberos:</para>
	  
	    <screen>&prompt.user; <userinput>kinit</userinput>
MIT Project Athena (grunt.example.com)
<prompt>Password:</prompt>
&prompt.user; <userinput>rlogin grunt</userinput>
Last login: Mon May  1 21:14:47 from grumble
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.

FreeBSD BUILT-19950429 (GR386) #0: Sat Apr 29 17:50:09 SAT 1995</screen>
	  
      <para>Or <username>jack</username> logs into <username>jane</username>'s account on the same machine
	(<username>jane</username> having
	set up the <filename>.klogin</filename> file as above, and the person
	in charge of Kerberos having set up principal
	<emphasis>jack</emphasis> with a null instance):</para>
	  
      <screen>&prompt.user; <userinput>kinit</userinput>
&prompt.user; <userinput>rlogin grunt -l jane</userinput>
MIT Project Athena (grunt.example.com)
<prompt>Password:</prompt>
Last login: Mon May  1 21:16:55 from grumble
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.
FreeBSD BUILT-19950429 (GR386) #0: Sat Apr 29 17:50:09 SAT 1995</screen>
    </sect2>
  </sect1>

  <sect1 id="kerberos5">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tillman</firstname>
	  <surname>Hodgson</surname>
	  <contrib>Contribuição de </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Mark</firstname>
	  <surname>Murray</surname>
	  <contrib>Based on a contribution by </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title><application>Kerberos5</application></title>

    <para>Every &os; release beyond &os;-5.1 includes support
      only for <application>Kerberos5</application>.  Hence
      <application>Kerberos5</application> is the only version
      included, and its configuration is similar in many aspects
      to that of <application>KerberosIV</application>.  The following
      information only applies to
      <application>Kerberos5</application> in post &os;-5.0
      releases.  Users who wish to use the
      <application>KerberosIV</application> package may install the
      <filename role="package">security/krb4</filename> port.</para>

    <para><application>Kerberos</application> is a network add-on
      system/protocol that allows users to authenticate themselves
      through the services of a secure server.  Services such as remote
      login, remote copy, secure inter-system file copying and other
      high-risk tasks are made considerably safer and more
      controllable.</para>

    <para><application>Kerberos</application> can be described as an
      identity-verifying proxy system.  It can also be described as a
      trusted third-party authentication system.
      <application>Kerberos</application> provides only one
      function &mdash; the secure authentication of users on the network.
      It does not provide authorization functions (what users are
      allowed to do) or auditing functions (what those users did).
      After a client and server have used
      <application>Kerberos</application> to prove their identity, they
      can also encrypt all of their communications to assure privacy
      and data integrity as they go about their business.</para>

    <para>Therefore it is highly recommended that
      <application>Kerberos</application> be used with other security
      methods which provide authorization and audit services.</para>

    <para>The following instructions can be used as a guide on how to set
      up <application>Kerberos</application> as distributed for &os;.
      However, you should refer to the relevant manual pages for a complete
      description.</para>

    <para>For purposes of demonstrating a <application>Kerberos</application>
      installation, the various namespaces will be handled as follows:</para>

    <itemizedlist>
      <listitem>
	<para>The <acronym>DNS</acronym> domain (<quote>zone</quote>)
	  will be example.org.</para>
      </listitem>

      <listitem>
	<para>The <application>Kerberos</application> realm will be
	  EXAMPLE.ORG.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Please use real domain names when setting up
	<application>Kerberos</application> even if you intend to run
	it internally.  This avoids <acronym>DNS</acronym> problems
	and assures inter-operation with other
	<application>Kerberos</application> realms.</para>
    </note>

    <sect2>
      <title>History</title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>History</secondary>
      </indexterm>

      <para><application>Kerberos</application> was created by
	<acronym>MIT</acronym> as a solution to network security problems.
	The <application>Kerberos</application> protocol uses strong
	cryptography so that a client can prove its identity to a server
	(and vice versa) across an insecure network connection.</para>

      <para><application>Kerberos</application> is both the name of a
	network authentication protocol and an adjective to describe
	programs that implement the program
	(<application>Kerberos</application> telnet, for example).  The
	current version of the protocol is version 5, described in
	<acronym>RFC</acronym>&nbsp;1510.</para>

      <para>Several free implementations of this protocol are available,
	covering a wide range of operating systems.  The Massachusetts
	Institute of Technology (<acronym>MIT</acronym>), where
	<application>Kerberos</application> was originally developed,
	continues to develop their <application>Kerberos</application>
	package.  It is commonly used in the <acronym>US</acronym>
	as a cryptography product, as such it
	has historically been affected by <acronym>US</acronym> export
	regulations.  The <acronym>MIT</acronym>
	<application>Kerberos</application> is available as a port
	(<filename role="package">security/krb5</filename>).  Heimdal
	<application>Kerberos</application> is another version 5
	implementation, and was explicitly developed outside of the
	<acronym>US</acronym> to avoid export
	regulations (and is thus often included in non-commercial &unix;
	variants).  The Heimdal <application>Kerberos</application>
	distribution is available as a port
	(<filename role="package">security/heimdal</filename>), and a
	minimal installation of it is included in the base &os;
	install.</para>

    <para>In order to reach the widest audience, these instructions assume
	the use of the Heimdal distribution included in &os;.</para>

    </sect2>

    <sect2>
      <title>Setting up a Heimdal <acronym>KDC</acronym></title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>Key Distribution Center Configuration</secondary>
      </indexterm>

      <para>The Key Distribution Center (<acronym>KDC</acronym>) is the
	centralized authentication service that
	<application>Kerberos</application> provides &mdash; it is the
	computer that issues <application>Kerberos</application> tickets.
	The <acronym>KDC</acronym> is considered <quote>trusted</quote> by
	all other computers in the <application>Kerberos</application>
	realm, and thus has heightened security concerns.</para>

    <para>Note that while running the <application>Kerberos</application>
	server requires very few computing resources, a dedicated machine
	acting only as a <acronym>KDC</acronym> is recommended for security
	reasons.</para>

    <para>To begin setting up a <acronym>KDC</acronym>, ensure that your
	<filename>/etc/rc.conf</filename> file contains the correct
	settings to act as a <acronym>KDC</acronym> (you may need to adjust
	paths to reflect your own system):</para>

    <programlisting>kerberos5_server_enable="YES"
kadmind5_server_enable="YES"
kerberos_stash="YES"</programlisting>

      <note>
	<para>The <option>kerberos_stash</option> is only available in
	  &os; 4.X.</para>
      </note>

      <para>Next we will set up your <application>Kerberos</application>
	config file, <filename>/etc/krb5.conf</filename>:</para>

      <programlisting>[libdefaults]
    default_realm = EXAMPLE.ORG
[realms]
    EXAMPLE.ORG = {
        kdc = kerberos.example.org
    }
[domain_realm]
    .example.org = EXAMPLE.ORG</programlisting>

      <para>Note that this <filename>/etc/krb5.conf</filename> file implies
	that your <acronym>KDC</acronym> will have the fully-qualified
	hostname of <hostid role="fqdn">kerberos.example.org</hostid>.
	You will need to add a CNAME (alias) entry to your zone file to
	accomplish this if your <acronym>KDC</acronym> has a different
	hostname.</para>

      <note>
	<para>For large networks with a properly configured
	  <acronym>BIND</acronym> <acronym>DNS</acronym> server, the
	  above example could be trimmed to:</para>

	<programlisting>[libdefaults]
      default_realm = EXAMPLE.ORG</programlisting>

	<para>With the following lines being appended to the
	  <hostid role="fqdn">example.org</hostid> zonefile:</para>

	<programlisting>_kerberos._udp      IN  SRV     01 00 88 kerberos.example.org.
_kerberos._tcp      IN  SRV     01 00 88 kerberos.example.org.
_kpasswd._udp       IN  SRV     01 00 464 kerberos.example.org.
_kerberos-adm._tcp  IN  SRV     01 00 749 kerberos.example.org.
_kerberos           IN  TXT     EXAMPLE.ORG.</programlisting></note>

      <para>Next we will create the <application>Kerberos</application>
	database.  This database contains the keys of all principals encrypted
	with a master password.  You are not
	required to remember this password, it will be stored in a file
	(<filename>/var/heimdal/m-key</filename>).  To create the master
	key, run <command>kstash</command> and enter a password.</para>

      <para>Once the master key has been created, you can initialize the
	database using the <command>kadmin</command> program with the
	<literal>-l</literal> option (standing for <quote>local</quote>).
	This option instructs <command>kadmin</command> to modify the
	database files directly rather than going through the
	<command>kadmind</command> network service.  This handles the
	chicken-and-egg problem of trying to connect to the database
	before it is created.  Once you have the <command>kadmin</command>
	prompt, use the <command>init</command> command to create your
	realms initial database.</para>

      <para>Lastly, while still in <command>kadmin</command>, create your
	first principal using the <command>add</command> command.  Stick
	to the defaults options for the principal for now, you can always
	change them later with the <command>modify</command> command.
	Note that you can use the <literal>?</literal> command at any
	prompt to see the available options.</para>

      <para>A sample database creation session is shown below:</para>

      <screen>&prompt.root; <userinput>kstash</userinput>
      Master key: <userinput>xxxxxxxx</userinput>
      Verifying password - Master key: <userinput>xxxxxxxx</userinput>

      &prompt.root; <userinput>kadmin -l</userinput>
      kadmin> <userinput>init EXAMPLE.ORG</userinput>
      Realm max ticket life [unlimited]:
      kadmin> <userinput>add tillman</userinput>
      Max ticket life [unlimited]:
      Max renewable life [unlimited]:
      Attributes []:
      Password: <userinput>xxxxxxxx</userinput>
      Verifying password - Password: <userinput>xxxxxxxx</userinput></screen>

      <para>Now it is time to start up the <acronym>KDC</acronym> services.
	Run <command>/etc/rc.d/kerberos start</command> and
	<command>/etc/rc.d/kadmind start</command> to bring up the
	services.  Note that you won't have any kerberized daemons running
	at this point but you should be able to confirm the that the
	<acronym>KDC</acronym> is functioning by obtaining and listing a
	ticket for the principal (user) that you just created from the
	command-line of the <acronym>KDC</acronym> itself:</para>

      <screen>&prompt.user;<userinput>k5init <replaceable>tillman</replaceable></userinput>
      tillman@EXAMPLE.ORG's Password:

      &prompt.user;<userinput>k5list</userinput>
      Credentials cache: FILE:<filename>/tmp/krb5cc_500</filename>
      Principal: tillman@EXAMPLE.ORG

              Issued           Expires          Principal
              Aug 27 15:37:58  Aug 28 01:37:58  krbtgt/EXAMPLE.ORG@EXAMPLE.ORG
              Aug 27 15:37:58  Aug 28 01:37:58  krbtgt/EXAMPLE.ORG@EXAMPLE.ORG

      v4-ticket file: /tmp/tkt500
      k5list: No ticket file (tf_util)</screen>

      </sect2>

      <sect2>
	<title><application>Kerberos</application> enabling a server with
	  Heimdal services</title>

        <indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>Enabling Services</secondary>
        </indexterm>

	<para>First, we need a copy of the <application>Kerberos</application>
	  configuration file, <filename>/etc/krb5.conf</filename>.  To do
	  so, simply copy it over to the client computer from the
	  <acronym>KDC</acronym> in a secure fashion (using network utilities,
	  such as &man.scp.1;, or physically via a
	  floppy disk).</para>

	<para>Next you need a <filename>/etc/krb5.keytab</filename> file.
	  This is the major difference between a server providing
	  <application>Kerberos</application> enabled daemons and a
	  workstation &mdash; the server must have a
	  <filename>keytab</filename> file.  This file
	  contains the servers host key, which allows it and the
	  <acronym>KDC</acronym> to verify each others identity.  It
	  must be transmitted to the server in a secure fashion, as the
	  security of the server can be broken if the key is made public.
	  This explicitly means that transferring it via a clear text
	  channel, such as <acronym>FTP</acronym>, is a very bad idea.</para>

	<para>Typically, you transfer to the <filename>keytab</filename>
	  to the server using the <command>kadmin</command> program.
	  This is handy because you also need to create the host principal
	  (the <acronym>KDC</acronym> end of the
	  <filename>krb5.keytab</filename>) using
	  <command>kadmin</command>.</para>

	<para>Note that you must have already obtained a ticket and that this
	  ticket must be allowed to use the <command>kadmin</command>
	  interface in the <filename>kadmind.acl</filename>.  See the section
	  titled <quote>Remote administration</quote> in the Heimdal info
	  pages (<command>info heimdal</command>) for details on designing
	  access control lists.  If you do not want to enable remote
	  <command>kadmin</command> access, you can simply securely connect
	  to the <acronym>KDC</acronym> (via local console,
	  &man.ssh.1; or <application>Kerberos</application>
	  &man.telnet.1;) and perform administration locally
	  using <command>kadmin -l</command>.</para>

	<para>After installing the <filename>/etc/krb5.conf</filename> file,
	  you can use <command>kadmin</command> from the
	  <application>Kerberos</application> server.  The
	  <command>add --random-key</command> command will let you add the
	  servers host principal, and the <command>ext</command> command
	  will allow you to extract the servers host principal to its own
	  keytab.  For example:</para>

	<screen>&prompt.root; <userinput>kadmin</userinput>
	kadmin><userinput> add --random-key host/myserver.EXAMPLE.ORG</userinput>
	Max ticket life [unlimited]:
	Max renewable life [unlimited]:
	Attributes []:
	kadmin><userinput> ext host/myserver.EXAMPLE.ORG</userinput>
	kadmin><userinput> exit</userinput></screen>

	<para>Note that the <command>ext</command> command (short for
	  <quote>extract</quote>) stores the extracted key in
	  <filename>/etc/krb5.keytab</filename> by default.</para>

	<para>If you do not have <command>kadmind</command> running on the
	  <acronym>KDC</acronym> (possibly for security reasons) and thus
	  do not have access to <command>kadmin</command> remotely, you
	  can add the host principal
	  (<username>host/myserver.EXAMPLE.ORG</username>) directly on the
	  <acronym>KDC</acronym> and then extract it to a temporary file
	  (to avoid over-writing the <filename>/etc/krb5.keytab</filename>
	  on the <acronym>KDC</acronym>) using something like this:</para>

	<screen>&prompt.root; <userinput>kadmin</userinput>
	kadmin><userinput> ext --keytab=/tmp/example.keytab host/myserver.example.org</userinput>
	kadmin><userinput> exit</userinput></screen>

	<para>You can then securely copy the keytab to the server
	  computer (using <command>scp</command> or a floppy, for
	  example).  Be sure to specify a non-default keytab name
	  to avoid over-writing the keytab on the
	  <acronym>KDC</acronym>.</para>

	<para>At this point your server can communicate with the
	  <acronym>KDC</acronym> (due to its <filename>krb5.conf</filename>
	  file) and it can prove its own identity (due to the
	  <filename>krb5.keytab</filename> file).  It is now ready for
	  you to enable some <application>Kerberos</application> services.
	  For this example we will enable the <command>telnet</command>
	  service by putting a line like this into your
	  <filename>/etc/inetd.conf</filename> and then restarting the
	  &man.inetd.8; service with
	  <command>/etc/rc.d/inetd restart</command>:</para>

	<programlisting>telnet    stream  tcp     nowait  root    /usr/libexec/telnetd  telnetd -a user</programlisting>

	<para>The critical bit is that the <command>-a</command>
	  (for authentication) type is set to user.  Consult the
	  &man.telnetd.8; manual page for more details.</para>

      </sect2>

      <sect2>
	<title><application>Kerberos</application> enabling a client with Heimdal</title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>Client Configuration</secondary>
	</indexterm>

	<para>Setting up a client computer is almost trivially easy.  As
	  far as <application>Kerberos</application> configuration goes,
	  you only need the <application>Kerberos</application>
	  configuration file, located at <filename>/etc/krb5.conf</filename>.
	  Simply securely copy it over to the client computer from the
	  <acronym>KDC</acronym>.</para>

	<para>Test your client computer by attempting to use
	  <command>kinit</command>, <command>klist</command>, and
	  <command>kdestroy</command> from the client to obtain, show, and
	  then delete a ticket for the principal you created above.  You
	  should also be able to use <application>Kerberos</application>
	  applications to connect to <application>Kerberos</application>
	  enabled servers, though if that does not work and obtaining a
	  ticket does the problem is likely with the server and not with
	  the client or the <acronym>KDC</acronym>.</para>

	<para>When testing an application like <command>telnet</command>,
	  try using a packet sniffer (such as &man.tcpdump.1;)
	  to confirm that your password is not sent in the clear.  Try
	  using <command>telnet</command> with the <literal>-x</literal>
	  option, which encrypts the entire data stream (similar to
	  <command>ssh</command>).</para>

	<para>The core <application>Kerberos</application> client applications
	  (traditionally named <command>kinit</command>,
	  <command>klist</command>, <command>kdestroy</command>, and
	  <command>kpasswd</command>) are installed in
	  the base &os; install. Note that &os; versions prior to 5.0
	  renamed them to <command>k5init</command>,
	  <command>k5list</command>, <command>k5destroy</command>,
	  <command>k5passwd</command>, and <command>k5stash</command>
	  (though it is typically only used once).</para>

	<para>Various non-core <application>Kerberos</application> client
	  applications are also installed by default.  This is where the
	  <quote>minimal</quote> nature of the base Heimdal installation is
	  felt: <command>telnet</command> is the only
	  <application>Kerberos</application> enabled service.</para>

	<para>The Heimdal port adds some of the missing client applications:
	  <application>Kerberos</application> enabled versions of
	  <command>ftp</command>, <command>rsh</command>,
	  <command>rcp</command>, <command>rlogin</command>, and a few
	  other less common programs. The <acronym>MIT</acronym> port also
	  contains a full suite of <application>Kerberos</application>
	  client applications.</para>

      </sect2>

      <sect2>
	<title>User configuration files: <filename>.k5login</filename> and <filename>.k5users</filename></title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>User Configuration Files</secondary>
	</indexterm>

	<para>Users within a realm typically have their
	  <application>Kerberos</application> principal (such as
	  <username>tillman@EXAMPLE.ORG</username>) mapped to a local
	  user account (such as a local account named
	  <username>tillman</username>).  Client applications such as
	  <command>telnet</command> usually do not require a user name
	  or a principal.</para>

	<para>Occasionally, however, you want to grant access to a local
	  user account to someone who does not have a matching
	  <application>Kerberos</application> principal.  For example,
	  <username>tillman@EXAMPLE.ORG</username> may need access to the
	  local user account <username>webdevelopers</username>.  Other
	  principals may also need access to that local account.</para>

	<para>The <filename>.k5login</filename> and
	  <filename>.k5users</filename> files, placed in a users home
	  directory, can be used similar to a powerful combination of
	  <filename>.hosts</filename> and <filename>.rhosts</filename>,
	  solving this problem. For example, if a
	  <filename>.k5login</filename> with the following
	  contents:</para>

	<screen>tillman@example.org
	jdoe@example.org</screen>

	<para>Were to be placed into the home directory of the local user
	  <username>webdevelopers</username> then both principals listed
	  would have access to that account without requiring a shared
	  password.</para>

	<para>Reading the man pages for these commands is recommended.
	  Note that the <command>ksu</command> man page covers
	  <filename>.k5users</filename>.</para>

      </sect2>

      <sect2>
	<title><application>Kerberos</application> Tips, Tricks, and Troubleshooting</title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>Troubleshooting</secondary>
	</indexterm>

	<itemizedlist>
	  <listitem>
	    <para>When using either the Heimdal or <acronym>MIT</acronym>
	      <application>Kerberos</application> ports ensure that your
	      <envar>PATH</envar> environment variable lists the
	      <application>Kerberos</application> versions of the client
	      applications before the system versions.</para>
	  </listitem>

	  <listitem>
	    <para>Is your time in sync? Are you sure? If the time is not in
	      sync (typically within five minutes) authentication will
	      fail.</para>
	  </listitem>

	  <listitem>
	    <para><acronym>MIT</acronym> and Heimdal inter-operate nicely.
	      Except for <command>kadmin</command>, the protocol for
	      which is not standardized.</para>
	  </listitem>

	  <listitem>
	    <para>If you change your hostname, you also need to change your
	      <username>host/</username> principal and update your keytab.
	      This also applies to special keytab entries like the
	      <username>www/</username> principal used for Apache's
	      <filename role="package">www/mod_auth_kerb</filename>.</para>
	  </listitem>

	  <listitem>
	    <para>All hosts in your realm must be resolvable (both forwards
	      and reverse) in <acronym>DNS</acronym> (or
	      <filename>/etc/hosts</filename> as a minimum).  CNAMEs
	      will work, but the A and PTR records must be correct and in
	      place. The error message isn't very intuitive:
	      <errorname>Kerberos5 refuses authentication because Read req
	      failed: Key table entry not found</errorname>.</para>
	  </listitem>

	  <listitem>
	    <para>Some operating systems that may being acting as clients
	      to your <acronym>KDC</acronym> do not set the permissions
	      for <command>ksu</command> to be setuid
	      <username>root</username>.  This means that
	      <command>ksu</command> does not work, which is a good
	      security idea but annoying. This is not a
	      <acronym>KDC</acronym> error.</para>
	  </listitem>

	  <listitem>
	    <para>With <acronym>MIT</acronym>
	      <application>Kerberos</application>, if you want to allow a
	      principal to have a ticket life longer than the default ten
	      hours, you must use <command>modify_principal</command> in
	      <command>kadmin</command> to change the maxlife of both the
	      principal in question and the <username>krbtgt</username>
	      principal.  Then the principal can use the
	      <literal>-l</literal> option with <command>kinit</command>
	      to request a ticket with a longer lifetime.</para>
	  </listitem>

	  <listitem>
	    <note><para>If you run a packet sniffer on your
	      <acronym>KDC</acronym> to add in troubleshooting and then
	      run <command>kinit</command> from a workstation, you will
	      notice that your <acronym>TGT</acronym> is sent
	      immediately upon running <command>kinit</command> &mdash;
	      even before you type your password!  The explanation is
	      that the <application>Kerberos</application> server freely
	      transmits a <acronym>TGT</acronym> (Ticket Granting
	      Ticket) to any unauthorized request;  however, every
	      <acronym>TGT</acronym> is encrypted in a key derived from
	      the user's password.  Therefore, when a user types their
	      password it is not being sent to the <acronym>KDC</acronym>,
	      it is being used to decrypt the <acronym>TGT</acronym> that
	      <command>kinit</command> already obtained. If the decryption
	      process results in a valid ticket with a valid time stamp,
	      the user has valid <application>Kerberos</application>
	      credentials.  These credentials include a session key for
	      establishing secure communications with the
	      <application>Kerberos</application> server in the future, as
	      well as the actual ticket-granting ticket, which is actually
	      encrypted with the <application>Kerberos</application>
	      server's own key.  This second layer of encryption is
	      unknown to the user, but it is what allows the
	      <application>Kerberos</application> server to verify
	      the authenticity of each <acronym>TGT</acronym>.</para></note>
	  </listitem>

	  <listitem>
	    <para>You have to keep the time in sync between all the
	      computers in your realm.  <acronym>NTP</acronym> is
	      perfect for this.  For more information on
	      <acronym>NTP</acronym>, see
	      <xref linkend="network-ntp">.</para>
	  </listitem>

	  <listitem>
	    <para>If you want to use long ticket lifetimes (a week, for
	      example) and you are using <application>OpenSSH</application>
	      to connect to the machine where your ticket is stored, make
	      sure that <application>Kerberos</application>
	      <option>TicketCleanup</option> is set to <literal>no</literal>
	      in your <filename>sshd_config</filename> or else your tickets
	      will be deleted when you log out.</para>
	  </listitem>

	  <listitem>
	    <para>Remember that host principals can have a longer ticket
	      lifetime as well.  If your user principal has a lifetime of a
	      week but the host you are connecting to has a lifetime of nine
	      hours, you will have an expired host principal in your cache
	      and the ticket cache will not work as expected.</para>
	  </listitem>

	  <listitem>
	    <para>When setting up a <filename>krb5.dict</filename> file to
	    prevent specific bad passwords from being used (the manual page
	    for <command>kadmind</command> covers this briefly), remember
	    that it only applies to principals that have a password policy
	    assigned to them.  The <filename>krb5.dict</filename> files
	    format is simple: one string per line.  Creating a symbolic
	    link to <filename>/usr/share/dict/words</filename> might be
	    useful.</para>
	  </listitem>
        </itemizedlist>

      </sect2>

      <sect2>
	<title>Differences with the <acronym>MIT</acronym> port</title>

	<para>The major difference between the <acronym>MIT</acronym>
	  and Heimdal installs relates to the <command>kadmin</command>
	  program which has a different (but equivalent) set of commands
	  and uses a different protocol.  This has a large implications
	  if your <acronym>KDC</acronym> is <acronym>MIT</acronym> as you
	  will not be able to use the Heimdal <command>kadmin</command>
	  program to administer your <acronym>KDC</acronym> remotely
	  (or vice versa, for that matter).</para>

	<para>The client applications may also take slightly different
	  command line options to accomplish the same tasks.  Following
	  the instructions on the <acronym>MIT</acronym>
	  <application>Kerberos</application> web site
	  (<ulink url="http://web.mit.edu/Kerberos/www/"></ulink>)
	  is recommended. Be careful of path issues: the
	  <acronym>MIT</acronym> port installs into
	  <filename>/usr/local/</filename> by default, and the
	  <quote>normal</quote> system applications may be run instead
	  of <acronym>MIT</acronym> if your <envar>PATH</envar>
	  environment variable lists the system directories first.</para>

	<note><para>With the <acronym>MIT</acronym>
	  <filename role="package">security/krb5</filename> port
	  that is provided by &os;, be sure to read the
	  <filename>/usr/local/share/doc/krb5/README.FreeBSD</filename>
	  file installed by the port if you want to understand why logins
	  via <command>telnetd</command> and <command>klogind</command>
	  behave somewhat oddly.  Most importantly, correcting the
	  <quote>incorrect permissions on cache file</quote> behavior
	  requires that the <command>login.krb5</command> binary be used
	  for authentication so that it can properly change ownership for
	  the forwarded credentials.</para></note>

      </sect2>

      <sect2>
	<title>Mitigating limitations found in <application>Kerberos</application></title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>Limitations and Shortcomings</secondary>
	</indexterm>

	<sect3>
	 <title><application>Kerberos</application> is an all-or-nothing approach</title>

	  <para>Every service enabled on the network must be modified to
	    work with <application>Kerberos</application> (or be otherwise
	    secured against network attacks) or else the users credentials
	    could be stolen and re-used.  An example of this would be
	    <application>Kerberos</application> enabling all remote shells
	    (via <command>rsh</command> and <command>telnet</command>, for
	    example) but not converting the <acronym>POP3</acronym> mail
	    server which sends passwords in plaintext.</para>

	</sect3>

	<sect3>
	  <title><application>Kerberos</application> is intended for single-user workstations</title>

	  <para>In a multi-user environment,
	    <application>Kerberos</application> is less secure.
	    This is because it stores the tickets in the
	    <filename>/tmp</filename> directory, which is readable by all
	    users.  If a user is sharing a computer with several other
	    people simultaneously (i.e. multi-user), it is possible that
	    the user's tickets can be stolen (copied) by another
	    user.</para>

	  <para>This can be overcome with the <literal>-c</literal>
	    filename command-line option or (preferably) the
	    <envar>KRB5CCNAME</envar> environment variable, but this
	    is rarely done. In principal, storing the ticket in the users
	    home directory and using simple file permissions can mitigate
	    this problem.</para>

	</sect3>

	<sect3>
	  <title>The KDC is a single point of failure</title>

	  <para>By design, the <acronym>KDC</acronym> must be as secure as
	    the master password database is contained on it.  The
	    <acronym>KDC</acronym> should have absolutely no other
	    services running on it and should be physically secured.  The
	    danger is high because <application>Kerberos</application>
	    stores all passwords encrypted with the same key (the
	    <quote>master</quote> key), which in turn is stored as a file
	    on the <acronym>KDC</acronym>.</para>

	  <para>As a side note, a compromised master key is not quite as
	    bad as one might normally fear.  The master key is only used
	    to encrypt the <application>Kerberos</application> database
	    and as a seed for the random number generator.  As long as
	    access to your <acronym>KDC</acronym> is secure, an attacker
	    cannot do much with the master key.</para>

	  <para>Additionally, if the <acronym>KDC</acronym> is unavailable
	    (perhaps due to a denial of service attack or network problems)
	    the network services are unusable as authentication can not be
	    performed, a recipe for a denial-of-service attack.  This can
	    alleviated with multiple <acronym>KDC</acronym>s (a single
	    master and one or more slaves) and with careful implementation
	    of secondary or fall-back authentication
	    (<acronym>PAM</acronym> is excellent for this).</para>

	</sect3>

	<sect3>
	  <title><application>Kerberos</application> Shortcomings</title>

	  <para><application>Kerberos</application> allows users, hosts
	    and services to authenticate between themselves.  It does not
	    have a mechanism to authenticate the <acronym>KDC</acronym>
	    to the users, hosts or services.  This means that a trojanned
	    <command>kinit</command> (for example) could record all user
	    names and passwords.  Something like
	    <filename role="package">security/tripwire</filename> or
	    other file system integrity checking tools can alleviate
	    this.</para>

	</sect3>
      </sect2>

      <sect2>
	<title>Resources and further information</title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>External Resources</secondary>
	</indexterm>

	<itemizedlist>
	  <listitem>
	  <para><ulink
	    url="http://www.faqs.org/faqs/Kerberos-faq/general/preamble.html">
	    The Kerberos FAQ</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink url="http://web.mit.edu/Kerberos/www/dialogue.html">Designing
	    an Authentication System: a Dialogue in Four Scenes</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink url="http://www.ietf.org/rfc/rfc1510.txt?number=1510">RFC 1510,
	    The <application>Kerberos</application> Network Authentication Service
	    (V5)</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink url="http://web.mit.edu/Kerberos/www/"><acronym>MIT</acronym>
	    <application>Kerberos</application> home page</ulink></para>
	</listitem>

	<listitem>
	<para><ulink url="http://www.pdc.kth.se/heimdal/">Heimdal
	  <application>Kerberos</application> home page</ulink></para>
	</listitem>

	</itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="firewalls">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Gary</firstname>
	  <surname>Palmer</surname>
	  <contrib>Contribuição de </contrib>
	</author>
	<author>
	  <firstname>Alex</firstname>
	  <surname>Nash</surname>
	</author>
      </authorgroup>
    </sect1info>

    <title><foreignphrase>Firewalls</foreignphrase></title>
    <indexterm><primary>firewall</primary></indexterm>
    <indexterm>
      <primary>segurança</primary>
      <secondary>firewalls</secondary>
    </indexterm>

    <para>Firewalls are an area of increasing interest for people who are
      connected to the Internet, and are even finding applications on private
      networks to provide enhanced security.  This section will hopefully
      explain what firewalls are, how to use them, and how to use the
      facilities provided in the FreeBSD kernel to implement them.</para>

    <note>
      <para>People often think that having a firewall between your
	internal network and the <quote>Big Bad Internet</quote> will solve all
	your security problems.  It may help, but a poorly set up firewall
	system is more of a security risk than not having one at all.  A
	firewall can add another layer of security to your systems, but it
	cannot stop a really determined cracker from penetrating your internal
	network.  If you let internal security lapse because you believe your
	firewall to be impenetrable, you have just made the crackers job that
	much easier.</para>
    </note>

    <sect2>
      <title>What Is a Firewall?</title>
      
      <para>There are currently two distinct types of firewalls in common use
	on the Internet today.  The first type is more properly called a
	<emphasis>packet filtering router</emphasis>.  This type of
	firewall utilizes a multi-homed machine and a set of rules to
	determine whether to forward or block individual packets.  A
	multi-homed machine is simply a device with multiple network
	interfaces.
        The second type, known as a <emphasis>proxy
	  server</emphasis>, relies on daemons to provide authentication and to
	forward packets, possibly on a multi-homed machine which has kernel
	packet forwarding disabled.</para>
	  
      <para>Sometimes sites combine the two types of firewalls, so that only a
	certain machine (known as a <emphasis>bastion host</emphasis>) is
	allowed to send packets through a packet filtering router onto an
	internal network.  Proxy services are run on the bastion host, which
	are generally more secure than normal authentication
	mechanisms.</para>
	  
      <para>FreeBSD comes with a kernel packet filter (known as
	IPFW), which is what the rest of this
	section will concentrate on.  Proxy servers can be built on FreeBSD
	from third party software, but there is such a variety of proxy
	servers available that it would be impossible to cover them in this
	section.</para>
	  
      <sect3 id="firewalls-packet-filters">
	<title>Packet Filtering Routers</title>

	<para>A router is a machine which forwards packets between two or more
	  networks.  A packet filtering router is programmed to
	  compare each packet to a list of rules before
	  deciding if it should be forwarded or not.  Most modern IP routing
	  software includes packet filtering functionality that defaults to
	  forwarding all packets.  To enable the filters, you need to define a
	  set of rules.</para>
	    
	<para>To decide whether a packet should be passed on, the firewall looks
	  through its set of rules for a rule which matches the contents of
	  the packet's headers.  Once a match is found, the rule action is
	  obeyed.  The rule action could be to drop the packet, to forward the
	  packet, or even to send an ICMP message back to the originator.
	  Only the first match counts, as the rules are searched in order.
	  Hence, the list of rules can be referred to as a <quote>rule
	  chain</quote>.</para>
	    
	<para>The packet-matching criteria varies depending on the software
	  used, but typically you can specify rules which depend on the source
	  IP address of the packet, the destination IP address, the source
	  port number, the destination port number (for protocols which
	  support ports), or even the packet type (UDP, TCP, ICMP,
	  etc).</para>
      </sect3>
	  
      <sect3 id="firewalls-proxy-servers">
	<title>Proxy Servers</title>
	    
	<para>Proxy servers are machines which have had the normal system
	  daemons (<application>telnetd</application>, 
	  <application>ftpd</application>, etc) replaced with special servers.
	  These
	  servers are called <emphasis>proxy servers</emphasis>, as they
	  normally only allow onward connections to be made.  This enables you
	  to run (for example) a proxy <application>telnet</application> server on your firewall host,
	  and people can <application>telnet</application> in to your firewall from the outside, go
	  through some authentication mechanism, and then gain access to the
	  internal network (alternatively, proxy servers can be used for
	  signals coming from the internal network and heading out).</para>
	    
	<para>Proxy servers are normally more secure than normal servers, and
	  often have a wider variety of authentication mechanisms available,
	  including <quote>one-shot</quote> password systems so that even if
	  someone manages to discover what password you used, they will not be
	  able to use it to gain access to your systems as the password
	  expires immediately after the first use.  As they do not actually give users access to the
	  host machine, it becomes a lot more difficult for someone to install
	  backdoors around your security system.</para>
	    
	<para>Proxy servers often have ways of restricting access further, so
	  that only certain hosts can gain access to the servers.
          Most will also allow the administrator to specify which
	  users can talk to which destination machines.
          Again, what facilities are available
	  depends largely on what proxy software you choose.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>What Does IPFW Allow Me to Do?</title>
      <indexterm><primary><command>ipfw</command></primary></indexterm>
      
      <para>IPFW, the software supplied with
	FreeBSD, is a packet filtering and accounting system which resides in
	the kernel, and has a user-land control utility,
	    &man.ipfw.8;.  Together, they allow you to define and query the
	rules used by the kernel in its routing decisions.</para>
	  
      <para>There are two related parts to IPFW.
	The firewall section performs packet filtering.  There is
	also an IP accounting section which tracks usage of the
	router, based on rules similar to those used in the firewall
	section.  This allows
	the administrator to monitor how much traffic the router is
	getting from a certain machine, or how much WWW traffic it is
	forwarding, for example.</para>
	  
      <para>As a result of the way that IPFW is
	designed, you can use IPFW on non-router
	machines to perform packet filtering on incoming and outgoing
	connections.  This is a special case of the more general use of
	IPFW, and the same commands and techniques
	should be used in this situation.</para>
    </sect2>

    <sect2>
      <title>Enabling IPFW on FreeBSD</title>
      <indexterm>
        <primary><command>ipfw</command></primary>
        <secondary>enabling</secondary>
      </indexterm>
      
      <para>As the main part of the IPFW system
	lives in the kernel, you will need to add one or more options to your
	kernel configuration file, depending on what facilities you want, and
	recompile your kernel.  See "Reconfiguring your Kernel" (<xref
	linkend="kernelconfig">)
	for more details on how to recompile your
	kernel.</para>

      <warning>
	<para>IPFW defaults to a policy of <literal>deny ip from any to
	  any</literal>.  If you do not add other rules during startup to
	  allow access, <emphasis>you will lock yourself out</emphasis> of the
	  server upon rebooting into a firewall-enabled kernel.  We suggest
	  that you set <literal>firewall_type=open</literal> in your
	  <filename>/etc/rc.conf</filename> file when first enabling this
	  feature, then refining the firewall rules in
	  <filename>/etc/rc.firewall</filename> after you have tested that the
	  new kernel feature works properly.  To be on the safe side, you may
	  wish to consider performing the initial firewall configuration from
	  the local console rather than via
	  <application>ssh</application>.  Another option is to build a kernel
	  using both the <literal>IPFIREWALL</literal> and
	  <literal>IPFIREWALL_DEFAULT_TO_ACCEPT</literal> options.  This will
	  change the default rule of IPFW to <literal>allow ip from any to
	  any</literal> and avoid the possibility of a lockout.</para>
      </warning>

      <para>There are currently four kernel configuration options relevant to
	IPFW:</para>
	  
      <variablelist>
	<varlistentry>
	  <term><literal>options IPFIREWALL</literal></term>

	  <listitem>
	    <para>Compiles into the kernel the code for packet
	      filtering.</para>
	  </listitem>
	</varlistentry>
	      
	<varlistentry>
	  <term><literal>options IPFIREWALL_VERBOSE</literal></term>
		
	  <listitem>
	    <para>Enables code to allow logging of packets through
		&man.syslogd.8;.  Without this option, even if you specify
	      that packets should be logged in the filter rules, nothing will
	      happen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>options IPFIREWALL_VERBOSE_LIMIT=10</literal></term>
		
	  <listitem>
	    <para>Limits the number of packets logged through
		&man.syslogd.8; on a per entry basis.  You may wish to use
	      this option in hostile environments in which you want to log
	      firewall activity, but do not want to be open to a denial of
	      service attack via syslog flooding.</para>

	    <para>When a chain entry reaches the packet limit specified,
	      logging is turned off for that particular entry.  To resume
	      logging, you will need to reset the associated counter using the
		&man.ipfw.8; utility:</para>
	    
	    <screen>&prompt.root; <userinput>ipfw zero 4500</userinput></screen>
	    <para>Where 4500 is the chain entry you wish to continue
	      logging.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>options IPFIREWALL_DEFAULT_TO_ACCEPT</literal></term>

	  <listitem>
	    <para>This changes the default rule action from <quote>deny</quote>
	      to <quote>allow</quote>.  This avoids the possibility of locking
	      yourself out if you happen to boot a kernel with
	      <literal>IPFIREWALL</literal> support but have not configured
	      your firewall yet.  It is also very useful if you often use
	      &man.ipfw.8; as a filter for specific problems as they arise.
	      Use with care though, as this opens up the firewall and changes
	      the way it works.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
      
      <note><para>Previous versions of FreeBSD contained an
	<literal>IPFIREWALL_ACCT</literal>  option.  This is now obsolete as
	the firewall code automatically  includes accounting
	facilities.</para>
      </note>
    </sect2>

    <sect2>
      <title>Configuring IPFW</title>
      <indexterm>
        <primary><command>ipfw</command></primary>
        <secondary>configuring</secondary>
      </indexterm>
      
      <para>The configuration of the IPFW software
	is done through the &man.ipfw.8; utility.  The syntax for this
	command looks quite complicated, but it is relatively simple once you
	understand its structure.</para>

      <para>There are currently four different command categories used by the
	utility: addition/deletion, listing, flushing, and clearing.
	Addition/deletion is used to build the rules that control how packets
	are accepted, rejected, and logged.  Listing is used to examine the
	contents of your rule set (otherwise known as the chain) and packet
	counters (accounting).  Flushing is used to remove all entries from
	the chain.  Clearing is used to zero out one or more accounting
	entries.</para>
	  
      <sect3>
	<title>Altering the IPFW Rules</title>

	<para>The syntax for this form of the command is:
	  <cmdsynopsis>
	    <command>ipfw</command>
	    <arg>-N</arg>
	    <arg choice="plain">command</arg>
	    <arg>index</arg>
	    <arg choice="plain">action</arg>
	    <arg>log</arg>
	    <arg choice="plain">protocol</arg>
	    <arg choice="plain">addresses</arg>
	    <arg>options</arg>
	  </cmdsynopsis></para>

	<para>There is one valid flag when using this form of the
	  command:</para>

	<variablelist>
	  <varlistentry>
	    <term>-N</term>

	    <listitem>
	      <para>Resolve addresses and service names in output.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>The <emphasis>command</emphasis> given can be shortened to the
	  shortest unique form.  The valid <emphasis>commands</emphasis>
	  are:</para>
	    
	<variablelist>
	  <varlistentry>
	    <term>add</term>

	    <listitem>
	      <para>Add an entry to the firewall/accounting rule list</para>
	    </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term>delete</term>
	    
	    <listitem>
	      <para>Delete an entry from the firewall/accounting rule
		list</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>Previous versions of IPFW used
	  separate firewall and accounting entries.  The present version
	  provides packet accounting with each firewall entry.</para>
	    
	<para>If an <emphasis>index</emphasis> value is supplied, it is used to
	  place the entry at a specific point in the chain.  Otherwise, the
	  entry is placed at the end of the chain at an index 100 greater than
	  the last chain entry (this does not include the default policy, rule
	  65535, deny).</para>
	    
	<para>The <literal>log</literal> option causes matching rules to be
	  output to the system console if the kernel was compiled with
	  <literal>IPFIREWALL_VERBOSE</literal>.</para>
	    
	<para>Valid <emphasis>actions</emphasis> are:</para>
	    
	<variablelist>
	  <varlistentry>
	    <term>reject</term>

	    <listitem>
	      <para>Drop the packet, and send an ICMP host or port unreachable
		(as appropriate) packet to the source.</para>
	    </listitem>
	  </varlistentry>
		
	  <varlistentry>
	    <term>allow</term>
	    
	    <listitem>
	      <para>Pass the packet on as normal.  (aliases:
		<literal>pass</literal>, <literal>permit</literal>, and
		<literal>accept</literal>)</para>
	    </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term>deny</term>
	    
	    <listitem>
	      <para>Drop the packet.  The source is not notified via an
		ICMP message (thus it appears that the packet never
		arrived at the destination).</para>
	    </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term>count</term>
	    
	    <listitem>
	      <para>Update packet counters but do not allow/deny the packet
		based on this rule.  The search continues with the next chain
		entry.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>Each <emphasis>action</emphasis> will be recognized by the
	  shortest unambiguous prefix.</para>
	    
	<para>The <emphasis>protocols</emphasis> which can be specified
	  are:</para>
	    
	<variablelist>
	  <varlistentry>
	    <term>all</term>

	    <listitem>
	      <para>Matches any IP packet</para>
	    </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term>icmp</term>
	    
	    <listitem>
	      <para>Matches ICMP packets</para>
	    </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term>tcp</term>
	    
	    <listitem>
	      <para>Matches TCP packets</para>
	    </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term>udp</term>
	    
	    <listitem>
	      <para>Matches UDP packets</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>The <emphasis>address</emphasis> specification is:</para>

	<cmdsynopsis>
	  <arg choice="plain">from</arg>
	  <arg choice="plain"><replaceable>address/mask</replaceable></arg><arg><replaceable>port</replaceable></arg>
	  <arg choice="plain">to</arg>
	  <arg choice="plain"><replaceable>address/mask</replaceable></arg><arg><replaceable>port</replaceable></arg>
	  <arg>via <replaceable>interface</replaceable></arg>
	</cmdsynopsis>
	    
	<para>You can only specify <replaceable>port</replaceable> in
	  conjunction with <emphasis>protocols</emphasis> which support ports
	  (UDP and TCP).</para>
	    
	<para>The <option>via</option> is optional and may specify the IP
	  address or domain name of a local IP interface, or an interface name
	  (e.g.  <devicename>ed0</devicename>) to match only packets coming
	  through this interface.  Interface unit numbers can be specified
	  with an optional wildcard.  For example, <literal>ppp*</literal>
	  would match all kernel PPP interfaces.</para>
	    
	<para>The syntax used to specify an
	  <replaceable>address/mask</replaceable> is:
	  
	  <screen><replaceable>address</replaceable></screen>
	      
	  or
	      
	  <screen><replaceable>address</replaceable>/<replaceable>mask-bits</replaceable></screen>
	      
	  or
	      
	  <screen><replaceable>address</replaceable>:<replaceable>mask-pattern</replaceable></screen>
	</para>

	<para>A valid hostname may be specified in place of the IP address.
	  <option><replaceable>mask-bits</replaceable></option> is a decimal
	  number representing how many bits in the address mask should be set.
	  e.g.  specifying <hostid role="netmask">192.216.222.1/24</hostid>
	  will create a
	  mask which will allow any address in a class C subnet (in this case,
	  <hostid role="ipaddr">192.216.222</hostid>) to be matched.
	  <option><replaceable>mask-pattern</replaceable></option> is an IP
	  address which will be logically AND'ed with the address given.  The
	  keyword <literal>any</literal> may be used to specify <quote>any IP
	  address</quote>.</para>
	    
	<para>The port numbers to be blocked are specified as:
	  
	  <cmdsynopsis>
	    <arg choice="plain"><replaceable>port</replaceable><arg>,<replaceable>port</replaceable><arg>,<replaceable>port</replaceable><arg>&hellip;</arg></arg></arg></arg>
	  </cmdsynopsis>

	  to specify either a single port or a list of ports, or
	  
	  <cmdsynopsis>
	    <arg choice="plain"><replaceable>port</replaceable>-<replaceable>port</replaceable></arg>
	  </cmdsynopsis>

	  to specify a range of ports.  You may also combine a single range
	  with a list, but the range must always be specified first.</para>
	    
	<para>The <emphasis>options</emphasis> available are:</para>

	<variablelist>
	  <varlistentry>
	    <term>frag</term>

	    <listitem>
	      <para>Matches if the packet is not the first fragment of the
		datagram.</para>
	    </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term>in</term>
	    
	    <listitem>
	      <para>Matches if the packet is on the way in.</para>
	    </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term>out</term>
	    
	    <listitem>
	      <para>Matches if the packet is on the way out.</para>
	    </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term>ipoptions <replaceable>spec</replaceable></term>
	    
	    <listitem>
	      <para>Matches if the IP header contains the comma separated list
		of options specified in <replaceable>spec</replaceable>.  The
		supported IP options are: <literal>ssrr</literal>
		(strict source route), <literal>lsrr</literal> (loose source
		route), <literal>rr</literal> (record packet route), and
		<literal>ts</literal> (time stamp).  The absence of a
		particular option may be specified with a leading
		<literal>!</literal>.</para>
	    </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term>established</term>
	    
	    <listitem>
	      <para>Matches if the packet is part of an already established
		TCP connection (i.e. it has the RST or ACK bits set).  You can
		optimize the performance of the firewall by placing
		<emphasis>established</emphasis> rules early in the
		chain.</para>
	    </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term>setup</term>
	    
	    <listitem>
	      <para>Matches if the packet is an attempt to establish a TCP
		connection (the SYN bit is set but the ACK bit is
		not).</para>
	    </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term>tcpflags <replaceable>flags</replaceable></term>
	    
	    <listitem>
	      <para>Matches if the TCP header contains the comma separated
		list of <replaceable>flags</replaceable>.  The supported flags
		are <literal>fin</literal>, <literal>syn</literal>,
		<literal>rst</literal>, <literal>psh</literal>,
		<literal>ack</literal>, and <literal>urg</literal>.  The
		absence of a particular flag may be indicated by a leading
		<literal>!</literal>.</para>
	    </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term>icmptypes <replaceable>types</replaceable></term>
	    
	    <listitem>
	      <para>Matches if the ICMP type is present in the list
		<replaceable>types</replaceable>.  The list may be specified
		as any combination of ranges and/or individual types separated
		by commas.  Commonly used ICMP types are: <literal>0</literal>
		echo reply (ping reply), <literal>3</literal> destination
		unreachable, <literal>5</literal> redirect,
		<literal>8</literal> echo request (ping request), and
		<literal>11</literal> time exceeded (used to indicate TTL
		expiration as with &man.traceroute.8;).</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect3>
      
      <sect3>
	<title>Listing the IPFW Rules</title>

	<para>The syntax for this form of the command is:
	  <cmdsynopsis>
	    <command>ipfw</command>
	    <arg>-a</arg>
	    <arg>-c</arg>
	    <arg>-d</arg>
	    <arg>-e</arg>
	    <arg>-t</arg>
	    <arg>-N</arg>
	    <arg>-S</arg>
	    <arg choice="plain">list</arg>
	  </cmdsynopsis></para>

	<para>There are seven valid flags when using this form of the
	  command:</para>
	    
	<variablelist>
	  <varlistentry>
	    <term>-a</term>

	    <listitem>
	      <para>While listing, show counter values.  This option is the
		only way to see accounting counters.</para>
	    </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term>-c</term>

	    <listitem>
	      <para>List rules in compact form.</para>
	    </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term>-d</term>

	    <listitem>
	      <para>Show dynamic rules in addition to static rules.</para>
	    </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term>-e</term>

	    <listitem>
	      <para>If <option>-d</option> was specified, also show expired
		dynamic rules.</para>
	    </listitem>
	  </varlistentry>
	  
          <varlistentry>
	    <term>-t</term>
	    
	    <listitem>
	      <para>Display the last match times for each chain entry.  The
		time listing is incompatible with the input syntax used by the
		  &man.ipfw.8; utility.</para>
	    </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term>-N</term>
	    
	    <listitem>
	      <para>Attempt to resolve given addresses and service
		names.</para>
	    </listitem>
	  </varlistentry>
	  
          <varlistentry>
	    <term>-S</term>
	    
	    <listitem>
	      <para>Show the set each rule belongs to. If this flag is not
		specified, disabled rules will not be listed.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect3>
      
      <sect3>
	<title>Flushing the IPFW Rules</title>

	<para>The syntax for flushing the chain is:
	  <cmdsynopsis>
	    <command>ipfw</command>
	    <arg choice="plain">flush</arg>
	  </cmdsynopsis></para>

	<para>This causes all entries in the firewall chain to be removed
	  except the fixed default policy enforced by the kernel (index
	  65535).  Use caution when flushing rules; the default deny policy
	  will leave your system cut off from the network until allow entries
	  are added to the chain.</para>
      </sect3>
      
      <sect3>
	<title>Clearing the IPFW Packet Counters</title>

	<para>The syntax for clearing one or more packet counters is:
	  <cmdsynopsis>
	    <command>ipfw</command>
	    <arg choice="plain">zero</arg>
	    <arg choice="opt"><replaceable>index</replaceable></arg>
	  </cmdsynopsis></para>

	<para>When used without an <replaceable>index</replaceable> argument,
	  all packet counters are cleared.  If an
	  <replaceable>index</replaceable> is supplied, the clearing operation
	  only affects a specific chain entry.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Example Commands for <application>ipfw</application></title>
      
      <para>This command will deny all packets from the host <hostid
	  role="fqdn">evil.crackers.org</hostid> to the telnet port of the
	host <hostid role="fqdn">nice.people.org</hostid>:</para>
	  	  
      <screen>&prompt.root; <userinput>ipfw add deny tcp from evil.crackers.org to nice.people.org 23</userinput></screen>
	  
      <para>The next example denies and logs any TCP traffic from the entire
	<hostid role="domainname">crackers.org</hostid> network (a class C) to
	the <hostid role="fqdn">nice.people.org</hostid> machine (any
	port).</para>
	  
      <screen>&prompt.root; <userinput>ipfw add deny log tcp from evil.crackers.org/24 to nice.people.org</userinput></screen>
	  
      <para>If you do not want people sending X sessions to your internal
	network (a subnet of a class C), the following command will do the
	necessary filtering:</para>
	  
      <screen>&prompt.root; <userinput>ipfw add deny tcp from any to my.org/28 6000 setup</userinput></screen>
	  
      <para>To see the accounting records:
	    
	<screen>&prompt.root; <userinput>ipfw -a list</userinput></screen>

	or in the short form
	    
	<screen>&prompt.root; <userinput>ipfw -a l</userinput></screen>
      </para>

      <para>You can also see the last time a chain entry was matched
	with:</para>
      
      <screen>&prompt.root; <userinput>ipfw -at l</userinput></screen>
    </sect2>
    
    <sect2>
      <title>Building a Packet Filtering Firewall</title>
      
      <note>
	<para>The following suggestions are just that: suggestions.  The
	  requirements of each firewall are different and we cannot tell you
	  how to build a firewall to meet your particular requirements.</para>
      </note>
	  
      <para>When initially setting up your firewall, unless you have a test
	bench setup where you can configure your firewall host in a controlled
	environment, it is strongly recommend you use the logging version of the
	commands and enable logging in the kernel.  This will allow you to
	quickly identify problem areas and cure them without too much
	disruption.  Even after the initial setup phase is complete, I
	recommend using the logging for `deny' as it allows tracing of
	possible attacks and also modification of the firewall rules if your
	requirements alter.</para>
	  
      <note>
	<para>If you use the logging versions of the <command>accept</command>
	  command, be aware that it can generate
	  <emphasis>large</emphasis> amounts of log data.  One log
	  entry will be generated for every packet that passes 
          through the firewall, so large FTP/http transfers, etc, will really
	  slow the system down.  It also increases the latencies on those
	  packets as it requires more work to be done by the kernel before the
	  packet can be passed on.  <application>syslogd</application> will 
	  also start using up a lot
	  more processor time as it logs all the extra data to disk, and it
	  could quite easily fill the partition <filename>/var/log</filename>
	  is located on.</para>
      </note>
	  
      <para>You should enable your firewall from
	<filename>/etc/rc.conf.local</filename> or
	<filename>/etc/rc.conf</filename>.  The associated manual page explains
	which knobs to fiddle and lists some preset firewall configurations.
	If you do not use a preset configuration, <command>ipfw list</command>
	will output the current ruleset into a file that you can
	pass to <filename>rc.conf</filename>.  If you do not use
	<filename>/etc/rc.conf.local</filename> or
	<filename>/etc/rc.conf</filename> to enable your firewall,
	it is important to make sure your firewall is enabled before
	any IP interfaces are configured.</para>
	  
      <para>The next problem is what your firewall should actually
	<emphasis>do</emphasis>! This is largely dependent on what access to
	your network you want to allow from the outside, and how much access
	to the outside world you want to allow from the inside.  Some general
	rules are:</para>
      
      <itemizedlist>
	<listitem>
	  <para>Block all incoming access to ports below 1024 for TCP.  This is
	    where most of the security sensitive services are, like finger,
	    SMTP (mail) and telnet.</para>
	</listitem>

	<listitem>
	  <para>Block <emphasis>all</emphasis> incoming UDP traffic.  There
	    are very few useful services that travel over UDP, and what useful
	    traffic there is, is normally a security threat (e.g. Suns RPC and
	    NFS protocols).  This has its disadvantages also, since UDP is a
	    connectionless protocol, denying incoming UDP traffic also blocks
	    the replies to outgoing UDP traffic.  This can cause a problem for
	    people (on the inside) using external archie (prospero) servers.
	    If you want to allow access to archie, you will have to allow
	    packets coming from ports 191 and 1525 to any internal UDP port
	    through the firewall.  <application>ntp</application> is another
	    service you may consider allowing through, which comes from port
	    123.</para>
	</listitem>
	      
	<listitem>
	  <para>Block traffic to port 6000 from the outside.  Port 6000 is the
	    port used for access to X11 servers, and can be a security threat
	    (especially if people are in the habit of doing <command>xhost
	      +</command> on their workstations).  X11 can actually use a
	    range of ports starting at 6000, the upper limit being how many X
	    displays you can run on the machine.  The upper limit as defined
	    by RFC 1700 (Assigned Numbers) is 6063.</para>
	</listitem>
	      
	<listitem>
	  <para>Check what ports any internal servers use (e.g. SQL servers,
	    etc).  It is probably a good idea to block those as well, as they
	    normally fall outside the 1-1024 range specified above.</para>
	</listitem>
      </itemizedlist>
	  
      <para>Another checklist for firewall configuration is available from
	CERT at <ulink
	  url="http://www.cert.org/tech_tips/packet_filtering.html"></ulink></para>
	  
      <para>As stated above, these are only <emphasis>guidelines</emphasis>.
	You will have to decide what filter rules you want to use on your
	firewall yourself.  We cannot accept ANY responsibility if someone
	breaks into your network, even if you follow the advice given
	above.</para>
    </sect2>

    <sect2 id="ipfw-overhead">
      <title>IPFW Overhead and Optimization</title>

      <para>Many people want to know how much overhead IPFW adds to a
	system.  The answer to this depends mostly on your rule set and
	processor speed.  For most applications dealing with Ethernet
	and small rule sets, the answer is
	<quote>negligible</quote>.  For those of you that need actual
	measurements to satisfy your curiosity, read on.</para>

      <para>The following measurements were made using 2.2.5-STABLE on
	a 486-66.  (While IPFW has changed slightly in later releases
	of FreeBSD, it still performs with similar speed.) IPFW was
	modified to measure the time spent within the
	<literal>ip_fw_chk</literal> routine, displaying the results
	to the console every 1000 packets.</para>

      <para>Two rule sets, each with 1000 rules, were tested.  The
	first set was designed to demonstrate a worst case scenario by
	repeating the rule:</para>

      <screen>&prompt.root; <userinput>ipfw add deny tcp from any to any 55555</userinput></screen>

      <para>This demonstrates a worst case scenario by causing most of IPFW's
	packet check routine to be executed before finally deciding
	that the packet does not match the rule (by virtue of the port
	number).  Following the 999th iteration of this rule was an
	<literal>allow ip from any to any</literal>.</para>

      <para>The second set of rules were designed to abort the rule
	check quickly:</para>

      <screen>&prompt.root; <userinput>ipfw add deny ip from 1.2.3.4 to 1.2.3.4</userinput></screen>

      <para>The non-matching source IP address for the above rule
	causes these rules to be skipped very quickly.  As before, the
	1000th rule was an <literal>allow ip from any to
	any</literal>.</para>

      <para>The per-packet processing overhead in the former case was
	approximately 2.703&nbsp;ms/packet, or roughly 2.7&nbsp;microseconds per
	rule.  Thus the theoretical packet processing limit with these
	rules is around 370&nbsp;packets per second.  Assuming 10&nbsp;Mbps
	Ethernet and a ~1500&nbsp;byte packet size, we would only be able
	to achieve 55.5% bandwidth utilization.</para>

      <para>For the latter case each packet was processed in
	approximately 1.172&nbsp;ms, or roughly 1.2&nbsp;microseconds per rule.
	The theoretical packet processing limit here would be about
	853&nbsp;packets per second, which could consume 10&nbsp;Mbps Ethernet
	bandwidth.</para>

      <para>The excessive number of rules tested and the nature of
	those rules do not provide a real-world scenario -- they were
	used only to generate the timing information presented here.
	Here are a few things to keep in mind when building an
	efficient rule set:</para>

      <itemizedlist>
	<listitem>
	  <para>Place an <literal>established</literal> rule early on
	    to handle the majority of TCP traffic.  Do not put any
	    <literal>allow tcp</literal> statements before this
	    rule.</para>
	</listitem>

	<listitem>
	  <para>Place heavily triggered rules earlier in the rule set
	    than those rarely used (<emphasis>without changing the
	    permissiveness of the firewall</emphasis>, of course).
	    You can see which rules are used most often by examining
	    the packet counting statistics with <command>ipfw -a
	    l</command>.</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="openssl">
    <title>OpenSSL</title>
    <indexterm>
      <primary>segurança</primary>
      <secondary>OpenSSL</secondary>
    </indexterm>
    <indexterm><primary>OpenSSL</primary></indexterm>

    <para>As of FreeBSD&nbsp;4.0, the OpenSSL toolkit is a part of the base
      system.  <ulink url="http://www.openssl.org/">OpenSSL</ulink>
      provides a general-purpose cryptography library, as well as the
      Secure Sockets Layer v2/v3 (SSLv2/SSLv3) and Transport Layer
      Security v1 (TLSv1) network security protocols.</para>

    <para>However, one of the algorithms (specifically IDEA)
      included in OpenSSL is protected by patents in the USA and
      elsewhere, and is not available for unrestricted use.
      IDEA is included in the OpenSSL sources in FreeBSD, but it is not
      built by default.  If you wish to use it, and you comply with the
      license terms, enable the <makevar>MAKE_IDEA</makevar> switch in
      <filename>/etc/make.conf</filename> and
      rebuild your sources using <command>make world</command>.</para>

    <para>Today, the RSA algorithm is free for use in USA and other
      countries.  In the past it was protected by a patent.</para>

    <indexterm>
      <primary>OpenSSL</primary>
      <secondary>install</secondary>
    </indexterm>

    <sect2>
      <title>Source Code Installations</title>
      
      <para>OpenSSL is part of the <literal>src-crypto</literal> and
	<literal>src-secure</literal> <application>CVSup</application> collections.  See the <link
	linkend="mirrors">Obtaining FreeBSD</link> section for more
	information about obtaining and updating FreeBSD source
	code.</para>
    </sect2>
  </sect1>

  <sect1 id="ipsec">
    <sect1info>
      <authorgroup>
        <author>
  	  <firstname>Nik</firstname>
	  <surname>Clayton</surname>
	  <affiliation>
	    <address><email>nik@FreeBSD.org</email></address>
          </affiliation>
          <contrib>Escrito por </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>VPN sobre IPsec</title>
    <para>Criando uma VPN entre duas redes, separadas pela internet, 
      usando <foreignphrase>gateways</foreignphrase> FreeBSD.</para>
 
    <sect2>
      <sect2info>
        <authorgroup>
          <author>
            <firstname>Hiten M.</firstname>
            <surname>Pandya</surname>
	    <affiliation>
	      <address><email>hmp@FreeBSD.org</email></address>
	    </affiliation>
	    <contrib>Written by </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Understanding IPsec</title>

      <para>This section will guide you through the process of setting
	up IPsec, and to use it in an environment which consists of
	FreeBSD and <application>&microsoft.windows; 2000/XP</application>
	machines, to make them communicate securely.  In order to set up
	IPsec, it is necessary that you are familiar with the concepts
	of building a custom kernel (see
	<xref linkend="kernelconfig">).</para>
    
      <para><emphasis>IPsec</emphasis> is a protocol which sits on top
	of the Internet Protocol (IP) layer.  It allows two or more
	hosts to communicate in a secure manner (hence the name).  The
	FreeBSD IPsec <quote>network stack</quote> is based on the
	<ulink url="http://www.kame.net/">KAME</ulink> implementation,
	which has support for both protocol families, IPv4 and
	IPv6.</para>

      <note>
        <para>FreeBSD 5.X contains a <quote>hardware
        accelerated</quote> IPsec stack, known as <quote>Fast
        IPsec</quote>, that was obtained from OpenBSD.  It employs
        cryptographic hardware (whenever possible) via the
        &man.crypto.4; subsystem to optimize the performance of IPsec.
        This subsystem is new, and does not support all the features
        that are available in the KAME version of IPsec.  However, in
        order to enable hardware-accelerated IPsec, the following
        kernel option has to be added to your kernel configuration
        file:</para>

        <screen>
options	  FAST_IPSEC  # new IPsec (cannot define w/ IPSEC)
        </screen>

        <para> Note, that it is not currently possible to use the
	  <quote>Fast IPsec</quote> subsystem in lue with the KAME
	  implementation of IPsec.  Consult the &man.fast.ipsec.4;
	  manual page for more information.</para>

      </note>
  
      <para>IPsec consists of two sub-protocols:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Encapsulated Security Payload
	      (ESP)</emphasis>, protects the IP packet data from third
	    party interference, by encrypting the contents using
	    symmetric cryptography algorithms (like Blowfish,
	    3DES).</para>
        </listitem>
        <listitem>
          <para><emphasis>Authentication Header (AH)</emphasis>,
	    protects the IP packet header from third party interference
	    and spoofing, by computing a cryptographic checksum and
	    hashing the IP packet header fields with a secure hashing
	    function.  This is then followed by an additional header
	    that contains the hash, to allow the information in the
	    packet to be authenticated.</para>
        </listitem>
      </itemizedlist>
      
      <para><acronym>ESP</acronym> and <acronym>AH</acronym> can
	either be used together or separately, depending on the
	environment.</para>
      
      <para>IPsec can either be used to directly encrypt the traffic
	between two hosts (known as <emphasis>Transport
	  Mode</emphasis>); or to build <quote>virtual tunnels</quote>
	between two subnets, which could be used for secure
	communication between two corporate networks (known as
	<emphasis>Tunnel Mode</emphasis>).  The latter is more commonly
	known as a <emphasis>Virtual Private Network (VPN)</emphasis>.
	The &man.ipsec.4; manual page should be consulted for detailed
	information on the IPsec subsystem in FreeBSD.</para>
      
      <para>To add IPsec support to your kernel, add the following
	options to your kernel configuration file:</para>
      
      <screen>
options   IPSEC        #IP security
options   IPSEC_ESP    #IP security (crypto; define w/ IPSEC)
      </screen>

      <para>If IPsec debugging support is desired, the following
	kernel option should also be added:</para>

      <screen>
options   IPSEC_DEBUG  #debug for IP security
      </screen>
    </sect2>

    <sect2>
      <title>The Problem</title>
 
      <para>There's no standard for what constitutes a VPN.  VPNs can
	be implemented using a number of different technologies, each of
	which have their own strengths and weaknesses.  This article
	presents a number of scenarios, and strategies for implementing a
	VPN for each scenario.</para>
    </sect2>
    
    <sect2> 
      <title>Scenario #1: Two networks, connected to the Internet, to
        behave as one</title>
      
      <para>This is the scenario that caused me to first investigating
        VPNs.  The premise is as follows:</para>
      
      <itemizedlist>
        <listitem>
          <para>You have at least two sites</para>
        </listitem>
        <listitem>
          <para>Both sites are using IP internally</para>
        </listitem>
        <listitem>
          <para>Both sites are connected to the Internet, through a
            gateway that is running FreeBSD.</para>
        </listitem>
        <listitem>
          <para>The gateway on each network has at least one public IP
            address.</para>
        </listitem>
        <listitem>
          <para>The internal addresses of the two networks can be
            public or private IP addresses, it doesn't matter.  You can
            be running NAT on the gateway machine if necessary.</para>
        </listitem>
        <listitem>
          <para>The internal IP addresses of the two networks
            <emphasis>do not collide</emphasis>.  While I expect it is
            theoretically possible to use a combination of VPN
            technology and NAT to get this to work, I expect it to be a
            configuration nightmare.</para>
        </listitem>
      </itemizedlist>
      
      <para>If you find that you are trying to connect two networks,
        both of which, internally, use the same private IP address range
        (e.g., both of them use <hostid
        role="ipaddr">192.168.1.x</hostid>), then one of the networks will
        have to be renumbered.</para>
 
      <para>The network topology might look something like this:</para>
 
      <mediaobject>
	<imageobject>
	  <imagedata fileref="security/ipsec-network" align="center">
	</imageobject>

	<textobject>
<literallayout class="monospaced">Network #1            [ Internal Hosts ]    Private Net, 192.168.1.2-254
                      [   Win9x/NT/2K  ]
                      [      UNIX      ]
                               |
                               |
                        .---[fxp1]---.      Private IP, 192.168.1.1
                        |   FreeBSD  |
                        `---[fxp0]---'      Public IP, A.B.C.D
                               |
                               |
                      -=-=- Internet -=-=-
                               |
                               |
                        .---[fxp0]---.      Public IP, W.X.Y.Z
                        |   FreeBSD  |
                        `---[fxp1]---'      Private IP, 192.168.2.1
                               |
                               |
Network #2            [ Internal Hosts ]
                      [   Win9x/NT/2K  ]    Private Net, 192.168.2.2-254
                      [      UNIX      ]</literallayout>
	</textobject>
      </mediaobject>
 
      <para>Notice the two public IP addresses.  I'll use the letters to
        refer to them in the rest of this article.  Anywhere you see those
        letters in this article, replace them with your own public IP
        addresses.  Note also that that internally, the two gateway
        machines have .1 IP addresses, and that the two networks have
        different private IP address (<hostid
        role="ipaddr">192.168.1.x</hostid> and <hostid
        role="ipaddr">192.168.2.x</hostid> respectively).  All the
        machines on the private networks have been configured to use the
        <hostid role="ipaddr">.1</hostid> machine as their default
        gateway.</para>
 
      <para>The intention is that, from a network point of view, each
        network should view the machines on the other network as though
        they were directly attached the same router -- albeit a slightly
        slow router with an occasional tendency to drop packets.</para>
 
      <para>This means that (for example), machine <hostid
        role="ipaddr">192.168.1.20</hostid> should be able to run</para>
 
      <programlisting>ping 192.168.2.34</programlisting>
 
      <para>and have it work, transparently.  &windows; machines should
        be able to see the machines on the other network, browse file
        shares, and so on, in exactly the same way that they can browse
        machines on the local network.</para>
 
      <para>And the whole thing has to be secure.  This means that
        traffic between the two networks has to be encrypted.</para>
 
      <para>Creating a VPN between these two networks is a multi-step
        process.  The stages are as follows:</para>
 
      <orderedlist>
        <listitem>
          <para>Create a <quote>virtual</quote> network link between the two
            networks, across the Internet.  Test it, using tools like
            &man.ping.8;, to make sure it works.</para>
        </listitem>
 
        <listitem>
          <para>Apply security policies to ensure that traffic between
            the two networks is transparently encrypted and decrypted as
            necessary.  Test this, using tools like &man.tcpdump.1;, to
            ensure that traffic is encrypted.</para>
        </listitem>

        <listitem>
          <para>Configure additional software on the FreeBSD gateways,
            to allow &windows; machines to see one another across the
            VPN.</para>
        </listitem>
      </orderedlist>

    <sect3>
      <title>Step 1: Creating and testing a <quote>virtual</quote>
        network link</title>
 
      <para>Suppose that you were logged in to the gateway machine on
        network #1 (with public IP address <hostid
        role="ipaddr">A.B.C.D</hostid>, private IP address <hostid
        role="ipaddr">192.168.1.1</hostid>), and you ran <command>ping
        192.168.2.1</command>, which is the private address of the machine
        with IP address <hostid role="ipaddr">W.X.Y.Z</hostid>.  What
        needs to happen in order for this to work?</para>

      <orderedlist>
        <listitem>
          <para>The gateway machine needs to know how to reach <hostid
            role="ipaddr">192.168.2.1</hostid>.  In other words, it needs
            to have a route to <hostid
            role="ipaddr">192.168.2.1</hostid>.</para>
        </listitem>
        <listitem>
          <para>Private IP addresses, such as those in the <hostid
            role="ipaddr">192.168.x</hostid> range are not supposed to
            appear on the Internet at large.  Instead, each packet you
            send to <hostid role="ipaddr">192.168.2.1</hostid> will need
            to be wrapped up inside another packet.  This packet will need
            to appear to be from <hostid role="ipaddr">A.B.C.D</hostid>,
            and it will have to be sent to <hostid
            role="ipaddr">W.X.Y.Z</hostid>.  This process is called
            <firstterm>encapsulation</firstterm>.</para>
        </listitem>
        <listitem>
          <para>Once this packet arrives at <hostid
            role="ipaddr">W.X.Y.Z</hostid> it will need to
            <quote>unencapsulated</quote>, and delivered to <hostid
            role="ipaddr">192.168.2.1</hostid>.</para>
	</listitem>
      </orderedlist>
 
      <para>You can think of this as requiring a <quote>tunnel</quote>
        between the two networks.  The two <quote>tunnel mouths</quote> are the IP
        addresses <hostid role="ipaddr">A.B.C.D</hostid> and <hostid
        role="ipaddr">W.X.Y.Z</hostid>, and the tunnel must be told the
        addresses of the private IP addresses that will be allowed to pass
        through it.  The tunnel is used to transfer traffic with private
        IP addresses across the public Internet.</para>
 
      <para>This tunnel is created by using the generic interface, or
        <devicename>gif</devicename> devices on FreeBSD.  As you can
        imagine, the <devicename>gif</devicename> interface on each
        gateway host must be configured with four IP addresses; two for
        the public IP addresses, and two for the private IP
        addresses.</para>
 
      <para>Support for the gif device must be compiled in to the
        FreeBSD kernel on both machines.  You can do this by adding the
        line:</para>
 
      <programlisting>pseudo-device gif</programlisting>
 
      <para>to the kernel configuration files on both machines, and
        then compile, install, and reboot as normal.</para>
 
      <para>Configuring the tunnel is a two step process.  First the
        tunnel must be told what the outside (or public) IP addresses
        are, using &man.gifconfig.8;.  Then the private IP addresses must be
        configured using &man.ifconfig.8;.</para>
 
      <para>On the gateway machine on network #1 you would run the
        following two commands to configure the tunnel.</para>
 
      <programlisting>gifconfig gif0 A.B.C.D W.X.Y.Z
ifconfig gif0 inet 192.168.1.1 192.168.2.1 netmask 0xffffffff
      </programlisting>
 
      <para>On the other gateway machine you run the same commands,
        but with the order of the IP addresses reversed.</para>
 
      <programlisting>gifconfig gif0 W.X.Y.Z A.B.C.D
ifconfig gif0 inet 192.168.2.1 192.168.1.1 netmask 0xffffffff
      </programlisting>
 
      <para>You can then run:</para>
 
      <programlisting>gifconfig gif0</programlisting>
 
      <para>to see the configuration.  For example, on the network #1
        gateway, you would see this:</para>
 
      <screen>&prompt.root; <userinput>gifconfig gif0</userinput>
gif0: flags=8011&lt;UP,POINTTOPOINT,MULTICAST&gt; mtu 1280
inet 192.168.1.1 --&gt; 192.168.2.1 netmask 0xffffffff
physical address inet A.B.C.D --&gt; W.X.Y.Z
      </screen>
 
      <para>As you can see, a tunnel has been created between the
        physical addresses <hostid role="ipaddr">A.B.C.D</hostid> and
        <hostid role="ipaddr">W.X.Y.Z</hostid>, and the traffic allowed
        through the tunnel is that between <hostid
        role="ipaddr">192.168.1.1</hostid> and <hostid
        role="ipaddr">192.168.2.1</hostid>.</para>
 
      <para>This will also have added an entry to the routing table
        on both machines, which you can examine with the command <command>netstat -rn</command>.
        This output is from the gateway host on network #1.</para>
 
      <screen>&prompt.root; <userinput>netstat -rn</userinput>
Routing tables
 
Internet:
Destination      Gateway       Flags    Refs    Use    Netif  Expire
...
192.168.2.1      192.168.1.1   UH        0        0    gif0
...
      </screen>
 
      <para>As the <quote>Flags</quote> value indicates, this is a
        host route, which means that each gateway knows how to reach the
        other gateway, but they do not know how to reach the rest of
        their respective networks.  That problem will be fixed
        shortly.</para>
 
      <para>It is likely that you are running a firewall on both
        machines.  This will need to be circumvented for your VPN
        traffic.  You might want to allow all traffic between both
        networks, or you might want to include firewall rules that
        protect both ends of the VPN from one another.</para>
 
      <para>It greatly simplifies testing if you configure the
        firewall to allow all traffic through the VPN.  You can always
        tighten things up later.  If you are using &man.ipfw.8; on the
        gateway machines then a command like</para>

      <programlisting>ipfw add 1 allow ip from any to any via gif0</programlisting>
 
      <para>will allow all traffic between the two end points of the
        VPN, without affecting your other firewall rules.  Obviously
        you will need to run this command on both gateway hosts.</para>
 
      <para>This is sufficient to allow each gateway machine to ping
        the other.  On <hostid role="ipaddr">192.168.1.1</hostid>, you
        should be able to run</para>
 
      <programlisting>ping 192.168.2.1</programlisting>
 
      <para>and get a response, and you should be able to do the same
        thing on the other gateway machine.</para>
 
      <para>However, you will not be able to reach internal machines
        on either network yet.  This is because of the routing --
        although the gateway machines know how to reach one another,
        they do not know how to reach the network behind each one.</para>
 
      <para>To solve this problem you must add a static route on each
        gateway machine.  The command to do this on the first gateway
        would be:</para>
 
      <programlisting>route add 192.168.2.0 192.168.2.1 netmask 0xffffff00
      </programlisting>
 
      <para>This says <quote>In order to reach the hosts on the
        network <hostid role="ipaddr">192.168.2.0</hostid>, send the
        packets to the host <hostid
        role="ipaddr">192.168.2.1</hostid></quote>.  You will need to
        run a similar command on the other gateway, but with the
        <hostid role="ipaddr">192.168.1.x</hostid> addresses
        instead.</para>
 
      <para>IP traffic from hosts on one network will now be able to
        reach hosts on the other network.</para>
 
      <para>That has now created two thirds of a VPN between the two
        networks, in as much as it is <quote>virtual</quote> and it is a
        <quote>network</quote>.  It is not private yet.  You can test
        this using &man.ping.8; and &man.tcpdump.1;.  Log in to the
        gateway host and run</para>
 
      <programlisting>tcpdump dst host 192.168.2.1</programlisting>

      <para>In another log in session on the same host run</para>

      <programlisting>ping 192.168.2.1</programlisting>
 
      <para>You will see output that looks something like this:</para>
 
      <programlisting>
16:10:24.018080 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:24.018109 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply
16:10:25.018814 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:25.018847 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply
16:10:26.028896 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:26.029112 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply
      </programlisting>
 
      <para>As you can see, the ICMP messages are going back and forth
        unencrypted.  If you had used the <option>-s</option> parameter to
        &man.tcpdump.1; to grab more bytes of data from the packets you
        would see more information.</para>
 
      <para>Obviously this is unacceptable.  The next section will
        discuss securing the link between the two networks so that it
        all traffic is automatically encrypted.</para>
 
      <itemizedlist>
        <title>Summary:</title>
        <listitem>
          <para>Configure both kernels with <quote>pseudo-device
          gif</quote>.</para>
        </listitem>
        <listitem>
          <para>Edit <filename>/etc/rc.conf</filename> on gateway host
            #1 and add the following lines (replacing IP addresses as
            necessary).</para>
          <programlisting>gifconfig_gif0="A.B.C.D W.X.Y.Z"
ifconfig_gif0="inet 192.168.1.1 192.168.2.1 netmask 0xffffffff"
static_routes="vpn"
route_vpn="192.168.2.0 192.168.2.1 netmask 0xffffff00"
          </programlisting>
        </listitem>

        <listitem>
          <para>Edit your firewall script
          (<filename>/etc/rc.firewall</filename>, or similar) on both
          hosts, and add</para>

          <programlisting>ipfw add 1 allow ip from any to any via gif0</programlisting>
        </listitem>
        <listitem>
          <para>Make similar changes to
            <filename>/etc/rc.conf</filename> on gateway host #2,
            reversing the order of IP addresses.</para>
        </listitem>
      </itemizedlist>
    </sect3>

    <sect3>
      <title>Step 2: Securing the link</title>
 
      <para>To secure the link we will be using IPsec.  IPsec provides
        a mechanism for two hosts to agree on an encryption key, and to
        then use this key in order to encrypt data between the two
        hosts.</para>
 
      <para>The are two areas of configuration to be considered here.</para>
 
      <orderedlist>
        <listitem>
          <para>There must be a mechanism for two hosts to agree on the
            encryption mechanism to use.  Once two hosts have agreed on
            this mechanism there is said to be a <quote>security association</quote>
            between them.</para>
        </listitem>
        <listitem>
          <para>There must be a mechanism for specifying which traffic
            should be encrypted.  Obviously, you don't want to encrypt
            all your outgoing traffic -- you only want to encrypt the
            traffic that is part of the VPN.  The rules that you put in
            place to determine what traffic will be encrypted are called
            <quote>security policies</quote>.</para>
         </listitem>
       </orderedlist>
 
       <para>Security associations and security policies are both
         maintained by the kernel, and can be modified by userland
         programs.  However, before you can do this you must configure the
         kernel to support IPsec and the Encapsulated Security Payload
         (ESP) protocol.  This is done by configuring a kernel with:</para>
 
       <programlisting>options IPSEC
options IPSEC_ESP
       </programlisting>
 
       <para>and recompiling, reinstalling, and rebooting.  As before
         you will need to do this to the kernels on both of the gateway
         hosts.</para>
 
       <para>You have two choices when it comes to setting up security
         associations.  You can configure them by hand between two hosts,
         which entails choosing the encryption algorithm, encryption keys,
         and so forth, or you can use daemons that implement the Internet
         Key Exchange protocol (IKE) to do this for you.</para>
 
       <para>I recommend the latter.  Apart from anything else, it is
         easier to set up.</para>
 
       <para>Editing and displaying security policies is carried out
         using &man.setkey.8;.  By analogy, <command>setkey</command> is
         to the kernel's security policy tables as &man.route.8; is to
         the kernel's routing tables.  <command>setkey</command> can
         also display the current security associations, and to continue
         the analogy further, is akin to <command>netstat -r</command>
         in that respect.</para>
 
       <para>There are a number of choices for daemons to manage
         security associations with FreeBSD.  This article will describe
         how to use one of these, racoon.  racoon is in the FreeBSD ports
         collection, in the security/ category, and is installed in the
         usual way.</para>
 
       <para>racoon must be run on both gateway hosts.  On each host it
         is configured with the IP address of the other end of the VPN,
         and a secret key (which you choose, and must be the same on both
         gateways).</para>
 
       <para>The two daemons then contact one another, confirm that they
         are who they say they are (by using the secret key that you
         configured).  The daemons then generate a new secret key, and use
         this to encrypt the traffic over the VPN.  They periodically
         change this secret, so that even if an attacker were to crack one
         of the keys (which is as theoretically close to unfeasible as it
         gets) it won't do them much good -- by the time they've cracked
         the key the two daemons have chosen another one.</para>
 
       <para>racoon's configuration is stored in
         <filename>${PREFIX}/etc/racoon</filename>.  You should find a
         configuration file there, which should not need to be changed
         too much.  The other component of racoon's configuration,
         which you will need to change, is the <quote>pre-shared
         key</quote>.</para>
 
       <para>The default racoon configuration expects to find this in
         the file <filename>${PREFIX}/etc/racoon/psk.txt</filename>.  It is important to note
         that the pre-shared key is <emphasis>not</emphasis> the key that will be used to
         encrypt your traffic across the VPN link, it is simply a token
         that allows the key management daemons to trust one another.</para>

       <para><filename>psk.txt</filename> contains a line for each
         remote site you are dealing with.  In this example, where there
         are two sites, each <filename>psk.txt</filename> file will contain one line (because
         each end of the VPN is only dealing with one other end).</para>
 
       <para>On gateway host #1 this line should look like this:</para>
 
       <programlisting>W.X.Y.Z            secret</programlisting>
 
       <para>That is, the <emphasis>public</emphasis> IP address of the remote end,
         whitespace, and a text string that provides the secret.
         Obviously, you shouldn't use <quote>secret</quote> as your key -- the normal
         rules for choosing a password apply.</para>
 
       <para>On gateway host #2 the line would look like this</para>
 
       <programlisting>A.B.C.D            secret</programlisting>
 
       <para>That is, the public IP address of the remote end, and the
         same secret key.  <filename>psk.txt</filename> must be mode
         <literal>0600</literal> (i.e., only read/write to
         <username>root</username>) before racoon will run.</para>
 
       <para>You must run racoon on both gateway machines.  You will
         also need to add some firewall rules to allow the IKE traffic,
         which is carried over UDP to the ISAKMP (Internet Security Association
         Key Management Protocol) port.  Again, this should be fairly early in
         your firewall ruleset.</para>
 
       <programlisting>ipfw add 1 allow udp from A.B.C.D to W.X.Y.Z isakmp
ipfw add 1 allow udp from W.X.Y.Z to A.B.C.D isakmp
       </programlisting>
 
       <para>Once racoon is running you can try pinging one gateway host
         from the other.  The connection is still not encrypted, but
         racoon will then set up the security associations between the two
         hosts -- this might take a moment, and you may see this as a
         short delay before the ping commands start responding.</para>
 
       <para>Once the security association has been set up you can
         view it using &man.setkey.8;.  Run</para>
 
       <programlisting>setkey -D</programlisting>
 
       <para>on either host to view the security association information.</para>
 
       <para>That's one half of the problem.  They other half is setting
         your security policies.</para>
 
       <para>To create a sensible security policy, let's review what's
         been set up so far.  This discussions hold for both ends of the
         link.</para>
 
       <para>Each IP packet that you send out has a header that contains
         data about the packet.  The header includes the IP addresses of
         both the source and destination.  As we already know, private IP
         addresses, such as the <hostid role="ipaddr">192.168.x.y</hostid>
         range are not supposed to appear on the public Internet.
         Instead, they must first be encapsulated inside another packet.
         This packet must have the public source and destination IP
         addresses substituted for the private addresses.</para>
 
       <para>So if your outgoing packet started looking like this:</para>
 
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="security/ipsec-out-pkt" align="center">
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">
  .----------------------.
  | Src: 192.168.1.1     |
  | Dst: 192.168.2.1     |
  | &lt;other header info&gt;  |
  +----------------------+
  | &lt;packet data&gt;        |
  `----------------------'</literallayout>
	  </textobject>
	</mediaobject>
 
       <para>Then it will be encapsulated inside another packet, looking
         something like this:</para>
 
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="security/ipsec-encap-pkt" align="center">
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">
  .--------------------------.
  | Src: A.B.C.D             |
  | Dst: W.X.Y.Z             |
  | &lt;other header info&gt;      |
  +--------------------------+
  | .----------------------. |
  | | Src: 192.168.1.1     | |
  | | Dst: 192.168.2.1     | |
  | | &lt;other header info&gt;  | |
  | +----------------------+ |
  | | &lt;packet data&gt;        | |
  | `----------------------' |
  `--------------------------'</literallayout>
	  </textobject>
	</mediaobject>
 
       <para>This encapsulation is carried out by the
         <devicename>gif</devicename> device.  As
         you can see, the packet now has real IP addresses on the outside,
         and our original packet has been wrapped up as data inside the
         packet that will be put out on the Internet.</para>
 
       <para>Obviously, we want all traffic between the VPNs to be
         encrypted.  You might try putting this in to words, as:</para>

       <para><quote>If a packet leaves from <hostid
         role="ipaddr">A.B.C.D</hostid>, and it is destined for <hostid
         role="ipaddr">W.X.Y.Z</hostid>, then encrypt it, using the
         necessary security associations.</quote></para>
 
       <para><quote>If a packet arrives from <hostid
         role="ipaddr">W.X.Y.Z</hostid>, and it is destined for <hostid
         role="ipaddr">A.B.C.D</hostid>, then decrypt it, using the
         necessary security associations.</quote></para>
 
       <para>That's close, but not quite right.  If you did this, all
         traffic to and from <hostid role="ipaddr">W.X.Y.Z</hostid>, even
         traffic that was not part of the VPN, would be encrypted.  That's
         not quite what you want.  The correct policy is as follows</para>
 
       <para><quote>If a packet leaves from <hostid
         role="ipaddr">A.B.C.D</hostid>, and that packet is encapsulating
         another packet, and it is destined for <hostid
         role="ipaddr">W.X.Y.Z</hostid>, then encrypt it, using the
         necessary security associations.</quote></para>
 
       <para><quote>If a packet arrives from <hostid
         role="ipaddr">W.X.Y.Z</hostid>, and that packet is encapsulating
         another packet, and it is destined for <hostid
         role="ipaddr">A.B.C.D</hostid>, then encrypt it, using the
         necessary security associations.</quote></para>
 
       <para>A subtle change, but a necessary one.</para>
 
       <para>Security policies are also set using &man.setkey.8;.
         &man.setkey.8; features a configuration language for defining the
         policy.  You can either enter configuration instructions via
         stdin, or you can use the <option>-f</option> option to specify a
         filename that contains configuration instructions.</para>
 
       <para>The configuration on gateway host #1 (which has the public
         IP address <hostid role="ipaddr">A.B.C.D</hostid>) to force all
         outbound traffic to <hostid role="ipaddr">W.X.Y.Z</hostid> to be
         encrypted is:</para>
 
       <programlisting>
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P out ipsec esp/tunnel/A.B.C.D-W.X.Y.Z/require;
       </programlisting>
 
       <para>Put these commands in a file (e.g.,
       <filename>/etc/ipsec.conf</filename>) and then run</para>

       <screen>&prompt.root; <userinput>setkey -f /etc/ipsec.conf</userinput></screen>
 
       <para><option>spdadd</option> tells &man.setkey.8; that we want
         to add a rule to the secure policy database.  The rest of this
         line specifies which packets will match this policy.  <hostid
         role="ipaddr">A.B.C.D/32</hostid> and <hostid
         role="ipaddr">W.X.Y.Z/32</hostid> are the IP addresses and
         netmasks that identify the network or hosts that this policy will
         apply to.  In this case, we want it to apply to traffic between
         these two hosts.  <option>ipencap</option> tells the kernel that
         this policy should only apply to packets that encapsulate other
         packets.  <option>-P out</option> says that this policy applies
         to outgoing packets, and <option>ipsec</option> says that the
         packet will be secured.</para>
 
       <para>The second line specifies how this packet will be
         encrypted.  <option>esp</option> is the protocol that will be
         used, while <option>tunnel</option> indicates that the packet
         will be further encapsulated in an IPsec packet.  The repeated
         use of <hostid role="ipaddr">A.B.C.D</hostid> and <hostid
         role="ipaddr">W.X.Y.Z</hostid> is used to select the security
         association to use, and the final <option>require</option>
         mandates that packets must be encrypted if they match this
         rule.</para>
 
       <para>This rule only matches outgoing packets.  You will need a
         similar rule to match incoming packets.</para>
 
       <programlisting>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P in ipsec esp/tunnel/W.X.Y.Z-A.B.C.D/require;</programlisting>
 
       <para>Note the <option>in</option> instead of
         <option>out</option> in this case, and the necessary reversal of
         the IP addresses.</para>
 
       <para>The other gateway host (which has the public IP address
         <hostid role="ipaddr">W.X.Y.Z</hostid>) will need similar rules.</para>
 
       <programlisting>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P out ipsec esp/tunnel/W.X.Y.Z-A.B.C.D/require;
       spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P in ipsec esp/tunnel/A.B.C.D-W.X.Y.Z/require;</programlisting>
 
       <para>Finally, you need to add firewall rules to allow ESP and
        IPENCAP packets back and forth.  These rules will need to be
        added to both hosts.</para>
 
       <programlisting>ipfw add 1 allow esp from A.B.C.D to W.X.Y.Z
ipfw add 1 allow esp from W.X.Y.Z to A.B.C.D
ipfw add 1 allow ipencap from A.B.C.D to W.X.Y.Z
ipfw add 1 allow ipencap from W.X.Y.Z to A.B.C.D
       </programlisting>
 
       <para>Because the rules are symmetric you can use the same rules
         on each gateway host.</para>
 
       <para>Outgoing packets will now look something like this:</para>
 
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="security/ipsec-crypt-pkt" align="center">
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">
  .------------------------------.  --------------------------.
  | Src: A.B.C.D                 |                            |
  | Dst: W.X.Y.Z                 |                            |
  | &lt;other header info&gt;          |                            |  Encrypted
  +------------------------------+                            |  packet.
  | .--------------------------. |  -------------.            |  contents
  | | Src: A.B.C.D             | |               |            |  are
  | | Dst: W.X.Y.Z             | |               |            |  completely
  | | &lt;other header info&gt;      | |               |            |- secure
  | +--------------------------+ |               |  Encap'd   |  from third
  | | .----------------------. | |  -.           |  packet    |  party
  | | | Src: 192.168.1.1     | | |   |  Original |- with real |  snooping
  | | | Dst: 192.168.2.1     | | |   |  packet,  |  IP addr   |
  | | | &lt;other header info&gt;  | | |   |- private  |            |
  | | +----------------------+ | |   |  IP addr  |            |
  | | | &lt;packet data&gt;        | | |   |           |            |
  | | `----------------------' | |  -'           |            |
  | `--------------------------' |  -------------'            |
  `------------------------------'  --------------------------'
	    </literallayout>
	  </textobject>
	</mediaobject>

       <para>When they are received by the far end of the VPN they will
         first be decrypted (using the security associations that have
         been negotiated by racoon).  Then they will enter the
         <devicename>gif</devicename> interface, which will unwrap
         the second layer, until you are left with the innermost
         packet, which can then travel in to the inner network.</para>
 
       <para>You can check the security using the same &man.ping.8; test from
         earlier.  First, log in to the
         <hostid role="ipaddr">A.B.C.D</hostid> gateway machine, and
         run:</para>
 
       <programlisting>tcpdump dst host 192.168.2.1</programlisting>
 
       <para>In another log in session on the same host run</para>
 
       <programlisting>ping 192.168.2.1</programlisting>
 
       <para>This time you should see output like the following:</para>
 
       <programlisting>XXX tcpdump output</programlisting>
 
       <para>Now, as you can see, &man.tcpdump.1; shows the ESP packets.  If
         you try and examine them with the <option>-s</option> option you will see
         (apparently) gibberish, because of the encryption.</para>
 
      <para>Congratulations.  You have just set up a VPN between two
        remote sites.</para>
 
      <itemizedlist>
        <title>Summary</title>
        <listitem>
          <para>Configure both kernels with:</para>
 
          <programlisting>options IPSEC
options IPSEC_ESP
          </programlisting>
        </listitem>
        <listitem>
          <para>Install <filename
            role="package">security/racoon</filename>.  Edit
            <filename>${PREFIX}/etc/racoon/psk.txt</filename> on both
            gateway hosts, adding an entry for the remote host's IP
            address and a secret key that they both know.  Make sure
            this file is mode 0600.</para>
        </listitem>
        <listitem>
          <para>Add the following lines to
            <filename>/etc/rc.conf</filename> on each host:</para>
 
          <programlisting>ipsec_enable="YES"
ipsec_file="/etc/ipsec.conf"
          </programlisting>
        </listitem>
        <listitem>
          <para>Create an <filename>/etc/ipsec.conf</filename> on each
            host that contains the necessary spdadd lines.  On gateway
            host #1 this would be:</para>
 
          <programlisting>
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P out ipsec
  esp/tunnel/A.B.C.D-W.X.Y.Z/require;
spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P in ipsec
  esp/tunnel/W.X.Y.Z-A.B.C.D/require;
</programlisting>
 
          <para>On gateway host #2 this would be:</para>
 
<programlisting>
spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P out ipsec
  esp/tunnel/W.X.Y.Z-A.B.C.D/require;
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P in ipsec
  esp/tunnel/A.B.C.D-W.X.Y.Z/require;
</programlisting>
        </listitem>
        <listitem>
          <para>Add firewall rules to allow IKE, ESP, and IPENCAP
            traffic to both hosts:</para>
 
          <programlisting>
ipfw add 1 allow udp from A.B.C.D to W.X.Y.Z isakmp
ipfw add 1 allow udp from W.X.Y.Z to A.B.C.D isakmp
ipfw add 1 allow esp from A.B.C.D to W.X.Y.Z
ipfw add 1 allow esp from W.X.Y.Z to A.B.C.D
ipfw add 1 allow ipencap from A.B.C.D to W.X.Y.Z
ipfw add 1 allow ipencap from W.X.Y.Z to A.B.C.D
          </programlisting>
        </listitem>
      </itemizedlist>

      <para>The previous two steps should suffice to get the VPN up and
        running.  Machines on each network will be able to refer to one
        another using IP addresses, and all traffic across the link will
        be automatically and securely encrypted.</para>
    </sect3> 
    </sect2> 
  </sect1>

  <sect1 id="openssh">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Chern</firstname>
	  <surname>Lee</surname>
	  <contrib>Contribuição de </contrib>
	</author>
	<!-- 21 April 2001 -->
      </authorgroup>
    </sect1info>

    <title>OpenSSH</title>
    <indexterm><primary>OpenSSH</primary></indexterm>
    <indexterm>
      <primary>security</primary>
      <secondary>OpenSSH</secondary>
    </indexterm>

    <para><application>OpenSSH</application> is a set of network connectivity tools used to
      access remote machines securely.  It can be used as a direct
      replacement for <command>rlogin</command>,
      <command>rsh</command>, <command>rcp</command>, and
      <command>telnet</command>.  Additionally, any other TCP/IP
      connections can be tunneled/forwarded securely through SSH.
      <application>OpenSSH</application> encrypts all traffic to effectively eliminate eavesdropping,
      connection hijacking, and other network-level attacks.</para>

    <para><application>OpenSSH</application> is maintained by the OpenBSD project, and is based
      upon SSH v1.2.12 with all the recent bug fixes and updates.  It
      is compatible with both SSH protocols 1 and 2.  <application>OpenSSH</application> has been
      in the base system since FreeBSD&nbsp;4.0.</para>

    <sect2>
      <title>Advantages of Using OpenSSH</title>
  
      <para>Normally, when using &man.telnet.1; or &man.rlogin.1;,
        data is sent over the network in an clear, un-encrypted form.
        Network sniffers anywhere in between the client and server can
        steal your user/password information or data transferred in
        your session.  <application>OpenSSH</application> offers a variety of authentication and
        encryption methods to prevent this from happening.</para>
    </sect2>

    <sect2>
      <title>Enabling sshd</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>enabling</secondary>
      </indexterm>

      <para>Be sure to make the following addition to your 
        <filename>rc.conf</filename> file:</para>
      <screen>sshd_enable="YES"</screen>
      <para>This will load &man.sshd.8;, the daemon program for <application>OpenSSH</application>,
	the next time your system initializes.  Alternatively, you can
	simply run directly the <application>sshd</application> daemon by typing <command>sshd</command> on the command line.</para>
    </sect2>

    <sect2>
      <title>SSH Client</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>client</secondary>
      </indexterm>

      <para>The &man.ssh.1; utility works similarly to 
        &man.rlogin.1;.</para>

      <screen>&prompt.root; <userinput>ssh <replaceable>user@example.com</replaceable></userinput>
Host key not found from the list of known hosts.
Are you sure you want to continue connecting (yes/no)? <userinput>yes</userinput>
Host 'example.com' added to the list of known hosts.
user@example.com's password: <userinput>*******</userinput></screen>

      <para>The login will continue just as it would have if a session was
        created using <command>rlogin</command> or
        <command>telnet</command>.  SSH utilizes a key fingerprint
        system for verifying the authenticity of the server when the 
        client connects.  The user is prompted to enter
	<literal>yes</literal> only when
        connecting for the first time.  Future attempts to login are all
        verified against the saved fingerprint key.  The SSH client
        will alert you if the saved fingerprint differs from the
        received fingerprint on future login attempts.  The fingerprints
        are saved in <filename>~/.ssh/known_hosts</filename>, or
	<filename>~/.ssh/known_hosts2</filename> for SSH v2
	fingerprints.</para>

      <para>By default, <application>OpenSSH</application> servers are configured to accept both
	SSH v1 and SSH v2 connections.  The client, however, can choose
	between the two.  Version 2 is known to be more robust and
	secure than its predecessor.</para>

      <para>The &man.ssh.1; command can be forced to use either protocol
	by passing it the <option>-1</option> or <option>-2</option> argument
	for v1 and v2, respectively.</para>
    </sect2>
    
    <sect2>
      <title>Secure Copy</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>secure copy</secondary>
      </indexterm>
      <indexterm><primary><command>scp</command></primary></indexterm>

      <para>The &man.scp.1; command works similarly to
	&man.rcp.1;; it copies a file to or from a remote machine,
	except in a secure fashion.</para>

      <screen>&prompt.root; <userinput> scp <replaceable>user@example.com:/COPYRIGHT COPYRIGHT</replaceable></userinput>
user@example.com's password: <userinput>*******</userinput>
COPYRIGHT            100% |*****************************|  4735       
00:00    
&prompt.root;</screen>
      <para>Since the fingerprint was already saved for this host in the
        previous example, it is verified when using &man.scp.1;
        here.</para>

      <para>The arguments passed to &man.scp.1; are similar
	to &man.cp.1;, with the file or files in the first
	argument, and the destination in the second.  Since the file is
	fetched over the network, through SSH, one or more of the file
	arguments takes on the form
	<option>user@host:&lt;path_to_remote_file&gt;</option>.</para>

    </sect2>

    <sect2>
      <title>Configuration</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>configuration</secondary>
      </indexterm>

      <para>The system-wide configuration files for both the <application>OpenSSH</application> 
        daemon and client reside within the <filename>/etc/ssh</filename> 
        directory.</para>

      <para><filename>ssh_config</filename> configures the client 
        settings, while <filename>sshd_config</filename> configures the 
        daemon.</para>

      <para>Additionally, the <option>sshd_program</option>
	(<filename>/usr/sbin/sshd</filename> by default), and
	<option>sshd_flags</option> <filename>rc.conf</filename>
	options can provide more levels of configuration.</para>
    </sect2>

    <sect2>
      <title>ssh-keygen</title>

      <para>Instead of using passwords, &man.ssh-keygen.1; can
        be used to generate RSA keys to authenticate a user:</para>

      <screen>&prompt.user; <userinput>ssh-keygen -t <replaceable>rsa1</replaceable></userinput>
Initializing random number generator...
Generating p:  .++ (distance 66)
Generating q:  ..............................++ (distance 498)
Computing the keys...
Key generation complete.
Enter file in which to save the key (/home/user/.ssh/identity):
Enter passphrase:
Enter the same passphrase again:
Your identification has been saved in /home/user/.ssh/identity.
...</screen>

      <para>&man.ssh-keygen.1; will create a public and private
        key pair for use in authentication.  The private key is stored in
        <filename>~/.ssh/identity</filename>, whereas the public key is
        stored in <filename>~/.ssh/identity.pub</filename>.  The public
        key must be placed in <filename>~/.ssh/authorized_keys</filename>
        of the remote machine in order for the setup to work.</para>

      <para>This will allow connection to the remote machine based upon
        RSA authentication instead of passwords.</para>

      <note><para>The <option>-t rsa1</option> option will create RSA
	keys for use by SSH protocol version 1.  If you want to use
	RSA keys with the SSH protocol version 2, you have to use the
	command <command>ssh-keygen -t rsa</command>.</para></note>

      <para>If a passphrase is used in &man.ssh-keygen.1;, the user
        will be prompted for a password each time in order to use the private
        key.</para>

      <para>A SSH protocol version 2 DSA key can be created for the same purpose by using
	the <command>ssh-keygen -t dsa</command> command.
	This will
	create a public/private DSA key for use in SSH protocol version 2 sessions only.
	The public key is stored in <filename>~/.ssh/id_dsa.pub</filename>,
	while the private key is in <filename>~/.ssh/id_dsa</filename>.</para>

      <para>DSA public keys are also placed in
	<filename>~/.ssh/authorized_keys</filename> on the remote
	machine.</para>

      <para>&man.ssh-agent.1; and &man.ssh-add.1; are 
        utilities used in managing multiple passworded private keys.</para>

      <warning><para>The various options and files can be different
	according to the <application>OpenSSH</application> version you have on your system, to
	avoid problems you should consult the &man.ssh-keygen.1;
	manual page.</para></warning>
    </sect2>

    <sect2>
      <title>SSH Tunneling</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>tunneling</secondary>
      </indexterm>

      <para><application>OpenSSH</application> has the ability to create a tunnel to encapsulate
        another protocol in an encrypted session.</para>

      <para>The following command tells &man.ssh.1; to create a tunnel 
         for <application>telnet</application>:</para>

       <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>5023:localhost:23 user@foo.example.com</replaceable></userinput>
&prompt.user;</screen>

      <para>The <command>ssh</command> command is used with the
	following options:</para>

      <variablelist>
	<varlistentry>
	  <term><option>-2</option></term>
	  
	  <listitem>
	    <para>Forces <command>ssh</command> to use version 2 of
	      the protocol. (Do not use if you are working with older
	      SSH servers)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-N</option></term>

	  <listitem>
	    <para>Indicates no command, or tunnel only.  If omitted,
	      <command>ssh</command> would initiate a normal
	      session.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Forces <command>ssh</command> to run in the
	      background.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-L</option></term>

	  <listitem>
	    <para>Indicates a local tunnel in
	      <replaceable>localport:remotehost:remoteport</replaceable>
	      fashion.</para>
	  </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><option>user@foo.example.com</option></term>

	  <listitem>
	    <para>The remote SSH server.</para>
	  </listitem>
	</varlistentry>
      </variablelist>


      <para>An SSH tunnel works by creating a listen socket on
	<hostid>localhost</hostid> on the specified port.
	It then forwards any connection received
	on the local host/port via the SSH connection to the specified
	remote host and port.</para>

      <para>In the example, port <replaceable>5023</replaceable> on
	<hostid>localhost</hostid> is being forwarded to port
	<replaceable>23</replaceable> on <hostid>localhost</hostid>
	of the remote machine.  Since <replaceable>23</replaceable> is <application>telnet</application>,
	this would create a secure <application>telnet</application> session through an SSH tunnel.</para>

      <para>This can be used to wrap any number of insecure TCP protocols 
        such as SMTP, POP3, FTP, etc.</para>

      <example>
	<title>Using SSH to Create a Secure Tunnel for SMTP</title>

        <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>5025:localhost:25 user@mailserver.example.com</replaceable></userinput>
user@mailserver.example.com's password: <userinput>*****</userinput>
&prompt.user; <userinput>telnet localhost 5025</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
220 mailserver.example.com ESMTP</screen>     

        <para>This can be used in conjunction with an
          &man.ssh-keygen.1; and additional user accounts to create a
          more seamless/hassle-free SSH tunneling environment.  Keys
          can be used in place of typing a password, and the tunnels
          can be run as a separate user.</para>
      </example>

      <sect3>
	<title>Practical SSH Tunneling Examples</title>

	<sect4>
	  <title>Secure Access of a POP3 Server</title>

	  <para>At work, there is an SSH server that accepts
	    connections from the outside.  On the same office network
	    resides a mail server running a POP3 server.  The network,
	    or network path between your home and office may or may not
	    be completely trustable.  Because of this, you need to check
	    your e-mail in a secure manner.  The solution is to create
	    an SSH connection to your office's SSH server, and tunnel
	    through to the mail server.</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>2110:mail.example.com:110 user@ssh-server.example.com</replaceable></userinput>
user@ssh-server.example.com's password: <userinput>******</userinput></screen>

	  <para>When the tunnel is up and running, you can point your
	    mail client to send POP3 requests to <hostid>localhost</hostid>
	    port 2110.  A connection here will be forwarded securely across
	    the tunnel to <hostid>mail.example.com</hostid>.</para>
	</sect4>

	<sect4>
	  <title>Bypassing a Draconian Firewall</title>

	  <para>Some network administrators impose extremely draconian
	    firewall rules, filtering not only incoming connections,
	    but outgoing connections.  You may be only given access
	    to contact remote machines on ports 22 and 80 for SSH
	    and web surfing.</para>

	  <para>You may wish to access another (perhaps non-work
	    related) service, such as an Ogg Vorbis server to stream
	    music.  If this Ogg Vorbis server is streaming on some other
	    port than 22 or 80, you will not be able to access it.</para>

	  <para>The solution is to create an SSH connection to a machine
	    outside of your network's firewall, and use it to tunnel to
	    the Ogg Vorbis server.</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>8888:music.example.com:8000 user@unfirewalled-system.example.org</replaceable></userinput>
user@unfirewalled-system.example.org's password: <userinput>*******</userinput></screen>

	  <para>Your streaming client can now be pointed to
	    <hostid>localhost</hostid> port 8888, which will be
	    forwarded over to <hostid>music.example.com</hostid> port
	    8000, successfully evading the firewall.</para>
        </sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Further Reading</title>
      <para><ulink url="http://www.openssh.com/">OpenSSH</ulink></para>
      <para>&man.ssh.1; &man.scp.1; &man.ssh-keygen.1; 
        &man.ssh-agent.1; &man.ssh-add.1;</para>
      <para>&man.sshd.8; &man.sftp-server.8;</para>
    </sect2>
  </sect1>

  <sect1 id="mac">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Robert</firstname>
	  <surname>Watson</surname>
	  <contrib>Patrocinado por DARPA e Network Associates Laboratories.
	    Contribuição de </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <indexterm>
      <primary>MAC</primary>
    </indexterm>
    <title>Controle de Acesso Obrigatório 
      (MAC-Mandatory Access Control)</title>

    <para>FreeBSD 5.0 includes a new kernel security framework, the
      TrustedBSD MAC Framework.  The MAC Framework permits compile-time,
      boot-time, and run-time extension of the kernel access control
      policy, and can be used to load support for Mandatory Access
      Control (<acronym>MAC</acronym>), and custom security modules
      such as hardening modules.  The MAC Framework is currently
      considered to be an experimental feature, and should not yet
      be used in production environments without careful consideration.
      It is anticipated that the MAC Framework will be appropriate for
      more widespread production use by FreeBSD 5.2.</para>

    <para>When configured into a kernel, the MAC Framework permits
      security modules to augment the existing kernel access control
      model, restricting access to system services and objects.  For
      example, the &man.mac.bsdextended.4; module augments file system
      access control, permitting administrators to provide a
      firewall-like ruleset constraining access to file system objects
      based on user ids and group membership.  Some modules require
      little or no configuration, such as &man.mac.seeotheruids.4,
      whereas others perform ubiquitous object labeling, such as
      &man.mac.biba.4; and &man.mac.mls.4;, and require extensive
      configuration.</para>

    <para>To enable the MAC Framework in your system kernel, you must
      add the following entry to your kernel configuration:</para>

    <programlisting>options MAC</programlisting>

    <para>Security policy modules shipped with the base system may
     be loaded using &man.kldload.8; or in the boot &man.loader.8;
     They may also be compiled directly into the kernel using the
     following options, if the use of modules is not desired.</para>

    <para>Different MAC policies may be configured in different ways;
      frequently, MAC policy modules export configuration parameters
      using the &man.sysctl.8; <acronym>MIB</acronym> using the
      <varname>security.mac</varname> namespace.  Policies relying on
      file system or other labels may require a configuration step
      that involves assigning initial labels to system objects or
      creating a policy configuration file.  For information on how to
      configure and use each policy module, see its man page.</para>

    <para>A variety of tools are available to configure the MAC Framework
      and labels maintained by various policies.  Extensions have been
      made to the login and credential management mechanisms
      (&man.setusercontext.3;) to support initial user labeling using
      &man.login.conf.5;.  In addition, modifications have been made
      to &man.su.1;, &man.ps.1;, &man.ls.1;, and &man.ifconfig.8; to
      inspect and set labels on processes, files, and interfaces.  In
      addition, several new tools have been added to manage labels
      on objects, including &man.getfmac.8;, &man.setfmac.8;, and
      &man.setfsmac.8; to manage labels on files, and &man.getpmac.8; and
      &man.setpmac.8;.</para>

    <para>What follows is a list of policy modules shipped with FreeBSD
      5.0.</para>
    <sect2 id="mac-policy-biba">
      <title>Biba Integrity Policy (mac_biba)</title>
      <indexterm>
	<primary>Biba Integrity Policy</primary>
      </indexterm>
      <para>Vendor: TrustedBSD Project</para>
      <para>Module name: mac_biba.ko</para>
      <para>Kernel option: <literal>MAC_BIBA</literal></para>
      <indexterm>
	<primary>TCB</primary>
      </indexterm>
      <para>The Biba Integrity Policy (&man.mac.biba.4;) provides
	for hierarchical and non-hierarchical labeling of all system
	objects with integrity data, and the strict enforcement of
	an information flow policy to prevent corruption of high
	integrity subjects and data by low-integrity subjects.
	Integrity is enforced by preventing high integrity
	subjects (generally processes) from reading low integrity
	objects (often files), and preventing low integrity
	subjects from writing to high integrity objects.
	This security policy is frequently used in commercial
	trusted systems to provide strong protection for the
	Trusted Code Base (<acronym>TCB</acronym>).  Because it
	provides ubiquitous labeling, the Biba integrity policy
	must be compiled into the kernel or loaded at boot.</para>
    </sect2>
    <sect2 id="mac-policy-bsdextended">
      <title>File System Firewall Policy (mac_bsdextended)</title>
      <indexterm>
	<primary>File System Firewall Policy</primary>
      </indexterm>
      <para>Vendor: TrustedBSD Project</para>
      <para>Module name: mac_bsdextended.ko</para>
      <para>Kernel option: <literal>MAC_BSDEXTENDED</literal></para>
      <para> The File System Firewall Policy (&man.mac.bsdextended.4;)
	provides an extension to the BSD file system permission model,
	permitting the administrator to define a set of firewall-like
	rules for limiting access to file system objects owned by
	other users and groups.  Managed using &man.ugidfw.8;, rules
	may limit access to files and directories based on the uid
	and gids of the process attempting the access, and the owner
	and group of the target of the access attempt.  All rules
	are restrictive, so they may be placed in any order.  This policy
	requires no prior configuration or labeling, and may be
	appropriate in multi-user environments where mandatory limits
	on inter-user data exchange are required.  Caution should be
	exercised in limiting access to files owned by the super-user or
	other system user ids, as many useful programs and directories
	are owned by these users.  As with a network firewall,
	improper application of file system firewall rules may render
	the system unusable.  New tools to manage the rule set may be
	easily written using the &man.libugidfw.3; library.</para>
    </sect2>
    <sect2 id="mac-policy-ifoff">
      <title>Interface Silencing Policy (mac_ifoff)</title>
      <indexterm>
	<primary>Interface Silencing Policy</primary>
      </indexterm>
      <para>Vendor: TrustedBSD Project</para>
      <para>Module name: mac_ifoff.ko</para>
      <para>Kernel option: <literal>MAC_IFOFF</literal></para>
      <para>The interface silencing policy (&man.mac.ifoff.4;)
	prohibits the use of network interfaces during the boot
	until explicitly enabled, preventing spurious stack output
	stack response to incoming packets.  This is appropriate
	for use in environments where the monitoring of packets
	is required, but no traffic may be generated.</para>
    </sect2>
    <sect2 id="mac-policy-lomac">
      <title>Low-Watermark Mandatory Access Control (LOMAC)
	(mac_lomac)</title>
      <indexterm>
	<primary>MAC</primary>
	<secondary>Low-Watermark</secondary>
      </indexterm>
      <indexterm>
	<primary>LOMAC</primary>
      </indexterm>
      <para>Vendor: Network Associates Laboratories</para>
      <para>Module name: mac_lomac.ko</para>
      <para>Kernel option: <literal>MAC_LOMAC</literal></para>
      <para>Similar to the Biba Integrity Policy, the LOMAC
	policy (&man.mac.lomac.4;) relies on the ubiquitous
	labeling of all system objects with integrity labels.
	Unlike Biba, LOMAC permits high integrity subjects to
	read from low integrity objects, but then downgrades the
	label on the subject to prevent future writes to high
	integrity objects.  This policy may provide for greater
	compatibility, as well as require less initial
	configuration than Biba.  However, as with Biba, it
	ubiquitously labels objects and must therefore be
	compiled into the kernel or loaded at boot.</para>
    </sect2>

    <sect2 id="mac-policy-mls">
      <title>Multi-Level Security Policy (MLS) (mac_mls)</title>
      <indexterm>
	<primary>Multi-Level Security Policy</primary>
      </indexterm>
      <indexterm>
	<primary>MAC</primary>
	<secondary>Multi-Level</secondary>
      </indexterm>

      <para>Vendor: TrustedBSD Project</para>
      <para>Module name: mac_mls.ko</para>
      <para>Kernel option: <literal>MAC_MLS</literal></para>
      <para>Multi-Level Security (<acronym>MLS</acronym>)
        (&man.mac.mls.4;) provides for hierarchical and non-hierarchical
        labeling of all system objects with sensitivity data, and the
        strict enforcement of an information flow policy to prevent
        the leakage of confidential data to untrusted parties.  The
        logical conjugate of the Biba Integrity Policy,
        <acronym>MLS</acronym> is frequently shipped in commercial
        trusted operating systems to protect data secrecy in
        multi-user environments.  Hierarchal labels provide support
        for the notion of clearances and classifications in
        traditional parlance; non-hierarchical labels provide support
        for <quote>need-to-know.</quote>  As with Biba, ubiquitous
        labeling of objects occurs, and it must therefore be compiled
        into the kernel or loaded at boot.  As with Biba, extensive
        initial configuration may be required.</para>
    </sect2>
    <sect2 id="mac-policy-none">
      <title>MAC Stub Policy (mac_none)</title>
      <indexterm>
	<primary>MAC Stub Policy</primary>
      </indexterm>
      <para>Vendor: TrustedBSD Project</para>
      <para>Module name: mac_none.ko</para>
      <para>Kernel option: <literal>MAC_NONE</literal></para>
      <para>The None policy (&man.mac.none.4;) provides a stub
	sample policy for developers, implementing all entry
	points, but not changing the system access control
	policy.  Running this on a production system would
	not be highly beneficial.</para>
    </sect2>
    <sect2 id="mac-policy-partition">
      <title>Process Partition Policy (mac_partition)</title>
      <indexterm>
	<primary>Process Partition Policy</primary>
      </indexterm>
      <para>Vendor: TrustedBSD Project</para>
      <para>Module name: mac_partition.ko</para>
      <para>Kernel option: <literal>MAC_PARTITION</literal></para>
      <para>The Partition policy (&man.mac.partition.4;) provides for a
	simple process visibility limitation, assigning labels to
	processes identifying what numeric system partition they
	are present in.  If none, all other processes are visible
	using standard monitoring tools; if a partition identifier
	is present, then only other processes in the same
	partition are visible.  This policy may be compiled into
	the kernel, loaded at boot, or loaded at run-time.</para>
    </sect2>
    <sect2 id="mac-policy-seeotheruids">
      <title>See Other Uids Policy (mac_seeotheruids)</title>
      <indexterm>
	<primary>See Other Uids Policy</primary>
      </indexterm>
      <para>Vendor: TrustedBSD Project</para>
      <para>Module name: mac_seeotheruids.ko</para>
      <para>Kernel option: <literal>MAC_SEEOTHERUIDS</literal></para>
      <para>The See Other Uids policy (&man.mac.seeotheruids.4;)
        implements a similar process visibility model to
        mac_partition, except that it relies on process credentials to
        control visibility of processes, rather than partition labels.
        This policy may be configured to exempt certain users and
        groups, including permitting system operators to view all
        processes without special privilege.  This policy may be
        compiled into the kernel, loaded at boot, or loaded at
        run-time.</para>
    </sect2>
    <sect2 id="mac-policy-test">
      <title>MAC Framework Test Policy (mac_test)</title>
      <indexterm>
	<primary>MAC Framework Test Policy</primary>
      </indexterm>
      <para>Vendor: TrustedBSD Project</para>
      <para>Module name: mac_test.ko</para>
      <para>Kernel option: <literal>MAC_TEST</literal></para>
      <para>The Test policy (&man.mac.test.4;) provides a regression
        test environment for the MAC Framework, and will cause a
        fail-stop in the event that internal MAC Framework assertions
        about proper data labeling fail.  This module can be used to
        detect failures to properly label system objects in the kernel
        implementation.  This policy may be compiled into the kernel,
        loaded at boot, or loaded at run-time.</para>
    </sect2>

  </sect1>

    <sect1 id="fs-acl">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Contribuição de </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <indexterm>
      <primary>ACL</primary>
    </indexterm>
    <title>File System Access Control Lists</title>

    <para>In conjunction with file system enhancements like snapshots, FreeBSD 5.0
      and later offers the security of File System Access Control Lists
      (<acronym>ACLs</acronym>).</para>

    <para>Access Control Lists extend the standard &unix;
      permission model in a highly compatible (&posix;.1e) way.  This feature
      permits an administrator to make use of and take advantage of a
      more sophisticated security model.</para>

    <para>To enable <acronym>ACL</acronym> support for <acronym>UFS</acronym>
      file systems, the following:</para>

    <programlisting>options UFS_ACL</programlisting>

    <para>must be compiled into the kernel.  If this option has
      not been compiled in, a warning message will be displayed
      when attempting to mount a file system supporting <acronym>ACLs</acronym>.
      This option is included in the <filename>GENERIC</filename> kernel.
      <acronym>ACLs</acronym> rely on extended attributes being enabled on
      the file system.  Extended attributes are natively supported in the next generation
      &unix; file system, <acronym>UFS2</acronym>.</para>

    <note><para>A higher level of administrative overhead is required to
      configure extended attributes on <acronym>UFS1</acronym> than on
      <acronym>UFS2</acronym>.  The performance of extended attributes
      on <acronym>UFS2</acronym> is also substantially higher.  As a
      result, <acronym>UFS2</acronym> is generally recommended in preference
      to <acronym>UFS1</acronym> for use with access control lists.</para></note>

    <para><acronym>ACLs</acronym> are enabled by the mount-time administrative
      flag, <option>acls</option>, which may be added to <filename>/etc/fstab</filename>.
      The mount-time flag can also be automatically set in a persistent manner using
      &man.tunefs.8; to modify a superblock <acronym>ACLs</acronym> flag in the
      file system header.  In general, it is preferred to use the superblock flag
      for several reasons:</para>

    <itemizedlist>
      <listitem>
	<para>The mount-time <acronym>ACLs</acronym> flag cannot be changed by a
	remount (&man.mount.8; <option>-u</option>), only by means of a complete
	&man.umount.8; and fresh &man.mount.8;.  This means that
	<acronym>ACLs</acronym> cannot be enabled on the root file system after boot.
	It also means that you cannot change the disposition of a file system once
	it is in use.</para>
      </listitem>

      <listitem>
	<para>Setting the superblock flag will cause the file system to always be
	mounted with <acronym>ACLs</acronym> enabled even if there is not an
	<filename>fstab</filename> entry or if the devices re-order.  This prevents
	accidental mounting of the file system without <acronym>ACLs</acronym>
	enabled, which can result in <acronym>ACLs</acronym> being improperly enforced,
	and hence security problems.</para>
      </listitem>
    </itemizedlist>

    <note><para>We may change the <acronym>ACLs</acronym> behavior to allow the flag to
      be enabled without a complete fresh &man.mount.8;, but we consider it desirable to
      discourage accidental mounting without <acronym>ACLs</acronym> enabled, because you
      can shoot your feet quite nastily if you enable <acronym>ACLs</acronym>, then disable
      them, then re-enable them without flushing the extended attributes.  In general, once
      you have enabled <acronym>ACLs</acronym> on a file system, they should not be disabled,
      as the resulting file protections may not be compatible with those intended by the
      users of the system, and re-enabling <acronym>ACLs</acronym> may re-attach the previous
      <acronym>ACLs</acronym> to files that have since had their permissions changed,
      resulting in other unpredictable behavior.</para></note>
      
    <para>File systems with <acronym>ACLs</acronym> enabled will show a <literal>+</literal>
      (plus) sign in their permission settings when viewed.  For example:</para>

    <programlisting>drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directory1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directory2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directory3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html</programlisting>

    <para>Here we see that the <filename>directory1</filename>,
      <filename>directory2</filename>, and <filename>directory3</filename>
      directories are all taking advantage of <acronym>ACLs</acronym>.  The
      <filename>public_html</filename> directory is not.</para>

    <sect2>
      <title>Making Use of <acronym>ACL</acronym>s</title>

      <para>The file system <acronym>ACL</acronym>s can be viewed by the
	&man.getfacl.1; utility.  For instance, to view the
	<acronym>ACL</acronym> settings on the <filename>test</filename>
	file, one would use the command:</para>

      <screen>%<userinput>getfacl <filename>test</filename></userinput>
	#file:test
	#owner:1001
	#group:1001
	user::rw-
	group::r--
	other::r--</screen>

      <para>To change the <acronym>ACL</acronym> settings on this file,
	invoke the &man.setfacl.1; utility.  Observe:</para>

      <screen>&prompt.user;<userinput>setfacl -k <filename>test</filename></userinput></screen>

      <para>The <literal>-k</literal> flag will remove all of the
	currently defined <acronym>ACL</acronym>s from a file or file
	system.  The more preferable method would be to use
	<literal>-b</literal> as it leaves the basic fields required for
	<acronym>ACL</acronym>s to work.</para>

      <screen>&prompt.user;<userinput>-m u:trhodes:rwx,group:web:r--,o::--- <filename>test</filename></userinput></screen>

      <para>In the aforementioned command, the <literal>-m</literal>
	option was used to modify the default <acronym>ACL</acronym>
	entries.  Since there were no pre-defined entries, as they were
	removed by the previous command, this will restore the default
	options and assign the options listed.  Take care to notice that
	if you add a user or group which does not exist on the system,
	an <errorname>Invalid argument</errorname> error will be printed
	to <devicename>stdout</devicename>.</para>
    </sect2>
  </sect1>

  <sect1 id="security-advisories">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Contribuição de </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <indexterm>
      <primary>recomendações de segurança do FreeBSD</primary>
    </indexterm>
    <title>Recomendações de Segurança do &os;</title>

    <para>Like many production quality operating systems, &os; publishes
      <quote>Security Advisories</quote>.  These advisories are usually
      mailed to the security lists and noted in the Errata only
      after the appropriate releases have been patched.  This section
      will work to explain what an advisory is, how to understand them,
      and what measures to take in order to patch a system.</para>

    <sect2>
      <title>What does an advisory look like?</title>

      <para>The &os; security advisories look similar to the one below,
	taken from the security mailing list.</para>

      <programlisting>=============================================================================
&os;-SA-XX:XX.UTIL                                     Security Advisory
                                                          The &os; Project

Topic:          denial of service due to some problem<co id="co-topic">

Category:       core<co id="co-category">
Module:         sys<co id="co-module">
Announced:      2003-09-23<co id="co-announce">
Credits:        Person@EMAIL-ADDRESS<co id="co-credit">
Affects:        All releases of &os;<co id="co-affects">
                &os; 4-STABLE prior to the correction date
Corrected:      2003-09-23 16:42:59 UTC (RELENG_4, 4.9-PRERELEASE)
                2003-09-23 20:08:42 UTC (RELENG_5_1, 5.1-RELEASE-p6)
                2003-09-23 20:07:06 UTC (RELENG_5_0, 5.0-RELEASE-p15)
                2003-09-23 16:44:58 UTC (RELENG_4_8, 4.8-RELEASE-p8)
                2003-09-23 16:47:34 UTC (RELENG_4_7, 4.7-RELEASE-p18)
                2003-09-23 16:49:46 UTC (RELENG_4_6, 4.6-RELEASE-p21)
                2003-09-23 16:51:24 UTC (RELENG_4_5, 4.5-RELEASE-p33)
                2003-09-23 16:52:45 UTC (RELENG_4_4, 4.4-RELEASE-p43)
                2003-09-23 16:54:39 UTC (RELENG_4_3, 4.3-RELEASE-p39)<co id="co-corrected">
&os; only:   NO<co id="co-only">

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit
http://www.freebsd.org/security/.

I.   Background<co id="co-backround">


II.  Problem Description<co id="co-descript">


III. Impact<co id="co-impact">


IV.  Workaround<co id="co-workaround">


V.   Solution<co id="co-solution">


VI.  Correction details<co id="co-details">


VII. References<co id="co-ref"></programlisting>


      <calloutlist>
	<callout arearefs="co-topic">
	  <para>The topic field indicates exactly what the problem is.
	    It is basically an introduction to the current security
	    advisory and notes the utility with the
	    vulnerability.</para>
	</callout>

	<callout arearefs="co-category">
	  <para>The Category refers to the affected part of the system
	    which may be one of core, contrib, or ports.  The core
	    category means that the vulnerability affects a core
	    component of the &os; operating system.  The contrib
	    category means that the vulnerability affects software
	    contributed to the &os; Project, such as
	    <application>Sendmail</application>.  Finally the ports
	    category indicates that the vulnerability affects add on
	    software available as part of the ports collection.</para>
	</callout>

	<callout arearefs="co-module">
	  <para>The Module field refers to the component location, for
	    instance sys.  In this example, we see that the module,
	    sys, is affected; therefore, this vulnerability
	    affects a component used within the kernel.</para>
	</callout>

	<callout arearefs="co-announce">
	  <para>The Announced field reflects the date said security
	    advisory was published, or announced to the world.  This
	    means that the security team has verified that the problem
	    does exist and that a patch has been committed to the &os;
	    source code repository.</para>
	</callout>

	<callout arearefs="co-credit">
	  <para>The Credits field gives credit to the individual or
	    organization who noticed the vulnerability and reported
	    it.</para>
	</callout>

	<callout arearefs="co-affects">
	  <para>The Affects field explains which releases of &os; are
	    affected by this vulnerability.  For the kernel, a quick
	    look over the output from <command>ident</command> on the
	    affected files will help in determining the revision.
	    For ports, the version number is listed after the port name
	    in <filename>/var/db/pkg</filename>.  If the system does not
	    sync with the &os; <acronym>CVS</acronym> repository and rebuild
	    daily, chances are that it is affected.</para>
	</callout>

	<callout arearefs="co-corrected">
	  <para>The Corrected field indicates the date, time, time
	    offset, and release that was corrected.</para>
	</callout>

	<callout arearefs="co-only">
	  <para>The &os; only field indicates whether this vulnerability
	    affects just &os;, or if it affects other operating systems
	    as well.</para>
	</callout>

	<callout arearefs="co-backround">
	  <para>The background field gives information on exactly what
	    the affected utility is.  Most of the time this is why
	    the utility exists in &os;, what it is used for, and a bit
	    of information on how the utility came to be.</para>
	</callout>

	<callout arearefs="co-descript">
	  <para>The Problem Description field explains the security hole
	    in depth.  This can include information on flawed code, or
	    even how the utility could be maliciously used to open
	    a security hole.</para>
	</callout>

	<callout arearefs="co-impact">
	  <para>The Impact field describes what type of impact the
	    problem could have on a system.  For example, this could
	    be anything from a denial of service attack, to extra
	    privileges available to users, or even giving the attacker
	    superuser access.</para>
	</callout>

	<callout arearefs="co-workaround">
	  <para>The Workaround field offers a feasible workaround to
	    system administrators who may be incapable of upgrading
	    the system.  This may be due to time constraints, network
	    availability, or a slew of other reasons.  Regardless,
	    security should not be taken lightly, and an affected system
	    should either be patched or the security hole workaround
	    should be implemented.</para>
	</callout>

	<callout arearefs="co-solution">
	  <para>The Solution field offers instructions on patching the
	    affected system.  This is a step by step tested and verified
	    method for getting a system patched and working
	    securely.</para>
	</callout>

	<callout arearefs="co-details">
	  <para>The Correction Details field displays the
	    <acronym>CVS</acronym> branch or release name with the
	    periods changed to underscore characters.  It also shows
	    the revision number of the affected files within each
	    branch.</para>

	<callout arearefs="co-ref">
	  <para>The References field usually offers sources of other
	    information.  This can included web <acronym>URL</acronym>s,
	    books, mailing lists, and newsgroups.</para>
	</callout>
      </calloutlist>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

