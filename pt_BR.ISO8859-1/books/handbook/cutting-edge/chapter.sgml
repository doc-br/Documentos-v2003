<!--
     The FreeBSD Documentation Project

     $FreeBSD: doc/en_US.ISO8859-1/books/handbook/cutting-edge/chapter.sgml,v 1.194 2003/11/05 10:36:53 ceri Exp $
-->

<chapter id="cutting-edge">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Jim</firstname>
	<surname>Mock</surname>
	<contrib>Reestruturado, regorganizado, e partes atualizadas por </contrib>
      </author>
      <!-- Mar 2000 -->
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Jordan</firstname>
	<surname>Hubbard</surname>
	<contrib>Trabalho original por </contrib>
      </author>
      <author>
	<firstname>Poul-Henning</firstname>
	<surname>Kamp</surname>
      </author>
      <author>
	<firstname>John</firstname>
	<surname>Polstra</surname>
      </author>
      <author>
	<firstname>Nik</firstname>
	<surname>Clayton</surname>
      </author>
    </authorgroup>
    <!-- with feedback from various others -->
  </chapterinfo>

  <title>A Vers&atilde;o Mais Recente</title>

  <sect1 id="cutting-edge-synopsis">
    <title>Sinopse</title>

    <para>O &os; est&aacute; constantemente sendo desenvolvido entre as suas 
      vers&otilde;es.  Para pessoas que querem estar sempre com as &uacute;ltimas novidades, existem 
      uma veriedade de mecanismos que facilitam manter seu sistem sincronizado 
      com os &uacute;ltimos desenvolvimentos.  Esteja avisado&mdash;as &uacute;ltimas novidades 
      n&atilde;o s&atilde;o para todos!  Este cap&iacute;tulo lhe ajudar&aacute; a decidir se voc&ecirc; 
      quer acompanhar o desenvolvimento do sistema, ou permanecer em uma 
      das vers&otilde;es liberadas.</para>

    <para>Ap&oacute;s ler este cap&iacute;tulo, voc&ecirc; saber&aacute;:</para>

    <itemizedlist>
      <listitem><para>As diferen&ccedil;as entre as duas &aacute;rvores de 
      desenvolvimento: &os.stable; e &os.current;.</para>
      </listitem>
      <listitem><para>Como manter seu sistema atualizado com 
	  <application>CVSup</application>,
	  <application>CVS</application>, ou
	  <application>CTM</application>.</para>
      </listitem>
      <listitem><para>Como reconstruir e reinstalar toda a base 
      do sistema com <command>make world</command>.</para>
      </listitem>

    </itemizedlist>

    <para>Antes de ler este cap&iacute;tulo, voc&ecirc; deve:</para>

    <itemizedlist>
      <listitem><para>Configurar adequadamente sua conex&atilde;o de rede (<xref
      linkend="advanced-networking">).</para>
      </listitem>
      <listitem><para>Saber como instalar programas adicionais de terceiros 
        (<xref linkend="ports">).</para></listitem>
    </itemizedlist>
  </sect1>
  
  <sect1 id="current-stable">
    <title>&os.current; vs. &os.stable;</title>
    <indexterm><primary>-CURRENT</primary></indexterm>
    <indexterm><primary>-STABLE</primary></indexterm>

    <para>Existem duas &aacute;rvores de desenvolvimento para o FreeBSD: &os.current; 
      e &os.stable;.  Esta se&ccedil;&atilde;o explicar&aacute; um pouco sobre cada uma e 
      descrever&aacute; como manter seu sistema atualizado em cada &aacute;rvore.  
      &os.current; ser&aacute; discutido primeiro, depois o &os.stable;.</para>

    <sect2 id="current">
      <title>Mantendo-se Atualizado com o &os;</title>

      <para>Enquanto voc&ecirc; l&ecirc; isto, tenha em mente que o &os.current; &eacute; 
	a <quote>&uacute;ltima das &uacute;ltimas</quote> vers&otilde;es de desenvolvimento do &os;.
	Espera-se que os usu&aacute;rios do &os.current; tenham um alto n&iacute;vel de 
	habilidades t&eacute;cnicas, e que possam ser capazes de resolver 
	problemas por si s&oacute;.  Se voc&ecirc; &eacute; novo no &os;, pense duas vezes 
	antes de instalar esta vers&atilde;o.</para>

      <sect3>
	<title>O que &eacute; o &os.current;?</title>
	<indexterm><primary>snapshot</primary></indexterm>

	<para>&os.current; s&atilde;o os &uacute;ltimos fontes trabalhados do &os;.
	  Isto inclui trabalho em progresso, mudan&ccedil;as experimentais, e 
	  mecanismos transacionais que podem ou n&atilde;o estar presentes na 
	  pr&oacute;xima vers&atilde;o original do sistema.  Enquanto muitos 
	  desenvolvedores do &os; compilam o c&oacute;digo fonte dp &os.current; 
	  diariamente, existem per&iacute;odos de tempo em que os fontes n&atilde;o 
	  s&atilde;o compil&aacute;veis.  Estes problemas s&atilde;o resolvidos o mais depressa 
	  poss&iacute;vel, se o &os.current causar ou n&atilde;o um desastre ou trazer  
	  uma funcionalidade muito desejada, isto pode ser uma quest&atilde;o de 
	  que em qual momento voc&ecirc; pegou o c&oacute;digo fonte!</para>
      </sect3>

      <sect3>
	<title>Quem precisa do &os.current;?</title>

	<para>&os.current; &eacute; disponibilizado para 3 grupos 
	  prim&aacute;rios de interesse:</para>

	<orderedlist>
	  <listitem>
	    <para>Membros do grupo do &os; que trabalhem ativamente 
	      em alguma parte da &aacute;rvore dos c&oacute;digos fonte e para quem 
	      tem uma grande necessidade de estar extremamente 
	      <quote>atualizado</quote>.</para>
	  </listitem>

	  <listitem>
	    <para>Membros do grupo do &os; que s&atilde;o testadores ativos, 
	      com disposi&ccedil;&atilde;o de gastar tempo resolvendo problemas para 
	      certificar-se que o &os;current; permane&ccedil;a o mais 
	      utiliz&aacute;vel poss&iacute;vel.  Tamb&eacute;m existem pessoas que desejam 
	      dar pequenas sugest&otilde;es em mudan&ccedil;as e nas dire&ccedil;&otilde;es gerais 
	      do &os;, e submeter corre&ccedil;&otilde;es para implement&aacute;-las.</para>
	  </listitem>

	  <listitem>
	    <para>Aqueles que simplesmente querem observar as coisas, 
	      ou usar os fontes com o prop&oacute;sito de refer&ecirc;ncia 
	      (e.g. para <emphasis>leitura</emphasis>, e n&atilde;o execu&ccedil;&atilde;o).
	      Estas pessoas tamb&eacute;m fazem coment&aacute;rios ocasionais ou 
	      contribuem com c&oacute;digo.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>O que o &os.current; <emphasis>N&atilde;o</emphasis> &eacute;?</title>

	<orderedlist>
	  <listitem>
	    <para>Um atalho para ter um gostinho da vers&atilde;o que est&aacute; 
	      para ser liberada s&oacute; porque voc&ecirc; ouviu falar de alguma 
	      funcionalidade legal que est&aacute; l&aacute; e voc&ecirc; quer ser o 
	      primeiro na sua rua a t&ecirc;-la.  Ser o primeiro a ter 
	      as novas funcionalidades siginifica ser o primeiro a 
	      ter os novos bugs.</para>
	  </listitem>

	  <listitem>
	    <para>Uma maneira r&aacute;pida de pegar corre&ccedil;&otilde;es de bugs.  Qualquer 
	      vers&atilde;o do &os;current; &eacute; pass&iacute;vel de introduzir novos bugs 
	      assim como corrigir os existentes.</para>
	  </listitem>

	  <listitem>
	    <para><quote>Oficialmente suportado</quote>.  N&oacute;s 
	      fazemos o melhor para verdadeiramete ajudar as pessoas 
	      em um dos 3 grupos <quote>leg&iacute;timos</quote> do 
	      &os.current;, mas n&oacute;s simplesmente <emphasis>N&atilde;o temos 
	      tempo</emphasis> para oferecer suporte t&eacute;cnico.  Isto 
	      n&atilde;o &eacute; porque n&oacute;s somos pessoas 
	      mesquinhas e nojentas que n&atilde;o gostam de ajudar os outros 
	      se fossemos nem estariamos fazendo o &os;).  N&oacute;s simplesmente 
	      n&atilde;o podemos responder centenas de mensagens por dia 
	      <emphasis>e</emphasis> trabalhar no FreeBSD!  Entre 
	      melhorar o &os; e responder centenas de mensagens sobre 
	      c&oacute;digo experimental, os desenvolvedores optaram pela 
	      primeira.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>Usando o &os.current;</title>
      
	<indexterm>
	  <primary>-CURRENT</primary>
	  <secondary>using</secondary>
	</indexterm>
	<orderedlist>
	  <listitem>
	    <para>Entre nas listas &a.current.name; e &a.cvsall.name;.  
	      Isto n&atilde;o &eacute; apenas uma boa id&eacute;ia, &eacute; <emphasis>essencial
	      </emphasis>.  Se voc&ecirc; n&atilde;o est&aacute; na lista <emphasis>
	      &a.current.name;</emphasis>, n&atilde;o ver&aacute; os coment&aacute;rios ue 
	      as pessoas est&atilde;o fazendo a respeito do estado atual do 
	      sistema, desta forma voc&ecirc; provavelmente vai acabar 
	      enfrentando um monte de problemas que outros j&aacute; encontraram 
	      e solucionaram.  Ainda mais importante, voc&ecirc; perder&aacute; 
	      boletins importantes que podem ser cr&iacute;ticos para que seu 
	      sistema continue saud&aacute;vel.</para>

	    <para>A lista &a.cvsall.name; permitir&aacute; que voc&ecirc; veja o 
	      <literal>log</literal> de cada mudan&ccedil;a submetida t&atilde;o 
	      logo elas estejam sendo feitas e informa&ccedil;&otilde;es sobre 
	      poss&iacute;veis efeitos colaterais.</para>

	    <para>Para entrar nestas listas, ou qualuer outra dispon&iacute;vel, 
	      v&aacute; em &a.mailman.lists.link; e clique na lista que voc&ecirc; 
	      deseja assinar.  Instru&ccedil;&otilde;es para o restante do procedimento 
	      est&atilde;o dispon&iacute;veis l&aacute; tamb&eacute;m.</para>
	  </listitem>

	  <listitem>
	    <para>Pegue os fontes de um dos <link linkend="mirrors">sites espelho do &os;. 
	      </link>.  Voc&ecirc; pode fazer isso de 
	      duas maneiras:</para>

	    <orderedlist>
              <indexterm>
                <primary><command>cvsup</command></primary>
              </indexterm>
              <indexterm>
                <primary><command>cron</command></primary>
              </indexterm>
              <indexterm>
	        <primary>-CURRENT</primary>
		<secondary>Syncing with <application>CVSup</application></secondary>
	      </indexterm>

	      <listitem>
		<para>Use o programa <link linkend="cvsup">cvsup</link> com 
                  o arquivo <filename>supfile</filename> de nome 
		  <filename>standard-supfile</filename> dispon&iacute;vel em 
                  <filename>/usr/share/examples/cvsup</filename>.
		  Este &eacute; o m&eacute;todo mais recomendado, uma vez que permite a 
		  voc&ecirc; pegar toda a cole&ccedil;&atilde;o uma vez e a partir da&iacute; pegar 
		  apenas as atualiza&ccedil;&otilde;es.  Muitas pessoas executam o 
		  <command>cvsup</command> a partir do <command>cron
		  </command> e mant&eacute;m seus fontes atualizados autom&aacute;ticamente.  
		  Voc&ecirc; precisa customizar o arquivo <filename>supfile
		  </filename> de exemplo, e configurar o <link linkend="cvsup">
		  cvsup</link> para o seu ambiente.</para>
	      </listitem>

              <indexterm>
	        <primary>-CURRENT</primary>
		<secondary>Syncing with CTM</secondary>
	      </indexterm>
	      <listitem>
		<para>Use o aplicativo <application><link
		  linkend="ctm">CTM</link></application>.  Se voc&ecirc; 
		  possui uma p&eacute;ssima conectividade (conex&otilde;es muito caras 
		  ou apenas endere&ccedil;o eletr&ocirc;nico) o <application>CTM
		  </application> &eacute; uma op&ccedil;&atilde;o.  Entretanto, &eacute; um pouco 
		  problem&aacute;tico, podendo te dar arquivos corruptos.  Isto 
		  leva este aplicativo a ser raramente usado, o que 
		  aumenta a chance do mesmo n&atilde;o funcionar por longos 
		  per&iacute;odos de tempo.  Recomendamos o uso do 
		  <application><link linkend="cvsup">CVSup</link></application>
		  para qualquer um que tenha um modem de 9600&nbsp;bps 
		  ou uma conex&atilde;o mais r&aacute;pida.
		</para>
	      </listitem>
	    </orderedlist>
	  </listitem>

	  <listitem>
	    <para>Se voc&ecirc; est&aacute; pegando os fontes para executar, e n&atilde;o 
	      apenas para olhar, ent&atilde;o pegue <emphasis>todo</emphasis> 
	      o &os;current;, e n&atilde;o apenas algumas partes.  A raz&atilde;o 
	      para isto &eacute; que v&aacute;rias partes dos fontes dependem de 
	      atualiza&ccedil;&otilde;es em outros lugares, e tenta compilar apenas 
	      um subconjunto &eacute; uma quase garantia que voc&ecirc; vai ter 
	      problemas.</para>

	  <indexterm>
	    <primary>-CURRENT</primary>
	    <secondary>compiling</secondary>
	  </indexterm>
	    <para>Antes de compilar o &os.current;, leia o arquivo 
	      <filename>Makefile</filename> em <filename>/usr/src</filename>
	      cuidadosamente.  Voc&ecirc; deve executar o <link
	      linkend="makeworld">make world</link> na primeira parte 
	      como parte do processo de atualiza&ccedil;&atilde;o.  Ler o &a.current; 
	      e o arquivo <filename>/usr/src/UPDATING</filename> 
	      manter&aacute; voc&ecirc; atualizado para outros processos de 
	      in&iacute;cio que algumas vezes se fazem necess&aacute;rios ao 
	      caminharmos para uma pr&oacute;xima vers&atilde;o.</para>
	  </listitem>
	      
	  <listitem>
	    <para>Seja ativo! Se voc&ecirc; est&aacute; executando o &os.current;, 
	      queremos saber o que voc&ecirc; tem a dizer sobre ele, 
	      especialmente se voc&ecirc; tem sugest&otilde;es para melhoras ou 
	      conserto para problemas.  Sugest&otilde;es junto com c&oacute;digo 
	      s&atilde;o recebidas de forma muito entusiasmada!</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>
  
    <sect2 id="stable">
      <title>Permanecendo Est&aacute;vel com o &os;</title>

      <sect3>
	<title>O que &eacute; o &os.stable;?</title>
	<indexterm><primary>-STABLE</primary></indexterm>

	<para>&os.stable; &eacute; a nossa &aacute;rvore de desenvolvimento vindas 
	  de vers&otilde;es principais.  Mudan&ccedil;as acontecem nesta &aacute;rvore de 
	  maneira diferente, e com a suposi&ccedil;&atilde;o geral de que foram 
	  previamente feitas no &os.current; em car&aacute;ter de teste.  Esta 
	  <emphasis>ainda</emphasis> &eacute; uma &aacute;rvore de desenvolvimento, 
	  entretanto, e isto pode significar a qualquer momento, os 
	  fontes do &os.stable; podem ou n&atilde;o ser adequados para um 
	  prop&oacute;sito particular.  Esta &eacute; simplesmente outra faixa de 
	  engenharia de desenvolvimento, n&atilde;o uma fonte para usu&aacute;rios 
	  finais.</para>
      </sect3>

      <sect3>
	<title>Quem Precisa do &os.stable;?</title>

	<para>Se voc&ecirc; est&aacute; interessado em acompanhar ou contribuir com 
	  o processo de desenvolvimento do FreeBSD, ent&atilde;o voc&ecirc; deve 
	  considerar o &os.stable;.</para>

	<para>Sendo verdadeiro o fato de que consertos de seguran&ccedil;a 
	  tamb&eacute;m sejam implementados na &aacute;rvore do &os.stable; voc&ecirc; 
	  n&atilde;o <emphasis>precisa</emphasis> acompanhar o &os.stable; 
	  para fazer isso.  Cada boletim de seguran&ccedil;a para o FreeBSD 
	  explica como consertar o problema para cada vers&atilde;o afetada 
	  <footnote><para>Isto n&atilde;o &eacute; completamente verdadeiro.  N&oacute;s 
	    n&atilde;o podemos dar suporte para vers&otilde;es antigas do FreeBSD 
	    para sempre, por favor veja <ulink
  	    url="../../../../security/index.html">http://www.FreeBSD.org/security/</ulink>.</para>
	  </footnote>
	  , e acompanhar uma &aacute;rvore de desenvolvimento inteira apenas 
	  raz&otilde;es de seguran&ccedil;a &eacute; pass&iacute;vel de trazer para a sua m&aacute;quina 
	  uma s&eacute;rie de mudan&ccedil;as indesej&aacute;veis tamb&eacute;m.</para>

	<para>Embora n&oacute;s nos esforcemos para ter certeza de que a &aacute;rvore 
	  &os.stable; compile e execute sempre, isto n&atilde;o pode ser 
	  garantido.  Al&eacute;m disso, enquanto o c&oacute;digo &eacute; escrito no 
	  &os.current; antes de ser incluido no &os.stable;, mais pessoas 
	  executam o &os.stable; do que o &os.current;, ent&atilde;o &eacute; 
	  inevit&aacute;vel que algumas vezes ser&atilde;o encotradas falhas no 
	  &os.stable; que aparentemente n&atilde;o est&atilde;o no &os.current;.</para>

	<para>Por estas raz&otilde;es, n&oacute;s <emphasis>n&atilde;o</emphasis> recomendamos que voc&ecirc; 
	  siga cegamente o &os.stable;, e &eacute; particularmente importante que voc&ecirc; 
	  n&atilde;o atualize qualquer servidor em produ&ccedil;&atilde;o para o &os.stable; sem 
	  antes fazer um teste completo no c&oacute;digo em seu ambiente de 
	  desenvolvimento.</para>

	<para>Se voc&ecirc; n&atilde;o possui recursos para fazer isso n&oacute;s recomendamos 
	  que voc&ecirc; execute a vers&atilde;o <quote>release</quote> mais recente do 
	  FreeBSD, e utlize o mecanismo de atualiza&ccedil;&atilde;o bin&aacute;rio para 
	  se atualizar de <quote>release</quote> em <quote>release</quote>.
	  </para>
      </sect3>

      <sect3>
	<title>Usando o &os.stable;</title>
      
	<indexterm>
	  <primary>-STABLE</primary>
	  <secondary>using</secondary>
	</indexterm>
	<orderedlist>
	  <listitem>
	    <para>Entre na lista &a.stable.name;.  Isto vai te manter 
	      informado sobre as depend&ecirc;ncias de compila&ccedil;&atilde;o que podem 
	      surgir no &os.stable; ou quaisquer outros problemas 
	      que necessitem de aten&ccedil;&atilde;o especial.  Os desenvolvedores 
	      far&atilde;o an&uacute;ncios nesta lista quando estiverem vendo algum 
	      conserto ou atualiza&ccedil;&atilde;o controversa, oferecendo aos 
	      usu&aacute;rios a chance de responder se possuem algo a dizer 
	      a respeito desta mudan&ccedil;a proposta.</para>

	    <para>A lista &a.cvsall.name; permitir&aacute; que voc&ecirc; acompanhe 
	      a entrada de submiss&atilde;o de <literal>log</literal> para cada 
	      mudan&ccedil;a na medida que forem sendo feitas e informa&ccedil;&otilde;es 
	      pertinentes sobre poss&iacute;veis efeitos colaterais.</para>

	    <para>Para entrar nestas listas, ou uma das outras 
	      dispon&iacute;veis, v&aacute; em &a.mailman.lists.link; e clique na 
	      lista em que deseja se cadastrar.  Instru&ccedil;&otilde;es para o 
	      restante do procedimento est&atilde;o l&aacute;.</para>
	  </listitem>

	  <listitem>
	    <para>Se voc&ecirc; est&aacute; instalando um novo sistema e quer que 
	      ele seja o mais est&aacute;vel poss&iacute;vel, voc&ecirc; pode simplesmente 
	      pegar o &uacute;ltimo c&oacute;digo compilado de <ulink
	      url="ftp://releng4.FreeBSD.org/pub/FreeBSD/"></ulink>
	      e instalar como qualquer outra release.</para>

	    <para>Se voc&ecirc; j&aacute; est&aacute; executando uma vers&atilde;o anterior do &os; 
	      e deseja atualiz&aacute;-la atrav&eacute;s dos fontes voce pode fazer 
	      isso com facilidade a partir dos 
	      <link linkend="mirrors">sites espelho</link> do &os;.  Isto 
	      pode ser feito de duas maneiras:</para>

	    <orderedlist>
	      <indexterm>
		<primary><command>cvsup</command></primary>
	      </indexterm>
	      <indexterm>
		<primary><command>cron</command></primary>
	      </indexterm>
	      <indexterm>
	        <primary>-STABLE</primary>
		<secondary>syncing with <application>CVSup</application></secondary>
	      </indexterm>
	      <listitem>
		<para>Use o programa <link linkend="cvsup">cvsup</link> com 
                  o arquivo <filename>supfile</filename> de nome <filename>stable-supfile</filename>
                  do diret&oacute;rio 
                  <filename>/usr/share/examples/cvsup</filename>.
		  Este &eacute; o m&eacute;todo mais recomendado, uma vez que 
		  permite que voc&ecirc; pegue toda a cole&ccedil;&atilde;o de fontes 
		  uma &uacute;nica vez e, da&iacute; em diante, pegar somente 
		  o que foi modificado.  Muitas pessoas executam o 
		  <command>cvsup</command> a partir do <command>cron</command> 
		  para manter seus fontes atualizados automaticamente.  Voc&ecirc; 
		  precisa customizar o arquivo <filename>supfile</filename> 
		  de exemplo acima, e configurar o 
		  <link linkend="cvsup">cvsup</link> para o seu 
		  ambiente.</para>
	      </listitem>

	      <indexterm>
	        <primary>-STABLE</primary>
		<secondary>syncing with CTM</secondary>
	      </indexterm>
	      <listitem>
		<para>Use o <application><link
		  linkend="ctm">CTM</link></application>.  Se voc&ecirc; 
		  n&atilde;o possui uma conex&atilde;o r&aacute;pida e barata com a Internet, 
		  este &eacute; o m&eacute;todo que voc&ecirc; deve considerar.
		  </para>
	      </listitem>
	   </orderedlist>
	 </listitem>

	  <listitem>
	    <para>Essencialmente, se voc&ecirc; precisa de acesso r&aacute;pido 
	      sob demanda aos fontes e a banda de comunica&ccedil;&atilde;o n&atilde;o 
	      &eacute; problema, use o <command>cvsup</command> ou o 
	      <command>ftp</command>.  Se n&atilde;o, use o 
	      <application>CTM</application>.</para>
	  </listitem>

	  <indexterm>
	    <primary>-STABLE</primary>
	    <secondary>compiling</secondary>
	  </indexterm>
	  <listitem>
	    <para>Antes de compilar o &os.stable;, leia o arquivo 
	    <filename>Makefile</filename> em <filename>/usr/src</filename>
	    cuidadosamente.  Voc&ecirc; deve executar um <link
	    linkend="makeworld">make world</link> na primeira vez como 
	    parte do processo de atualiza&ccedil;&atilde;o.  A leitura da lista &a.stable; e 
	    do arquivo <filename>/usr/src/UPDATING</filename> manter&aacute; voc&ecirc; 
	    atualizado em outros processos iniciais que algumas vezes 
	    podem ser necess&aacute;rios em mover-se para a pr&oacute;xima 
	    release.</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="synching">
    <title>Sincronizando Seus Fontes</title>
    
    <para>Existem v&aacute;rias maneiras de usar uma conex&atilde;o Internet 
      (ou de email) para ficar atualizado com qualquer &aacute;rea dos 
      fontes do projeto &os;, ou todas as &aacute;reas, dependendo do seu 
      interesse.  Os servi&ccedil;os prim&aacute;rios que oferecemos s&atilde;o 
      <link linkend="anoncvs">CVS An&ocirc;nimo
      </link>, <link linkend="cvsup">CVSup</link>, e <link
      linkend="ctm">CTM</link>.</para>

    <warning>
      <para> Enquanto &eacute; poss&iacute;vel atualizar apenas partes da sua &aacute;rvore 
	dos fontes, o &uacute;nico procedimento de atualiza&ccedil;&atilde;o com suporte &eacute; 
	o de atualizar toda a &aacute;rvore e recompilar os fontes de n&iacute;vel de 
	usu&aacute;rio (i.e., todos os programas que s&atilde;o executados no espa&ccedil;o 
	do usu&aacute;rio, tais como aqueles em <filename>/bin</filename> e 
        <filename>/sbin</filename>) e fontes do <foreignphrase>kernel
	</foreignphrase>.  Atualizar apenas parte da sua &aacute;rvore de 
	fontes, ou apenas os fontes a n&iacute;vel de usu&aacute;rio, frequentemente 
	resultar&aacute; em problemas.  Estes problemas podem variar de erros 
	de compila&ccedil;&atilde;o a panico no <foreignphrase>kernel</foreignphrase> 
	ou corrup&ccedil;&atilde;o de dados.</para>
    </warning>

    <indexterm><primary>anonymous CVS</primary></indexterm>
    <para><application>CVS An&ocirc;nimo</application> e
      <application>CVSup</application> usam o modelo <emphasis>pull</emphasis>
      de atualiza&ccedil;&atilde;o dos fontes.  No caso do <application>CVSup</application> o 
      usu&aacute;rio (ou um <literal>script</literal> <command>cron</command>) invocar 
      o programa <command>cvsup</command>, e ele interagir com um servidor 
      <command>cvsupd</command> em algum lugar para fazer com que seus arquivos fiquem 
      atualizados.  As atualiza&ccedil;&otilde;es que voc&ecirc; recebe s&atilde;o as mais recentes e voc&ecirc; 
      as obt&eacute;m, e somente quando, voc&ecirc; as quer.  Voc&ecirc; pode facilmente 
      restringir suas atualiza&ccedil;&otilde;es &agrave; arquivos ou diret&oacute;rios espec&iacute;ficos que s&atilde;o 
      do seu interesse.  As atualiza&ccedil;&otilde;es s&atilde;o geradas rapidamente pelo servidor, 
      de acordo com o que voc&ecirc; tem o com o que voc&ecirc; quer ter.  
      <application>CVS An&ocirc;nimo</application> &eacute; um pouco mais simples do que o 
      <application>CVSup</application>, sendo apenas uma extens&atilde;o do 
      <application>CVS</application> que permite puxar as mudan&ccedil;as diretamente 
      de um reposit&oacute;rio CVS.  <application>CVSup</application> pode fazer 
      isto de maneira bem mais eficiente, mas o <application>CVS An&ocirc;nimo
      </application> &eacute; mais f&aacute;cil de usar.</para>

    <indexterm>
      <primary><application>CTM</application></primary>
    </indexterm>
    <para>O <application>CTM</application>, por outro lado, n&atilde;o compara 
      interativamente os fontes que voc&ecirc; tem com os que est&atilde;o no arquivo 
      principal ou com os que foram puxados.  Ao inv&eacute;s disso, um <literal>
      script</literal> que identifica as mudan&ccedil;as nos arquivos desde a 
      &uacute;ltima vez que o <application>CTM</application> foi usado &eacute; executado 
      v&aacute;rias vezes por dia na m&aacute;quina CTM principal, as mudan&ccedil;as s&atilde;o 
      comprimidas, estampadas com um n&uacute;mero sequencial e codificadas para 
      transmiss&atilde;o por correio eletr&ocirc;nico (apenas em caracteres ASCII 
      imprim&iacute;veis).  Uma vez recebidos, estes <quote>deltas CTM</quote> 
      podem ser manipulados pelo utilit&aacute;rio &man.ctm.rmail.1; que 
      decodificar&aacute; automaticamente, verificar&aacute; e aplicar&aacute; as mudan&ccedil;as nos 
      fontes do usu&aacute;rio.  Este processo &eacute; bem mais eficiente do que o 
      <application>CVSup</application>, e n&atilde;o sobrecarrega o nosso 
      servidor uma vez que o modelo <emphasis>push</emphasis> ao inv&eacute;s do 
      <emphasis>pull</emphasis> &eacute; utilizado.</para>

    <para>Existem alguns contratempos, &eacute; claro.  Se voc&ecirc; inadivertidamente 
      apagar parte dos seus fontes, o <application>CVSup</application> 
      detectar&aacute; e reconstruir&aacute; as partes denificadas para voc&ecirc;.  O 
      <application>CTM</application> n&atilde;o far&aacute; isto, se voc&ecirc; apagar alguma 
      parte da sua &aacute;rvore de fontes (e n&atilde;o possuir c&oacute;pia de seguran&ccedil;a) 
      ent&atilde;o voc&ecirc; vai ter que come&ccedil;ar do zero (da mais recente <quote>
      base delta</quote> do CVS) e reconstruir tudo com o <application>
      CTM</application> ou, com o <application>CVS An&ocirc;nimo</application>, 
      simplesmente apagar os bits problem&aacute;ticos e resincronizar.</para>
  </sect1>

  <sect1 id="makeworld">
    <title>Usando o <command>make world</command></title>

    <indexterm>
      <primary><command>make world</command></primary>
    </indexterm>
    <para>Uma vez sincronizados os fontes locais com uma vers&atilde;o particular 
      do &os; (&os.stable;, &os.current;, e assim por diante) voc&ecirc; pode 
      usar a &aacute;rvore dos fontes para reconstruir o sistema.</para>

    <warning>
      <title>Tire uma C&oacute;pia de Seguran&ccedil;a</title>

      <para>Nunca &eacute; demais falar como &eacute; importante tirar uma c&oacute;pia de 
	seguran&ccedil;a do seu sistema <emphasis>antes</emphasis> de fazer 
	isso.  Enquanto que reconstruir tudo &eacute; (se voc&ecirc; seguir estas 
	instru&ccedil;&otilde;es) uma tarefa f&aacute;cil, inevitavelmente existir&atilde;o 
	ocasi&otilde;es em que voc&ecirc; cometer&aacute; erros, ou quando erros cometidos 
	por outros na &aacute;rvore dos fontes fazendo com que seu sistema 
	n&atilde;o inicialize.</para>

      <para>Tenha certeza de que voc&ecirc; tirou uma c&oacute;pia de seguran&ccedil;a.  E 
	tenha um disquete de boot em m&atilde;os.  Voc&ecirc; provavelmente nunca vai 
	precisar utliz&aacute;-lo, mas &eacute; melhor previnir do que remediar!</para>
    </warning>

    <warning>
      <title>Inscreva-se na Lista de Discuss&atilde;o Certa</title>

      <indexterm><primary>mailing list</primary></indexterm>
      <para>O &os.stable; e &os.current; est&atilde;o, por sua natureza, 
	<emphasis>em desenvolvimento</emphasis>.  Pessoas que 
	contribuem com o &os; s&atilde;o humanas, e erros acontecem 
	de vez em quando.</para>

      <para>Algumas vezes estes erros podem ser um pouquinho nocivos, 
	apenas fazendo com que seu sistema imprima uma mensagem de 
	diagn&oacute;stico de alerta.  Ou as mudan&ccedil;as podem ser catastr&oacute;ficas, 
	fazendo com que seu sistema n&atilde;o inicialize mais ou destrua seus 
	sistemas de arquivos (ou pior).</para>

      <para>Se acontecerem problemas como estes, uma <quote>nota</quote> 
	&eacute; postada na lista apropriada, explicando a natureza do problema e 
	quais sistemas s&atilde;o afetados por ele.  E um an&uacute;ncio <quote>tudo 
	limpo</quote> &eacute; postado quando o problema foi solucionado.</para>

      <para>Se voc&ecirc; tentar acompanhar o &os.stable; ou o &os.current; e n&atilde;o 
	ler a &a.stable; ou a &a.current; respectivamente, ent&atilde;o voc&ecirc; 
	est&aacute; ca&ccedil;ando problemas.</para>
    </warning>

    <sect2>
      <title>Leia o Arquivo <filename>/usr/src/UPDATING</filename></title>

      <para>Antes de fazer qualquer coisa, leia o arquivo 
	<filename>/usr/src/UPDATING</filename> (ou o arquivo equivalente 
	sempre que voc&ecirc; possuir uma c&oacute;pia dos c&oacute;digos fonte).  Este arquivo 
	pode conter informa&ccedil;&otilde;es importantes a respeito de problemas que 
	voc&ecirc; pode encontrar, ou especifica a ordem na qual voc&ecirc; deve 
	executar certos comandos.  Se o arquivo <filename>UPDATING</filename> 
	contradizer algo que voc&ecirc; ler aqui, ele tem precedencia.</para>

      <important>
	<para>Ler o <filename>UPDATING</filename> n&atilde;o substitu&iacute; 
	  a inscri&ccedil;&atilde;o e acompanhamento da lista de discuss&atilde;o correta, 
	  como mencionado anteriormente.  Os dois requisitos s&atilde;o complementares, 
	  n&atilde;o exclusivos.</para>
      </important>
    </sect2>

    <sect2>
      <title>Verifique o <filename>/etc/make.conf</filename></title>
      <indexterm>
        <primary><filename>make.conf</filename></primary>
      </indexterm>

      <para>Examine os arquivos 
	<filename>/etc/defaults/make.conf</filename> e
	<filename>/etc/make.conf</filename>.  O primeiro cont&eacute;m algumas 
	defini&ccedil;&otilde;es padr&atilde;o &ndash; muitas comentadas.  Para fazer uso 
	delas quando voc&ecirc; reconstruir seu sistema dos fontes, adicione-as 
	ao arquivo <filename>/etc/make.conf</filename>.  Tenha em mente 
	que qualquer coisa que voc&ecirc; adicione ao arquivo <filename>
	/etc/make.conf</filename> tamb&eacute;m &eacute; usado sempre que voc&ecirc; executar 
	o comando <command>make</command>, ent&atilde;o &eacute; uma boa id&eacute;ia configur&aacute;-lo 
	para alguma coisa sens&iacute;vel para seu sistema.</para>

      <para>Um usu&aacute;rio t&iacute;pico provavelmente copiar&aacute; as linhas 
	<makevar>CFLAGS</makevar> e
	<makevar>NOPROFILE</makevar> encontradas em 
	<filename>/etc/defaults/make.conf</filename> para 
	<filename>/etc/make.conf</filename> e remover&aacute; seus coment&aacute;rios.</para>

      <para>Examine outras defini&ccedil;&otilde;es (<makevar>COPTFLAGS</makevar>, 
	<makevar>NOPORTDOCS</makevar> e assim por diante) 
	e decida se elas s&atilde;o relevantes para voc&ecirc;.<para>
    </sect2>

    <sect2>
      <title>Atualize os Arquivos em <filename>/etc</filename></title>

      <para>O diret&oacute;rio <filename>/etc</filename> cont&eacute;m grande parte da 
	informa&ccedil;&atilde;o de configura&ccedil;&atilde;o do seu sistema, assim como <literal>
	scripts</literal> que s&atilde;o executados na inicializa&ccedil;&atilde;o do sistema.  Alguns 
	destes <literal>scripts</literal> mudam de vers&atilde;o para vers&atilde;o do 
	FreeBSD.</para>

      <para>Alguns dos arquivos de configura&ccedil;&atilde;o tamb&eacute;m s&atilde;o usados diariamente 
	na execu&ccedil;&atilde;o do sistema.  Particularmente, o 
	<filename>/etc/group</filename>.</para>

      <para>Existiram ocasi&otilde;es em que algumas partes da instala&ccedil;&atilde;o do 
        <quote>make world</quote> esperava encontrar certos nomes de 
	usu&aacute;rios ou grupos no sistema.  Ao fazer uma atualiza&ccedil;&atilde;o &eacute; 
	bem prov&aacute;vel que estes usu&aacute;rios ou grupos n&atilde;o existissem.  Isto 
	causava problemas na atualiza&ccedil;&atilde;o.</para>

      <para>Um exemplo recente foi quando o usu&aacute;rio <username>smmsp
	</username> foi adicionado.  Os usu&aacute;rios tiveram falhas no 
	processo de instala&ccedil;&atilde;o quando o &man.mtree.8; tentava criar 
	o arquivo <filename>/var/spool/clientmqueue</filename>.</para>

      <para>A solu&ccedil;&atilde;o &eacute; examinar o arquivo 
	<filename>/usr/src/etc/group</filename> e comparar com o seu 
	arquivo de grupos.  Se existirem grupos no arquivo novo que n&atilde;o 
	existirem no seu ent&atilde;o copie-os.  Similarmente, voc&ecirc; deve 
	renomear quaisquer grupos no <filename>/etc/group</filename> que 
	possuirem o mesmo GID mas um nome diferente dos que est&atilde;o em 
	<filename>/usr/src/etc/group</filename>.</para>

      <para>Desde o 4.6-RELEASE voc&ecirc; pode executar o &man.mergemaster.8;  
	antes da constru&ccedil;&atilde;o do sistema com a op&ccedil;&atilde;o <option>-p</option>.  
	Isto comparar&aacute; apenas aqueles arquivos que s&atilde;o essenciais para o 
	sucesso do <maketarget>buildworld</maketarget> ou <maketarget>
	installworld</maketarget>.  Se a sua vers&atilde;o antiga do <command>
	mergemasger</command> n&atilde;o suportar a op&ccedil;&atilde;o <option>-p</option>, 
	use a vers&atilde;o mais nova na &aacute;rvore dos fontes ao execut&aacute;-lo pela 
	primeira vez:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/usr.sbin/mergemaster</userinput>
&prompt.root; <userinput>./mergemaster.sh -p</userinput></screen>

      <tip>
	<para>Se voc&ecirc; est&aacute; se sentindo particularmente paran&oacute;ico, voc&ecirc; pode 
	  checar seu sistema para ver quais arquivos foram possuidos pelo 
	  grupo que voc&ecirc; est&aacute; renomeando ou apagando:</para>

	<screen>&prompt.root; <userinput>find / -group <replaceable>GID</replaceable> -print</userinput></screen>

	<para>mostrar&aacute; tdos os arquivos pertencidos pelo grupo 
	  <replaceable>GID</replaceable> (que pode ser um nome de grupo 
	  ou um ID num&eacute;rico de grupo).</para>
      </tip>
    </sect2>

    <sect2 id="makeworld-singleuser">
      <title>V&aacute; para o Modo Mono Usu&aacute;rio</title>
      <indexterm><primary>single-user mode</primary></indexterm>

      <para>Voc&ecirc; pode querer compilar o sistema no modo mono usu&aacute;rio.  
	Sem mencionar o benef&iacute;cio &oacute;bvio de fazer com que as coisas 
	andem mais r&aacute;pido, a reinstala&ccedil;&atilde;o do sistema tocar&aacute; em v&aacute;rios 
	arquivos de sistema importantes, todos os bin&aacute;rios padr&atilde;o de 
	sistema, bibliotecas, arquivos de inclus&atilde;o e assim por diante.  
	Modific&aacute;-los com o sistema no ar (particularmente se voc&ecirc; possuir 
	usu&aacute;rios ativos neste per&iacute;odo) &eacute; ca&ccedil;ar problema.</para>

      <indexterm><primary>multi-user mode</primary></indexterm>
      <para>Outro m&eacute;todo &eacute; compilar o sistema em modo multi-usu&aacute;rio, e ent&atilde;o 
	ir para o modo mono usu&aacute;rio para a instala&ccedil;&atilde;o.  Se voc&ecirc; quer fazer 
	desta maneira, simplesmente siga os passos a seguir at&eacute; que a 
	constru&ccedil;&atilde;o do sistema tenha sido completada.  Voc&ecirc; pode deixar para 
	ir para o modo mono usu&aacute;rio em uma outra hora at&eacute; que voc&ecirc; tenha que 
	fazer o <maketarget>installkernel</maketarget> ou o 
	<maketarget>installworld</maketarget>.</para>

      <para>Como super usu&aacute;rio, voc&ecirc; pode executar:</para>

      <screen>&prompt.root; <userinput>shutdown now</userinput></screen>

      <para>de um sistema em execu&ccedil;&atilde;o, que ir&aacute; para o modo mono usu&aacute;rio. 
	</para>

      <para>Alternativamente, reinicialize o sistema, e na linha de comando, 
        entre com a op&ccedil;&atilde;o <option>-s</option>.  O sistema iniciar&aacute; em modo 
	mono usu&aacute;rio.  Na linha de comando execute:</para>

      <screen>&prompt.root; <userinput>fsck -p</userinput>
&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>swapon -a</userinput></screen>

      <para>Isto verifica todos os sistemas de arquivo, remonta o 
	<filename>/</filename> para leitura/escrita, monta todos os outros 
	sistemas de arquivo UFS referenciados em <filename>/etc/fstab
	</filename> e liga o swap.</para>


        <note>
          <para>Se o seu rel&oacute;gio de CMOS est&aacute; configurado para a hora local 
	    e n&atilde;o para GMT (isto &eacute; verdadeiro se a sa&iacute;da do comando &man.date.1; 
	    n&atilde;o mostrar a zona e a hora corretamente), voc&ecirc; pode ter que 
	    executar o seguinte comando:</para>
<screen>&prompt.root; <userinput>adjkerntz -i</userinput></screen>

          <para>Isto ceritificar&aacute; que as suas configura&ccedil;&otilde;es locais de zona/tempo 
	    sejam configuradas corretamente &mdash; sem isto, voc&ecirc; pode ter 
	    alguns problemas mais tarde.
          </para>
        </note>

    </sect2>

    <sect2>
      <title>Remova o <filename>/usr/obj</filename></title>

      <para>Na medida em que partes do sistema v&atilde;o sendo reconstruidas 
	s&atilde;o colocadas em diret&oacute;rios que (por padr&atilde;o) est&atilde;o abaixo de 
	<filename>/usr/obj</filename>.  A sombra daqueles que est&atilde;o em 
	<filename>/usr/src</filename>.</para>

      <para>Voc&ecirc; pode acelerar o processo do <quote>make world</quote>, e
	poss&iacute;velmente evitar algumas dores de cabe&ccedil;a de depend&ecirc;ncia 
	removendo este diret&oacute;rio.</para>

      <para>Alguns arquivos abaixo de <filename>/usr/obj</filename> podem 
	ter a op&ccedil;&atilde;o imut&aacute;vel configurada (veja &man.chflags.1; para mais 
	informa&ccedil;&otilde;es) que deve ser removida antes.</para>

      <screen>&prompt.root; <userinput>cd /usr/obj</userinput>
&prompt.root; <userinput>chflags -R noschg *</userinput>
&prompt.root; <userinput>rm -rf *</userinput></screen>
    </sect2>

    <sect2>
      <title>Recompile o Fonte</title>

      <sect3>
	<title>Gravando a Sa&iacute;da</title>

	<para>&Eacute; uma boa id&eacute;ia gravar a sa&iacute;da que voc&ecirc; tem do comando 
	  &man.make.1; em outro arquivo.  Se alguma coisa der errado 
	  voc&ecirc; ter&aacute; uma c&oacute;pia da mensagem de erro.  Enquanto isto n&atilde;o 
	  possa te ajudar a diagnosticar o que deu errado, pode ajudar 
	  outros se voc&ecirc; postar seu problema em uma das listas de 
	  discuss&atilde;o do &os;.</para>

	<para>A maneira mais f&aacute;cil de fazer isso &eacute; usar o comando 
	  &man.script.1;, com um par&acirc;metro que especifica o nome do 
	  arquivo onde toda a sa&iacute;da ser&aacute; gravada.  Voc&ecirc; pode fazer isto 
	  imediatamente antes de reconstruir todo o sistema, e ent&atilde;o 
	  digitar <userinput>exit</userinput> quando o processo 
	  terminar.</para>

	<screen>&prompt.root; <userinput>script /var/tmp/mw.out</userinput>
Script started, output file is /var/tmp/mw.out	 
&prompt.root; <userinput>make TARGET</userinput>
<emphasis>&hellip; compile, compile, compile &hellip;</emphasis>	  
&prompt.root; <userinput>exit</userinput>
Script done, &hellip;</screen>

	<para>Se voc&ecirc; fizer isto, <emphasis>n&atilde;o</emphasis> grave a sa&iacute;da 
	  no diret&oacute;rio <filename>/tmp/</filename>.  Este diret&oacute;rio pode 
	  ser apagado na pr&oacute;xima vez que voc&ecirc; reinicializar o sistema.  
	  Um lugar melhor para gravar &eacute; <filename>/var/tmp/</filename> 
	  (como no exemplo anterior) ou no diret&oacute;rio inicial do 
	  <username>root</username>.</para>
      </sect3>

      <sect3 id="make-buildworld">
	<title>Compilando a Base do Sistema</title>

	<para>Voc&ecirc; deve estar no diret&oacute;rio:<filename>/usr/src</filename>
	  </para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>

	<para>(a n&atilde;o ser que, claro, seu c&oacute;digo fonte esteja em outro lugar, 
	  neste caso v&aacute; para este diret&oacute;rio).</para>
	<indexterm><primary><command>make</command></primary></indexterm>

	<para>Para reconstruir todo o seu sistema use o comando &man.make.1;  Este 
	  comando l&ecirc; as instru&ccedil;&otilde;es do arquivo <filename>Makefile</filename>, 
	  que descreve como os programas que comp&otilde;em o &os; devem ser 
	  recompilados, a ordem em que isto deve acontecer, e assim por 
	  diante.</para>

	<para>O formato geral da linha de comando que voc&ecirc; digitar&aacute; 
	  &eacute; a seguinte:</para>

	<screen>&prompt.root; <userinput>make -<replaceable>x</replaceable> -D<replaceable>VARIABLE</replaceable> <replaceable>target</replaceable></userinput></screen>

	<para>Neste exemplo, <option>-<replaceable>x</replaceable></option>
	  &eacute; a op&ccedil;&atilde;o que voc&ecirc; deve passar para o &man.make.1;.  Veja a 
	  p&aacute;gina de manual do &man.make.1; para exemplos de op&ccedil;&otilde;es que 
	  voc&ecirc; pode passar.</para>

	<para><option>-D<replaceable>VARIABLE</replaceable></option>
	  passa uma vari&aacute;vel para o <filename>Makefile</filename>.  O
	  comportamento do <filename>Makefile</filename> &eacute; controlado 
	  por estas vari&aacute;veis.  Estas s&atilde;o as mesmas vari&aacute;veis configuradas 
	  no <filename>/etc/make.conf</filename>, e isto &eacute; um outro modo 
	  de configur&aacute;-las.</para>

	<screen>&prompt.root; <userinput>make -DNOPROFILE <replaceable>target</replaceable></userinput></screen>

	<para>&eacute; outra maneira de especificar bibliotecas que n&atilde;o devem 
	  ser compiladas, e &eacute; o mesmo que a linha</para>

	<programlisting>NOPROFILE=    true 	#    Avoid compiling profiled libraries</programlisting>

	<para>no arquivo <filename>/etc/make.conf</filename>.</para>

	<para><replaceable>target</replaceable> diz ao &man.make.1; o que 
	  voc&ecirc; quer fazer.  Cada <filename>Makefile</filename> define um 
	  n&uacute;mero diferente de <quote>targets</quote>, e a sua escolha 
	  determina o que acontece.</para>

	<para>Alguns <quote>targets</quote> s&atilde;o listados no arquivo 
	  <filename>Makefile</filename>, mas n&atilde;o foram feitos para que 
	  voc&ecirc; os execute.  Eles s&atilde;o usados pelo processo de compila&ccedil;&atilde;o 
	  nos passos necess&aacute;rios para recompilar o sistema em v&aacute;rios 
	  sub passos.</para>

	<para>Na maioria das vezes voc&ecirc; n&atilde;o vai precisar passar qualquer 
	    par&acirc;metro para o &man.make.1;, ent&atilde;o sua linha de comando 
	    deve ficar parecida com:</para>

	<screen>&prompt.root; <userinput>make <replaceable>target</replaceable></userinput></screen>

	<para>Desde a vers&atilde;o 2.2.5 do &os; (na verdade, primeiro foi 
	  criado na &aacute;rvore &os.current;, e depois reintroduzida no 
	  &os.stable; entre a 2.2.2 e 2.2.5) o <quote>target</quote> 
	  <maketarget>world</maketarget> foi dividido em dois: 
	  <maketarget>buildworld</maketarget> e
	  <maketarget>installworld</maketarget>.</para>

	<para>Como implicam os nomes, <maketarget>buildworld</maketarget>
	  compila uma nova &aacute;rvore debaixo de <filename>/usr/obj</filename>,
	  e <maketarget>installworld</maketarget> instala esta &aacute;rvore na 
	  m&aacute;quina.</para>

	<para>Isto &eacute; muito &uacute;til por duas raz&otilde;es.  Primeiro, permite 
	  que voc&ecirc; fa&ccedil;a uma recompila&ccedil;&atilde;o segura, sabendo que os componentes 
	  do sistema que est&atilde;o em execu&ccedil;&atilde;o n&atilde;o ser&atilde;o afetados. A 
	  compila&ccedil;&atilde;o &eacute; <quote>self hosted</quote>.  Por causa disso, voc&ecirc; 
	  pode seguramente executar o <maketarget>buildworld</maketarget> 
	  em uma m&aacute;quina em execu&ccedil;&atilde;o em modo multi usu&aacute;rio sem medo de 
	  efeitos colaterais.  Entretanto, ainda &eacute; recomend&aacute;vel que voc&ecirc;  
	  execute o <maketarget>installworld</maketarget> em modo mono 
	  usu&aacute;rio.</para>

	<para>Segundo, permite que voc&ecirc; use NFS para atulizar multiplas 
	  m&aacute;quinas na sua rede.  Se voc&ecirc; possui tr&ecirc;s m&aacute;quinas, 
	  <hostid>A</hostid>, <hostid>B</hostid> e <hostid>C</hostid> que voc&ecirc; quer 
	  atualizar, execute o <command>make buildworld</command> e <command>
	  make installworld</command> no <hostid>A</hostid>.  <hostid>B</hostid> e 
	  <hostid>B</hostid> e <hostid>C</hostid> devem montar atrav&eacute;s de NFS o 
	  <filename>/usr/src</filename> e <filename>/usr/obj</filename> do 
	  <hostid>A</hostid>, e ent&atilde;o voc&ecirc; pode executar o <command>make installworld
	  </command> para instalar o resultado da compila&ccedil;&atilde;o nas maquinas 
	  <hostid>B</hostid> e <hostid>C</hostid>.</para>

	<para>Embora o <literal>target</literal> <maketarget>world</maketarget> 
	  ainda exista, voc&ecirc; &eacute; fortemente encorajado a n&atilde;o us&aacute;-lo.</para>

	<para>Execute</para>

	<screen>&prompt.root; <userinput>make buildworld</userinput></screen>
 
        <para>Agora &eacute; poss&iacute;vel especificar a op&ccedil;&atilde;o <option>-j</option> para o 
          <command>make</command>, que far&aacute; com que ele gere v&aacute;rios processos 
	  simult&acirc;neos.  Isto &eacute; mais &uacute;til em m&aacute;quinas com multiplas CPUs.  Entretanto, 
	  uma vez que muito do processo de compila&ccedil;&atilde;o utiliza mais IO do que CPU, 
	  isto tamb&eacute;m &eacute; &uacute;til em m&aacute;quinas com apenas um processador.</para>

	<para>Em uma m&aacute;quina t&iacute;pica de uma CPU voc&ecirc; deve executar:</para>
	  
	  <screen>&prompt.root; <userinput>make -j4 buildworld</userinput></screen>

	<para>&man.make.1; ter&aacute; 4 processos rodando ao mesmo tempo.  Evid&ecirc;ncias 
	  emp&iacute;ricas postadas nas listas de discuss&atilde;o mostram que isto resulta 
	  em benef&iacute;cios de melhora de performance.</para>

	<para>Se voc&ecirc; tem uma m&aacute;quina com v&aacute;rios procesadores e est&aacute; usando um 
	  um <foreignphrase>kernel</foreignphrase> configurado para SMP, tente 
	  valores entre 6 e 10 e veja como eles aumentam a velocidade.</para>

	<para>Saiba que isto &eacute; um tanto quando experimental, e envio de novos 
	  c&oacute;digos para a &aacute;rvore de fontes pode causar um n&atilde;o funcionamento desta 
	  caracter&iacute;stica.  Se a compila&ccedil;&atilde;o do sistema falhar ao usar este 
	  par&acirc;metro tente novamente sem ele antes de reportar problemas.</para>
      </sect3>
      
      <sect3>
	<title>Tempos</title>
	<indexterm>
	  <primary><command>make world</command></primary>
	  <secondary>timings</secondary>
	</indexterm>

	<para>Muitos fatores influenciam no tempo de compila&ccedil;&atilde;o, mas
          atualmente um &pentium;&nbsp;III com 128&nbsp;MB de RAM leva
          aproximadamente duas horas para compilar a &aacute;rvore &os.stable;,
          sem o uso de atalhos ou truques durante o processo.  Uma &aacute;rvore
          do &os.current; levar&aacute; um pouco mais de tempo.</para>
      </sect3>
    </sect2>
    
    <sect2>
      <title>Compile e Instale um Novo Kernel</title>
      <indexterm>
        <primary>kernel</primary>
        <secondary>compiling</secondary>
      </indexterm>

      <para>Para aproveitar ao m&aacute;ximo seu novo sistema voc&ecirc; deve recompilar
        o <foreignphrase>kernel</foreignphrase>.  Isto &eacute; praticamente uma
        necessidade, uma vez que certas estruturas de mem&oacute;rias mudaram, e
        programas como o &man.ps.1; e &man.top.1; n&atilde;o funcionar&atilde;o at&eacute; que
        as vers&otilde;es do <foreignphrase>kernel</foreignphrase> e dos fontes
        sejam as mesmas.</para>

      <para>A maneira mais simples e segura de fazer isto &eacute; recompilar e
        instalar o <foreignphrase>kernel</foreignphrase> baseado no
        arquivo <filename>GENERIC</filename>. Enquanto o <filename>GENERIC
        </filename> n&atilde;o cont&eacute;m todos os dispositivos necess&aacute;rios para o
        seu sistema, ele deve conter tudo que for necess&aacute;rio para
        inicializar de volta seu sistema em modo mono usu&aacute;rio.  Isto &eacute;
        um bom teste para ver se o sistema funciona corretamente.  Ap&oacute;s
        inicializar a partir do <filename>GENERIC</filename> e verificar
        que seu sistema funciona ent&atilde;o voc&ecirc; pode recompilar um novo
        <foreignphrase>kernel</foreignphrase> baseado no seu arquivo de
        configura&ccedil;&atilde;o.</para>

      <para>Se voc&ecirc; est&aacute; atualizando para o &os; 4.0 ou superior ent&atilde;o o
        procedimento antigo de compila&ccedil;&atilde;o do kernel (como descrito em
        <xref linkend="kernelconfig">) est&aacute; defasado.  Ao inv&eacute;s desse
        voc&ecirc; deve executar estes comandos <emphasis>depois</emphasis>
        de ter <link linkend="make-buildworld"> compilado o sistema
        com o <maketarget>buildworld</maketarget>.</link>.</para>

      <note><para>Se voc&ecirc; quer compilar um <foreignphrase>kernel
        </foreignphrase> customizado e j&aacute; possuir um arquivo de
        configura&ccedil;&atilde;o, apenas use <literal>KERNCONF=<replaceable>
        MYKERNEL</replaceable></literal> desta forma:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput>
&prompt.root; <userinput>make installkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput></screen>

<para>No FreeBSD&nbsp;4.2 e anteriores voc&ecirc; deve substituir
          <literal>KERNCONF=</literal> por <literal>KERNEL=</literal>.
          4.2-STABLE anterior a 2 de Fevereiro de 2001 n&atilde;o reconhece
          <literal>KERNCONF=</literal>.</para>
      </note>

      <para>Note que, se voc&ecirc; subiu o <literal>kern.securelevel</literal>
        acima de 1 <emphasis>e</emphasis> configurou o atributo
        <literal>noschg</literal> ou similar no seu arquivo bin&aacute;rio de
        <foreignphrase>kernel</foreignphrase>, ser&aacute; necess&aacute;rio ir para
        o modo mono usu&aacute;rio para usar o <maketarget>installkernel
        </maketarget>.  Caso contr&aacute;rio, voc&ecirc; dever&aacute; ser capaz de executar
        ambos comandos no modo multi usu&aacute;rio sem problemas.  Veja
        &man.init.8; para detalhes a respeito do <literal>kern.securelevel
        </literal> e &man.chflags.1; para detalhes sobre as v&aacute;rias op&ccedil;&otilde;es
        de par&acirc;metros de arquivos.</para>
      <para>Se voc&ecirc; est&aacute; atualizando para uma vers&atilde;o do &os; inferior &agrave;
        4.0 voc&ecirc; deve usar o procedimento antigo de compila&ccedil;&atilde;o do
        <foreignphrase>kernel</foreignphrase>.  Entretanto, &eacute; recomendado
        que voc&ecirc; use a nova vers&atilde;o do &man.config.8;, usando uma linha de
        comando como esta.</para>

      <screen>&prompt.root; <userinput>/usr/obj/usr/src/usr.sbin/config/config <replaceable>KERNELNAME</replaceable></userinput></screen>
    </sect2>

    <sect2>
      <title>Reinicialize no Modo Mono Usu&aacute;rio</title>
      <indexterm><primary>single-user mode</primary></indexterm>

      <para>Voc&ecirc; deve inicializar no modo monousu&aacute;rio para testar
        o funcionamento do novo kernel. Fa&ccedil;a isto seguindo as
        instru&ccedil;&otilde;es desritas em <xref linkend="makeworld-singleuser">.
        </para>
    </sect2>

    <sect2>
      <title>Instale os Novos Bin&aacute;rios do Sistema</title>

      <para>Se voc&ecirc; estiver compilando uma vers&atilde;o do &os; recente o
        bastante para ter usado o <command>make buildworld</command>,
        ent&atilde;o voc&ecirc; deve us&aacute;-lo o <maketarget>installworld
        </maketarget> para instalar os novos bin&aacute;rios do sistema.<para>

      <para>Execute</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput></screen>

      <note>
        <para>Se voc&ecirc; especificou vari&aacute;veis na linha do comando
          <command>make buildworld</command>, voc&ecirc; deve especificar
          as mesmas vari&aacute;veis na linha do comando <command>make
          installworld</command>.  Isto n&atilde;o &eacute; necess&aacute;riamente
          verdadeiro para algumas op&ccedil;&otilde;es; por exemplo, a op&ccedil;&atilde;o
          <option>-j</option> nunca deve ser usada com o
          <maketarget>installworld</maketarget>.</para>

	<para>Por exemplo, se voc&ecirc; executou:</para>

	<screen>&prompt.root; <userinput>make -DNOPROFILE buildworld</userinput></screen>

	<para>voc&ecirc; deve instalar o resultado com:</para>

	<screen>&prompt.root; <userinput>make -DNOPROFILE installworld</userinput></screen>

	<para>sen&atilde;o o sistema tentar&aacute; instalar bibliotecas que
          n&atilde;o foram compiladas durante o comando <command>make buildworld
          </command>.</para>
      </note>
    </sect2>

    <sect2>
      <title>Atualize os Arquivos n&atilde;o Atualizados pelo <command>make world</command></title>
      
      <para>Recompilar todo o sistema n&atilde;o atualizar&aacute; certos diret&oacute;rios
        (em particular, <filename>/etc</filename>, <filename>/var</filename>
        e <filename>/usr</filename>) com arquivos de configura&ccedil;&atilde;o novos
        ou modificados.</para>

      <para>A maneira mais simples de atualizar estes arquivos e usar
        o &man.mergemaster.8;, embora seja poss&iacute;vel fazer isto
        manualmente se voc&ecirc; preferir.  Independente da maneira que voc&ecirc;
        escolha, esteja certo de ter uma c&oacute;pia de seguran&ccedil;a do
        diret&oacute;rio <filename>/etc</filename> caso algo saia errado.</para>

    <sect3 id="mergemaster">
      <sect3info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Contribui&ccedil;&atilde;o de </contrib>
	  </author>
	</authorgroup>
      </sect3info>
      <title><command>mergemaster</command></title>
        <indexterm><primary><command>mergemaster</command></primary></indexterm>

      <para>O utilit&aacute;rio &man.mergemaster.8; &eacute; um <literal>script</literal>
        Bourne que ajudar&aacute; voc&ecirc; a determinar as diferen&ccedil;as entre seus
        arquivos de configura&ccedil;&atilde;o em <filename>/etc</filename>, e os arquivos
        de configura&ccedil;&atilde;o na &aacute;rvore dos fontes em <filename>/usr/src/etc
        </filename>.  Esta &eacute; a solu&ccedil;&atilde;o recomendada para manter os arquivos
        de configura&ccedil;&atilde;o do sistema atualizados com os que est&atilde;o na &aacute;rvore
        dos fontes.</para>

      <para>O <command>mergemaster</command> foi integrado ao sistema base
        do FreeBSD entre o 3.3-RELEASE e 3.4-RELEASE, o que significa que
        estava presente em todos os -STABLE e -CURRENT deste o 3.3.</para>

      <para>Para come&ccedil;ar simplesmente digite <command>mergemaster</command>
        na sua linha de comando e obserse.  <command>mergemaster</command>
        compilar&aacute; um ambiente tempor&aacute;rio de root, a partir de <filename>/</filename>,
        e colocar&aacute; l&aacute; v&aacute;rios arquivos de configura&ccedil;&atilde;o de sistema.  Neste ponto,
        os arquivos diferentes ser&atilde;o mostrados pelo formato do &man.diff.1;, com
        o sinal de <option>+</option> representado linhas adicionadas ou
        modificadas, e o sinal <option>-</option> representado linhas que foram
        removidas completamente, ou substitu&iacute;das por uma nova linha.  Veja a
        p&aacute;gina de manual de &man.diff.1 para mais informa&ccedil;&otilde;es sobre a sintaxe do
        &man.diff.1; e como as diferen&ccedil;as entre os arquivos s&atilde;o mostradas.</para>

      <para>&man.mergemaster.8; mostrar&aacute; a voc&ecirc; cada arquivo que possuem
        diferen&ccedil;as, e neste ponto voc&ecirc; ter&aacute; a op&ccedil;&atilde;o de apagar o arquivo novo
        (referenciado como um arquivo tempor&aacute;rio), instalar o arquivo
        tempor&aacute;rio em seu estado n&atilde;o modificado, unir o arquivo tempor&aacute;rio
        com o arquivo atualmente instalado, ou visualizar as diferen&ccedil;as
        geradas pelo &man.diff.1; novamente.</para>

      <para>Escolher pela remo&ccedil;&atilde;o do arquivo tempor&aacute;rio instruir&aacute; o
        &man.mergemaster.8; a manter nosso arquivo atual intacto, e apagar
        a nova vers&atilde;o.  Esta op&ccedil;&atilde;o n&atilde;o &eacute; recomendada, a menos que voc&ecirc;
        n&atilde;o veja raz&otilde;es para modificar o arquivo atual.  Voc&ecirc; pode obter
        ajuda a qualquer momento digitando <keycap>?</keycap> no prompt
        do &man.mergemaster.8;.  Se o usu&aacute;rio quiser pular o arquivo, o
        mesmo ser&aacute; mostrado novamente depois que todos os arquivos tenham
        sido tratados.</para>

      <para>Optar por instalar o arquivo tempor&aacute;rio n&atilde;o modificado substiuir&aacute; o 
	arquivo atual com o novo.  Para arquivos n&atilde;o modificados, esta &eacute; a 
	melhor op&ccedil;&atilde;o.</para>

      <para>Optar por unir os arquivos mostrar&aacute; um editor de textos, e o conte&uacute;do 
	dos dois arquivos.  Voc&ecirc; pode uni-los revisando-os lado a lado na tela, 
	escolhendo partes de cada um para obter um produto final.  Quando os 
	arquivos s&atilde;o comparados lado a lado, a tecla <keycap>l</keycap> selecionar&aacute; 
	o conte&uacute;do da esquerda e a tecla <keycap>r</keycap> da sua direita.  A sa&iacute;da 
	final ser&aacute; um arquivo formado por ambas as partes, que pode ser instalado.  
	Esta op&ccedil;&atilde;o normalmente &eacute; usada para arquivos que foram modificados pelo 
	usu&aacute;rio.</para>

      <para>Optar por visualizar novamente os resultados do &man.diff.1; lhe 
	mostrar&aacute; as diferen&ccedil;as assim como o &man.mergemaster.8; fez antes 
	de lhe solicitar uma op&ccedil;&atilde;o.</para>

      <para>Depois de terminar os arquivos de sistema o &man.mergemaster.8; 
	lhe mostrar&aacute; outras op&ccedil;&otilde;es.  Perguntar&aacute; se voc&ecirc; deseja recompilar o 
	arquivo de senhas e/ou executar o &man.MAKEDEV.8; se voc&ecirc; estiver 
	executando o FreeBSD anterior a vers&atilde;o 5.0, e terminar&aacute; com a op&ccedil;&atilde;o 
	de remover os arquivos tempor&aacute;rios que ficaram para tr&aacute;s.</para>
      </sect3>

      <sect3>
	<title>Atualiza&ccedil;&atilde;o Manual</title>

      <para>Se voc&ecirc; deseja atualizar manualmente, voc&ecirc; n&atilde;o pode simplesmente 
	sobrescrever os arquivos de <filename>/usr/src/etc</filename> para 
	<filename>/etc</filename> e esperar que funcione.  Alguns destes 
	arquivos devem ser <quote>instalados</quote> primeiro.  Isto porque 
	o diret&oacute;rio <filename>/usr/src/etc</filename> <emphasis>n&atilde;o &eacute;
	</emphasis> uma c&oacute;pia do que est&aacute; em seu <filename>/etc</filename>.  
	Al&eacute;m disso, existem arquivos que podem estar em <filename>/etc
	</filename> e n&atilde;o estar em <filename>/usr/src/etc</filename>.</para>

      <para>Se voc&ecirc; estiver usando o &man.mergemaster.8; (como 
	recomendado), voc&ecirc; pode pular para 
        <link linkend="update-dev">pr&oacute;xima se&ccedil;&atilde;o
	</link>.</para>

      <para>A maneira mais simples de fazer isto manualmente &eacute; 
	instalar os arquivos em um novo diret&oacute;rio, e trabalhar neles 
	procurando por diferen&ccedil;as.</para>
    
      <warning>
	<title>Fa&ccedil;a uma C&oacute;pia de Seguran&ccedil;a do seu <filename>/etc</filename></title>

	<para>Embora, teoricamente, nada v&aacute; tocar em neste diret&oacute;rio 
	  automaticamente, &eacute; sempre melhor estar previnido.  Ent&atilde;o copie 
	  seu diret&oacute;rio <filename>/etc</filename> para um lugar seguro.
	  Algo do tipo:</para>

	<screen>&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput></screen>

	<para>A op&ccedil;&atilde;o <option>-R</option> faz uma c&oacute;pia recursiva, a op&ccedil;&atilde;o 
	  <option>-p</option> preserva os tempos, propriedades dos arquivos 
	  e coisas do tipo.</para>
      </warning>
      
      <para>Voc&ecirc; precisa ter alguns diret&oacute;rios tempor&aacute;rios para instalar 
	o novo <filename>/etc</filename> nestes diret&oacute;rios.  <filename>
	/var/tmp/root</filename> &eacute; uma boa escolha, e existe v&aacute;rios 
	diret&oacute;rios necess&aacute;rios abaixo dele.</para>

      <screen>&prompt.root; <userinput>mkdir /var/tmp/root</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root distrib-dirs distribution</userinput></screen>

      <para>Isto criar&aacute; a estrutura de diret&oacute;rios necess&aacute;ria e instalar&aacute; 
	os arquivos.  Muitos subdiret&oacute;rios que foram criados abaixo de 
	<filename>/var/tmp/root</filename> estar&atilde;o vazios e podem ser 
	apagados.  A maneira mais simples de se fazer isto &eacute;:</para>
      
      <screen>&prompt.root; <userinput>cd /var/tmp/root</userinput>
&prompt.root; <userinput>find -d . -type d | xargs rmdir 2&gt;/dev/null</userinput></screen>
      
      <para>Isto remover&aacute; os diret&oacute;rios vazios.  (O erro padr&atilde;o &eacute; 
	redirecionado para <filename>/dev/null</filename> para evitar que 
	alertas a respeito de diret&oacute;rios vazios sejam exibidos.)</para>

      <para><filename>/var/tmp/root</filename> agora cont&eacute;m todos os 
	arquivos que devem ser colocados em locais apropriados abaixo de 
	<filename>/</filename>.  Voc&ecirc; agora deve ir em cada um destes 
	arquivos, determinando como eles diferem dos que es&atilde;o no seu 
	sistema.</para>
    
      <para>Note que alguns dos arquivos que foram instalados em 
	<filename>/var/tmp/root</filename> possuem um <quote>.</quote> 
	no in&iacute;cio.  Na hora da escrita os &uacute;nicos arquivos como estes s&atilde;o 
	arquivos de inicializa&ccedil;&atilde;o de linha de comando em 
	<filename>/var/tmp/root/</filename> e
	<filename>/var/tmp/root/root/</filename>, embora possam existir 
	outros (dependendo de quando voc&ecirc; estiver lendo isto).  Use o 
	comando <command>ls -a</command> para peg&aacute;-los.</para>
    
      <para>A maneira mais simples de ser fazer isso &eacute; usar o &man.diff.1; 
	para comparar dois arquivos:</para>
    
      <screen>&prompt.root; <userinput>diff /etc/shells /var/tmp/root/etc/shells</userinput></screen>
      
      <para>Isto exibir&aacute; as diferen&ccedil;as entre o seu arquivo 
	<filename>/etc/shells</filename> e o novo 
	<filename>/var/tmp/root/etc/shells</filename>.  Assim voc&ecirc; pode 
	decidir por incluir as mudan&ccedil;as que voc&ecirc; fez ou substituir seu 
	arquivo antigo.</para>
    
      <tip>
	<title>Nomeie o novo diret&oacute;rio Root 
	  (<filename>/var/tmp/root</filename>) com um Novo Selo de Hora, 
	  Assim Voc&ecirc; Pode Facilmente Comparar as Diferen&ccedil;as Entre 
	  as Vers&otilde;es</title>

	<para>Recompilar o sistema frequentemente significa ter que 
	  atualizar o <filename>/etc</filename> frequentemente tamb&eacute;m, que 
	  pode ser uma tarefa um pouco chata.</para>

	<para>Voc&ecirc; pode acelerar este processo mantendo um c&oacute;pia do &uacute;ltimo 
	  conjunto de arquivos modificados que voc&ecirc; fez a jun&ccedil;&atilde;o em 
	  <filename>/etc</filename>.  O seguinte procedimento lhe d&aacute; uma 
	  id&eacute;ia de como fazer isto.</para>

	<procedure>
	  <step>
	    <para>Make the world as normal.  When you want to update
	      <filename>/etc</filename> and the other directories, give the
	      target directory a name based on the current date.  If you were
	      doing this on the 14th of February 1998 you could do the
	      following:</para>
	  
	    <screen>&prompt.root; <userinput>mkdir /var/tmp/root-19980214</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root-19980214 \
    distrib-dirs distribution</userinput></screen>
	  </step>
	  
	  <step>
	    <para>Merge in the changes from this directory as outlined
	      above.</para>
	    
	    <para><emphasis>Do not</emphasis> remove the
	      <filename>/var/tmp/root-19980214</filename> directory when you
	      have finished.</para>
	  </step>
	  
	  <step>
	    <para>When you have downloaded the latest version of the source
	      and remade it, follow step 1.  This will give you a new
	      directory, which might be called
	      <filename>/var/tmp/root-19980221</filename> (if you wait a week
	      between doing updates).</para>
	  </step>
	  
	  <step>
	    <para>You can now see the differences that have been made in the
	      intervening week using &man.diff.1; to create a recursive diff
	      between the two directories:</para>
	      
	    <screen>&prompt.root; <userinput>cd /var/tmp</userinput>
&prompt.root; <userinput>diff -r root-19980214 root-19980221</userinput></screen>
	  
	    <para>Typically, this will be a much smaller set of differences
	      than those between
	      <filename>/var/tmp/root-19980221/etc</filename> and
	      <filename>/etc</filename>.  Because the set of differences is
	      smaller, it is easier to migrate those changes across into your
	      <filename>/etc</filename> directory.</para>
	  </step>
	  
	  <step>
	    <para>You can now remove the older of the two
	      <filename>/var/tmp/root-*</filename> directories:</para>
	      
	    <screen>&prompt.root; <userinput>rm -rf /var/tmp/root-19980214</userinput></screen>
	  </step>
	  
	  <step>
	    <para>Repeat this process every time you need to merge in changes
	      to <filename>/etc</filename>.</para>
	  </step>
	</procedure>

	<para>You can use &man.date.1; to automate the generation of the
	  directory names:</para>
	  
	<screen>&prompt.root; <userinput>mkdir /var/tmp/root-`date "+%Y%m%d"`</userinput></screen>
      </tip>
      </sect3>
    </sect2>
  
    <sect2 id="update-dev">
      <title>Update <filename>/dev</filename></title>
      
      <note>
        <indexterm><primary>DEVFS</primary></indexterm>
	<para>If you are running FreeBSD&nbsp;5.0 or later you can safely
	  skip this section.  These versions use &man.devfs.5; to
	  allocate device nodes transparently for the user.</para>
      </note>

      <para>In most cases, the &man.mergemaster.8; tool will realize when
        it is necessary to update the device nodes, and offer to complete it
        automatically.  These instructions tell how to update the device
        nodes manually.</para>
      
      <para>For safety's sake, this is a multi-step process.</para>

      <procedure>
	<step>
	  <para>Copy <filename>/var/tmp/root/dev/MAKEDEV</filename> to
	    <filename>/dev</filename>:</para>

	  <screen>&prompt.root; <userinput>cp /var/tmp/root/dev/MAKEDEV /dev</userinput></screen>
	  <indexterm>
	    <primary><filename>MAKEDEV</filename></primary>
	  </indexterm>

          <para>If you used &man.mergemaster.8; to
            update <filename>/etc</filename>, then your
            <filename>MAKEDEV</filename> script should have been updated
            already, though it cannot hurt to check (with &man.diff.1;)
            and copy it manually if necessary.</para>
	</step>

	<step>
	  <para>Now, take a snapshot of your current
	    <filename>/dev</filename>.  This snapshot needs to contain the
	    permissions, ownerships, major and minor numbers of each filename,
	    but it should not contain the time stamps.  The easiest way to do
	    this is to use &man.awk.1; to strip out some of the
	    information:</para>

	  <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>ls -l | awk '{print $1, $2, $3, $4, $5, $6, $NF}' > /var/tmp/dev.out</userinput></screen>
	</step>

	<step>
	  <para>Remake all the device nodes:</para>
	    
	    <screen>&prompt.root; <userinput>sh MAKEDEV all</userinput></screen>
	</step>

	<step>
	  <para>Write another snapshot of the directory, this time to
	    <filename>/var/tmp/dev2.out</filename>.  Now look through these
	    two files for any device node that you missed creating.  There should
	    not be any, but it is better to be safe than sorry.</para>

	  <screen>&prompt.root; <userinput>diff /var/tmp/dev.out /var/tmp/dev2.out</userinput></screen>

	  <para>You are most likely to notice disk slice discrepancies which
	    will involve commands such as:</para>
	  
	    <screen>&prompt.root; <userinput>sh MAKEDEV sd0s1</userinput></screen>

	  <para>to recreate the slice entries.  Your precise circumstances may
	    vary.</para>
	</step>
      </procedure>
    </sect2>
    
    <sect2>
      <title>Update <filename>/stand</filename></title>
      
      <note>
	<para>This step is included only for completeness.  It can safely be
	  omitted.  If you are using FreeBSD&nbsp;5.2 or later, the
          <filename>/rescue</filename> directory is automatically updated
          for the user with current, statically compiled binaries during
	  <command>make installworld</command>, thus obsoleting the need
	  to update <filename>/stand</filename>.</para>
      </note>
      
      <para>For the sake of completeness, you may want to update the files in
	<filename>/stand</filename> as well.  These files consist of hard
	links to the <filename>/stand/sysinstall</filename> binary.  This
	binary should be statically linked, so that it can work when no other
	file systems (and in particular <filename>/usr</filename>) have been
	mounted.</para>

      <screen>&prompt.root; <userinput>cd /usr/src/release/sysinstall</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>
    
    <sect2>
      <title>Rebooting</title>
      
      <para>You are now done.  After you have verified that everything appears
	to be in the right place you can reboot the system.  A simple
	&man.shutdown.8; should do it:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>
    </sect2>

    <sect2>
      <title>Finished</title>
      
      <para>You should now have successfully upgraded your &os; system.
	Congratulations.</para>
      
      <para>If things went slightly wrong, it is easy to rebuild a particular
        piece of the system.  For example, if you accidentally deleted
        <filename>/etc/magic</filename> as part of the upgrade or merge of
        <filename>/etc</filename>, the &man.file.1; command will stop working.
        In this case, the fix would be to run:</para>

	<screen>&prompt.root; <userinput>cd /usr/src/usr.bin/file</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>    
    
    <sect2>
      <title>Questions</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para>Do I need to re-make the world for every change?</para>
	  </question>

	  <answer>
            <para>There is no easy answer to this one, as it depends on the
	      nature of the change.  For example, if you just ran <application>CVSup</application>, and
	      it has shown the following files as being updated:</para>
      
	    <screen><filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename></screen>

	    <para>it probably is not worth rebuilding the entire world.
	      You could just go to the appropriate sub-directories and
	      <command>make all install</command>, and that's about it.  But
	      if something major changed, for example
	      <filename>src/lib/libc/stdlib</filename> then you should either
	      re-make the world, or at least those parts of it that are
	      statically linked (as well as anything else you might have added
	      that is statically linked).</para>
      
	    <para>At the end of the day, it is your call.  You might be happy
	      re-making the world every fortnight say, and let changes
	      accumulate over that fortnight.  Or you might want to re-make
	      just those things that have changed, and be confident you can
	      spot all the dependencies.</para>
      
	    <para>And, of course, this all depends on how often you want to
	      upgrade, and whether you are tracking &os.stable; or
	      &os.current;.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>My compile failed with lots of signal 11 (or other signal
	      number) errors.  What has happened?</para>
	  </question>
    <indexterm><primary>signal 11</primary></indexterm>

	  <answer>

	    <para>This is normally indicative of hardware problems.
	      (Re)making the world is an effective way to stress test your
	      hardware, and will frequently throw up memory problems.  These
	      normally manifest themselves as the compiler mysteriously dying
	      on receipt of strange signals.</para>
      
	    <para>A sure indicator of this is if you can restart the make and
	      it dies at a different point in the process.</para>
      
	    <para>In this instance there is little you can do except start
	      swapping around the components in your machine to determine
	      which one is failing.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Can I remove <filename>/usr/obj</filename> when I have
	      finished?</para>
	  </question>
	  
	  <answer>
	    <para>The short answer is yes.</para>
      
	    <para><filename>/usr/obj</filename> contains all the object files
	      that were produced during the compilation phase.  Normally, one
	      of the first steps in the <quote>make world</quote> process is to
	      remove this directory and start afresh.  In this case, keeping
	      <filename>/usr/obj</filename> around after you have finished
	      makes little sense, and will free up a large chunk of disk space
	      (currently about 340&nbsp;MB).</para>
      
	    <para>However, if you know what you are doing you can have
	      <quote>make world</quote> skip this step.  This will make subsequent
	      builds run much faster, since most of sources will not need to
	      be recompiled.  The flip side of this is that subtle dependency
	      problems can creep in, causing your build to fail in odd ways.
	      This frequently generates noise on the &os; mailing lists,
	      when one person complains that their build has failed, not
	      realizing that it is because they have tried to cut
	      corners.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Can interrupted builds be resumed?</para>
	  </question>

	  <answer>
	    <para>This depends on how far through the process you got before
	      you found a problem.</para>

	    <para><emphasis>In general</emphasis> (and this is not a hard and
	      fast rule) the <quote>make world</quote> process builds new
	      copies of essential tools (such as &man.gcc.1;, and
	      &man.make.1;) and the system libraries.  These tools and
	      libraries are then installed.  The new tools and libraries are
	      then used to rebuild themselves, and are installed again. The
	      entire system (now including regular user programs, such as
		&man.ls.1; or &man.grep.1;) is then rebuilt with the new
	      system files.</para>

	    <para>If you are at the last stage, and you know it (because you
	      have looked through the output that you were storing) then you
	      can (fairly safely) do:</para>

	    <screen><emphasis>&hellip; fix the problem &hellip;</emphasis>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make -DNOCLEAN all</userinput></screen>

	    <para>This will not undo the work of the previous
	      <quote>make world</quote>.</para>

	    <para>If you see the message:</para>

	      <screen>--------------------------------------------------------------
Building everything..
--------------------------------------------------------------</screen>

	    <para>in the <quote>make world</quote> output then it is
	      probably fairly safe to do so.</para>
	    
	    <para>If you do not see that message, or you are not sure, then it
	      is always better to be safe than sorry, and restart the build
	      from scratch.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>How can I speed up making the world?</para>
          </question>

          <answer>
	    <itemizedlist>
	      <listitem>
		<para>Run in single user mode.</para>
	      </listitem>
	      
	      <listitem>
		<para>Put the <filename>/usr/src</filename> and
		  <filename>/usr/obj</filename> directories on separate
		  file systems held on separate disks.  If possible, put these
		  disks on separate disk controllers.</para>
	      </listitem>
	      
	      <listitem>
		<para>Better still, put these file systems across multiple
		  disks using the &man.ccd.4; (concatenated disk
		  driver) device.</para>
	      </listitem>
	      
	      <listitem>
		<para>Turn off profiling (set <quote>NOPROFILE=true</quote> in
		  <filename>/etc/make.conf</filename>).  You almost certainly
		  do not need it.</para>
	      </listitem>
	      
	      <listitem>
		<para>Also in <filename>/etc/make.conf</filename>, set
		  <makevar>CFLAGS</makevar> to something like <option>-O
		  -pipe</option>.  The optimization <option>-O2</option> is much
		  slower, and the optimization difference between
		  <option>-O</option> and <option>-O2</option> is normally
		  negligible.  <option>-pipe</option> lets the compiler use
		  pipes rather than temporary files for communication, which
		  saves disk access (at the expense of memory).</para>
	      </listitem>
	      
	      <listitem>
		<para>Pass the <option>-j<replaceable>n</replaceable></option> option to &man.make.1; to
		  run multiple processes in parallel.  This usually helps 
		  regardless of whether you have a single or a multi processor
		  machine.</para>
	      </listitem>
	      
	      <listitem><para>The file system holding
		  <filename>/usr/src</filename> can be mounted (or remounted)
		  with the <option>noatime</option> option.  This prevents the
		  file system from recording the file access time.  You probably
		  do not need this information anyway.</para>
		  
		  <screen>&prompt.root; <userinput>mount -u -o noatime /usr/src</userinput></screen>
		  
		  <warning>
		    <para>The example assumes <filename>/usr/src</filename> is
		      on its own file system.  If it is not (if it is a part of
		      <filename>/usr</filename> for example) then you will
		      need to use that file system mount point, and not
		      <filename>/usr/src</filename>.</para>
		  </warning>
	      </listitem>
	      
	      <listitem>
		<para>The file system holding <filename>/usr/obj</filename> can
		  be mounted (or remounted) with the <option>async</option>
		  option.  This causes disk writes to happen asynchronously.
		  In other words, the write completes immediately, and the
		  data is written to the disk a few seconds later.  This
		  allows writes to be clustered together, and can be a
		  dramatic performance boost.</para>

		<warning>
		  <para>Keep in mind that this option makes your file system
		    more fragile.  With this option there is an increased
		    chance that, should power fail, the file system will be in
		    an unrecoverable state when the machine restarts.</para>
	   
		  <para>If <filename>/usr/obj</filename> is the only thing on
		    this file system then it is not a problem.  If you have
		    other, valuable data on the same file system then ensure
		    your backups are fresh before you enable this
		    option.</para>
		</warning>
		
		<screen>&prompt.root; <userinput>mount -u -o async /usr/obj</userinput></screen>
		
		<warning>
		  <para>As above, if <filename>/usr/obj</filename> is not on
		    its own file system, replace it in the example with the
		    name of the appropriate mount point.</para>
		</warning>
	      </listitem>
	    </itemizedlist>
	  </answer>
	</qandaentry>

        <qandaentry>
          <question>
            <para>What do I do if something goes wrong?</para>
          </question>

          <answer>
            <para>Make absolutely sure your environment has no
              extraneous cruft from earlier builds.  This is simple
              enough.</para>

            <screen>&prompt.root; <userinput>chflags -R noschg /usr/obj/usr</userinput>
&prompt.root; <userinput>rm -rf /usr/obj/usr</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

            <para>Yes, <command>make cleandir</command> really should
              be run twice.</para>

            <para>Then restart the whole process, starting
              with <command>make buildworld</command>.</para>

            <para>If you still have problems, send the error and the
              output of <command>uname -a</command> to &a.questions;.
              Be prepared to answer other questions about your
              setup!</para>
          </answer>
        </qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 id="small-lan">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Mike</firstname>
	  <surname>Meyer</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Preparando Multiplas M&aacute;quinas</title>
    <indexterm>
      <primary>NFS</primary>
      <secondary>installing multiple machines</secondary>
    </indexterm>
    
    <para>Se voc&ecirc; possui multiplas m&aacute;quinas que voc&ecirc; quer manter
      a mesma &aacute;rvore de fontes, ent&atilde;o fazer com que todas fa&ccedil;am
      download dos fontes e recompilem tudo parece ser uma perda
      de recursos: espa&ccedil;o em disco, banda de rede, e ciclos de
      CPU.  E &eacute;, e uma &eacute; possuir uma m&aacute;quina para fazer a maior
      parte do trabalho, enquanto o resto das m&aacute;quinas pegam este
      trabalho atrav&eacute;s de NFS.  Esta se&ccedil;&atilde;o exp&otilde;e um m&eacute;todo para
      fazer isto.</para>

    <sect2 id="small-lan-preliminaries">
      <title>Preliminares</title>

      <para>Primeiro, identifique um conjunto de m&aacute;quinas que
        executar&atilde;o o mesmo conjunto de bin&aacute;rios, as quais
        chamaremos de <emphasis>conjunto de compila&ccedil;&atilde;o</emphasis>.
        Cada m&aacute;quina pode possuir um <foreignphrase>kernel
        </foreignphrase> customizado, mas elas estar&atilde;o executando
        os mesmos bin&aacute;rios de usu&aacute;rio.  Deste conjunto, escolha
        uma m&aacute;quina para ser a <emphasis>m&aacute;quina de compila&ccedil;&atilde;o
        </emphasis>.  Ser&aacute; a m&aacute;quina onde os bin&aacute;rios de sistema
        e o <foreignphrase>kernel</foreignphrase> ser&atilde;o compilados.
        Idealmente, deve ser uma m&aacute;quina r&aacute;pida com folga para
        executar o comando <command>make world</command>.  Voc&ecirc;
        tamb&eacute;m desejar&aacute; escolher uma <emphasis>maquina de testes
        </emphasis>, para testar as atualiza&ccedil;&otilde;es de programas
        antes de coloc&aacute;-las em produ&ccedil;&atilde;o.  Esta <emphasis>deve
        </emphasis> ser uma m&aacute;quina que pode permanecer fora do
        ar por grandes per&iacute;odos de tempo.  Pode ser a m&aacute;quina de
        compila&ccedil;&atilde;o, mas n&atilde;o necessariamente.</para>    

      <para>Todas as m&aacute;quinas neste conjunto de compila&ccedil;&atilde;o precisam
        montar o <filename>/usr/obj</filename> e <filename>/usr/src
        </filename> da mesma m&aacute;quina, e no mesmo ponto.  Idealmente,
        estes s&atilde;o dois <literal>drives</literal> diferentes na m&aacute;quina
        de compila&ccedil;&atilde;o, mas eles podem ser montados via NFS nesma
        m&aacute;quina tamb&eacute;m.  Se voc&ecirc; possui multiplos conjuntos de
        compila&ccedil;&atilde;o, o <filename>/usr/src</filename> deve estar na
        m&aacute;quina de compila&ccedil;&atilde;o, e montado atrav&eacute;s de NFS no resto.</para>

      <para>Finalmente esteja certo que o arquivo
        <filename>/etc/make.conf</filename> em todas as m&aacute;quinas
        do conjunto de compila&ccedil;&atilde;o estejam de acordo com a m&aacute;quina
        de compila&ccedil;&atilde;o.  Isto significa que a m&aacute;quina de compila&ccedil;&atilde;o
        deve todas as partes do sistema base que qualquer m&aacute;quina
        do conjunto de instala&ccedil;&atilde;o v&aacute; instalar.  Al&eacute;m disso, cada
        m&aacute;quina deve ter seu nome de <foreignphrase>kernel</foreignphrase>
        configurado atrav&eacute;s da vari&aacute;vel <makevar>KERNCONF</makevar> em
        <filename>/etc/make.conf</filename> e a m&aacute;quina de compila&ccedil;&atilde;o
        deve listar todas em <makevar>KERNCONF</makevar>, listando
        seu pr&oacute;prio <foreignphrase>kernel</foreignphrase> primeiro.  A
        m&aacute;quina de compila&ccedil;&atilde;o deve ter os arquivos de configura&ccedil;&atilde;o de
        <foreignphrase>kernel</foreignphrase> para cada m&aacute;quina em
        <filename>/usr/src/sys/<replaceable>arch</replaceable>/conf</filename>
        se for compilar seus <foreignphrase>kernels</foreignphrase>.</para>
    </sect2>

    <sect2>
      <title>O Sistema Base</title>

      <para>Agora que tudo est&aacute; feito, voc&ecirc; est&aacute; pronto para compilar
        tudo.  Compile o <foreignphrase>kernel</foreignphrase> e o
        sistema como descrito em <xref linkend="make-buildworld"> na
        m&aacute;quina de compila&ccedil;&atilde;o, mas n&atilde;o instale nada.  Depois que a
        compila&ccedil;&atilde;o terminar, v&aacute; para a m&aacute;quina de teste e instale o
        <foreignphrase>kernel</foreignphrase> que voc&ecirc; acabou de
        compilar.  Se est&aacute; m&aacute;quina monta os diret&oacute;rios <filename>
        /usr/src</filename> e <filename>/usr/obj</filename> via
        NFS, quando voc&ecirc; reinicializar no modo mono usu&aacute;rio, voc&ecirc;
        precisar&aacute; habilitar a rede e mont&aacute;-los.  A maneira mais
        f&aacute;cil de fazer isto &eacute; reinicializar no modo multi usu&aacute;rio
        e executar o comando <command>shutdown now</command> para
        ir para o modo mono usu&aacute;rio.  Uma vez l&aacute;, voc&ecirc; pode instalar
        o novo <foreignphrase>kernel</foreignphrase> e sistema e
        executar o <command>mergemaster</command> como voc&ecirc; faz
        normalmente.  Ao terminar, reinicialize e volte &agrave;s opera&ccedil;&otilde;es
        normais de multi usu&aacute;rio desta m&aacute;quina.</para>

      <para>Ap&oacute;s estar certo de que tudo na m&aacute;quina de teste est&aacute; 
	funcionando apropriadamente, use o mesmo procedimento para 
	instalar em cada uma das m&aacute;quinas do conjunto de 
	compila&ccedil;&atilde;o.</para>
    </sect2>

    <sect2>
      <title>Ports</title>

      <para>A mesma id&eacute;ia pode ser usada na &aacute;rvore de aplica&ccedil;&otilde;es
        portadas.  O primeiro passo cr&iacute;tico &eacute; montar o diret&oacute;rio
        <filename>/usr/ports</filename> a partir da mesma m&aacute;quina
        para todas as do conjunto de compila&ccedil;&atilde;o.  Voc&ecirc; pode ent&atilde;o
        configurar o arquivo <filename>/etc/make.conf</filename>
        apropriadamente para compartilhar os <literal>distfiles
        </literal>.  Voc&ecirc; deve configuarar a vari&aacute;vel <makevar>
        DISTDIR</makevar> para um diret&oacute;rio comum compartilhado
        com permiss&atilde;o de escrita para qualquer usu&aacute;rio <username>
        root</username> esteja conectado aos diret&oacute;rios montados
        via NFS.  Cada m&aacute;quina deve configurar a vari&aacute;vel <makevar>
        WRKDIRPREFIX</makevar> para um diret&oacute;rio local de compila&ccedil;&atilde;o.
        Finalmente, se voc&ecirc; for compilar e distribuir pacotes, voc&ecirc;
        deve configurar a vari&aacute;vel <makevar>PACKAGES</makevar>
        para um diret&oacute;rio similar ao da vari&aacute;vel
        <makevar>DISTDIR</makevar>.</para>
    </sect2>
  </sect1>
</chapter>
<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

