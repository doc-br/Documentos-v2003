<!--
     The FreeBSD Documentation Project

     $FreeBSD: doc/en_US.ISO8859-1/books/handbook/boot/chapter.sgml,v 1.55 2003/08/23 23:26:43 simon Exp $
-->

<chapter id="boot">
  <title>O processo de inicialização do FreeBSD</title>

  <sect1 id="boot-synopsis">
    <title>Sinópse</title>
    <indexterm><primary>booting</primary></indexterm>
    <indexterm><primary>bootstrap</primary></indexterm>

    <para>O processo de inicialização e carregamento de um computador com sistema operacional
      refere-se a um <quote>processo de inicializar</quote>, ou simplesmente
      <quote>carregar</quote>. O processo de inicialização do FreeBSD fornece uma grande flexibilidade 
      que acontece quando você inicia o sistema,
      permitindo que você selecione das diferentes operações no sistema instalado no mesmo
      computador, ou igualar diferentes versões do mesmo sistema operacional
      ou do kernel instalado.</para>

    <para>Este capítulo detalha as opções de configuração que você pode ajustar e
      personalizar o processo de inicialização do FreeBSD. Isto inclui tudo o que 
      acontece desde a hora do kernel do FreeBSD carregar, testar os dispositivos, e
      inicializar &man.init.8;. Se voce nao estiver totalmente certo de quando isso acontece, isto
      acontece quando a cor do texto muda de branco brilhante para cinza.</para>

    <para>Depois de ler este capitulo, voce sabera:</para>

    <itemizedlist>
      <listitem>
	<para>O que os componentes do FreeBSD tiram e colocam no sistema, e como
	  eles interagem.</para>
      </listitem>

      <listitem>
	<para>A opcoes que voce pode dar a componentes no FreeBSD
	  colocando ou tirando para controlar o processo de inicializacao.</para>
      </listitem>
      
      <listitem>
        <para>O basico de &man.device.hints.5;.</para>
      </listitem>
    </itemizedlist>

    <note>
      <title>Somente x86</title>

      <para>Este capitulo somente descreve o processo de inicializacao para FreeBSD rodando
	em sistemas Intel x86.</para>
    </note>
  </sect1>

  <sect1 id="boot-introduction">
    <title>O problema na inicializacao</title>

    <para>Voltando a um computador inicializando o sistema operacional a atitude e um
      dilema interessante. Por definicao, o computador nao sabe qualquer
      coisa antes que o sistema operacional esteja iniciando. isto inclui
      rodar programas do disco. Assim se o computador nao pode rodar um
      programa do disco sem o sistema operacional, e os programas do sistema operacional
      estao no disco, como o sistema operacional foi inicializado?</para>

    <para>Este problema paralelo um estao no livro <citetitle>As aventuras de
      Baron Munchausen</citetitle>. Um caracter teve afastado parte way down a
      manhole, and pulled himself out by grabbing his bootstraps, and
      lifting.  Nos dias de computacao o termo
      <firstterm>colocar e tirar</firstterm> foi aplicado no mecanismo usado para
      carregar o sistema operacional, que se tornou compacto para
      <quote>carregar</quote>.</para>

    <para>No hardware x86 o Sistema Basico de Entrada/Saida (BIOS) e responsavel
      por carregar o sistema operacional. Para fazer isto, na BIOS aparece o
      hard disk para o Master Boot Record (MBR), que deve ser alocado sobre um
      local especifico do disco. A BIOS tem bastante mudancas que podem ser feitas para carregar e
      rodar a MBR, e assume que a MBR pode entao carregar a saida do resto das
      tarefas involvidas na inicializacao do sistema operacional.</para>

    <indexterm>
      <primary>BIOS</primary>
      <secondary>Basic Input/Output System</secondary>
    </indexterm>

    <para>Se voce tiver somente um sistema operacional instalado no seu disco entao
      MBR padrao sera suficiente. Esta MBR procurara pela primeira particao inicializavel
      no disco, e entao roda o codigo nesta particao para carregar o
      restante do sistema operacional.</para>

    <para>Se voce tiver instalado varios sistemas operacionais em seus discos entao
      voce pode instalar uma MBR diferente, um que pode mostrar uma lista de
      diferentes sistemas operacionais, e permite a voce escolher um para carregar.
      FreeBSD vem com um MBR que pode ser instalado, e outros
      sistemas operacionais vendidos fornecem MBRs alternativos.</para>

    <para>O restante do sistema bootstrap do FreeBSD e divido em tres
      estagios. O primeiro estagio e executado pela MBR, que sabe apenas iniciar
      o computador em um estado especifico e rodar o segundo estagio. O
      segundo estagio pode fazer mais um pedaco em pouco tempo, depois roda o terceiro estagio.
      O terceiro estagio terminara a tarefa de carregar o sistema operacional. O
      trabalho e dividido dentro destes tres estagios porque o padrao do PC impoe
      limites sobre o tamanho dos programas que podem ser rodados nos estagios 1 e
      2. Encadear as tarefas permite que o FreeBSD forneca um carregador mais
      flexivel.</para>

    <indexterm><primary>kernel</primary></indexterm>
    <indexterm><primary><command>init</command></primary></indexterm>

    <para>O kernel entao e inicializado e esta inicializacao testa os dispositivos
      e entao inicializa estes para o uso. Uma vez que o processo de inicializacao do kernel
      e terminado, o kernel passa o controle do processo para
      &man.init.8;, qual se certifica que os discos estao em um estado aproveitavel.
      &man.init.8; comeca entao a configuracao user-level que
      mounta o sistema de arquivos, seta e levanta drivers de rede para comunicacao com
      a rede, e normalmente inicia todos os processos que normalmente
      sao rodados sobre um sistema FreeBSD na inicializacao.</para>
  </sect1>

  <sect1 id="boot-blocks">
    <title>A MBR, e estagios da inicializacao Um, Dois, e Tres</title>

    <sect2 id="boot-boot0">
      <title>MBR, <filename>/boot/boot0</filename></title>
      <indexterm><primary>Master Boot Record (MBR)</primary></indexterm>

      <para>A MBR do FreeBSD e localizado no <filename>/boot/boot0</filename>.
	Este e uma <emphasis>copia</emphasis> do MBR, por que a real MBR deve
	ficar em uma parte especial do disco, fora da area do FreeBSD.</para>

      <para><filename>boot0</filename> e muito simples, visto que o
	programa dentro da <abbrev>MBR</abbrev> pode ter no maximo o tamanho de 512 bytes.
	Se voce tiver instalado na MBR o FreeBSD e tiver instalado
	multiplos sistemas operacionais em seu HD entao voce vera um
	menu similar a este um na hora da inicializacao:</para>

      <example id="boot-boot0-example">
	<title><filename>boot0</filename> Screenshot</title>

	<screen>F1 DOS
F2 FreeBSD
F3 Linux
F4 ??
F5 Drive 1

Default: F2</screen>
      </example>

      <para>Outros sistemas operacionais, em particular &windows;&nbsp;95, tem conhecimento que
	sobscrevem informacoes ja existentes na MBR com suas proprias. Se isto acontecer a voce,
	ou voce queira substituir sua existente MBR com o FreeBSD MBR entao use
	o seguinte comando:</para>

      <screen>&prompt.root; <userinput>fdisk -B -b /boot/boot0 <replaceable>device</replaceable></userinput></screen>

      <para>Como <replaceable>dispositivo</replaceable> e o dispositivo de que voce
	carrega, como <devicename>ad0</devicename> para o primeiro disco IDE,
	<devicename>ad2</devicename> para o primeiro disco IDE da segunda
	controladora IDE, <devicename>da0</devicename> para o primeiro disco SCSI,
	e assim por diante.</para>

      <para>Se voce for um usuario  Linux, entretanto, e preferir que
	<application>LILO</application> controle o processo de inicializacao, voce pode
	editar o arquivo <filename>/etc/lilo.conf</filename> para FreeBSD, ou
	selecionar <option>Leave The Master Boot Record Untouched</option>
	durante o processo de instalacao do FreeBSD. Se voce tiver instalado o
	gerenciador de boot do FreeBSD, voce pode carregar dentro do Linux e modificar o
	<application>LILO</application> no arquivo de configuracao
	<filename>/etc/lilo.conf</filename> e adicionar a seguinte
	opcao:</para>

      <programlisting>other=/dev/hdXY
table=/dev/hdb
loader=/boot/chain.b
label=FreeBSD</programlisting>

      <para>Qual permitira a inicializacao do FreeBSD e Linux via
	<application>LILO</application>. Em outro exemplo, nos usamos
	<replaceable>XY</replaceable> para determinar o numero do drive e
	particao. Se estiver usando um drive <acronym>SCSI</acronym>, voce
	ira querer mudar o <replaceable>/dev/hdXY</replaceable> para leitura
	algo similar a <replaceable>/dev/sdXY</replaceable>, com
	novamente usando a sintase <replaceable>XY</replaceable>. O
	<option>loader=/boot/chain.b</option> pode ser omitido se voce tiver
	ambos os sistemas operacionais na mesma particao. Voce pode agora rodar
	<command>/sbin/lilo -v</command> para executar suas novas alteracoes no
	sistema, este deve ser verificado com messagens na tela.</para>
    </sect2>
  
    <sect2 id="boot-boot1">
      <title>Estagio Um, <filename>/boot/boot1</filename>, e Estagio Dois,
	<filename>/boot/boot2</filename></title>
      
      <para>Conceitual o primeiro e segundo estagios sao parte do mesmo
	programa, sobre a mesma area do disco. Por que do espaco contido
	eles foram divididos em duas partes, mas voce deve instala-los juntos.</para>

      <para>Eles sao encontrados no setor de inicializacao, 
	que e onde <link
	  linkend="boot-boot0">boot0</link>, ou alguns outros programas na
	<abbrev>MBR</abbrev> espera encontrar um programa para rodar
	continuar o processo de carga. O arquivo no diretorio
	<filename>/boot</filename> sao copiados dos arquivos reais,
	que sao armazenados fora do sistema de arquivos do FreeBSD.</para>

      <para><filename>boot1</filename> e muito simples, desde tambem possa
	somente ser 512 bytes
	de tamanho, e sabemos justamente para o
	<firstterm>disklabel</firstterm> do FreeBSD, com informacoes armazenadas
	no silindro, para procurar e executar o <filename>boot2</filename>.</para>
      
      <para><filename>boot2</filename> e ligeiramente mais sofisticado, e compreende
	bastante o sistema de arquivos do FreeBSD para procurar arquivos nele, e pode
	fornecer uma simples interface para escolher o kernel ou o carregador para
	executar.</para>

      <para>Desde o <link linkend="boot-loader">carregador</link> e
	mais sofisticado, e forncecido um boa facil-para-usar
	configuracao de inicializacao, <filename>boot2</filename> usualmente executa
	isto, mas previamente isto
	era tarefa para executar diretamente no kernel.</para>

      <example id="boot-boot2-example">
	<title><filename>boot2</filename> Screenshot</title>

	<screen>&gt;&gt; FreeBSD/i386 BOOT
Default: 0:ad(0,a)/kernel
boot:</screen>
      </example>

      <para>Se voce precisar sempre substituir a instalacao
	<filename>boot1</filename> e <filename>boot2</filename> use
	&man.disklabel.8;.</para>
      
      <screen>&prompt.root; <userinput>disklabel -B <replaceable>diskslice</replaceable></userinput></screen>

      <para>Onde <replaceable>diskslice</replaceable> e o disco e silindro
	da sua inicializacao, tal como <devicename>ad0s1</devicename> para o primeiro
	HD sobre a IDE.</para>

      <warning>
	<title>Modalidade Perigosamente Dedicada</title>

	<para>Se voce usar apenas o nome do disco, tal como
	  <devicename>ad0</devicename>, no &man.disklabel.8; comando voce
	  ira criar um disco perigosamente dedicado, sem particoes.  Isto nao
	  devera ser o que voce quer fazer, assim que voce verificar o dobro
	  do &man.disklabel.8; depois voce devera pressionar
	  <keycap>Return</keycap>.</para>
      </warning>
    </sect2>

  <sect2 id="boot-loader">
    <title>Estagio tres, <filename>/boot/loader</filename></title>

    <indexterm><primary>boot-loader</primary></indexterm>
    <para>A inicializacao e o estagio final dos tres-estagios
      de bootstrap, e e localizado no sistema de arquivos, usualmente como
      <filename>/boot/loader</filename>.</para>
      
    <para>A inicializacao e usada como um metodo amigavel para
      configuracao, usando um jogo de comandos internos facil-para-usar,
      voltado por um interpretador mais poderoso, com um jogo de comandos mais complexo.</para> 

    <sect3 id="boot-loader-flow">
      <title>Fluxo de programa do carregador</title>
      
      <para>Durante a initializacao, o carregador sodara para uma
	console e para discos, e figura de saida de que os discos sao 
	carregados. Isto setara variaveis conformemente, e um
	interpretador e iniciado onde os comandos do usuario podem ser passados de 
        um script ou interativamente.</para>
      <indexterm><primary>carregados</primary></indexterm>
      <indexterm><primary>carregados na configuracao</primary></indexterm>

      <para>Entao o carregador lera entao o
	<filename>/boot/loader.rc</filename>, que por padrao le
	dentro de  <filename>/boot/defaults/loader.conf</filename> que
	seta padroes para variaveis e leen em 
	<filename>/boot/loader.conf</filename> para mudanca destas variaveis locais.
	<filename>loader.rc</filename> eles atuam
	sobre estas variaveis, carregando qualquer modulo e kernel que sao
	selecionados.</para>

      <para>Finalmente, por padrao, o carregador emite uma espera de  10 segundos
	para precionar alguma tecla, e carregar o kernel se este nao for interrompido.
	Se interrompido, ao usuario e apresentado um alerta no prompt que e para
	entender o facil-para-usar o comando setado, onde o usuario pode
	ajustar variaveis, descarregar todos os modulos, carregar modulos, e eles
	finalmente carregar ou reiniciar.</para>

    </sect3>
    
    <sect3 id="boot-loader-commands">
      <title>Comandos Carregando e Compilando</title>
      
      <para>Estes sao os comandos mais comum usados na carga do sistema. Para uma
        completa discussao de todas avaliacoes dos comandos, por favor veja
        &man.loader.8;.</para>

      <variablelist>
	<varlistentry>
	  <term>auto carregamento <replaceable>segundos</replaceable></term>

	  <listitem>
	    <para>O processo de carregamento do kernel nao e interrompido
	      durante o tempo concedido, em segundos. Isto mostra uma
	      contagem regrassiva, e o tempo padrao concedido e 10
	      segundos.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>boot
	    <optional><replaceable>-options</replaceable></optional>
	    <optional><replaceable>kernelname</replaceable></optional></term>

	  <listitem>
	    <para>Imediatamente o processo de carregamento do kernel, com as
	      opcoes dadas, se existir, e com o nome do kernel dado,
	      se isto for.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>boot-conf</term>

	  <listitem>
	    <para>Ir atraves da mesma configuracao automatica dos
	      modulos baseados em variaveis como que acontece no boot.
	      Isto somente faz sentido se voce primeiramente
	      <command>descarregar</command>, e alterar algumas
	      variaveis, do <envar>kernel</envar> mais frequente.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>help
	    <optional><replaceable>topico</replaceable></optional></term>

	  <listitem>
	    <para>Mensagens de ajuda soa lidas em
	      <filename>/boot/loader.help</filename>. Se o topico
	      dado for <literal>index</literal>, entao a lista de
	      topicos disponiveis e dada.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>include <replaceable>filename</replaceable>
	    &hellip;</term>

	  <listitem>
	    <para>Processa o arquivo com o nome dado ao mesmo. O
	      arquivos e lido, e interpretado linha por linha. Um
	      erro immediatamente para o comando de inclusao.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>load <optional><option>-t</option>
	    <replaceable>type</replaceable></optional>
	    <replaceable>filename</replaceable></term>

	  <listitem>
	    <para>Carregar o kernel, kernel modular, ou arquivo do
	      tipo preparado, com o nome dado. Alguns argumentos
	      depois do nome do arquivo sao passados para o arquivo.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>ls <optional><option>-l</option></optional>
	    <optional><replaceable>path</replaceable></optional></term>

	  <listitem>
	    <para>Mostra uma lista de arquivos dentro dos caminhos dados, ou
	      o diretorio do root, se o caminho nao e especificado. Se e especificado
	      <option>-l</option>, tamanho do arquivo sera
	      mostrado tambem.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>lsdev <optional><option>-v</option></optional></term>

	  <listitem>
	    <para>Lista todos os dispositivos que pode ser possivel
	      para carregar modulos. Se <option>-v</option> e
	      especificado, mais detalhes serao mostrados.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>lsmod <optional><option>-v</option></optional></term>

	  <listitem>
	    <para>Mostra modulos carregados. Se <option>-v</option> e
	      especificado, mais detalhes serao mostrados.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>more <replaceable>filename</replaceable></term>

	  <listitem>
	    <para>Mostra os arquivos especificados, com uma pausa em cada
	      <varname>LINHA</varname> mostrada.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>reboot</term>

	  <listitem>
	    <para>Imediatamente reiniciara o sistema.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>set <replaceable>variable</replaceable></term>
	  <term>set
	    <replaceable>variable</replaceable>=<replaceable>value</replaceable></term>

	  <listitem>
	    <para>Seta as variaveis do ambiente do carregador.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>unload</term>

	  <listitem>
	    <para>Remove todos modulos carregados.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect3>

    <sect3 id="boot-loader-examples">
      <title>Exemplos de carregador</title>

      <para>Estao aqui alguns exemplos praticos do uso do carregador:</para>

      <itemizedlist>
	<indexterm><primary>single-user mode</primary></indexterm>
	<listitem>
	  <para>Para simplesmente carregar seu kernel usual, mas em modo usuario-singular:</para>

	  <screen><userinput>boot -s</userinput></screen>
	</listitem>

	<listitem>
	  <para>Para descarregar seu kernel e modulos usuais, e entao
	    carregar apenas seu kernel velho (ou outro):</para>
    <indexterm>
      <primary><filename>kernel.old</filename></primary>
    </indexterm>

	  <screen><userinput>unload</userinput>
<userinput>load <replaceable>kernel.old</replaceable></userinput></screen>

	  <para>Voce pode usar o <filename>kernel.GENERIC</filename> para
	    referir ao kernel generico que vem no disco instalado,
	    ou <filename>kernel.old</filename> para consultar 
	    seu kernel previamente instalado (quando voce tiver atualizado
	    ou configurado seu kernel, por exemplo).</para>

	  <note>
	    <para>Use o seguinte para carregar seus modulos usuais com
	      outro kernel:</para>

	    <screen><userinput>unload</userinput>
<userinput>set kernel="<replaceable>kernel.old</replaceable>"</userinput>
<userinput>boot-conf</userinput></screen></note>
	</listitem>

	<listitem>
	  <para>Para carregar um script de configuracao do kernel (um script automatizado
	    qual faca as coisas que voce faria normalmente dentro do
	    kernel na configuracao do boot-time):</para>

	  <screen><userinput>load -t userconfig_script <replaceable>/boot/kernel.conf</replaceable></userinput></screen>
	</listitem>
      </itemizedlist>
  </sect3>
    </sect2>
  </sect1>

  <sect1 id="boot-kernel">
    <title>Interacao do Kernel durante o boot</title>
    <indexterm>
      <primary>kernel</primary>
      <secondary>interacao do boot</secondary>
    </indexterm>
    
    <para>Once the kernel is loaded by either <link
	linkend="boot-loader">loader</link> (como usado) ou <link
	linkend="boot-boot1">boot2</link> (passando o carregador), isto
      examina suas boot flags, se existir, e ajusta seu comportamento como
      necessario.</para>

    <sect2 id="boot-kernel-bootflags">
      <indexterm>
        <primary>kernel</primary>
        <secondary>bootflags</secondary>
      </indexterm>
      <title>Kernel Boot Flags</title>

      <para>Estao aqui as boot flags mais comuns:</para>

      <variablelist id="boot-kernel-bootflags-list">
	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
	    <para>durante a inicializacao do kernel, pede para o dispositivo
	      para montar um arquivo de sistema do root.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-C</option></term>

	  <listitem>
	    <para>boot do CDROM.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-c</option></term>

	  <listitem>
	    <para>rode UserConfig, o configurador do boot-time kernel</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-s</option></term>

	  <listitem>
	    <para>boot dentro usando o modo single-user</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>seja mais verbose durante a inicializacao do kernel</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <note>
	<para>Existem outras boot flags, leia &man.boot.8; para maiores
	  informacoes sobre elas.</para></note>
    </sect2>

<!--    <sect2 id="boot-kernel-userconfig">
      <title>UserConfig: o configurador do  Boot-time do Kernel</title>
      
      <para> </para>
    </sect2> -->
  </sect1>
  
  <sect1 id="device-hints">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Contribuido por </contrib>
	</author>
      </authorgroup>
      <!-- 18 OCT 2002 -->
    </sect1info>
    <indexterm>
      <primary>device.hints</primary>
    </indexterm>
    <title>Dispositivos Hints</title>

    <note><para>Esta e uma caracteristica do FreeBSD&nbsp;5.0 e posteriores que nao 
      existe em versoes atrasadas.</para></note>

    <para>Durante a inicializacao do sistema, o boot &man.loader.8; ira ler o arquivo
      &man.device.hints.5;. Este arquivo armazena informacoes do boot do kernel 
      conhecidas como variaveis, sobretudo referenciando as vezes <quote>device hints</quote>.
      Estas <quote>device hints</quote> sao usadas pelos drivers do dispositivo para configuraracao
      do dispositivo.</para>
      
    <para>Device hints podem tambem ser especificados no <link linkend="boot-loader">
      estagio 3 no prompt de inicializacao</link>. Variaveis podem ser adicionadas usando
      comando <command>set</command>, removidas com o comando <command>unset</command>, e visualizadas
      com o comando <command>show</command>. Variaveis setadas dentro do arquivo
      <filename>/boot/device.hints</filename> podem ser canceladas aqui tambem. Device hints incorporadas no
      boot nao sao permanentes e serao perdidas na proxima 
      inicializacao.</para>

    <para>Uma vez que o sistema e carregado, o comando &man.kenv.1; pode ser usado para
      dump todas as variaveis.</para>

    <para>A sintaxe para o arquivo <filename>/boot/device.hints</filename> e uma variavel por linha, usando
      a mistura padrao <quote>#</quote> como marcadores do comentario. Linhas sao
      construidas como segue:</para>

    <screen><userinput>hint.driver.unit.keyword="<replaceable>value</replaceable>"</userinput></screen>

    <para>A sintaxe para o estagio 3 do boot loader e:</para>
    <screen><userinput>set hint.driver.unit.keyword=<replaceable>value</replaceable></userinput></screen>

    <para><literal>driver</literal> e o nome do dispositivo, <literal>unit</literal>
      e o numero do driver dispositivo, e <literal>keyword</literal> e a sugestao
      keyword. O keyword pode consistir nas seguintes opcoes:</para>

    <itemizedlist>
      <listitem>
	<para><literal>at</literal>: especifica o dispositivo para o qual e anexado.</para>
      </listitem>

      <listitem>
	<para><literal>port</literal>: especifica o endereco de inicio do <acronym>I/O</acronym>
	  para ser usado.</para>
      </listitem>

      <listitem>
	<para><literal>irq</literal>: especifica o numero da interrupcao requerida para ser usado.</para>
      </listitem>

      <listitem>
	<para><literal>drq</literal>: especifica o numero do canal DMA.</para>
      </listitem>

      <listitem>
	<para><literal>maddr</literal>: especifica o endereco fisico da memoria ocupado pelo
	  dispositivo.</para>
      </listitem>

      <listitem>
	<para><literal>flags</literal>: seta variacoes de bits de flags para o dispositivos.</para>
      </listitem>

      <listitem>
	<para><literal>disabled</literal>: if set to <literal>1</literal> the device is disabled.</para>
      </listitem>
    </itemizedlist>

    <para>Device drivers may accept (or require) more hints not listed here, viewing
      their manual page is recommended.  For more information, consult the
      &man.device.hints.5;, &man.kenv.1;, &man.loader.conf.5;, and &man.loader.8;
      manual pages.</para>
  </sect1>

  <sect1 id="boot-init">
    <indexterm>
      <primary><command>init</command></primary>
    </indexterm>
    <title>Init: Process Control Initialization</title>
	
    <para>Once the kernel has finished booting, it passes control to
      the user process &man.init.8;, which is located at
      <filename>/sbin/init</filename>, or the program path specified
      in the <envar>init_path</envar> variable in
      <command>loader</command>.</para>

    <sect2 id="boot-autoreboot">
      <title>Automatic Reboot Sequence</title>
      
      <para>The automatic reboot sequence makes sure that the
	file systems available on the system are consistent.  If they
	are not, and &man.fsck.8; cannot fix the
	inconsistencies, &man.init.8; drops the system
	into <link linkend="boot-singleuser">single-user mode</link>
	for the system administrator to take care of the problems
	directly.</para>
    </sect2>

    <sect2 id="boot-singleuser">
      <title>Single-User Mode</title>
      <indexterm><primary>single-user mode</primary></indexterm>
      <indexterm><primary>console</primary></indexterm>
      
      <para>This mode can be reached through the <link
	  linkend="boot-autoreboot">automatic reboot
	  sequence</link>, or by the user booting with the
	<option>-s</option> option or setting the
	<envar>boot_single</envar> variable in
	<command>loader</command>.</para>

      <para>It can also be reached by calling
	&man.shutdown.8; without the reboot
	(<option>-r</option>) or halt (<option>-h</option>) options,
	from <link linkend="boot-multiuser">multi-user
	  mode</link>.</para>

      <para>If the system <literal>console</literal> is set
	to <literal>insecure</literal> in <filename>/etc/ttys</filename>,
	then the system prompts for the <username>root</username> password
	before initiating single-user mode.</para>

      <example id="boot-insecure-console">
	<title>An Insecure Console in <filename>/etc/ttys</filename></title>

	<programlisting># name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off insecure</programlisting>
      </example>

      <note>
	<para>An <literal>insecure</literal> console means that you
	  consider your physical security to the console to be
	  insecure, and want to make sure only someone who knows the
	  <username>root</username> password may use single-user mode, and it
	  does not mean that you want to run your console insecurely.  Thus,
	  if you want security, choose <literal>insecure</literal>,
	  not <literal>secure</literal>.</para>
      </note>
    </sect2>
    
    <sect2 id="boot-multiuser">
      <title>Multi-User Mode</title>
      <indexterm><primary>multi-user mode</primary></indexterm>
      
      <para>If &man.init.8; finds your file systems to be
	in order, or once the user has finished in <link
	  linkend="boot-singleuser">single-user mode</link>, the
	system enters multi-user mode, in which it starts the
	resource configuration of the system.</para>

      <sect3 id="boot-rc">
      <indexterm><primary>rc files</primary></indexterm>
	<title>Resource Configuration (rc)</title>

	<para>The resource configuration system reads in
	  configuration defaults from
	  <filename>/etc/defaults/rc.conf</filename>, and
	  system-specific details from
	  <filename>/etc/rc.conf</filename>, and then proceeds to
	  mount the system file systems mentioned in
	  <filename>/etc/fstab</filename>, start up networking
	  services, start up miscellaneous system daemons, and
	  finally runs the startup scripts of locally installed
	  packages.</para>

	<para>The &man.rc.8; manual page is a good reference to the resource
	  configuration system, as is examining the scripts
	  themselves.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="boot-shutdown">
    <title>Shutdown Sequence</title>
    <indexterm>
      <primary><command>shutdown</command></primary>
    </indexterm>

    <para>Upon controlled shutdown, via &man.shutdown.8;,
      &man.init.8; will attempt to run the script
      <filename>/etc/rc.shutdown</filename>, and then proceed to send
      all processes the <literal>TERM</literal> signal, and subsequently 
      the <literal>KILL</literal> signal to any that do not terminate 
      timely.</para>

    <para>To power down a FreeBSD machine on architectures and systems
      that support power management, simply use the command
      <command>shutdown -p now</command> to turn the power off
      immediately.  To just reboot a FreeBSD system, just use
      <command>shutdown -r now</command>.  You need to be
      <username>root</username> or a member of
      <groupname>operator</groupname> group to run &man.shutdown.8;.
      The &man.halt.8; and &man.reboot.8; commands can also be used,
      please refer to their manual pages and to &man.shutdown.8;'s one
      for more informations.</para>

    <note>
      <para>Power management requires &man.acpi.4; support in the kernel
	or loaded as module for FreeBSD&nbsp;5.X and &man.apm.4;
	support for FreeBSD&nbsp;4.X.</para>
    </note>

  </sect1>
</chapter>

<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

