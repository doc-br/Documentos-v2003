<!--
     The FreeBSD Documentation Project

     $FreeBSD: doc/en_US.ISO8859-1/books/handbook/boot/chapter.sgml,v 1.55 2003/08/23 23:26:43 simon Exp $
-->

<chapter id="boot">
  <title>O processo de inicialização do FreeBSD</title>

  <sect1 id="boot-synopsis">
    <title>Sinópse</title>
    <indexterm><primary>booting</primary></indexterm>
    <indexterm><primary>bootstrap</primary></indexterm>

    <para>O processo de inicialização e carregamento de um computador com sistema operacional
      refere-se a um <quote>processo de inicializar</quote>, ou simplesmente
      <quote>carregar</quote>. O processo de inicialização do FreeBSD fornece uma grande flexibilidade 
      que acontece quando você inicia o sistema,
      permitindo que você selecione das diferentes operações no sistema instalado no mesmo
      computador, ou igualar diferentes versões do mesmo sistema operacional
      ou do kernel instalado.</para>

    <para>Este capítulo detalha as opções de configuração que você pode ajustar e
      personalizar o processo de inicialização do FreeBSD. Isto inclui tudo o que 
      acontece desde a hora do kernel do FreeBSD carregar, testar os dispositivos, e
      inicializar &man.init.8;. Se voce nao estiver totalmente certo de quando isso acontece, isto
      acontece quando a cor do texto muda de branco brilhante para cinza.</para>

    <para>Depois de ler este capitulo, voce sabera:</para>

    <itemizedlist>
      <listitem>
	<para>O que os componentes do FreeBSD tiram e colocam no sistema, e como
	  eles interagem.</para>
      </listitem>

      <listitem>
	<para>A opcoes que voce pode dar a componentes no FreeBSD
	  colocando ou tirando para controlar o processo de inicializacao.</para>
      </listitem>
      
      <listitem>
        <para>O basico de &man.device.hints.5;.</para>
      </listitem>
    </itemizedlist>

    <note>
      <title>Somente x86</title>

      <para>Este capitulo somente descreve o processo de inicializacao para FreeBSD rodando
	em sistemas Intel x86.</para>
    </note>
  </sect1>

  <sect1 id="boot-introduction">
    <title>O problema na inicializacao</title>

    <para>Voltando a um computador inicializando o sistema operacional a atitude e um
      dilema interessante. Por definicao, o computador nao sabe qualquer
      coisa antes que o sistema operacional esteja iniciando. isto inclui
      rodar programas do disco. Assim se o computador nao pode rodar um
      programa do disco sem o sistema operacional, e os programas do sistema operacional
      estao no disco, como o sistema operacional foi inicializado?</para>

    <para>Este problema paralelo um estao no livro <citetitle>As aventuras de
      Baron Munchausen</citetitle>. Um caracter teve afastado parte way down a
      manhole, and pulled himself out by grabbing his bootstraps, and
      lifting.  Nos dias de computacao o termo
      <firstterm>colocar e tirar</firstterm> foi aplicado no mecanismo usado para
      carregar o sistema operacional, que se tornou compacto para
      <quote>carregar</quote>.</para>

    <para>No hardware x86 o Sistema Basico de Entrada/Saida (BIOS) e responsavel
      por carregar o sistema operacional. Para fazer isto, na BIOS aparece o
      hard disk para o Master Boot Record (MBR), que deve ser alocado sobre um
      local especifico do disco. A BIOS tem bastante mudancas que podem ser feitas para carregar e
      rodar a MBR, e assume que a MBR pode entao carregar a saida do resto das
      tarefas involvidas na inicializacao do sistema operacional.</para>

    <indexterm>
      <primary>BIOS</primary>
      <secondary>Basic Input/Output System</secondary>
    </indexterm>

    <para>Se voce tiver somente um sistema operacional instalado no seu disco entao
      MBR padrao sera suficiente. Esta MBR procurara pela primeira particao inicializavel
      no disco, e entao roda o codigo nesta particao para carregar o
      restante do sistema operacional.</para>

    <para>Se voce tiver instalado varios sistemas operacionais em seus discos entao
      voce pode instalar uma MBR diferente, um que pode mostrar uma lista de
      diferentes sistemas operacionais, e permite a voce escolher um para carregar.
      FreeBSD vem com um MBR que pode ser instalado, e outros
      sistemas operacionais vendidos fornecem MBRs alternativos.</para>

    <para>O restante do sistema bootstrap do FreeBSD e divido em tres
      estagios. O primeiro estagio e executado pela MBR, que sabe apenas iniciar
      o computador em um estado especifico e rodar o segundo estagio. O
      segundo estagio pode fazer mais um pedaco em pouco tempo, depois roda o terceiro estagio.
      O terceiro estagio terminara a tarefa de carregar o sistema operacional. O
      trabalho e dividido dentro destes tres estagios porque o padrao do PC impoe
      limites sobre o tamanho dos programas que podem ser rodados nos estagios 1 e
      2. Encadear as tarefas permite que o FreeBSD forneca um carregador mais
      flexivel.</para>

    <indexterm><primary>kernel</primary></indexterm>
    <indexterm><primary><command>init</command></primary></indexterm>

    <para>O kernel entao e inicializado e esta inicializacao testa os dispositivos
      e entao inicializa estes para o uso. Uma vez que o processo de inicializacao do kernel
      e terminado, o kernel passa o controle do processo para
      &man.init.8;, qual se certifica que os discos estao em um estado aproveitavel.
      &man.init.8; comeca entao a configuracao user-level que
      mounta o sistema de arquivos, seta e levanta drivers de rede para comunicacao com
      a rede, e normalmente inicia todos os processos que normalmente
      sao rodados sobre um sistema FreeBSD na inicializacao.</para>
  </sect1>

  <sect1 id="boot-blocks">
    <title>A MBR, e estagios da inicializacao Um, Dois, e Tres</title>

    <sect2 id="boot-boot0">
      <title>MBR, <filename>/boot/boot0</filename></title>
      <indexterm><primary>Master Boot Record (MBR)</primary></indexterm>

      <para>A MBR do FreeBSD e localizado no <filename>/boot/boot0</filename>.
	Este e uma <emphasis>copia</emphasis> do MBR, por que a real MBR deve
	ficar em uma parte especial do disco, fora da area do FreeBSD.</para>

      <para><filename>boot0</filename> e muito simples, visto que o
	programa dentro da <abbrev>MBR</abbrev> pode ter no maximo o tamanho de 512 bytes.
	Se voce tiver instalado na MBR o FreeBSD e tiver instalado
	multiplos sistemas operacionais em seu HD entao voce vera um
	menu similar a este um na hora da inicializacao:</para>

      <example id="boot-boot0-example">
	<title><filename>boot0</filename> Screenshot</title>

	<screen>F1 DOS
F2 FreeBSD
F3 Linux
F4 ??
F5 Drive 1

Default: F2</screen>
      </example>

      <para>Outros sistemas operacionais, em particular &windows;&nbsp;95, tem conhecimento que
	sobscrevem informacoes ja existentes na MBR com suas proprias. Se isto acontecer a voce,
	ou voce queira substituir sua existente MBR com o FreeBSD MBR entao use
	o seguinte comando:</para>

      <screen>&prompt.root; <userinput>fdisk -B -b /boot/boot0 <replaceable>device</replaceable></userinput></screen>

      <para>Como <replaceable>dispositivo</replaceable> e o dispositivo de que voce
	carrega, como <devicename>ad0</devicename> para o primeiro disco IDE,
	<devicename>ad2</devicename> para o primeiro disco IDE da segunda
	controladora IDE, <devicename>da0</devicename> para o primeiro disco SCSI,
	e assim por diante.</para>

      <para>Se voce for um usuario  Linux, entretanto, e preferir que
	<application>LILO</application> controle o processo de inicializacao, voce pode
	editar o arquivo <filename>/etc/lilo.conf</filename> para FreeBSD, ou
	selecionar <option>Leave The Master Boot Record Untouched</option>
	durante o processo de instalacao do FreeBSD. Se voce tiver instalado o
	gerenciador de boot do FreeBSD, voce pode carregar dentro do Linux e modificar o
	<application>LILO</application> no arquivo de configuracao
	<filename>/etc/lilo.conf</filename> e adicionar a seguinte
	opcao:</para>

      <programlisting>other=/dev/hdXY
table=/dev/hdb
loader=/boot/chain.b
label=FreeBSD</programlisting>

      <para>Qual permitira a inicializacao do FreeBSD e Linux via
	<application>LILO</application>. Em outro exemplo, nos usamos
	<replaceable>XY</replaceable> para determinar o numero do drive e
	particao. Se estiver usando um drive <acronym>SCSI</acronym>, voce
	ira querer mudar o <replaceable>/dev/hdXY</replaceable> para leitura
	algo similar a <replaceable>/dev/sdXY</replaceable>, com
	novamente usando a sintase <replaceable>XY</replaceable>. O
	<option>loader=/boot/chain.b</option> pode ser omitido se voce tiver
	ambos os sistemas operacionais na mesma particao. Voce pode agora rodar
	<command>/sbin/lilo -v</command> para executar suas novas alteracoes no
	sistema, este deve ser verificado com messagens na tela.</para>
    </sect2>
  
    <sect2 id="boot-boot1">
      <title>Estagio Um, <filename>/boot/boot1</filename>, e Estagio Dois,
	<filename>/boot/boot2</filename></title>
      
      <para>Conceitual o primeiro e segundo estagios sao parte do mesmo
	programa, sobre a mesma area do disco. Por que do espaco contido
	eles foram divididos em duas partes, mas voce deve instala-los juntos.</para>

      <para>Eles sao encontrados no setor de inicializacao, 
	que e onde <link
	  linkend="boot-boot0">boot0</link>, ou alguns outros programas na
	<abbrev>MBR</abbrev> espera encontrar um programa para rodar
	continuar o processo de carga. O arquivo no diretorio
	<filename>/boot</filename> sao copiados dos arquivos reais,
	que sao armazenados fora do sistema de arquivos do FreeBSD.</para>

      <para><filename>boot1</filename> e muito simples, desde tambem possa
	somente ser 512 bytes
	de tamanho, e sabemos justamente para o
	<firstterm>disklabel</firstterm> do FreeBSD, com informacoes armazenadas
	no silindro, para procurar e executar o <filename>boot2</filename>.</para>
      
      <para><filename>boot2</filename> e ligeiramente mais sofisticado, e compreende
	bastante o sistema de arquivos do FreeBSD para procurar arquivos nele, e pode
	fornecer uma simples interface para escolher o kernel ou o carregador para
	executar.</para>

      <para>Desde o <link linkend="boot-loader">carregador</link> e
	mais sofisticado, e forncecido um boa facil-para-usar
	configuracao de inicializacao, <filename>boot2</filename> usualmente executa
	isto, mas previamente isto
	era tarefa para executar diretamente no kernel.</para>

      <example id="boot-boot2-example">
	<title><filename>boot2</filename> Screenshot</title>

	<screen>&gt;&gt; FreeBSD/i386 BOOT
Default: 0:ad(0,a)/kernel
boot:</screen>
      </example>

      <para>Se voce precisar sempre substituir a instalacao
	<filename>boot1</filename> e <filename>boot2</filename> use
	&man.disklabel.8;.</para>
      
      <screen>&prompt.root; <userinput>disklabel -B <replaceable>diskslice</replaceable></userinput></screen>

      <para>Onde <replaceable>diskslice</replaceable> e o disco e silindro
	da sua inicializacao, tal como <devicename>ad0s1</devicename> para o primeiro
	HD sobre a IDE.</para>

      <warning>
	<title>Modalidade Perigosamente Dedicada</title>

	<para>Se voce usar apenas o nome do disco, tal como
	  <devicename>ad0</devicename>, no &man.disklabel.8; comando voce
	  ira criar um disco perigosamente dedicado, sem particoes.  Isto nao
	  devera ser o que voce quer fazer, assim que voce verificar o dobro
	  do &man.disklabel.8; depois voce devera pressionar
	  <keycap>Return</keycap>.</para>
      </warning>
    </sect2>

  <sect2 id="boot-loader">
    <title>Estagio tres, <filename>/boot/loader</filename></title>

    <indexterm><primary>boot-loader</primary></indexterm>
    <para>A inicializacao e o estagio final dos tres-estagios
      de bootstrap, e e localizado no sistema de arquivos, usualmente como
      <filename>/boot/loader</filename>.</para>
      
    <para>The loader is intended as a user-friendly method for
      configuration, using an easy-to-use built-in command set,
      backed up by a more powerful interpreter, with a more complex
      command set.</para> 

    <sect3 id="boot-loader-flow">
      <title>Loader Program Flow</title>
      
      <para>During initialization, the loader will probe for a
	console and for disks, and figure out what disk it is
	booting from.  It will set variables accordingly, and an
	interpreter is started where user commands can be passed from
	a script or interactively.</para>
      <indexterm><primary>loader</primary></indexterm>
      <indexterm><primary>loader configuration</primary></indexterm>

      <para>The loader will then read
	<filename>/boot/loader.rc</filename>, which by default reads
	in <filename>/boot/defaults/loader.conf</filename> which
	sets reasonable defaults for variables and reads
	<filename>/boot/loader.conf</filename> for local changes to
	those variables.  <filename>loader.rc</filename> then acts
	on these variables, loading whichever modules and kernel are
	selected.</para>

      <para>Finally, by default, the loader issues a 10 second wait
	for key presses, and boots the kernel if it is not interrupted.
	If interrupted, the user is presented with a prompt which
	understands the easy-to-use command set, where the user may
	adjust variables, unload all modules, load modules, and then
	finally boot or reboot.</para>

    </sect3>
    
    <sect3 id="boot-loader-commands">
      <title>Loader Built-In Commands</title>
      
      <para>These are the most commonly used loader commands.  For a
        complete discussion of all available commands, please see
        &man.loader.8;.</para>

      <variablelist>
	<varlistentry>
	  <term>autoboot <replaceable>seconds</replaceable></term>

	  <listitem>
	    <para>Proceeds to boot the kernel if not interrupted
	      within the time span given, in seconds.  It displays a
	      countdown, and the default time span is 10
	      seconds.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>boot
	    <optional><replaceable>-options</replaceable></optional>
	    <optional><replaceable>kernelname</replaceable></optional></term>

	  <listitem>
	    <para>Immediately proceeds to boot the kernel, with the
	      given options, if any, and with the kernel name given,
	      if it is.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>boot-conf</term>

	  <listitem>
	    <para>Goes through the same automatic configuration of
	      modules based on variables as what happens at boot.
	      This only makes sense if you use
	      <command>unload</command> first, and change some
	      variables, most commonly <envar>kernel</envar>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>help
	    <optional><replaceable>topic</replaceable></optional></term>

	  <listitem>
	    <para>Shows help messages read from
	      <filename>/boot/loader.help</filename>.  If the topic
	      given is <literal>index</literal>, then the list of
	      available topics is given.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>include <replaceable>filename</replaceable>
	    &hellip;</term>

	  <listitem>
	    <para>Processes the file with the given filename.  The
	      file is read in, and interpreted line by line.  An
	      error immediately stops the include command.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>load <optional><option>-t</option>
	    <replaceable>type</replaceable></optional>
	    <replaceable>filename</replaceable></term>

	  <listitem>
	    <para>Loads the kernel, kernel module, or file of the
	      type given, with the filename given.  Any arguments
	      after filename are passed to the file.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>ls <optional><option>-l</option></optional>
	    <optional><replaceable>path</replaceable></optional></term>

	  <listitem>
	    <para>Displays a listing of files in the given path, or
	      the root directory, if the path is not specified.  If
	      <option>-l</option> is specified, file sizes will be
	      shown too.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>lsdev <optional><option>-v</option></optional></term>

	  <listitem>
	    <para>Lists all of the devices from which it may be
	      possible to load modules. If <option>-v</option> is
	      specified, more details are printed.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>lsmod <optional><option>-v</option></optional></term>

	  <listitem>
	    <para>Displays loaded modules. If <option>-v</option> is
	      specified, more details are shown.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>more <replaceable>filename</replaceable></term>

	  <listitem>
	    <para>Displays the files specified, with a pause at each
	      <varname>LINES</varname> displayed.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>reboot</term>

	  <listitem>
	    <para>Immediately reboots the system.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>set <replaceable>variable</replaceable></term>
	  <term>set
	    <replaceable>variable</replaceable>=<replaceable>value</replaceable></term>

	  <listitem>
	    <para>Sets the loader's environment variables.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>unload</term>

	  <listitem>
	    <para>Removes all loaded modules.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect3>

    <sect3 id="boot-loader-examples">
      <title>Loader Examples</title>

      <para>Here are some practical examples of loader usage:</para>

      <itemizedlist>
	<indexterm><primary>single-user mode</primary></indexterm>
	<listitem>
	  <para>To simply boot your usual kernel, but in single-user
	    mode:</para>

	  <screen><userinput>boot -s</userinput></screen>
	</listitem>

	<listitem>
	  <para>To unload your usual kernel and modules, and then
	    load just your old (or another) kernel:</para>
    <indexterm>
      <primary><filename>kernel.old</filename></primary>
    </indexterm>

	  <screen><userinput>unload</userinput>
<userinput>load <replaceable>kernel.old</replaceable></userinput></screen>

	  <para>You can use <filename>kernel.GENERIC</filename> to
	    refer to the generic kernel that comes on the install
	    disk, or <filename>kernel.old</filename> to refer to
	    your previously installed kernel (when you have upgraded
	    or configured your own kernel, for example).</para>

	  <note>
	    <para>Use the following to load your usual modules with
	      another kernel:</para>

	    <screen><userinput>unload</userinput>
<userinput>set kernel="<replaceable>kernel.old</replaceable>"</userinput>
<userinput>boot-conf</userinput></screen></note>
	</listitem>

	<listitem>
	  <para>To load a kernel configuration script (an automated
	    script which does the things you would normally do in the
	    kernel boot-time configurator):</para>

	  <screen><userinput>load -t userconfig_script <replaceable>/boot/kernel.conf</replaceable></userinput></screen>
	</listitem>
      </itemizedlist>
  </sect3>
    </sect2>
  </sect1>

  <sect1 id="boot-kernel">
    <title>Kernel Interaction During Boot</title>
    <indexterm>
      <primary>kernel</primary>
      <secondary>boot interaction</secondary>
    </indexterm>
    
    <para>Once the kernel is loaded by either <link
	linkend="boot-loader">loader</link> (as usual) or <link
	linkend="boot-boot1">boot2</link> (bypassing the loader), it
      examines its boot flags, if any, and adjusts its behavior as
      necessary.</para>

    <sect2 id="boot-kernel-bootflags">
      <indexterm>
        <primary>kernel</primary>
        <secondary>bootflags</secondary>
      </indexterm>
      <title>Kernel Boot Flags</title>

      <para>Here are the more common boot flags:</para>

      <variablelist id="boot-kernel-bootflags-list">
	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
	    <para>during kernel initialization, ask for the device
	      to mount as the root file system.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-C</option></term>

	  <listitem>
	    <para>boot from CDROM.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-c</option></term>

	  <listitem>
	    <para>run UserConfig, the boot-time kernel
	      configurator</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-s</option></term>

	  <listitem>
	    <para>boot into single-user mode</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>be more verbose during kernel startup</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <note>
	<para>There are other boot flags, read &man.boot.8; for more
	  information on them.</para></note>
    </sect2>

<!--    <sect2 id="boot-kernel-userconfig">
      <title>UserConfig: the Boot-time Kernel Configurator</title>
      
      <para> </para>
    </sect2> -->
  </sect1>
  
  <sect1 id="device-hints">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
      <!-- 18 OCT 2002 -->
    </sect1info>
    <indexterm>
      <primary>device.hints</primary>
    </indexterm>
    <title>Device Hints</title>

    <note><para>This is a FreeBSD&nbsp;5.0 and later feature which does not
      exist in earlier versions.</para></note>

    <para>During initial system startup, the boot &man.loader.8; will read the
      &man.device.hints.5; file.  This file stores kernel boot information
      known as variables, sometimes referred to as <quote>device hints</quote>.
      These <quote>device hints</quote> are used by device drivers for device
      configuration.</para>
      
    <para>Device hints may also be specified at the <link linkend="boot-loader">
      Stage 3 boot loader</link> prompt.  Variables can be added using
      <command>set</command>, removed with <command>unset</command>, and viewed
      with the <command>show</command> commands.  Variables set in the
      <filename>/boot/device.hints</filename> file can be overridden here also.  Device hints entered at
      the boot loader are not permanent and will be forgotten on the next
      reboot.</para>

    <para>Once the system is booted, the &man.kenv.1; command can be used to
      dump all of the variables.</para>

    <para>The syntax for the <filename>/boot/device.hints</filename> file is one variable per line, using
      the standard hash <quote>#</quote> as comment markers.  Lines are
      constructed as follows:</para>

    <screen><userinput>hint.driver.unit.keyword="<replaceable>value</replaceable>"</userinput></screen>

    <para>The syntax for the Stage 3 boot loader is:</para>
    <screen><userinput>set hint.driver.unit.keyword=<replaceable>value</replaceable></userinput></screen>

    <para><literal>driver</literal> is the device driver name, <literal>unit</literal>
      is the device driver unit number, and <literal>keyword</literal> is the hint
      keyword.  The keyword may consist of the following options:</para>

    <itemizedlist>
      <listitem>
	<para><literal>at</literal>: specifies the bus which the device is attached to.</para>
      </listitem>

      <listitem>
	<para><literal>port</literal>: specifies the start address of the <acronym>I/O</acronym>
	  to be used.</para>
      </listitem>

      <listitem>
	<para><literal>irq</literal>: specifies the interrupt request number to be used.</para>
      </listitem>

      <listitem>
	<para><literal>drq</literal>: specifies the DMA channel number.</para>
      </listitem>

      <listitem>
	<para><literal>maddr</literal>: specifies the physical memory address occupied by the
	  device.</para>
      </listitem>

      <listitem>
	<para><literal>flags</literal>: sets various flag bits for the device.</para>
      </listitem>

      <listitem>
	<para><literal>disabled</literal>: if set to <literal>1</literal> the device is disabled.</para>
      </listitem>
    </itemizedlist>

    <para>Device drivers may accept (or require) more hints not listed here, viewing
      their manual page is recommended.  For more information, consult the
      &man.device.hints.5;, &man.kenv.1;, &man.loader.conf.5;, and &man.loader.8;
      manual pages.</para>
  </sect1>

  <sect1 id="boot-init">
    <indexterm>
      <primary><command>init</command></primary>
    </indexterm>
    <title>Init: Process Control Initialization</title>
	
    <para>Once the kernel has finished booting, it passes control to
      the user process &man.init.8;, which is located at
      <filename>/sbin/init</filename>, or the program path specified
      in the <envar>init_path</envar> variable in
      <command>loader</command>.</para>

    <sect2 id="boot-autoreboot">
      <title>Automatic Reboot Sequence</title>
      
      <para>The automatic reboot sequence makes sure that the
	file systems available on the system are consistent.  If they
	are not, and &man.fsck.8; cannot fix the
	inconsistencies, &man.init.8; drops the system
	into <link linkend="boot-singleuser">single-user mode</link>
	for the system administrator to take care of the problems
	directly.</para>
    </sect2>

    <sect2 id="boot-singleuser">
      <title>Single-User Mode</title>
      <indexterm><primary>single-user mode</primary></indexterm>
      <indexterm><primary>console</primary></indexterm>
      
      <para>This mode can be reached through the <link
	  linkend="boot-autoreboot">automatic reboot
	  sequence</link>, or by the user booting with the
	<option>-s</option> option or setting the
	<envar>boot_single</envar> variable in
	<command>loader</command>.</para>

      <para>It can also be reached by calling
	&man.shutdown.8; without the reboot
	(<option>-r</option>) or halt (<option>-h</option>) options,
	from <link linkend="boot-multiuser">multi-user
	  mode</link>.</para>

      <para>If the system <literal>console</literal> is set
	to <literal>insecure</literal> in <filename>/etc/ttys</filename>,
	then the system prompts for the <username>root</username> password
	before initiating single-user mode.</para>

      <example id="boot-insecure-console">
	<title>An Insecure Console in <filename>/etc/ttys</filename></title>

	<programlisting># name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off insecure</programlisting>
      </example>

      <note>
	<para>An <literal>insecure</literal> console means that you
	  consider your physical security to the console to be
	  insecure, and want to make sure only someone who knows the
	  <username>root</username> password may use single-user mode, and it
	  does not mean that you want to run your console insecurely.  Thus,
	  if you want security, choose <literal>insecure</literal>,
	  not <literal>secure</literal>.</para>
      </note>
    </sect2>
    
    <sect2 id="boot-multiuser">
      <title>Multi-User Mode</title>
      <indexterm><primary>multi-user mode</primary></indexterm>
      
      <para>If &man.init.8; finds your file systems to be
	in order, or once the user has finished in <link
	  linkend="boot-singleuser">single-user mode</link>, the
	system enters multi-user mode, in which it starts the
	resource configuration of the system.</para>

      <sect3 id="boot-rc">
      <indexterm><primary>rc files</primary></indexterm>
	<title>Resource Configuration (rc)</title>

	<para>The resource configuration system reads in
	  configuration defaults from
	  <filename>/etc/defaults/rc.conf</filename>, and
	  system-specific details from
	  <filename>/etc/rc.conf</filename>, and then proceeds to
	  mount the system file systems mentioned in
	  <filename>/etc/fstab</filename>, start up networking
	  services, start up miscellaneous system daemons, and
	  finally runs the startup scripts of locally installed
	  packages.</para>

	<para>The &man.rc.8; manual page is a good reference to the resource
	  configuration system, as is examining the scripts
	  themselves.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="boot-shutdown">
    <title>Shutdown Sequence</title>
    <indexterm>
      <primary><command>shutdown</command></primary>
    </indexterm>

    <para>Upon controlled shutdown, via &man.shutdown.8;,
      &man.init.8; will attempt to run the script
      <filename>/etc/rc.shutdown</filename>, and then proceed to send
      all processes the <literal>TERM</literal> signal, and subsequently 
      the <literal>KILL</literal> signal to any that do not terminate 
      timely.</para>

    <para>To power down a FreeBSD machine on architectures and systems
      that support power management, simply use the command
      <command>shutdown -p now</command> to turn the power off
      immediately.  To just reboot a FreeBSD system, just use
      <command>shutdown -r now</command>.  You need to be
      <username>root</username> or a member of
      <groupname>operator</groupname> group to run &man.shutdown.8;.
      The &man.halt.8; and &man.reboot.8; commands can also be used,
      please refer to their manual pages and to &man.shutdown.8;'s one
      for more informations.</para>

    <note>
      <para>Power management requires &man.acpi.4; support in the kernel
	or loaded as module for FreeBSD&nbsp;5.X and &man.apm.4;
	support for FreeBSD&nbsp;4.X.</para>
    </note>

  </sect1>
</chapter>

<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

