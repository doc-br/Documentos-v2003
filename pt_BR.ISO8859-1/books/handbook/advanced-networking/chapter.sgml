<!--
     The FreeBSD Documentation Project

     $FreeBSD: doc/en_US.ISO8859-1/books/handbook/advanced-networking/chapter.sgml,v 1.251 2003/11/23 17:52:10 ceri Exp $
-->

<chapter id="advanced-networking">
  <title>Rede Avan&ccedil;ada</title>

  <sect1 id="advanced-networking-synopsis">
    <title>&Iacute;ndice</title>

    <para>Este cap&iacute;tulo aborda alguns servi&ccedil;os de redes
    usados com mais freq&uuml;&ecirc;ncia em sistemas &unix;.  Vamos
    abordar como definir, configurar, testar e manter todos
    os servi&ccedil;os de rede que o FreeBSD usa.  Adicionalmente,
    existem exemplos de arquivos de configura&ccedil;&atilde;o
    inclusos pelo cap&iacute;tulo para seu usufruto.</para>

    <para>Ap&oacute;s a leitura deste cap&iacute;tulo, voc&ecirc; saber&aacute;:</para>

    <itemizedlist>
      <listitem>
	<para>O b&aacute;sico sobre gateways e rotas.</para>
      </listitem>

      <listitem>
	<para>Como fazer o FreeBSD atuar como uma
	ponte.</para>
      </listitem>

      <listitem>
	<para>Como ativar um sistema de arquivos em
	rede.</para>
      </listitem>

      <listitem>
	<para>Como ativar inicializa&ccedil;&atilde;o remota em uma
	m&aacute;quina sem disco.</para>
      </listitem>

      <listitem>
	<para>Como ativar um servidor de informa&ccedil;&atilde;o de
	rede.</para>
      </listitem>

      <listitem>
	<para>Como ativar configura&ccedil;&otilde;es autom&aacute;ticas de rede
	usando DHCP.</para>
      </listitem>

      <listitem>
	<para>Como ativar um servidor de nome de
	dom&iacute;nio.</para>
      </listitem>

      <listitem>
	<para>Como sincronizar a hora e data, e ativar um servidor
	de hora com o protocolo NTP.</para>
      </listitem>

      <listitem>
	<para>Como ativar tradu&ccedil;&atilde;o de endere&ccedil;o de rede.</para>
      </listitem>

      <listitem>
	<para>Como gerenciar o daemon <application>inetd</application>.</para>
      </listitem>

      <listitem>
	<para>Como conectar dois computadores via PLIP.</para>
      </listitem>

      <listitem>
	<para>Como ativar o IPv6 em uma m&aacute;quina FreeBSD.</para>
      </listitem>
    </itemizedlist>

    <para>Antes de ler este cap&iacute;tulo, voc&ecirc; deve:</para>

    <itemizedlist>
      <listitem>
	<para>Compreender os princ&iacute;pios dos scripts
	<filename>/etc/rc</filename> .</para>
      </listitem>

      <listitem>
	<para>Estar familiarizado com a terminologia b&aacute;sica de
	redes.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="network-routing">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Coranth</firstname>
      	  <surname>Gryphon</surname>
	  <contrib>Contribui&ccedil;&atilde;o de </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Gateways e Rotas</title>

    <indexterm><primary>routing</primary></indexterm>
    <indexterm><primary>gateway</primary></indexterm>
    <indexterm><primary>subrede</primary></indexterm>
    <para>Para uma m&aacute;quina ser capaz de encontrar outra atrav&eacute;s de uma
    rede, &eacute; necess&aacute;rio um mecanismo que descreva como ir de uma
    para a outra.  Isto &eacute; chamado
      <firstterm>roteamento</firstterm>.  Uma <quote>rota</quote> &eacute; um
      par definido de endere&ccedil;os: um <quote>destino</quote> e um
      <quote>gateway</quote>.  O par indica que se voc&ecirc; estiver
      tentando alcan&ccedil;ar este <emphasis>destino</emphasis>, deve se
      comunicar atrav&eacute;s deste <emphasis>gateway</emphasis>.
      Existem tr&ecirc;s tipos de destinos: m&aacute;quinas individuais,
      subredes e <quote>padr&atilde;o</quote> .  A <quote>rota padr&atilde;o</quote> &eacute;
      usada se nenhuma das outras rotas for aplic&aacute;vel.  Vamos falar um
      pouco mais sobre rotas padr&atilde;o mais tarde.  Tamb&eacute;m existem tr&ecirc;s
      tipos de gateways: m&aacute;quinas individuais, interfaces (tamb&eacute;m
      chamadas de <quote>enlaces</quote>) e endere&ccedil;os f&iacute;sicos de
      hardware Ethernet (endere&ccedil;os MAC).
</para>

    <sect2>
      <title>Um Exemplo</title>

      <para>Para ilustrar diferentes aspectos do roteamento, vamos usar o
	seguinte exemplo do <command>netstat</command>:</para>

      <screen>&prompt.user; <userinput>netstat -r</userinput>
Routing tables

Destination      Gateway	    Flags     Refs     Use     Netif Expire

default		 outside-gw	    UGSc       37      418      ppp0
localhost	 localhost	    UH		0      181       lo0
test0		 0:e0:b5:36:cf:4f   UHLW	5    63288       ed0     77
10.20.30.255     link#1		    UHLW	1     2421
exemplo.com      link#1		    UC		0	 0
host1		 0:e0:a8:37:8:1e    UHLW	3     4601       lo0
host2		 0:e0:a8:37:8:1e    UHLW	0	 5	 lo0 =>
host2.exemplo.com link#1	    UC		0	 0
224		 link#1		    UC		0	 0</screen>

      <indexterm><primary>default route</primary></indexterm>
      <para>As duas primeiras linhas especificam a rota padr&atilde;o (a qual
      ser&aacute; abordada na <link linkend="network-routing-default">pr&oacute;xima
      se&ccedil;&atilde;o</link>) e a rota para <hostid>localhost</hostid> (a
      pr&oacute;pria m&aacute;quina).</para>

      <indexterm><primary>loopback device</primary></indexterm>
      <para>A interface (coluna <literal>Netif</literal> ) que esta
      tabela de roteamento usa para especificar o
	<literal>localhost</literal> &eacute; <devicename>lo0</devicename>,
	tamb&eacute;m conhecido como o dispositivo de loopback.  Isto quer
	dizer para manter interno todo o tr&aacute;fego para este destino,
	ao inv&eacute;s de envi&aacute;-lo para fora pela rede local, uma vez que
	simplesmente dever&aacute; retornar ao local de origem.</para>

      <indexterm>
	<primary>Ethernet</primary>
	<secondary>MAC address</secondary>
      </indexterm>
      <para>As pr&oacute;ximas coisas que chamam a aten&ccedil;&atilde;o s&atilde;o os endere&ccedil;os
      come&ccedil;ando com <hostid role="mac">0:e0:</hostid>.  Estes s&atilde;o
      endere&ccedil;os de hardware Ethernet, tamb&eacute;m conhecidos como
      endere&ccedil;os MAC.  O FreeBSD ir&aacute; identificar automaticamente
      quaisquer m&aacute;quinas (no exemplo <hostid>test0</hostid>) na
      Ethernet local e adicionar uma rota direta para aquela m&aacute;quina
      pela interface Ethernet, <devicename>ed0</devicename>.  H&aacute;, tamb&eacute;m,
      um tempo de expira&ccedil;&atilde;o (timeout) associado a este tipo de rota,
      que &eacute; usado em caso de n&atilde;o se receber mais transmiss&otilde;es da m&aacute;quina
      dentro de um prazo espec&iacute;fico de tempo.  Quando isto acontece, a
      rota para esta m&aacute;quina ser&aacute; automaticamente removida.  Estas
      m&aacute;quinas s&atilde;o identificadas usando um mecanismo conhecido como
      RIP (Protocolo de Informa&ccedil;&atilde;o de Roteamento - Routing Information
      Protocol), que calcula rotas para as m&aacute;quinas locais baseado na
      determina&ccedil;&atilde;o do menor caminho.</para>

      <indexterm><primary>subnet</primary></indexterm>
      <para>O FreeBSD tamb&eacute;m adicionar&aacute; rotas de subrede para a subrede
      local (<hostid role="ipaddr">10.20.30.255</hostid> &eacute; o endere&ccedil;o
      de difus&atilde;o (broadcast) para a subrede
      <hostid role="ipaddr">10.20.30</hostid>, e
      <hostid role="domainname">exemplo.com</hostid> &eacute; o nome de dom&iacute;nio
      associado &agrave;quela subrede).  A designa&ccedil;&atilde;o <literal>link#1</literal>
      refere-se &agrave; primeira placa Ethernet na m&aacute;quina.  Voc&ecirc; ir&aacute; notar que
      nenhuma interface adicional &eacute; especificada para aquelas.</para>

      <para>Ambos os grupos (m&aacute;quinas de rede local e subredes locais) t&ecirc;m
	suas rotas configuradas automaticamente por um daemon chamado
	<application>routed</application>.  Se ele n&atilde;o estiver sendo
	executado, ent&atilde;o somente existir&atilde;o rotas definidas estaticamente
	(p.ex.  configuradas explicitamente).</para>

      <para>A linha <literal>host1</literal> refere-se &agrave; nossa m&aacute;quina,
	conhecida pelo endere&ccedil;o Ethernet.  Uma vez que somos a m&aacute;quina
	transmissora, o FreeBSD sabe fazer uso da interface loopback
	(<devicename>lo0</devicename>) ao inv&eacute;s de transmitir pela interface
	Ethernet afora.</para>

      <para>As duas linhas <literal>host2</literal> s&atilde;o um exemplo do
	que acontece quando usamos um apelido &man.ifconfig.8; (veja a
	se&ccedil;&atilde;o sobre Ethernet por raz&otilde;es pelas quais far&iacute;amos isso).  O
	s&iacute;mbolo <literal>=&gt;</literal> ap&oacute;s a interface
	<devicename>lo0</devicename> diz que n&atilde;o somente estamos
	usando a loopback (uma vez que este endere&ccedil;o tamb&eacute;m se refere
	&agrave; maquina local), mas especificamente que &eacute; um apelido.  Tais
	rotas somente surgem nas m&aacute;quinas que suportam o apelido;
	todas as outras m&aacute;quinas na rede local simplesmente ter&atilde;o uma
	linha <literal>link#1</literal> para tais rotas.</para>

      <para>A &uacute;ltima linha (subrede de destino <literal>224</literal>) trata
	do uso de multicast, que ser&aacute; abordado em outra se&ccedil;&atilde;o.</para>

      <para>Finalmente, diversos atributos das rotas podem ser vistos
	na coluna <literal>Flags</literal>.  Abaixo est&aacute; uma breve
	tabela contendo algumas destas flags e seus significados:</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry>U</entry>
	      <entry>Up: A rota &eacute; ativa.</entry>
	    </row>

	    <row>
	      <entry>H</entry>
	      <entry>Host: O destino da rota &eacute; uma &uacute;nica m&aacute;quina.</entry>
	    </row>

	    <row>
	      <entry>G</entry>
	      <entry>Gateway: Envie qualquer coisa para este destino
	      por este sistema remoto, que o mesmo ir&aacute; calcular a
	      partir de l&aacute; para onde envi&aacute;-la.
		it.</entry>
	    </row>

	    <row>
	      <entry>S</entry>
	      <entry>Static: Esta rota foi configurada manualmente, e n&atilde;o
		gerada automaticamente pelo sistema.</entry>
	    </row>

	    <row>
	      <entry>C</entry>
	      <entry>Clone: Gera uma nova rota baseada nesta rota para
	      m&aacute;quinas a quem nos conectarmos.  Este tipo de rota &eacute;
	      normalmente usada em redes locais.</entry>
	    </row>

	    <row>
	      <entry>W</entry>
	      <entry>WasCloned: Indica uma rota que foi autoconfigurada
		baseada em uma rota (Clone) da rede local.</entry>
	    </row>

	    <row>
	      <entry>L</entry>
	      <entry>Link: Rota envolve refer&ecirc;ncias ao hardware
	      Ethernet.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2 id="network-routing-default">
      <title>Rotas Padr&atilde;o</title>

      <indexterm><primary>default route</primary></indexterm>
      <para>Quando um sistema local precisa fazer uma conex&atilde;o a um
      sistema remoto, ele verifica a tabela de roteamento para
      determinar se existe um caminho conhecido.  Se o sistema remoto
      estiver em uma das subredes que j&aacute; sabemos como alcan&ccedil;ar (rotas
      Clonadas), ent&atilde;o o sistema verifica se pode se conectar por
      aquela interface.</para>

      <para>Se falharem todos os caminhos conhecidos, o sistema
      tem uma &uacute;ltima op&ccedil;&atilde;o: a rota <quote>padr&atilde;o</quote>.  Esta rota &eacute;
      um tipo especial rota de sa&iacute;da,  ou gateway (normalmente a
      &uacute;nica presente no sistema), e &eacute; sempre indicada por um
      <literal>c</literal> no campo flags.  Para sistemas em uma rede
      local, este gateway &eacute; configurado para qualquer m&aacute;quina que
      tenha uma conex&atilde;o direta para o mundo exterior (seja via enlace
      PPP, DSL, modem a cabo, T1 ou outra interface de rede).</para>

      <para>Se voc&ecirc; estiver configurando a rota padr&atilde;o em uma m&aacute;quina
      que esteja funcionando como o gateway para o mundo exterior,
      ent&atilde;o a rota padr&atilde;o ser&aacute; a m&aacute;quina gateway localizada no seu
      Provedor de Servi&ccedil;os Internet (PSI).</para>

      <para>Vamos dar uma olhada em um exemplo de rotas padr&atilde;o.  Esta &eacute;
      uma configura&ccedil;&atilde;o comum:</para>

      <literallayout>
[Local2]  &lt;--ether--&gt;  [Local1]  &lt;--PPP--&gt; [ISP-Serv]  &lt;--ether--&gt;  [T1-GW]
      </literallayout>

      <para>Os sistemas <hostid>Local1</hostid> e
	<hostid>Local2</hostid> est&atilde;o em seu s&iacute;tio local.
	<hostid>Local1</hostid> est&aacute; conectado a um PSI por uma conex&atilde;o
	PPP discada.  Este servidor PPP est&aacute; conectado por uma rede
	local a outro computador gateway atrav&eacute;s de uma interface
	externa ao canal Internet do PSI.</para>

      <para>As rotas padr&atilde;o para cada uma das suas m&aacute;quinas ser&atilde;o:</para>

      <informaltable frame="none">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Sistema</entry>
	      <entry>Gateway Padr&atilde;o</entry>
	      <entry>Interface</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>Local2</entry>
	      <entry>Local1</entry>
	      <entry>Ethernet</entry>
	    </row>

	    <row>
	      <entry>Local1</entry>
	      <entry>T1-GW</entry>
	      <entry>PPP</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Uma pergunta comum &eacute; <quote>Por que (ou como)
      n&oacute;s configuramos o <hostid>T1-GW</hostid> para ser o gateway
      padr&atilde;o para <hostid>Local1</hostid>, ao inv&eacute;s do servidor do PSI
      ao qual est&aacute; conectado?</quote>.</para>

      <para>Lembre-se, uma vez que a interface PPP est&aacute; usando um
      endere&ccedil;o da rede local do PSI para o seu lado da conex&atilde;o, rotas
      para qualquer outra m&aacute;quina na rede local do PSI ser&atilde;o criadas
      automaticamente.  Assim, uma vez que voc&ecirc; j&aacute; sabe como alcan&ccedil;ar
      a m&aacute;quina <hostid>T1-GW</hostid>, ent&atilde;o n&atilde;o h&aacute; necessidade do
      passo intermedi&aacute;rio de enviar tr&aacute;fego para o servidor do PSI.</para>

      <para>Como observa&ccedil;&atilde;o final, &eacute; comum usar o endere&ccedil;o
      <hostid role="IPADDR">X.X.X.1</hostid> como o endere&ccedil;o do gateway
      para sua rede local.  Ent&atilde;o (usando o mesmo exemplo), se o seu
      espa&ccedil;o de endere&ccedil;amento classe-C era
      <hostid role="IPADDR">10.20.30</hostid> e seu PSI estava usando
      <hostid role="IPADDR">10.9.9</hostid> ent&atilde;o as rotas padr&atilde;o
      seriam:</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Sistema</entry>
	      <entry>Rota Padr&atilde;o</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Local2 (10.20.30.2)</entry>
	      <entry>Local1 (10.20.30.1)</entry>
	    </row>
	    <row>
	      <entry>Local1 (10.20.30.1, 10.9.9.30)</entry>
	      <entry>T1-GW (10.9.9.1)</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>Sistemas Duplamente Conectados</title>
      <indexterm><primary>dual homed hosts</primary></indexterm>
      <para>Existe um outro tipo de configura&ccedil;&atilde;o que devemos abordar,
       que se trata de um sistema pertencente a duas redes diferentes.
       Tecnicamente, qualquer m&aacute;quina funcionando como um gateway
       (no exemplo acima, usando uma conex&atilde;o PPP) conta como um
       sistema duplamente conectado.  Mas, na verdade, o termo somente
       &eacute; usado para se referir a uma m&aacute;quina conectada a duas redes locais
       diferentes.</para>

      <para>Em um caso, a m&aacute;quina tem duas placas Ethernet, cada uma
      possuindo um endere&ccedil;o em subredes separadas.  Alternativamente,
      a m&aacute;quina pode ter somente uma placa Ethernet e estar usando um
      apelido &man.ifconfig.8;.  O primeiro caso &eacute; usado se duas redes
      Ethernet fisicamente separadas est&atilde;o em uso, e o segundo se h&aacute;
      somente um segmento f&iacute;sico Ethernet, mas duas subredes separadas
      logicamente.</para>

      <para>De um jeito ou de outro, as tabelas de roteamento s&atilde;o
      configuradas de forma que cada subrede saiba que esta m&aacute;quina &eacute;
      o gateway definido (rota de entrada) para a outra subrede.  Esta
      configura&ccedil;&atilde;o, com a m&aacute;quina atuando como um roteador entre duas
      subredes, &eacute; muitas vezes usado quando precisamos implementar
      filtragem de pacotes ou um firewall de seguran&ccedil;a em cada uma ou
      em ambas as dire&ccedil;&otilde;es.</para>

      <para>Se voc&ecirc; deseja que esta m&aacute;quina, na pr&aacute;tica, passe adiante
      pacotes entre as duas interfaces, voc&ecirc; precisa dizer ao FreeBSD
      para permitir esta capacidade.</para>
    </sect2>

    <sect2 id="network-dedicated-router">
      <title>Construindo um Roteador</title>

      <indexterm><primary>router</primary></indexterm>

      <para>Um roteador de rede &eacute; simplesmente um sistema que repassa
      pacotes de uma interface para outra.  Padr&otilde;es da Internet e boas
      pr&aacute;ticas de engenharia impedem o Projeto FreeBSD de permitir
      isto por padr&atilde;o no FreeBSD.  Voc&ecirc; pode permitir esta
      caracter&iacute;stica alterando a seguinte vari&aacute;vel para
      <literal>YES</literal> no &man.rc.conf.5;:</para>

      <programlisting>gateway_enable=YES	  # Set to YES if this host will be a gateway</programlisting>

      <para>Esta op&ccedil;&atilde;o ir&aacute; ajustar a vari&aacute;vel do &man.sysctl.8;
      chamada <varname>net.inet.ip.forwarding</varname> para
	<literal>1</literal>.  Se voc&ecirc; precisar parar o roteamento
	temporariamente, voc&ecirc; pode reajust&aacute;-la para
	<literal>0</literal>.</para>

      <para>Seu novo roteador precisar&aacute; de rotas para saber aonde
      enviar o tr&aacute;fego.  Se sua rede for simples o suficiente voc&ecirc;
      pode usar rotas est&aacute;ticas.  O FreeBSD tamb&eacute;m vem com o daemon
      de roteamento padr&atilde;o do BSD &man.routed.8;, o qual fala RIP
      (ambas as vers&otilde;es 1 e 2) e IRDP.  O suporte para BGP v4, OSPF v2
      e outros protocolos de roteamento sofisticados est&atilde;o dispon&iacute;veis
      com o pacote <filename role="package">net/zebra</filename>.
      Produtos comerciais, como o gated, tamb&eacute;m est&atilde;o dispon&iacute;veis para
      solu&ccedil;&otilde;es mais complexas de roteamento.</para>

<indexterm><primary>BGP</primary></indexterm>
<indexterm><primary>RIP</primary></indexterm>
<indexterm><primary>OSPF</primary></indexterm>

      <para>Mesmo quando o FreeBSD &eacute; configurado desta forma, ele
      ainda n&atilde;o cumpre completamente com os requisitos padr&otilde;es da
      Internet para roteadores.  Mas chega bem perto para uso
      normal, entretanto.</para>
    </sect2>

    <sect2>
      <title>Propaga&ccedil;&atilde;o do Roteamento</title>
      <indexterm><primary>routing propagation</primary></indexterm>
      <para>N&oacute;s j&aacute; falamos sobre como definimos nossas rotas para o
      mundo exterior, mas n&atilde;o sobre como o mundo exterior nos
      encontra.</para>

      <para>J&aacute; sabemos como as tabelas de roteamento podem ser
      configuradas de forma que todo o tr&aacute;fego para um espa&ccedil;o de
      endere&ccedil;amento em particular (nos nossos exemplos, uma subrede
      classe-C) pode ser enviado a um determinado sistema naquela
      rede, o qual ir&aacute; repassar os pacotes para dentro.</para>

      <para>Quando voc&ecirc; obtiver a designa&ccedil;&atilde;o de um espa&ccedil;o de
      endere&ccedil;amento para seu s&iacute;tio, seu provedor de servi&ccedil;os ir&aacute;
      configurar suas tabelas de roteamento de forma que todo o
      tr&aacute;fego para sua subrede ser&aacute; enviado atrav&eacute;s do seu enlace PPP
      ao seu s&iacute;tio.  Mas como os s&iacute;tios atrav&eacute;s do pa&iacute;s saber&atilde;o enviar
      ao seu PSI?</para>

      <para>H&aacute; um sistema (muito parecido com a informa&ccedil;&atilde;o DNS
      distribu&iacute;da) que mant&eacute;m registros de todos os espa&ccedil;os de
      endere&ccedil;amento designados, e que define seu ponto de conex&atilde;o &agrave;
      Espinha Dorsal Internet.  A <quote>Espinha Dorsal</quote> s&atilde;o
      os principais canais que carregam o tr&aacute;fego da Internet atrav&eacute;s
      do pa&iacute;s e ao redor do mundo.  Cada m&aacute;quina de espinha dorsal tem
      uma c&oacute;pia de um conjunto mestre de tabelas, as quais direcionam
      tr&aacute;fego a uma determinada rede e a um provedor de espinha dorsal
      espec&iacute;fico e, de l&aacute;, abaixo na cadeia de provedores de servi&ccedil;os
      at&eacute; atingir a sua rede.</para>

      <para>&Eacute; a tarefa do seu provedor de servi&ccedil;os anunciar para os
      s&iacute;tios da espinha dorsal que eles s&atilde;o o ponto de conex&atilde;o (e,
      assim, o caminho de entrada) para seu s&iacute;tio.  Isto &eacute; conhecido
      como propaga&ccedil;&atilde;o de rotas.</para>
    </sect2>

    <sect2>
      <title>Resolu&ccedil;&atilde;o de Problemas</title>
      <indexterm>
	<primary><command>traceroute</command></primary>
      </indexterm>
      <para>&Agrave;s vezes, h&aacute; um problema com propaga&ccedil;&atilde;o de rotas, e alguns
      s&iacute;tios ficam incapazes de se conectar a voc&ecirc;.  Talvez o comando
      mais &uacute;til para tentar descobrir onde o roteamento est&aacute; em pane &eacute;
      o &man.traceroute.8;.  Ele &eacute; igualmente &uacute;til se voc&ecirc; n&atilde;o parece
      conseguir realizar uma conex&atilde;o a uma m&aacute;quina remota (p.ex.  o
      &man.ping.8; falhou).</para>

      <para>O comando &man.traceroute.8; &eacute; executado com o nome do
      sistema remoto que voc&ecirc; est&aacute; tentando se conectar.  Ele vai
      mostrar os sistemas gateway ao longo do caminho da tentativa,
      eventualmente alcan&ccedil;ando o sistema-alvo, ou terminando por falta
      de conectividade.</para>

      <para>Para maiores informa&ccedil;&otilde;es, veja a p&aacute;gina do manual do
      &man.traceroute.8;.</para>
    </sect2>

    <sect2>
      <title>Roteamento Multicast</title>
      <indexterm>
	<primary>multicast</primary>
	<secondary>options MROUTING</secondary>
      </indexterm>
      <para>O FreeBSD suporta aplica&ccedil;&otilde;es multicast e roteamento multicast
	de forma nativa.  Aplica&ccedil;&otilde;es multicast n&atilde;o requerem qualquer
	configura&ccedil;&atilde;o especial no FreeBSD; aplica&ccedil;&otilde;es geralmente ir&atilde;o
	funcionar sem necessidade de ajustes.  O roteamento multicast
	requer que o suporte seja compilado no n&uacute;cleo, ou kernel:</para>

      <programlisting>options MROUTING</programlisting>

      <para>Al&eacute;m disso, o daemon de roteamento multicast
      &man.mrouted.8; precisa ser configurado para ativar t&uacute;neis e
      DVMRP atrav&eacute;s do <filename>/etc/mrouted.conf</filename>.  Mais
      detalhes sobre as configura&ccedil;&otilde;es multicast podem ser encontradas
      nas p&aacute;ginas de manual do mrouted.</para>
    </sect2>
  </sect1>

  <sect1 id="network-wireless">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Eric</firstname>
	  <surname>Anderson</surname>
	  <contrib>Escrito por </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Rede Sem Fio (Wireless)</title>

   <indexterm><primary>wireless networking</primary></indexterm>
   <indexterm>
     <primary>802.11</primary>
     <see>wireless networking</see>
   </indexterm>

   <sect2>
      <title>Introdu&ccedil;&atilde;o</title>
      <para>Pode ser muito &uacute;til a possibilidade de usar um computador
      sem o inc&ocirc;modo de ter um cabo de rede conectado o tempo todo.  O
      FreeBSD pode ser usado como um cliente sem fio e at&eacute; mesmo como
      um <quote>ponto de acesso</quote> sem fio.</para>
   </sect2>

   <sect2>
     <title>Modos de Opera&ccedil;&atilde;o Sem Fio</title>
     <para>H&aacute; duas formas diferentes de configurar dispositivos sem
     fio 802.11: BSS e IBSS.</para>

     <sect3>
       <title>Modo BSS</title>
       <para>BSS &eacute; o modo tipicamente utilizado.  O modo BSS &eacute;
	tamb&eacute;m chamado de modo infra-estrutura.  Neste modo, uma
	quantidade de pontos de acesso sem fio est&aacute; conectada a uma
	rede cabeada.  Cada rede sem fio tem seu pr&oacute;prio nome.  Este
	nome &eacute; chamado SSID da rede.</para>

       <para>Clientes sem fio conectam-se a estes pontos de acesso.
       O padr&atilde;o IEEE 802.11 define o protocolo que redes sem fio usam
       para conex&otilde;es.  Um cliente sem fio pode ser ligado a uma rede
       espec&iacute;fica, quando um SSID &eacute; configurado.  Um cliente sem fio
       tamb&eacute;m pode conectar-se a qualquer rede desde que n&atilde;o configure
       explicitamente um SSID.</para>
     </sect3>

     <sect3>
       <title>Modo IBSS</title>
       <para>O modo IBSS, tamb&eacute;m chamado modo ad-hoc, &eacute; projetado para
       conex&otilde;es ponto-a-ponto.  Existem, de fato, dois tipos de modo
       ad-hoc.  Um &eacute; o modo IBSS, tamb&eacute;m chamado de ad-hoc ou
       modo ad-hoc do IEEE.  Este modo &eacute; definido pelos padr&otilde;es IEEE
       802.11.  O segundo modo &eacute; chamado modo ad-hoc demo ou modo
       ad-hoc da Lucent (e, &agrave;s vezes, confusamente, modo ad-hoc).
       Este &eacute; o antigo modo ad-hoc, pr&eacute;-802.11 e somente deve ser
       usado em instala&ccedil;&otilde;es legadas.  N&atilde;o iremos abordar nenhum dos
       modos ad-hoc mais adiante.</para>
     </sect3>
   </sect2>

   <sect2>
     <title>Modo Infra-estrutura</title>
     <sect3>
       <title>Pontos de Acesso</title>

       <para>Pontos de acesso s&atilde;o dispositivos de rede sem fio que
       permitem um ou mais clientes sem fio utilizar o dispositivo
       como um concentrador central.  Ao usar um ponto de acesso, todos
       os clientes comunicam-se atrav&eacute;s do ponto de acesso.  M&uacute;ltiplos
       pontos de acesso s&atilde;o freq&uuml;entemente usados para cobrir uma &aacute;rea
       completa como uma casa, neg&oacute;cio ou parque, com uma rede sem
       fio.</para>

       <para>Pontos de acesso tipicamente possuem m&uacute;ltiplas conex&otilde;es
       de rede: o cart&atilde;o sem fio e um ou mais adaptadores Ethernet
       para conex&atilde;o ao resto da rede.</para>

       <para>Pontos de acesso podem ser comprados montados ou voc&ecirc;
       pode construir o seu pr&oacute;prio com FreeBSD e um cart&atilde;o sem fio
       suportado. Diversos fornecedores fazem pontos de acesso sem fio
       e cart&otilde;es sem fio com caracter&iacute;sticas variadas.</para>
     </sect3>

     <sect3>
       <title>Construindo um Ponto de Acesso FreeBSD</title>
       <indexterm><primary>wireless networking</primary>
	 <secondary>access point</secondary>
       </indexterm>

       <sect4><title>Requisitos</title>

	 <para>Para ativar um ponto de acesso com FreeBSD, voc&ecirc;
	 precisa ter uma placa sem fio compat&iacute;vel.  Atualmente,
	 somente s&atilde;o suportadas as placas com o chipset Prism.  Voc&ecirc;
	 tamb&eacute;m vai precisar de uma placa de rede com fio suportada
	 pelo FreeBSD (n&atilde;o deve ser dif&iacute;cil encontrar, o FreeBSD
	 suporta diversos diferentes dispositivos).  Neste guia, vamos
	 assumir que voc&ecirc; deseja fazer uma ponte (&man.bridge.4;)
	 de todo o tr&aacute;fego entre o dispositivo sem fio e a rede
	 conectada na placa de rede com fio.</para>

	 <para>A funcionalidade hostap que o FreeBSD usa para
	 implementar o ponto de acesso funciona melhor com certas
	 vers&otilde;es de firmware.  Placas Prism 2 devem usar o firmware
	 vers&atilde;o 1.3.4 ou mais recente.  Placas Prism 2.5 e Prism 3
	 devem usar o firmware 1.4.9. Vers&otilde;es anteriores de firmware
	 podem ou n&atilde;o funcionar corretamente.  Neste momento, a &uacute;nica
	 forma de atualizar placas &eacute; com ferramentas de atualiza&ccedil;&atilde;o
	 para &windows; disponibilizadas pelo fabricante de sua placa.</para>
       </sect4>

       <sect4>
	 <title>Ativando o Ponto de Acesso</title>
	 <para>Primeiro, certifique-se de que seu sistema reconhece a
	 placa sem fio:</para>
	 <screen>&prompt.root; <userinput>ifconfig -a</userinput>
wi0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
	inet6 fe80::202:2dff:fe2d:c938%wi0 prefixlen 64 scopeid 0x7
	inet 0.0.0.0 netmask 0xff000000 broadcast 255.255.255.255
	ether 00:09:2d:2d:c9:50
	media: IEEE 802.11 Wireless Ethernet autoselect (DS/2Mbps)
	status: no carrier
	ssid ""
	stationname "FreeBSD Wireless node"
	channel 10 authmode OPEN powersavemode OFF powersavesleep 100
	wepmode OFF weptxkey 1</screen>

	 <para>N&atilde;o se preocupe com os detalhes agora, apenas
	 certifique-se de que algo &eacute; mostrado, indicando que voc&ecirc; tem
	 uma placa sem fio instalada.  Se voc&ecirc; tiver problemas em
	 encontrar a interface sem fio e estiver usando um PC card,
	 voc&ecirc; pode querer verificar as p&aacute;ginas de manual
	 &man.pccardc.8; e &man.pccardd.8; para maiores informa&ccedil;&otilde;es.</para>

	 <para>A seguir, voc&ecirc; vai precisar carregar um m&oacute;dulo para
	 ter o FreeBSD funcionando como ponte e pronto para o ponto de
	 acesso. Para carregar o m&oacute;dulo &man.bridge.4;, simplesmente
	 execute o comando:</para>

	 <screen>&prompt.root; <userinput>kldload bridge</userinput></screen>

	 <para>N&atilde;o deve ser mostrado nenhum erro ao se carregar o
	 m&oacute;dulo.  Se houve algum, talvez voc&ecirc; precise compilar o
	 c&oacute;digo &man.bridge.4; no kernel do seu sistema.  A se&ccedil;&atilde;o
	 <link linkend="network-bridging">Liga&ccedil;&atilde;o</link> do
	 handbook deve ajud&aacute;-lo a executar esta tarefa.</para>

	 <para>Agora que voc&ecirc; tem a parte de liga&ccedil;&atilde;o pronta,
	 precisamos dizer ao kernel do FreeBSD quais interfaces deve
	 ligar.  Fazemos isto usando &man.sysctl.8;:</para>

	 <screen>&prompt.root; <userinput>sysctl net.link.ether.bridge=1</userinput>
&prompt.root; <userinput>sysctl net.link.ether.bridge_cfg="wi0 xl0"</userinput>
&prompt.root; <userinput>sysctl net.inet.ip.forwarding=1</userinput></screen>

	 <para>Agora &eacute; a hora de configurar a placa sem fio.</para>
	 <para>O seguinte comando vai ativar a placa como um ponto de
	 acesso:</para>

	 <screen>
&prompt.root; <userinput>ifconfig wi0 ssid my_net channel 11 media DS/11Mbps mediaopt hostap up stationname "FreeBSD AP"</userinput>
	 </screen>

	 <para>A linha &man.ifconfig.8; ativa a interface
	  <devicename>wi0</devicename>, configura seu SSID para
	  <literal>my_net</literal>, e ajusta o nome  da esta&ccedil;&atilde;o para
	  <literal>FreeBSD AP</literal>.  A op&ccedil;&atilde;o <option>media
	  DS/11Mbps</option> configura a placa em modo 11Mbps e &eacute;
	  necess&aacute;ria para qualquer par&acirc;metro <option>mediaopt</option>
	  ter efeito.  A op&ccedil;&atilde;o <option>mediaopt hostap</option> coloca
	  a interface em modo ponto de acesso.  A p&aacute;gina de manual
	  &man.wicontrol.8; tem as op&ccedil;&otilde;es v&aacute;lidas para canais de seu
	  controlador de dom&iacute;nio.</para>

	 <para>Agora voc&ecirc; deve ter um ponto de acesso completamente
	 funcional ativado e funcionando.  Recomendamos a leitura de
	 &man.wicontrol.8;, &man.ifconfig.8;, e &man.wi.4; para maiores
	 informa&ccedil;&otilde;es.</para>

	 <para>Tamb&eacute;m &eacute; sugerido que voc&ecirc; leia a se&ccedil;&atilde;o sobre
	 criptografia a seguir.</para>
       </sect4>

       <sect4>
	 <title>Informa&ccedil;&otilde;es de Estado</title>
	 <para>Uma vez que o ponto de acesso est&aacute; configurado e
	 operacional, os operadores v&atilde;o querer ver os clientes
	 associados ao ponto de acesso.  Em qualquer momento, o
	 operador pode digitar:</para>

	 <screen>&prompt.root; <userinput>wicontrol -l</userinput>
1 station:
00:09:b7:7b:9d:16 asid=04c0, flags=3&lt;ASSOC,AUTH&gt;, caps=1&lt;ESS&gt;, rates=f&lt;1M,2M,5.5M,11M&gt;, sig=38/15
</screen>

	 <para>Isto mostra que h&aacute; uma esta&ccedil;&atilde;o associada, junto com
	 seus par&acirc;metros.  O sinal indicado deve ser usado somente
	 como uma indica&ccedil;&atilde;o relativa de pot&ecirc;ncia.  Sua tradu&ccedil;&atilde;o para
	 dBm ou outras unidades variam entre diferentes revis&otilde;es de
	 firmware.</para>
       </sect4>
     </sect3>

     <sect3>
       <title>Clientes</title>

       <para>Um cliente sem fio &eacute; um sistema que acessa um ponto de
       acesso ou outro cliente diretamente.</para>

       <para>Tipicamente, os clientes sem fio possuem somente um
       dispositivo de rede, a placa de rede sem fio.</para>

       <para>Existem algumas poucas formas diferentes de configurar
       um cliente sem fio.  Estas configura&ccedil;&otilde;es s&atilde;o baseadas nos
       diferentes modos sem fio, geralmente BSS (modo infra-estrutura,
       que requer um ponto de acesso), e IBSS (ad-hoc, ou modo
       ponto-a-ponto).  Em nosso exemplo, vamos usar o mais popular
       dos dois, modo BSS, para comunica&ccedil;&atilde;o com um ponto de acesso.</para>

       <sect4>
       <title>Requisitos</title>
       <para>H&aacute; somente um &uacute;nico requisito real para ativar o FreeBSD
       como um cliente sem fio.  Voc&ecirc; precisa de uma placa sem fio
       suportada pelo FreeBSD.</para>
       </sect4>

       <sect4>
       <title>Ativando um Cliente FreeBSD Sem Fio</title>

       <para>Antes de come&ccedil;ar, precisa saber algumas coisas
       sobre a rede sem fio &agrave; qual estar&aacute; se conectando.  Neste
       exemplo, estamos nos conectando a uma rede que tem o nome de
       <literal>my_net</literal>, e criptografia desligada.</para>

       <para>Neste exemplo, n&atilde;o estamos usando criptografia o que &eacute;
       uma situa&ccedil;&atilde;o de perigo.  Na pr&oacute;xima se&ccedil;&atilde;o, voc&ecirc; aprender&aacute;
       como ativar criptografia, porque &eacute; importante faz&ecirc;-lo e porque
       algumas tecnologias de criptografia ainda n&atilde;o o protegem
       completamente.</para>

       <para>Certifique-se de que sua placa &eacute; reconhecida pelo
       FreeBSD:</para>

       <screen>&prompt.root; <userinput>ifconfig -a</userinput>
wi0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
	inet6 fe80::202:2dff:fe2d:c938%wi0 prefixlen 64 scopeid 0x7
	inet 0.0.0.0 netmask 0xff000000 broadcast 255.255.255.255
	ether 00:09:2d:2d:c9:50
	media: IEEE 802.11 Wireless Ethernet autoselect (DS/2Mbps)
	status: no carrier
	ssid ""
	stationname "FreeBSD Wireless node"
	channel 10 authmode OPEN powersavemode OFF powersavesleep 100
	wepmode OFF weptxkey 1</screen>

       <para>Agora vamos configurar a placa com os par&acirc;metros corretos
       para nossa rede:</para>

       <screen>&prompt.root; <userinput>ifconfig wi0 inet 192.168.0.20 netmask 255.255.255.0 ssid my_net</userinput></screen>

       <para>Substitua <hostid role="IPADDR">192.168.0.20</hostid> e
       <hostid role="Netmask">255.255.255.0</hostid> com um endere&ccedil;o
       IP e m&aacute;scara de subrede v&aacute;lidos em sua rede com fio.  Lembre-se
       que nosso ponto de acesso est&aacute; fazendo a liga&ccedil;&atilde;o (ponte)
       de dados entre a rede sem fio e a rede com fio, de forma
       que vai parecer aos outros dispositivos na rede que voc&ecirc; est&aacute;
       na rede com fio, assim como eles.</para>

       <para>Feito isto, voc&ecirc; deve ser capaz de usar ping nos sistemas
       na rede com fio assim como se estivesse conectado usando uma
       conex&atilde;o padr&atilde;o, com fio.</para>

       <para>Se estiver com problemas em sua conex&atilde;o sem fio,
       certifique-se que est&aacute; associado (conectado) ao ponto de
       acesso:</para>

       <screen>&prompt.root; <userinput>ifconfig wi0</userinput></screen>

       <para>deve retornar alguma informa&ccedil;&atilde;o, e voc&Ecirc; deve ver:</para>
       <screen>status: associated</screen>

       <para>Se n&atilde;o mostrar que est&aacute; associado, ent&atilde;o voc&ecirc; deve estar
       fora de alcance do ponto de acesso, estar sem criptografia
       ativada, ou possivelmente tem um problema de configura&ccedil;&atilde;o.</para>

       </sect4>
     </sect3>

     <sect3>
      <title>Criptografia</title>
      <indexterm>
	<primary>wireless networking</primary>
	<secondary>encryption</secondary>
      </indexterm>

      <para>Criptografia em uma rede sem fio &eacute; importante porque voc&ecirc;
      n&atilde;o mais ter&aacute; a capacidade de manter a rede contida em uma &aacute;rea
      bem protegida.  Seus dados sem fio ser&atilde;o transmitidos atrav&eacute;s de
      toda a sua vizinhan&ccedil;a, ent&atilde;o quem quiser poder&aacute; ler seus
      dados.  Aqui entra a criptografia.  Criptografando os dados
      transmitidos por ondas a&eacute;reas, voc&ecirc; torna muito mais dif&iacute;cil a
      qualquer um capturar seus dados do ar.</para>

     <para>As duas formas mais comuns de criptografar os dados entre
     seu cliente e o ponto de acesso s&atilde;o WEP, e &man.ipsec.4;.</para>

     <sect4>
     <title>WEP</title>
      <indexterm><primary>WEP</primary></indexterm>

      <para>WEP &eacute; uma abrevia&ccedil;&atilde;o para Protocolo para Equival&ecirc;ncia em
      Fio (Wired Equivalency Protocol). WEP &eacute; uma tentativa de tornar
      as redes sem fio t&atilde;o seguras quanto uma rede com fio.
      Infelizmente, foi quebrado e &eacute; bem trivial quebr&aacute;-lo.  Isto
      tamb&eacute;m significa que n&atilde;o &eacute; uma coisa para se contar quando se
      trata de criptografar dados sens&iacute;veis.</para>

      <para>&Eacute; melhor que nada, ent&atilde;o fa&ccedil;a o seguinte para ativar WEP
      em seu novo ponto de acesso FreeBSD:</para>

      <screen>&prompt.root; <userinput>ifconfig wi0 inet up ssid my_net wepmode on wepkey 0x1234567890 media DS/11Mbps mediaopt hostap</userinput></screen>

      <para>E voc&ecirc; pode ativar WEP em um cliente com este comando:</para>

      <screen>&prompt.root; <userinput>ifconfig wi0 inet 192.168.0.20 netmask 255.255.255.0 ssid my_net wepmode on wepkey 0x1234567890</userinput></screen>

      <para>Note que voc&ecirc; deve substituir o
      <literal>0x1234567890</literal> por uma chave mais
      exclusiva.</para>

     </sect4>

     <sect4>
     <title>IPsec</title>

     <para>&man.ipsec.4; &eacute; uma ferramenta muito mais robusta e poderosa
     para criptografar dados atrav&eacute;s de uma rede.  Esta &eacute;
     definitivamente a forma preferida de criptografar dados em uma
     rede sem fio.  Voc&ecirc; pode ler mais sobre seguran&ccedil;a &man.ipsec.4; e
     como implement&aacute;-la na se&ccedil;&atilde;o <link linkend="ipsec">IPsec</link> do
     handbook.</para>
     </sect4>
    </sect3>

    <sect3>
    <title>Ferramentas</title>

    <para>H&aacute; um pequeno n&uacute;mero de ferramentas dispon&iacute;vel para uso na
    determina&ccedil;&atilde;o de problemas e ativa&ccedil;&atilde;o de sua rede sem fio, e aqui
    vamos tentar descrever algumas delas e o que fazem.</para>

    <sect4>
    <title>O Pacote <application>bsd-airtools</application></title>

    <para>O pacote <application>bsd-airtools</application> &eacute; um
    conjunto de ferramentas completo que inclui ferramentas de
    auditoria sem fio para quebrar chaves WEP, detectar pontos de
    acesso etc.</para>

    <para>Os utilit&aacute;rios <application>bsd-airtools</application> podem
    ser instalados a partir do port <filename
    role="package">net/bsd-airtools</filename>.  Informa&ccedil;&otilde;es sobre
    como instalar ports podem ser encontradas em <xref
    linkend="ports"> do handbook.</para>

    <para>O programa <command>dstumbler</command> &eacute; a ferramenta
    no pacote que permite a descoberta de pontos de acesso e
    representa&ccedil;&atilde;o gr&aacute;fica da raz&atilde;o entre sinal e ru&iacute;do. Se voc&ecirc;
    estiver com dificuldades para ativar seu ponto de acesso,
    <command>dstumbler</command> pode ajud&aacute;-lo a familiarizar-se.</para>

    <para>Para testar a seguran&ccedil;a de sua rede sem fio, voc&ecirc; pode
    escolher usar <quote>dweputils</quote>
    (<command>dwepcrack</command>, <command>dwepdump</command> e
    <command>dwepkeygen</command>) para ajud&aacute;-lo a determinar se WEP &eacute;
    a solu&ccedil;&atilde;o adequada para suas necessidades de seguran&ccedil;a sem
    fio.</para>

    </sect4>

    <sect4>
    <title>Os Utilit&aacute;rios<application> wicontrol</application>,
    <application>ancontrol</application> e
    <application>raycontrol</application></title>

    <para>Estas s&atilde;o as ferramentas que voc&ecirc; deve usar para controlar
    como sua placa sem fio se comporta na rede sem fio.  Nos exemplos
    acima, escolhemos usar &man.wicontrol.8;, uma vez que nossa placa
    sem fio &eacute; uma interface <devicename>wi0</devicename>.  Se voc&ecirc;
    tivesse um dispositivo sem fio Cisco, ele apareceria como
    <devicename>an0</devicename>, e assim voc&ecirc; deveria usar
    &man.ancontrol.8;.</para>

    </sect4>

    <sect4>
    <title>O Comando <application>ifconfig</application></title>
    <indexterm><primary>ifconfig</primary></indexterm>

    <para>O &man.ifconfig.8; pode ser usado para fazer muitas das
    mesmas configura&ccedil;&otilde;es que &man.wicontrol.8;, entretanto &eacute;
    desprovido de algumas poucas op&ccedil;&otilde;es.  Verifique &man.ifconfig.8;
    para op&ccedil;&otilde;es e par&acirc;metros de linha de comando.</para>

    </sect4>

    </sect3>

    <sect3>
    <title>Placas Suportadas</title>
    <sect4>
    <title>Pontos de Acesso</title>

    <para>As &uacute;nicas placas que s&atilde;o suportadas atualmente para modo BSS
    (como um ponto de acesso) s&atilde;o dispositivos baseados nos chipsets
    Prism 2, 2.5 ou 3.  Para uma lista completa, veja &man.wi.4;.</para>

    </sect4>

    <sect4>
    <title>Clientes</title>

    <para>Quase todas as placas sem fio 802.11b s&atilde;o suportadas
    atualmente pelo FreeBSD.  A maioria das placas baseadas em Prism,
    Spectrum24, Hermes, Aironet e Raylink v&atilde;o funcionar como uma placa
    de rede em modo IBSS (ad-hoc, ponto-a-ponto e BSS).</para>

    </sect4>
    </sect3>

   </sect2>
  </sect1>

  <sect1 id="network-bluetooth">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Pav</firstname>
	  <surname>Lucistnik</surname>
	  <contrib>Escrito por </contrib>
	  <affiliation>
	    <address><email>pav@oook.cz</email></address>
	  </affiliation>
	</author>
      </authorgroup>
    </sect1info>
    <title>Bluetooth</title>

    <indexterm><primary>Bluetooth</primary></indexterm>
    <sect2>
      <title>Introdu&ccedil;&atilde;o</title>

      <para>Bluetooth &eacute; uma tecnologia sem fio para criar redes
      pessoais operando na banda n&atilde;o licenciada de 2.4GHz, com
      alcance de 10 metros.  As redes geralmente s&atilde;o criadas sob medida
      para este prop&oacute;sito, a partir de dispositivos port&aacute;teis como
      telefones celulares, handhelds e laptops.  Diferente de outras
      tecnologias sem fio populares, como Wi-Fi, o Bluetooth
      oferece perfis de servi&ccedil;o de alto n&iacute;vel, por exemplo: servidores
      de arquivos similares ao FTP, distribui&ccedil;&atilde;o de arquivos,
      transporte de voz, emula&ccedil;&atilde;o de linha serial e outras.</para>

      <para>A pilha Bluetooth em &os; &eacute; implementada usando o
      framework Netgraph (veja &man.netgraph.4;).  Uma ampla variedade
      de plugues USB Bluetooth &eacute; suportada pelo gerenciador &man.ng.ubt.4;.
      Os dispositivos baseado no chip Bluetooth Broadcom BCM2033 s&atilde;o
      suportados atrav&eacute;s dos gerenciadores &man.ubtbcmfw.4; e
      &man.ng.ubt.4;.  O cart&atilde;o PC Bluetooth 3Com 3CRWB60-A &eacute;
      suportado pelo gerenciador &man.ng.bt3c.4;. Dispositivos Bluetooth
      baseados em serial e UART s&atilde;o suportados via &man.sio.4;,
      &man.ng.h4.4; e &man.hcseriald.8;.  Este cap&iacute;tulo descreve o uso
      do plugue Bluetooth USB.  O suporte ao Bluetooth est&aacute; dispon&iacute;vel
      em sistemas com &os; 5.0 e mais recentes.</para>
    </sect2>

    <sect2>
      <title>Conectando o Dispositivo</title>

      <para>Por padr&atilde;o, os gerenciadores de dispositivos Bluetooth est&atilde;o
      dispon&iacute;veis na forma de m&oacute;dulos de kernel.  Antes de ligar um
      dispositivo, voc&ecirc; vai precisar carregar o gerenciador no kernel.</para>

      <screen>&prompt.root; <userinput>kldload ng_ubt</userinput></screen>

      <para>Se o dispositivo Bluetooth est&aacute; presente no sistema
      durante a inicializa&ccedil;&atilde;o, carregue o m&oacute;dulo de
      <filename>/boot/loader.conf</filename>.</para>

      <programlisting>ng_ubt_load="YES"</programlisting>

      <para>Conecte seu plugue USB.  Uma sa&iacute;da similar &agrave; seguinte ser&aacute;
      exibida na console (ou no syslog).</para>

      <screen>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2
ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,
      wMaxPacketSize=49, nframes=6, buffer size=294</screen>

      <para>Copie
      <filename>/usr/share/examples/netgraph/bluetooth/rc.bluetooth</filename>
      para algum lugar conveniente como <filename>/etc/rc.bluetooth</filename>.
      Este script &eacute; usado para iniciar e parar a pilha Bluetooth.  &Eacute;
      uma boa id&eacute;ia parar a pilha antes de desplugar o dispositivo,
      mas, se o dispositivo for desplugado sem a parada da pilha, 
      isto (geralmente) n&atilde;o &eacute; fatal.  Quando iniciar a pilha, voc&ecirc; 
      poder&aacute; ver uma sa&iacute;da similar &agrave; seguinte:</para>

      <screen>&prompt.root; <userinput>/etc/rc.bluetooth start ubt0</userinput>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO link&gt;
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max.  ACL packet size: 192 bytes
Number of ACL packets: 8
Max.  SCO packet size: 64 bytes
Number of SCO packets: 8</screen>

    </sect2>

    <indexterm><primary>HCI</primary></indexterm>
    <sect2>
      <title>Interface Controladora de Sistema (HCI)</title>

      <para>A Interface Controladora de Sistema, ou, Host Controller
      Interface (HCI) fornece uma interface de comando para o
      controlador de banda base e o gerenciador de liga&ccedil;&atilde;o, e acesso
      ao estado do hardware e registradores de controle.  Esta
      interface fornece um m&eacute;todo uniforme de acesso &agrave;s capacidades de
      banda base do Bluetooth.  A camada HCI no Sistema troca dados e
      comandos com o firmware HCI no hardware Bluetooth.  O
      gerenciador da Camada de Transporte Controladora do Sistema
      - Host Controller Transport Layer - (barramento f&iacute;sico) fornece
      a ambas as camadas HCI a capacidade de trocar informa&ccedil;&otilde;es com
      a outra.</para>

      <para>Um &uacute;nico n&oacute; Netgraph do tipo <emphasis>hci</emphasis> &eacute;
      criado para um &uacute;nico dispositivo Bluetooth.  O n&oacute; HCI
      normalmente &eacute; conectado ao n&oacute; do gerenciador de dispositivo
      Bluetooth (downstream) e ao n&oacute; L2CAP (upstream).  Todas as
      opera&ccedil;&otilde;es HCI devem ser desempenhadas no n&oacute; HCI e n&atilde;o no n&oacute; do
      gerenciador de dispositivo.  O nome padr&atilde;o para o n&oacute; HCI &eacute;
      <quote>devicehci</quote>.  Para maiores detalhes consulte a
      p&aacute;gina de manual &man.ng.hci.4;.</para>


      <para>Uma das tarefas mais comuns &eacute; o descobrimento de
      dispositivos Bluetooth nas proximidades de radiofreq&uuml;&ecirc;ncia, RF.
      Esta opera&ccedil;&atilde;o chama-se <emphasis>investiga&ccedil;&atilde;o</emphasis>
      (inquiry).  A investiga&ccedil;&atilde;o e outras opera&ccedil;&otilde;es relativas a HCI
      s&atilde;o feitas com o utilit&aacute;rio &man.hccontrol.8;.  O exemplo abaixo
      exibe como encontrar quais dispositivos Bluetooth est&atilde;o dentro
      de alcance.  Voc&ecirc; deve receber a lista de dispositivos em
      poucos segundos.  Note que um dispositivo remoto somente vai
      responder &agrave; investiga&ccedil;&atilde;o se estiver em modo
      <quote>encontr&aacute;vel</quote> (discoverable).</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci inquiry</userinput>
Inquiry result, num_responses=1
Inquiry result #0
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep.  Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete.  Status: No error [00]</screen>

      <para>O <literal>BD_ADDR</literal> &eacute; o endere&ccedil;o &uacute;nico de um
      dispositivo Bluetooth, similar ao endere&ccedil;o MAC de uma placa de
      rede.  Este endere&ccedil;o &eacute; necess&aacute;rio para promover comunica&ccedil;&otilde;es com
      um dispositivo.  &Eacute; poss&iacute;vel designar um nome leg&iacute;vel por humanos
      a um BD_ADDR.  O arquivo <filename>/etc/bluetooth/hosts</filename>
      cont&eacute;m informa&ccedil;&atilde;o relativas aos sistemas Bluetooth conhecidos.
      O seguinte exemplo mostra como obter um nome leg&iacute;vel por humanos
      que foi designado a um dispositivo remoto.</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4</userinput>
BD_ADDR: 00:80:37:29:19:a4
Name: Pav's T39</screen>

      <para>Se voc&ecirc; executar uma investiga&ccedil;&atilde;o em um dispositivo
      Bluetooth remoto, ele ir&aacute; encontrar seu computador como
      <quote>nome.do.seu.sistema (ubt0)</quote>.  O nome designado
      para o dispositivo local pode ser trocado a qualquer hora.</para>

      <para>O sistema Bluetooth fornece conex&atilde;o ponto-a-ponto (somente
      duas unidades envolvidas), ou uma conex&atilde;o ponto-a-multiponto.
      Na conex&atilde;o ponto-a-multiponto, a mesma &eacute; compartilhada entre
      diversos dispositivos Bluetooth.  O exemplo a seguir mostra como
      obter a lista de conex&otilde;es de banda base para o dispositivo
      local.</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci read_connection_list</userinput>
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41 ACL    0 MAST    NONE       0     0 OPEN</screen>

      <para>Um <emphasis>identificador de conex&atilde;o (handle)</emphasis>
      &eacute; &uacute;til quando &eacute; necess&aacute;rio o encerramento de uma conex&atilde;o de
      banda base.  Note que geralmente n&atilde;o &eacute; necess&aacute;rio se fazer isto
      manualmente.  A pilha automaticamente ir&aacute; encerrar conex&otilde;es de
      banda base inativas.</para>

      <screen>&prompt.root; <userinput>hccontrol -n ubt0hci disconnect 41</userinput>
Connection handle: 41
Reason: Connection terminated by local host [0x16]</screen>

      <para>Consulte <command>hccontrol help</command> para uma
      listagem completa dos comandos HCI dispon&iacute;veis.  A maioria dos
      comandos HCI n&atilde;o requerem privil&eacute;gios de superusu&aacute;rio.</para>

    </sect2>

    <indexterm><primary>L2CAP</primary></indexterm>
    <sect2>
      <title>Protocolo de Controle L&oacute;gico da Liga&ccedil;&atilde;o e de Adapta&ccedil;&atilde;o
      (L2CAP)</title>

      <para>O Protocolo de Controle L&oacute;gico da Liga&ccedil;&atilde;o e de Adapta&ccedil;&atilde;o
      - Logical Link Control and Adaptation Protocol - (L2CAP),
      fornece servi&ccedil;os de dados orientados &agrave; conex&atilde;o e desconectados
      (connectionless) aos protocolos dos n&iacute;veis superiores com
      capacidade de multiplexa&ccedil;&atilde;o e opera&ccedil;&atilde;o de segmenta&ccedil;&atilde;o e
      remontagem.  O L2CAP permite aos protocolos dos n&iacute;veis
      superiores e aplica&ccedil;&otilde;es transmitirem e receberem pacotes de
      dados L2CAP de at&eacute; 64 kilobytes de comprimento.</para>

      <para>O L2CAP &eacute; baseado em torno do conceito de
      <emphasis>canais (channels)</emphasis>.  Um canal &eacute; uma 
      conex&atilde;o l&oacute;gica sobre uma conex&atilde;o de banda base.  Cada canal 
      est&aacute; ligado a um &uacute;nico protocolo de modo muitos-para-um.  M&uacute;ltiplos 
      canais podem ser ligados ao mesmo protocolo, mas um canal 
      n&atilde;o pode ser ligado a m&uacute;ltiplos protocolos.  Cada pacote 
      L2CAP recebido em um canal &eacute; direcionado ao protocolo de 
      n&iacute;vel superior apropriado.
      M&uacute;ltiplos canais podem compartilhar a mesma conex&atilde;o 
      banda base.</para>

      <para>Um &uacute;nico n&oacute; Netgraph do tipo <emphasis>l2cap</emphasis> &eacute;
      criado para um &uacute;nico dispositivo Bluetooth.  O n&oacute; L2CAP
      geralmente &eacute; conectado a um n&oacute; Bluetooth HCI (downstream) e
      n&oacute;s de dispositivos de envio/recep&ccedil;&atilde;o (sockets) Bluetooth
      (upstream).  O nome padr&atilde;o para o n&oacute; L2CAP &eacute;
      <quote>devicel2cap</quote>.  Para maiores detalhes consulte a
      p&aacute;gina de manual &man.ng.l2cap.4;.</para>

      <para>Um comando &uacute;til &eacute; o &man.l2ping.8;, que pode ser usado
      para testar (ping) outros dispositivos.  Algumas implementa&ccedil;&otilde;es
      Bluetooth podem n&atilde;o responder a todos os dados a elas enviado,
      ent&atilde;o o resultado <emphasis>0 bytes</emphasis> no exemplo abaixo
      &eacute; considerado normal.</para>

      <screen>&prompt.root; <userinput>l2ping -a 00:80:37:29:19:a4</userinput>
0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0</screen>

      <para>O utilit&aacute;rio &man.l2control.8; &eacute; usado para executar
      diversas opera&ccedil;&otilde;es em n&oacute;s L2CAP.  Este exemplo mostra como obter
      a lista de conex&otilde;es l&oacute;gicas (canais) e a lista de conex&otilde;es banda
      base para o dispositivo local.</para>

      <screen>&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_channel_list</userinput>
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_connection_list</userinput>
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O	   0 OPEN</screen>

      <para>Outra ferramenta de diagn&oacute;stico &eacute; &man.btsockstat.1;.
      Esta ferramenta faz um trabalho similar ao de &man.netstat.1;,
      mas para estruturas de dados Bluetooth relacionadas &agrave; rede.  O
      exemplo abaixo mostra a mesma conex&atilde;o l&oacute;gica que
      &man.l2control.8;, acima.</para>


      <screen>&prompt.user; <userinput>btsockstat</userinput>
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</screen>

    </sect2>

    <indexterm><primary>RFCOMM</primary></indexterm>
    <sect2>
      <title>Protocolo RFCOMM</title>

      <para>O protocolo RFCOMM fornece emula&ccedil;&atilde;o de portas seriais
      sobre o protocolo L2CAP.  O protocolo &eacute; baseado no padr&atilde;o ETSI
      TS 07.10.  O RFCOMM &eacute; um protocolo de transporte simples, com
      provis&otilde;es adicionais para emular os nove circuitos das portas
      seriais RS-232 (EIATIA-232-E).  O protocolo RFCOMM suporta at&eacute;
      60 conex&otilde;es simult&acirc;neas (canais RFCOMM) entre dois dispositivos
      Bluetooth.</para>

      <para>Para os prop&oacute;sitos do RFCOMM, um caminho completo de
      comunica&ccedil;&atilde;o envolve duas aplica&ccedil;&otilde;es rodando em dispositivos
      diferentes (as pontas da comunica&ccedil;&atilde;o) com um segmento de
      comunica&ccedil;&atilde;o entre eles.  O RFCOMM &eacute; planejado para cobrir
      aplica&ccedil;&otilde;es que utilizem as portas seriais dos dispositivos em
      que residem.  O segmento de comunica&ccedil;&atilde;o &eacute; uma liga&ccedil;&atilde;o Bluetooth
      de um dispositivo para outro (conex&atilde;o direta).</para>

      <para>O RFCOMM preocupa-se somente com o caso da conex&atilde;o direta
      entre os dispositivos, ou com o caso de rede entre um
      dispositivo e um modem.  O RFCOMM pode suportar outras
      configura&ccedil;&otilde;es, como m&oacute;dulos que comunicam-se via tecnologia sem
      fio Bluetooth em um lado, e fornecem uma interface cabeada na
      outra ponta.</para>

      <para>No &os; o protocolo RFCOMM &eacute; implementado na camada de
      sockets Bluetooth.</para>
    </sect2>

    <indexterm><primary>pairing</primary></indexterm>
    <sect2>
      <title>Uni&atilde;o de Dispositivos (Pairing)</title>

      <para>Por padr&atilde;o, a comunica&ccedil;&atilde;o Bluetooth n&atilde;o &eacute; autenticada e
      qualquer dispositivo pode falar para qualquer outro
      dispositivo.  Um dispositivo Bluetooth (por exemplo, um telefone
      celular) pode escolher exigir autentica&ccedil;&atilde;o para fornecer um
      servi&ccedil;o particular (por exemplo, acesso discado).  A
      autentica&ccedil;&atilde;o no Bluetooth &eacute; feita normalmente com
      <emphasis>c&oacute;digo PIN</emphasis>.  Um c&oacute;digo PIN &eacute; uma
      seq&uuml;&ecirc;ncia de caracteres ASCII de at&eacute; 16 caracteres de
      comprimento.  &Eacute; preciso que o usu&aacute;rio entre com o mesmo c&oacute;digo
      PIN em ambos os dispositivos.  Uma vez que o usu&aacute;rio entrou com
      o c&oacute;digo PIN, ambos os dispositivos v&atilde;o gerar uma
      <emphasis>chave de liga&ccedil;&atilde;o (link key)</emphasis>.  Depois, a
      chave de liga&ccedil;&atilde;o pode ser armazenada nos pr&oacute;prios dispositivos
      ou em um armazenamento persistente.  Da pr&oacute;xima vez, ambos os
      dispositivos v&atilde;o usar a chave de liga&ccedil;&atilde;o previamente
      armazenada.  O procedimento acima descrito &eacute; chamada de
      <emphasis>uni&atilde;o (pairing)</emphasis>.  Note que se a chave de
      liga&ccedil;&atilde;o for perdida por qualquer dispositivo, ent&atilde;o a uni&atilde;o
      precisar&aacute; ser repetida.</para>

      <para>O daemon &man.hcsecd.8; &eacute; respons&aacute;vel por tratar todas as
      solicita&ccedil;&otilde;es de autentica&ccedil;&atilde;o Bluetooth.  O arquivo de
      configura&ccedil;&atilde;o padr&atilde;o &eacute;
      <filename>/etc/bluetooth/hcsecd.conf</filename>.  Abaixo &eacute;
      mostrada uma se&ccedil;&atilde;o de exemplo para um telefone celular com o
      c&oacute;digo PIN configurado arbitrariamente para
      <quote>1234</quote>.</para>


      <programlisting>device {
	bdaddr 00:80:37:29:19:a4;
	name    "Pav's T39";
	key     nokey;
	pin     "1234";
      }</programlisting>


      <para>N&atilde;o h&aacute; limites em c&oacute;digos de PIN (exceto tamanho).  Alguns
      dispositivos (por exemplo, fones Bluetooth) podem ter um c&oacute;digo
      PIN fixo embutido.  O par&acirc;metro <option>-d</option> for&ccedil;a o
      daemon &man.hcsecd.8; a se manter rodando em primeiro plano,
      de forma que seja f&aacute;cil observar o que est&aacute; acontecendo.  Ajuste
      o dispositivo remoto para receber uni&atilde;o e iniciar a conex&atilde;o
      Bluetooth ao dispositivo remoto.  O dispositivo remoto deveria
      dizer que a uni&atilde;o foi aceita, e solicitar o c&oacute;digo PIN.  Entre o
      mesmo c&oacute;digo PIN que voc&ecirc; tem em
      <filename>hcsecd.conf</filename>.  Agora seu PC e o dispositivo
      remoto est&atilde;o unidos.  Alternativamente, voc&ecirc; pode iniciar a
      uni&atilde;o no dispositivo remoto.  Abaixo, a amostra da sa&iacute;da do
      comando <command>hcsecd</command>.</para>

<programlisting>hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4</programlisting>

    </sect2>

    <indexterm><primary>SDP</primary></indexterm>
    <sect2>
      <title>Protocolo de Descoberta de Servi&ccedil;o (SDP)</title>


      <para>O Protocolo de Descoberta de Servi&ccedil;o - Service Discovery
      Protocol (SDP) - fornece os meios para as aplica&ccedil;&otilde;es clientes
      descobrirem a exist&ecirc;ncia de servi&ccedil;os fornecidos por aplica&ccedil;&otilde;es
      servidoras, bem como os atributos destes servi&ccedil;os.  Os atributos
      de um servi&ccedil;o incluem o tipo de classe de servi&ccedil;o oferecido e a
      informa&ccedil;&atilde;o do protocolo ou mecanismo necess&aacute;rios para utilizar o
      servi&ccedil;o.</para>

      <para>O SDP envolve comunica&ccedil;&atilde;o entre um servidor SDP e um
      cliente SDP.  O servidor mant&eacute;m uma lista de registros de
      servi&ccedil;os que descrevem as caracter&iacute;sticas dos servi&ccedil;os
      associados com o servidor.  Cada registro de servi&ccedil;o cont&eacute;m
      informa&ccedil;&atilde;o sobre um &uacute;nico servi&ccedil;o.  Um cliente pode recuperar
      informa&ccedil;&atilde;o de um servi&ccedil;o mantido pelo servidor SDP emitindo uma
      solicita&ccedil;&atilde;o SDP.  Se um cliente ou uma aplica&ccedil;&atilde;o associada com o
      cliente decide usar um servi&ccedil;o, ele precisa abrir uma conex&atilde;o
      separada ao provedor para utiliz&aacute;-lo.  O SDP fornece um
      mecanismo para descoberta de servi&ccedil;os e seus atributos, mas n&atilde;o
      fornece um mecanismo para utiliza&ccedil;&atilde;o destes servi&ccedil;os.</para>

      <para>Normalmente, um cliente SDP busca por servi&ccedil;os baseados em
      algumas caracter&iacute;sticas desejadas dos servi&ccedil;os.  Entretanto,
      h&aacute; momentos nos quais &eacute; desej&aacute;vel descobrir quais tipos de
      servi&ccedil;os est&atilde;o descritos por registros de servi&ccedil;o de um servidor
      SDP sem qualquer informa&ccedil;&atilde;o a priori sobre os mesmos.  ESte
      processo de procurar por quaisquer servi&ccedil;os oferecidos &eacute; chamado
      de <emphasis>navega&ccedil;&atilde;o (browsing)</emphasis>.</para>

      <para>Atualmente, o cliente e o servidor SDP s&atilde;o implementados em
      uma pacote externo, <application>sdp-1.5</application>, que pode
      ser copiado
      <ulink url="http://www.geocities.com/m_evmenkin/">daqui</ulink>.
      O <application>sdptool</application> &eacute; um cliente SDP de linha
      de comando.  O seguinte exemplo mostra como executar uma
      solicita&ccedil;&atilde;o de navega&ccedil;&atilde;o SDP.</para>

      <screen>&prompt.root; <userinput>sdptool browse 00:80:37:29:19:a4</userinput>
Browsing 00:80:37:29:19:A4 ...
Service Name: Dial-up Networking
Protocol Descriptor List:
 "L2CAP" (0x0100)
 "RFCOMM" (0x0003)
   Channel: 1

Service Name: Fax
Protocol Descriptor List:
 "L2CAP" (0x0100)
 "RFCOMM" (0x0003)
   Channel: 2

Service Name: Voice gateway
Service Class ID List:
 "Headset Audio Gateway" (0x1112)
 "Generic Audio" (0x1203)
Protocol Descriptor List:
 "L2CAP" (0x0100)
 "RFCOMM" (0x0003)
   Channel: 3
</screen>

      <para>...e assim por diante.  Note que cada servi&ccedil;o tem uma lista
      de atributos (canal RFCOMM, por exemplo).  Dependendo do servi&ccedil;o
      voc&ecirc; pode precisar anotar alguns dos atributos.  Algumas
      implementa&ccedil;&otilde;es Bluetooth n&atilde;o suportam navega&ccedil;&atilde;o nos servi&ccedil;os,
      e podem retornar uma lista vazia.  Neste caso, &eacute; poss&iacute;vel buscar
      pelo servi&ccedil;o espec&iacute;fico.  O exemplo abaixo mostra como buscar
      pelo servi&ccedil;o OBEX Object Push (OPUSH).</para>

      <screen>&prompt.root; <userinput>sdptool search --bdaddr 00:07:e0:00:0b:ca OPUSH</userinput></screen>

      <para>Oferecendo servi&ccedil;os em &os; a clientes Bluetooth &eacute; feito
      com o servidor <application>sdpd</application>.</para>

      <screen>&prompt.root; <userinput>sdpd</userinput></screen>

      <para>O <application>sdptool</application> tamb&eacute;m &eacute; usado para
      registrar um servi&ccedil;o no servidor SDP local.  O exemplo abaixo
      mostra como registrar o servi&ccedil;o de Acesso &agrave; Rede com PPP (LAN).
      Repare que alguns servi&ccedil;os exigem atributos (canal RFCOMM, por
      exemplo).</para>

      <screen>&prompt.root; <userinput>sdptool add --channel=7 LAN</userinput></screen>

      <para>A lista de servi&ccedil;os registrados com o servidor SDP local
      pode ser obtida emitindo uma requisi&ccedil;&atilde;o de navega&ccedil;&atilde;o SDP a um
      BD_ADDR <quote>especial</quote>.</para>

      <screen>&prompt.root; <userinput>sdptool browse ff:ff:ff:00:00:00</userinput></screen>

    </sect2>

    <sect2>
      <title>Perfis de Acesso discado (DUN) e Acesso &agrave; Rede com PPP
      (LAN)</title>

      <para>O perfil de acesso discado - Dial-Up Networking (DUN) - &eacute;
      mais usado com modems e telefones celulares.  Os cen&aacute;rios
      cobertos por este perfil s&atilde;o os seguintes:</para>

      <itemizedlist>
	<listitem><para>uso de um telefone celular ou modem por um
	computador como modem sem-fio (wireless) para conectar &agrave;
	Internet atrav&eacute;s de um servidor de acesso discado, ou usar
	outros servi&ccedil;os de acesso discado;</para></listitem>

	<listitem><para>uso de um telefone celular ou modem por um
	computador para receber chamadas de dados.</para></listitem>

      </itemizedlist>

      <para>O perfil de Acesso &agrave; Rede com PPP (LAN) pode ser usado nas
      seguintes situa&ccedil;&otilde;es:</para>

      <itemizedlist>
	<listitem><para>Acesso na Rede Local (LAN) para um &uacute;nico
	dispositivo Bluetooth;</para></listitem>

	<listitem><para>Acesso &agrave; Rede Local para m&uacute;ltiplos
	dispositivos Bluetooth;</para></listitem>

	<listitem><para>PC a PC (usando rede PPP sobre emula&ccedil;&atilde;o de
	cabo serial).</para></listitem>
      </itemizedlist>

      <para>No &os; ambos os perfis s&atilde;o implementados com &man.ppp.8;
      e &man.rfcomm.pppd.8; - uma cobertura (wrapper) que converte a
      conex&atilde;o Bluetooth RFCOMM em algo com o qual o PPP pode operar.
      Antes que qualquer perfil possa ser usado, um novo r&oacute;tulo PPP
      deve ser criado em <filename>/etc/ppp/ppp.conf</filename>.
      Consulte a p&aacute;gina de manual &man.rfcomm.pppd.8; para ver
      exemplos.</para>

      <para>No seguinte exemplo, &man.rfcomm.pppd.8; ser&aacute; usado para
      abrir uma conex&atilde;o RFCOMM ao dispositivo remoto com o BD_ADDR
      00:80:37:29:19:a4 no canal RFCOMM DUN.  O n&uacute;mero do canal RFCOMM
      atual ser&aacute; obtido do dispositivo remoto via SDP.  &Eacute; poss&iacute;vel
      especificar o canal RFCOMM manualmente, e, neste caso,
      &man.rfcomm.pppd.8; n&atilde;o ir&aacute; executar uma requisi&ccedil;&atilde;o SDP.  Use
      <application>sdptool</application> para descobrir o canal RFCOMM
      no dispositivo remoto.</para>

      <screen>&prompt.root; <userinput>rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</userinput></screen>

      <para>Para fornecer o servi&ccedil;o de Acesso &agrave; Rede com PPP (LAN), o
      servidor <application>sdpd</application> deve estar sendo
      executado.  Tamb&eacute;m &eacute; necess&aacute;rio registrar o servi&ccedil;o de Rede
      Local com o servidor SDP local.  Note que o servi&ccedil;o de rede
      exige o atributo do canal RFCOMM.  Uma nova entrada para
      clientes da Rede Local precisa ser criada no arquivo
      <filename>/etc/ppp/ppp.conf</filename>.  Consulte a p&aacute;gina de
      manual &man.rfcomm.pppd.8; para ver exemplos.  Finalmente, o
      servidor PPP RFCOMM precisa estar rodando e ouvindo no mesmo
      canal RFCOMM como foi registrado com o servidor SDP local.  O
      exemplo abaixo mostra como iniciar o servidor PPP RFCOMM.</para>

      <screen>&prompt.root; <userinput>rfcomm_pppd -s -C 7 -l rfcomm-server</userinput></screen>

    </sect2>

    <indexterm><primary>OBEX</primary></indexterm>
    <sect2>
      <title>Perfil OBEX Push (OPUSH)</title>

      <para>O OBEX &eacute; um protocolo amplamente usado para transfer&ecirc;ncias
      de arquivos simples entre dispositivos m&oacute;veis.  Seu principal
      uso &eacute; nas comunica&ccedil;&atilde;o em infravermelho, onde &eacute; usado para
      transfer&ecirc;ncias de arquivos gen&eacute;ricos entre notebooks ou
      dispositivos Palm, e para enviar cart&otilde;es de visita ou entradas
      em calend&aacute;rios entre telefones celulares e outros dispositivos
      com aplica&ccedil;&otilde;es de Gerenciamento de Informa&ccedil;&otilde;es Pessoal (PIM).</para>

      <para>O cliente e o servidor OBEX s&atilde;o implementados como pacotes
      de terceiros <application>obexapp-1.0</application> que pode ser
      copiada
      <ulink url="http://www.geocities.com/m_evmenkin/">daqui</ulink>.
        O pacote requer a biblioteca <application>openobex</application>
	(j&aacute; inclu&iacute;da) e o port
	<filename role="package">devel/glib12</filename>.  Note que
	<application>obexapp</application> n&atilde;o requer privil&eacute;gios de
	superusu&aacute;rio (root) para operar.</para>

      <para>O cliente OBEX &eacute; usado para remeter e/ou copiar objetos do
      servidor OBEX.  Um objeto pode, por exemplo, ser um cart&atilde;o de
      visitas ou um agendamento.  O cliente OBEX pode obter um n&uacute;mero
      de canal RFCOMM do dispositivo remoto via SDP.  Isto pode ser
      feito especificando-se o nome do servi&ccedil;o ao inv&eacute;s do n&uacute;mero do
      canal RFCOMM.  Nomes de dispositivos suportados s&atilde;o: IrMC, FTRN
      e OPUSH.  &Eacute; poss&iacute;vel especificar o canal RFCOMM como um n&uacute;mero.
      Abaixo est&aacute; um exemplo de sess&atilde;o OBEX, onde o objeto de
      informa&ccedil;&atilde;o do dispositivo &eacute; copiado do telefone celular e, um
      novo objeto (cart&atilde;o de visita) &eacute; remetido &agrave; agenda do
      telefone.</para>

      <screen>&prompt.user; <userinput>obexapp -a 00:80:37:29:19:a4 -C IrMC</userinput>
obex&gt; get
get: remote file&gt; telecom/devinfo.txt
get: local file&gt; devinfo-t39.txt
Success, response: OK, Success (0x20)
obex&gt; put
put: local file&gt; new.vcf
put: remote file&gt; new.vcf
Success, response: OK, Success (0x20)
obex&gt; di
Success, response: OK, Success (0x20)</screen>

      <para>Para fornecer o servi&ccedil;o de envio OBEX, o servidor
      <application>sdpd</application> precisa estar sendo executado.
      Tamb&eacute;m &eacute; necess&aacute;rio registrar o servi&ccedil;o OPUSH no servidor SDP
      local.  Note que o servi&ccedil;o OPUSH requer o atributo do canal
      RFCOMM.  Uma pasta raiz, onde todos os objetos recebidos ser&atilde;o
      armazenados, precisa ser criado.  O caminho padr&atilde;o para a pasta
      raiz &eacute; <filename>/var/spool/obex</filename>.  Finalmente, o
      servidor OBEX precisa estar rodando e ouvindo no mesmo canal
      RFCOMM como registrado com o servidor SDP local.  O exemplo
      abaixo mostra como iniciar o servidor OBEX.</para>

      <screen>&prompt.root; <userinput>obexapp -s -C 10</userinput></screen>
    </sect2>

    <sect2>
      <title>Perfil da Porta Serial (SP)</title>

      <para>A porta serial - Serial Port (SP) - permite a um
      dispositivo Bluetooth executar uma emula&ccedil;&atilde;o de cabo serial RS232
      (ou similar).  O cen&aacute;rio abordado neste perfil trata de
      aplica&ccedil;&otilde;es legadas usando o Bluetooth como substituto do cabo,
      atrav&eacute;s de uma abstra&ccedil;&atilde;o de porta serial virtual.</para>

      <para>O utilit&aacute;rio &man.rfcomm.sppd.1; implementa o perfil de
      Porta Serial.  Um pseudo tty &eacute; usado como uma abstra&ccedil;&atilde;o de porta
      serial virtual.  O exemplo abaixo mostra que voc&ecirc; n&atilde;o tem que
      especificar o canal RFCOMM - &man.rfcomm.sppd.1; pode obt&ecirc;-lo do
      dispositivo remoto via SDP.  Se voc&ecirc; quiser ativar manualmente
      isto, especifique o canal RFCOMM na linha de comando.</para>

      <screen>&prompt.root; <userinput>rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6</userinput>
rfcomm_sppd[94692]: Starting on /dev/ttyp6...</screen>

      <para>Uma vez conectado, o pseudo tty pode ser usado como porta
      serial.</para>

      <screen>&prompt.root; <userinput>cu -l ttyp6</userinput></screen>

    </sect2>

    <sect2>
      <title>Localiza&ccedil;&atilde;o de Defeitos</title>

      <sect3>
	<title>Um dispositivo remoto n&atilde;o consegue conectar-se</title>

	<para>Alguns dispositivos Bluetooth mais antigos n&atilde;o suportam
	troca de fun&ccedil;&atilde;o.  Por padr&atilde;o, quando o &os; est&aacute; aceitando uma
	nova conex&atilde;o, ele tenta efetuar uma troca de fun&ccedil;&atilde;o e
	tornar-se um mestre. Os dispositivos que n&atilde;o suportarem esta
	caracter&iacute;stica, n&atilde;o ser&atilde;o capazes de se conectar.  Note que a
	troca de fun&ccedil;&atilde;o &eacute; executada quando uma nova conex&atilde;o est&aacute;
	sendo estabelecida, de forma que n&atilde;o seja poss&iacute;vel perguntar
	ao dispositivo remoto se ele suporta troca de fun&ccedil;&atilde;o.  H&aacute; uma
	op&ccedil;&atilde;o HCI para desabilitar a troca de fun&ccedil;&atilde;o na ponta local.</para>

	<screen>&prompt.root; <userinput>hccontrol -n ubt0hci write_node_role_switch 0</userinput></screen>

      </sect3>

      <sect3>
	<title>Algo est&aacute; errado, posso ver o que exatamente est&aacute;
	acontecendo?</title>

	<para>Sim, voc&ecirc; pode. Use o pacote de terceiros
	<application>hcidump-1.5</application>, que pode ser copiado
	<ulink url="http://www.geocities.com/m_evmenkin/">daqui</ulink>.
	  O utilit&aacute;rio <application>hcidump</application> &eacute; similar ao
	  &man.tcpdump.1;.  Ele pode ser usado para mostrar o conte&uacute;do
	  dos pacotes Bluetooth no terminal, e jogar pacotes em um
	  arquivo.</para>

      </sect3>

    </sect2>

  </sect1>

  <sect1 id="network-bridging">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Steve</firstname>
      	  <surname>Peterson</surname>
	  <contrib>Escrito por </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Liga&ccedil;&atilde;o (Bridging)</title>

    <sect2>
      <title>Introdu&ccedil;&atilde;o</title>
      <indexterm><primary>IP subnet</primary></indexterm>
      <indexterm><primary>bridge</primary></indexterm>
      <para>&Agrave;s vezes &eacute; &uacute;til dividir uma rede f&iacute;sica (como um segmento
      Ethernet) em dois segmentos sem ter que criar subredes IP e usar
      um roteador para conectar os segmentos.  Um dispositivo que
      conecta duas redes juntas desta maneira &eacute; chamado de
      <quote>liga&ccedil;&atilde;o</quote>, ou <quote>ponte</quote>.  Um sistema
      FreeBSD com duas interfaces de rede pode atuar como uma liga&ccedil;&atilde;o.</para>

      <para>A liga&ccedil;&atilde;o funciona aprendendo os endere&ccedil;os da camada MAC
      (endere&ccedil;os Ethernet) dos dispositivos em cada uma de suas
      interfaces de rede.  Ela repassa  o tr&aacute;fego entre duas redes
      somente quando sua origem e destino est&atilde;o em redes diferentes.</para>

      <para>Em muitos aspectos, uma liga&ccedil;&atilde;o &eacute; como um comutador
      Ethernet com muito poucas portas.</para>
    </sect2>

    <sect2>
      <title>Situa&ccedil;&otilde;es Convenientes Para Uso de Liga&ccedil;&atilde;o</title>

      <para>Atualmente, existem duas situa&ccedil;&otilde;es comuns nas quais
      liga&ccedil;&otilde;es s&atilde;o implementadas.</para>

      <sect3>
	<title>Alto Tr&aacute;fego em um Segmento</title>

	<para>A primeira situa&ccedil;&atilde;o &eacute; onde seu segmento de rede f&iacute;sico
	est&aacute; sobrecarregado com tr&aacute;fego mas voc&ecirc; n&atilde;o quer, por
	quaisquer raz&otilde;es, subdividir a rede e interconectar as
	subredes com um roteador.</para>

	<para>Vamos considerar um exemplo de um jornal onde os
	departamentos Editorial e de Produ&ccedil;&atilde;o est&atilde;o na mesma subrede.
	Todos os usu&aacute;rios do Editorial usam o servidor A para servir
	arquivos e os usu&aacute;rios de Produ&ccedil;&atilde;o est&atilde;o no servidor B.  Uma
	Ethernet &eacute; usada para conectar todos os usu&aacute;rios e altas
	cargas de tr&aacute;fego na rede est&atilde;o degradando o desempenho.</para>

	<para>Se o os usu&aacute;rios do Editorial pudessem ser segregados em
	um segmento de rede e os usu&aacute;rios da Produ&ccedil;&atilde;o em outra, ambos
	segmentos de rede podem ser conectados com uma liga&ccedil;&atilde;o.  Somente
	o tr&aacute;fego destinado a interfaces no <quote>outro</quote>
	lado da liga&ccedil;&atilde;o poderia ser enviado para a outra rede,
	reduzindo a congest&atilde;o em cada segmento de rede.</para>

      </sect3>

      <sect3>
	<title>Filtering/Traffic Shaping Firewall</title>
	<indexterm><primary>firewall</primary></indexterm>
	<indexterm><primary>IP Masquerading</primary></indexterm>

	<para>A segunda situa&ccedil;&atilde;o comum &eacute; aquela onde a funcionalidade
	de firewall &eacute; necess&aacute;ria sem uso de mascaramento de IP
	(NAT).</para>

	<para>Um exemplo &eacute; uma pequena companhia conectada via DSL ou
	ISDN ao seu PSI.  Eles possuem 13 endere&ccedil;os IP de seu PSI
	globalmente acess&iacute;veis e 10 PCs em sua rede.  Nesta situa&ccedil;&atilde;o,
	&eacute; dif&iacute;cil usar um firewall baseado em roteador por quest&otilde;es
	de divis&otilde;es de subrede.</para>

	<indexterm><primary>router</primary></indexterm>
	<indexterm><primary>DSL</primary></indexterm>
	<indexterm><primary>ISDN</primary></indexterm>
	<para>Um firewall baseado em ponte (bridge) pode ser
	configurado e inserido no caminho somente de entrada do
	roteador DSL/ISDN sem quaisquer quest&otilde;es de numera&ccedil;&atilde;o IP.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Configurando uma Ponte (Bridge)</title>

      <sect3>
	<title>Sele&ccedil;&atilde;o de Placa Interface de Rede</title>

	<para>Uma ponte requer pelo menos duas interfaces de rede para
	funcionar.  Infelizmente, nem todas as placas interface de
	rede da &eacute;poca do FreeBSD&nbsp;4.0 suportam liga&ccedil;&otilde;es.  Leia
	&man.bridge.4; para detalhes sobre placas suportadas.</para>

	<para>Instale e teste as duas placas de rede antes de
	continuar.</para>
      </sect3>

      <sect3>
	<title>Altera&ccedil;&otilde;es nas Configura&ccedil;&otilde;es do Kernel</title>
	<indexterm>
	  <primary>kernel options</primary>
	  <secondary>options BRIDGE</secondary>
	</indexterm>

	<para>Para ativar suporte no kernel para liga&ccedil;&otilde;es, adicione:</para>

	<programlisting>options BRIDGE</programlisting>

	<para>ao seu arquivo de configura&ccedil;&atilde;o do kernel e recompile o
	mesmo.</para>
      </sect3>

      <sect3>
	<title>Suporte a Firewall</title>
	<indexterm><primary>firewall</primary></indexterm>
	<para>Se voc&ecirc; estiver planejando usar a ponte como firewall,
	voc&ecirc; tamb&eacute;m vai precisar adicionar a op&ccedil;&atilde;o
	<varname>IPFIREWALL</varname>.  Leia <xref
	linkend="firewalls"> para informa&ccedil;&otilde;es gerais sobre
	configura&ccedil;&atilde;o de ponte como firewall.</para>

	<para>Se precisar permitir pacotes n&atilde;o-IP (como ARP)
	trafegarem atrav&eacute;s da ponte, h&aacute; uma op&ccedil;&atilde;o n&atilde;o documentada de
	firewall que precisa ser ativada.  Esta op&ccedil;&atilde;o &eacute;
	<literal>IPFIREWALL_DEFAULT_TO_ACCEPT</literal>.  Note que
	isto altera a regra padr&atilde;o para que o firewall aceite qualquer
	pacote.  Certifique-se de que compreende como isto muda o
	sentido de seu conjunto de regras antes de ativ&aacute;-la.</para>
      </sect3>

      <sect3>
	<title>Suporte a Formata&ccedil;&atilde;o de Tr&aacute;fego (Traffic Shaping)</title>

	<para>Se voc&ecirc; desejar usar a ponte como formatador de tr&aacute;fego,
	voc&ecirc; vai precisar adicionar a op&ccedil;&atilde;o <literal>DUMMYNET</literal>
	&agrave; sua configura&ccedil;&atilde;o de kernel.  Leia &man.dummynet.4; para
	maiores informa&ccedil;&otilde;es.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Ativando a Ponte</title>

      <para>Adicione a linha:</para>

      <programlisting>net.link.ether.bridge=1</programlisting>

      <para>ao <filename>/etc/sysctl.conf</filename> para ativar a
      ponte em tempo de execu&ccedil;&atilde;o, e a linha:</para>

      <programlisting>net.link.ether.bridge_cfg=<replaceable>if1</replaceable>,<replaceable>if2</replaceable></programlisting>

      <para>para ativar a liga&ccedil;&atilde;o nas interfaces especificadas
      (substitua <replaceable>if1</replaceable> e
      <replaceable>if2</replaceable> com os nomes de suas duas
      interfaces de rede).  Se quiser que os pacotes de liga&ccedil;&atilde;o sejam
      filtrados por &man.ipfw.8;, voc&ecirc; tamb&eacute;m deve adicionar:</para>

      <programlisting>net.link.ether.bridge_ipfw=1</programlisting>

      <para>ao arquivo de configura&ccedil;&atilde;o.</para>
    </sect2>

    <sect2>
      <title>Outras Informa&ccedil;&otilde;es</title>

      <para>Se voc&ecirc; precisar efetuar um telnet para a ponte a partir
      da rede, n&atilde;o h&aacute; problemas em se atribuir um endere&ccedil;o IP a uma
      das placas de interface de rede.  O consenso &eacute; que n&atilde;o &eacute; boa
      id&eacute;ia atribuir endere&ccedil;os a ambas as placas.</para>

      <para>Se voc&ecirc; tem m&uacute;ltiplas pontes em sua rede, n&atilde;o pode haver
      mais que um caminho entre duas esta&ccedil;&otilde;es de trabalho.
      Tecnicamente, isto significa que n&atilde;o h&aacute; suporte para
      gerenciamento de enlaces spanning tree.</para>

      <para>Uma ponte pode acrescentar lat&ecirc;ncia ao tempo de resposta
      de pings, especialmente no tr&aacute;fego entre segmentos.</para>

    </sect2>
  </sect1>

  <sect1 id="network-nfs">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Reorganizado e aumentado por </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Bill</firstname>
      	  <surname>Swingle</surname>
	  <contrib>Escrito por </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>NFS</title>

    <indexterm><primary>NFS</primary></indexterm>
    <para>Dentre os diversos sistemas de arquivos suportados pelo
    FreeBSD est&aacute; o Sistema de Arquivo em Rede (Network File System),
    tamb&eacute;m conhecido como <acronym>NFS</acronym>.  O
    <acronym>NFS</acronym> permite que um sistema compartilhe seus
    diret&oacute;rios e arquivos com outros sistemas atrav&eacute;s de uma rede.
    Usando <acronym>NFS</acronym>, os usu&aacute;rios e programas podem
    acessar arquivos em sistemas remotos quase como se fossem arquivos
    locais.</para>

    <para>Alguns dos benef&iacute;cios mais not&aacute;veis que o
    <acronym>NFS</acronym> pode oferecer s&atilde;o:</para>

    <itemizedlist>
      <listitem>
	<para>Esta&ccedil;&otilde;es locais usam menos espa&ccedil;o em disco porque dados
	freq&uuml;entemente usados podem ser armazenados em uma
	&uacute;nica m&aacute;quina e ainda permanecerem acess&iacute;veis a outras pela
	rede.</para>
      </listitem>

      <listitem>
	<para>N&atilde;o h&aacute; necessidade de usu&aacute;rios terem diret&oacute;rios pessoais
	separados em cada m&aacute;quina da rede.  Diret&oacute;rios pessoais podem
	ser configurados no servidor <acronym>NFS</acronym> e serem
	disponibilizados atrav&eacute;s da rede.</para>
      </listitem>

      <listitem>
	<para>Dispositivos de armazenamento como disquetes, leitores
	de CD-ROM e leitores de ZIP podem ser usados por outras
	m&aacute;quinas na rede.  Isto pode reduzir o n&uacute;mero de leitores de
	m&iacute;dia remov&iacute;vel em toda a rede.</para>
      </listitem>
    </itemizedlist>

    <sect2>
      <title>Como o <acronym>NFS</acronym> Funciona</title>

      <para>O <acronym>NFS</acronym> consiste de, pelo menos, duas
      partes principais: um servidor e um ou mais clientes.  O cliente
      acessa remotamente os dados armazenados na m&aacute;quina servidora.
      Para que isto funcione direito, alguns poucos processos precisam
      estar configurados e rodando:</para>

      <note><para>No &os; 5.X, o utilit&aacute;rio <application>portmap</application> 
      foi substitu&iacute;do pelo utilit&aacute;rio <command>rpcbind</command>.  
      Assim, no &os; 5.X &eacute; preciso que o usu&aacute;rio substitua cada
      inst&acirc;ncia do <application>portmap</application> pelo 
      <command>rpcbind</command> nos exemplos a seguir.</para></note>

      <para>O servidor precisa ter rodando os seguintes daemons:</para>
      <indexterm>
	<primary>NFS</primary>
	<secondary>server</secondary>
      </indexterm>
      <indexterm>
	<primary><application>portmap</application></primary>
      </indexterm>
      <indexterm>
	<primary><application>mountd</application></primary>
      </indexterm>
      <indexterm>
	<primary><application>nfsd</application></primary>
      </indexterm>

      <informaltable frame="none">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Daemon</entry>
	      <entry>Descri&ccedil;&atilde;o</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>nfsd</entry>
	      <entry> O daemon <acronym>NFS</acronym>, que atende
	      requisi&ccedil;&otilde;es dos clientes <acronym>NFS</acronym>.</entry>
	    </row>
	    <row>
	      <entry>mountd</entry>
	      <entry> O daemon de montagem <acronym>NFS</acronym>, que executa 
	      as solicita&ccedil;&otilde;es que o &man.nfsd.8; lhe passa.</entry>
	    </row>
	    <row>
	      <entry>portmap</entry>
	      <entry> O daemon portmapper permite que clientes
	      <acronym>NFS</acronym> descubram qual porta o servidor
	      <acronym>NFS</acronym> est&aacute; utilizando.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>O cliente tamb&eacute;m pode rodar um daemon, conhecido como
      <application>nfsiod</application>.  O daemon 
      <application>nfsiod</application> atende &agrave;s solicita&ccedil;&otilde;es do
      servidor <acronym>NFS</acronym>.  Isto &eacute; opcional e aumenta o
      desempenho, mas n&atilde;o &eacute; requerido para a opera&ccedil;&atilde;o normal e
      correta.  Veja a p&aacute;gina de manual &man.nfsiod.8; para mais
      informa&ccedil;&otilde;es.</para>
    </sect2>

    <sect2 id="network-configuring-nfs">
      <title>Configurando o <acronym>NFS</acronym></title>
      <indexterm>
	<primary>NFS</primary>
	<secondary>configuration</secondary>
      </indexterm>

      <para>A configura&ccedil;&atilde;o do <acronym>NFS</acronym> &eacute; um processo
      relativamente claro e direto.  Os processos que precisam estar
      rodando podem todos ser ativados no momento da inicializa&ccedil;&atilde;o do
      sistema, com poucas modifica&ccedil;&otilde;es no seu arquivo 
      <filename>/etc/rc.conf</filename>.</para>

      <para>No servidor <acronym>NFS</acronym>, certifique-se de que
      as seguintes op&ccedil;&otilde;es est&atilde;o configuradas no arquivo 
      <filename>/etc/rc.conf</filename>:</para>

      <programlisting>portmap_enable="YES"
nfs_server_enable="YES"
mountd_flags="-r"</programlisting>

      <para>O <command>mountd</command> &eacute; automaticamente executado
      quando o servidor <acronym>NFS</acronym> &eacute; ativado.</para>

      <para>No cliente, certifique-se de que esta op&ccedil;&atilde;o est&aacute; presente
      no <filename>/etc/rc.conf</filename>:</para>

      <programlisting>nfs_client_enable="YES"</programlisting>

      <para>O arquivo <filename>/etc/exports</filename> especifica
      quais sistemas de arquivos o <acronym>NFS</acronym> deve
      exportar (&agrave;s vezes chamados de 
      <quote>compartilhamentos</quote>).  Cada linha no 
      <filename>/etc/exports</filename> determina um sistema de
      arquivo a ser exportado e quais m&aacute;quinas t&ecirc;m acesso &agrave;quele
      sistema de arquivo.  Junto com quais m&aacute;quinas t&ecirc;m acesso ao
      sistema de arquivos, op&ccedil;&otilde;es de acesso tamb&eacute;m podem ser
      especificadas.  Existem muitas op&ccedil;&otilde;es que podem ser usadas neste
      arquivo, mas somente umas poucas ser&atilde;o mencionadas aqui.  Voc&ecirc;
      pode facilmente descobrir outras op&ccedil;&otilde;es lendo a p&aacute;gina de manual
      &man.exports.5;.</para>

      <para>Aqui est&atilde;o uns poucos exemplos de entradas no 
      <filename>/etc/exports</filename>:</para>

      <indexterm>
	<primary>NFS</primary>
	<secondary>export examples</secondary>
      </indexterm>

      <para>Os seguintes exemplos d&atilde;o uma id&eacute;ia de como exportar
      sistemas de arquivos, ainda que os par&acirc;metros possam ser
      diferentes, dependendo do seu ambiente e das configura&ccedil;&otilde;es de
      rede.  Por exemplo, para exportar o diret&oacute;rio
      <filename>/cdrom</filename> para tr&ecirc;s m&aacute;quinas de exemplo, que
      possuem o mesmo nome de dom&iacute;nio que o servidor (por conseguinte
      a aus&ecirc;ncia do nome de dom&iacute;nio em cada uma) ou possuem entradas 
      no seu arquivo <filename>/etc/hosts</filename>.  O par&acirc;metro 
      <option>-ro</option> torna o sistema de arquivo exportado
      somente-para-leitura (read-only).  Com este par&acirc;metro, o sistema
      remoto n&atilde;o ser&aacute; capaz de gravar quaisquer mudan&ccedil;as no sistema de
      arquivo exportado.</para>

      <programlisting>/cdrom -ro host1 host2 host3</programlisting>

      <para>A linha abaixo exporta o <filename>/home</filename> para
      tr&ecirc;s sistemas atrav&eacute;s de seus endere&ccedil;os IP.  Esta &eacute; uma
      configura&ccedil;&atilde;o &uacute;til, se voc&ecirc; tem uma rede privada, sem servidor 
      <acronym>DNS</acronym> configurado.  Opcionalmente, o arquivo 
      <filename>/etc/hosts</filename> poderia ser configurado para
      nomear os sistemas internos; por favor reveja &man.hosts.5; para
      maiores informa&ccedil;&otilde;es.  O par&acirc;metro <option>-alldirs</option>
      permite que os subdiret&oacute;rios sejam pontos de montagem.  Em
      outras palavras, n&atilde;o vai montar os subdiret&oacute;rios, mas vai
      permitir que o cliente monte somente os diret&oacute;rios que s&atilde;o
      requeridos os necess&aacute;rios.</para>

      <programlisting>/home  -alldirs 10.0.0.2 10.0.0.3 10.0.0.4</programlisting>

      <para>A seguinte linha exporta <filename>/a</filename> de forma
      que dois clientes de diferentes dom&iacute;nios acessem o sistema de
      arquivos.  O par&acirc;metro <option>-maproot=root</option> permite
      que o usu&aacute;rio <username>root</username> do sistema remoto 
      grave dados no sistema de arquivos exportado como 
      <username>root</username>.  Se o par&acirc;metro 
      <literal>-maproot=root</literal> n&atilde;o for especificado, ent&atilde;o,
      mesmo que um usu&aacute;rio tenha acesso de <username>root</username> 
      no sistema remoto, ele n&atilde;o ser&aacute; capaz de modificar arquivos no sistema de arquivos exportado.</para>

      <programlisting>/a  -maproot=root host.exemplo.com box.exemplo.org</programlisting>

      <para>Para que um cliente tenha acesso a um sistema de arquivos
      exportado, o cliente precisa ter permiss&atilde;o para tal.
      Certifique-se de que o cliente est&aacute; listado no seu arquivo 
      <filename>/etc/exports</filename>.</para>

      <para>No <filename>/etc/exports</filename>, cada linha
      representa a informa&ccedil;&atilde;o de exporta&ccedil;&atilde;o para um sistema de arquivo
      para um sistema.  Um sistema remoto pode ser especificado 
      somente uma vez por sistema de arquivo, e pode ter somente uma 
      entrada padr&atilde;o.  Por exemplo, assuma que
      <filename>/usr</filename> &eacute; um &uacute;nico sistema de arquivo.  O 
      <filename>/etc/exports</filename> abaixo seria inv&aacute;lido:</para>

      <programlisting>/usr/src   cliente
/usr/ports cliente</programlisting>

      <para>Um sistema de arquivo, <filename>/usr</filename>, tem duas
      linhas especificando exporta&ccedil;&otilde;es para o mesmo sistema, 
      <hostid>cliente</hostid>.  O formato correto para esta situa&ccedil;&atilde;o
      &eacute;:</para>

      <programlisting>/usr/src /usr/ports cliente</programlisting>

      <para>As propriedades de um sistema de arquivo exportado para um
      dado sistema precisa estar em uma mesma linha.  Linhas sem um
      cliente especificado s&atilde;o tratadas como um &uacute;nico sistema.  Isto
      limita como voc&ecirc; pode exportar sistemas de arquivos, mas para a
      maioria das pessoas isto n&atilde;o &eacute; um problema.</para>

      <para>Abaixo segue um exemplo de uma lista de exporta&ccedil;&atilde;o v&aacute;lida,
      onde <filename>/usr</filename> e <filename>/exports</filename> 
      s&atilde;o sistemas de arquivos locais:</para>

      <programlisting># Exporte src e ports ao cliente01 e cliente02, mas somente o 
# cliente01 tem privil&eacute;gios de root nele
/usr/src /usr/ports -maproot=root    cliente01
/usr/src /usr/ports	       cliente02
# As m&aacute;quinas cliente possuem acesso de root e podem montar em
# qualquer lugar de /exports.  Qualquer um no mundo pode montar /exports/obj somente-leitura.
/exports -alldirs -maproot=root      cliente01 cliente02
/exports/obj -ro</programlisting>

      <para>Voc&ecirc; precisa reiniciar o <command>mountd</command> todas
      as vezes que modificar o <filename>/etc/exports</filename> de 
      forma que as mudan&ccedil;as tenham efeito.  Isto pode ser executado
      enviando o sinal HUP ao processo <command>mountd</command>:</para>

      <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/mountd.pid`</userinput></screen>

      <para>Alternativamente, uma reinicializa&ccedil;&atilde;o (reboot) far&aacute; o FreeBSD
      configurar tudo corretamente.  Entretanto, uma reinicializa&ccedil;&atilde;o 
      n&atilde;o &eacute; necess&aacute;ria.  Executando o seguinte comando como 
      <username>root</username> dever&aacute; ativar tudo.</para>

      <para>No servidor <acronym>NFS</acronym>:</para>

      <screen>&prompt.root; <userinput>portmap</userinput>
&prompt.root; <userinput>nfsd -u -t -n 4</userinput>
&prompt.root; <userinput>mountd -r</userinput></screen>

      <para>No cliente <acronym>NFS</acronym>:</para>

      <screen>&prompt.root; <userinput>nfsiod -n 4</userinput></screen>

      <para>Agora tudo deve estar pronto para, na pr&aacute;tica, montar um
      sistema de arquivo remoto.  Nestes exemplos, o nome do servidor
      ser&aacute; <literal>server</literal> e o nome do cliente ser&aacute;
      <literal>client</literal>.  Se voc&ecirc; quer somente montar
      temporariamente um sistema de arquivo ou prefere testar a
      configura&ccedil;&atilde;o, apenas execute um comando como este como
      <username>root</username> no cliente:</para>

      <indexterm>
	<primary>NFS</primary>
	<secondary>mounting</secondary>
      </indexterm>
      <screen>&prompt.root; <userinput>mount server:/home /mnt</userinput></screen>

      <para>Isto ir&aacute; montar o diret&oacute;rio <filename>/home</filename> 
      do servidor em <filename>/mnt</filename> no cliente.  Se tudo
      estiver configurado corretamente, voc&ecirc; deve ser capaz de entrar
      no <filename>/mnt</filename> no cliente e ver todos os arquivos
      que est&atilde;o no servidor.</para>

      <para>Se voc&ecirc; quer montar automaticamente um sistema de arquivo
      remoto cada vez que o computador iniciar, adicione o sistema de
      arquivos no arquivo <filename>/etc/fstab</filename>.  Eis um
      exemplo:</para>

      <programlisting>server:/home	/mnt	nfs	rw	0	0</programlisting>

      <para>A p&aacute;gina de manual &man.fstab.5; lista todas as op&ccedil;&otilde;es
      dispon&iacute;veis.</para>
    </sect2>

    <sect2>
      <title>Usos Pr&aacute;ticos</title>

      <para>O <acronym>NFS</acronym> tem muitos usos pr&aacute;ticos.  Alguns
      dos usos mais comuns est&atilde;o listados abaixo:</para>


      <indexterm>
	<primary>NFS</primary>
	<secondary>uses</secondary>
      </indexterm>
      <itemizedlist>
	<listitem>
	  <para>Configurar diversas m&aacute;quinas para compartilhar um CDROM
	  ou outra m&iacute;dia entre eles.  Isto &eacute; mais barato e
	  freq&uuml;entemente um m&eacute;todo mais conveniente de instalar
	  software em m&uacute;ltiplas m&aacute;quinas.</para>
	</listitem>

	<listitem>
	  <para>Em grandes redes, pode ser mais conveniente
	  configurar um servidor central para armazenar todos os
	  diret&oacute;rios pessoais dos usu&aacute;rios.  Estes diret&oacute;rios pessoais
	  ent&atilde;o podem ser exportados para a rede, de forma que os
	  usu&aacute;rios sempre tenham o mesmo diret&oacute;rio pessoal,
	  sem se preocupar com qual esta&ccedil;&atilde;o de trabalho eles
	  utilizem.</para>
	<listitem>
	  <para>Diversas m&aacute;quinas poderiam ter um diret&oacute;rio
	  <filename>/usr/ports/distfiles</filename> comum.  Desta
	  forma, quando voc&ecirc; precisar instalar um port em diversas
	  m&aacute;quinas, voc&ecirc; pode rapidamente acessar o fonte sem precisar
	  baix&aacute;-lo em cada m&aacute;quina.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2 id="network-amd">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Wylie</firstname>
	    <surname>Stilwell</surname>
	    <contrib>Contribu&iacute;do por </contrib>
	  </author>
	</authorgroup>
	<authorgroup>
	  <author>
	    <firstname>Chern</firstname>
	    <surname>Lee</surname>
	    <contrib>Reescrito por </contrib>
	  </author>
	</authorgroup>
      </sect2info>
      <title>Montagens Autom&aacute;ticas com <application>amd</application></title>

      <indexterm><primary>amd</primary></indexterm>
      <indexterm><primary>automatic mounter daemon</primary></indexterm>

      <para>O daemon de automontagem, &man.amd.8; (automatic
      mounter daemon), monta automaticamente um sistema de arquivo 
      remoto todas as vezes que um arquivo ou diret&oacute;rio naquele
      sistema de arquivo &eacute; acessado.  Sistemas de arquivos que ficam
      inativos por um per&iacute;odo de tempo tamb&eacute;m ser&atilde;o automaticamente
      desmontados pelo <application>amd</application>.  Usar o
      <application>amd</application> &eacute; uma alternativa para montagens
      permanentes, uma vez que as montagens permanentes geralmente
      est&atilde;o listadas no <filename>/etc/fstab</filename>.</para>

      <para>O <application>amd</application> opera anexando-se como um
      servidor NFS aos diret&oacute;rios <filename>/host</filename> e
      <filename>/net</filename>.  Quando um arquivo &eacute; acessado dentro
      destes diret&oacute;rios, o <application>amd</application> procura pelo
      ponto de montagem remoto correspondente e o monta 
      automaticamente.  O <filename>/net</filename> &eacute; usado para
      montar um sistema de arquivo exportado de um endere&ccedil;o IP,
      enquanto o <filename>/host</filename> &eacute; usado para montar uma
      exporta&ccedil;&atilde;o de um nome de sistema remoto.</para>

      <para>Um acesso a um arquivo dentro de 
      <filename>/host/foobar/usr</filename> diria ao 
      <application>amd</application> para tentar montar a exporta&ccedil;&atilde;o
      <filename>/usr</filename> no sistema <hostid>foobar</hostid>.
      </para>

      <example>
	<title>Montando uma Exporta&ccedil;&atilde;o com 
	<application>amd</application></title>

	<para>Voc&ecirc; pode ver as montagens dispon&iacute;veis de um sistema
	remoto com o comando <command>showmount</command>.  Por
	exemplo, para ver as montagens de um sistema chamado 
	<hostid>foobar</hostid>, voc&ecirc; pode usar:</para>

	<screen>&prompt.user; <userinput>showmount -e foobar</userinput>
Exports list on foobar:
/usr			       10.10.10.0
/a				 10.10.10.0
&prompt.user; <userinput>cd /host/foobar/usr</userinput></screen>
      </example>

      <para>Como visto no exemplo, o <command>showmount</command> mostra 
      <filename>/usr</filename> como uma exporta&ccedil;&atilde;o.  Quando trocar de
      diret&oacute;rios para <filename>/host/foobar/usr</filename>, o
      <application>amd</application> tenta resolver o nome do sistema
      <hostid>foobar</hostid> e automaticamente monta a exporta&ccedil;&atilde;o
      desejada.</para>

      <para>O <application>amd</application> pode ser iniciado pelos
      scripts de inicializa&ccedil;&atilde;o colocando as seguintes linhas no
      <filename>/etc/rc.conf</filename>:</para>

      <programlisting>amd_enable="YES"</programlisting>

      <para>Adicionalmente, par&acirc;metros personalizados podem ser
      passados ao <application>amd</application> pela op&ccedil;&atilde;o 
      <varname>amd_flags</varname>.  Por padr&atilde;o, o
      <varname>amd_flags</varname> &eacute; ajustado para:</para>

      <programlisting>amd_flags="-a /.amd_mnt -l syslog /host /etc/amd.map /net /etc/amd.map"</programlisting>

      <para>O arquivo <filename>/etc/amd.map</filename> define as
      op&ccedil;&otilde;es padr&atilde;o com as quais as exporta&ccedil;&otilde;es ser&atilde;o montadas.  O
      arquivo <filename>/etc/amd.conf</filename> define algumas das
      caracter&iacute;sticas mais avan&ccedil;adas do 
      <application>amd</application>.</para>

      <para>Consulte as p&aacute;ginas de manual &man.amd.8; e
      &man.amd.conf.5; para maiores informa&ccedil;&otilde;es.</para>
    </sect2>

    <sect2 id="network-nfs-integration">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>John</firstname>
	    <surname>Lind</surname>
	    <contrib>Contribu&iacute;do por </contrib>
	  </author>
	</authorgroup>
      </sect2info>
      <title>Problemas na Integra&ccedil;&atilde;o com Outros Sistemas</title>

      <para>Certos adaptadores Ethernet para sistemas PC ISA possuem
      limita&ccedil;&otilde;es que podem causar s&eacute;rios problemas de rede,
      particularmente com NFS.  Esta dificuldade n&atilde;o &eacute; espec&iacute;fica do
      FreeBSD, mas sistemas FreeBSD s&atilde;o afetados por ela.</para>

      <para>O problema quase sempre ocorre quando sistemas PC
      (FreeBSD) s&atilde;o conectados em rede com esta&ccedil;&otilde;es de trabalho de
      alto desempenho com as feitas pela Silicon Graphics, Inc., e Sun
      Microsystems, Inc.  As montagens NFS funcionar&atilde;o bem, e algumas
      opera&ccedil;&otilde;es podem ser bem sucedidas, mas repentinamente, o
      servidor vai parecer n&atilde;o mais responder ao cliente, mesmo que as
      solicita&ccedil;&otilde;es de e para outros sistemas continuem a ser
      processadas.  Isto acontece ao sistema cliente, se o cliente for
      o sistema FreeBSD ou a esta&ccedil;&atilde;o de trabalho.  Em muitos
      sistemas, n&atilde;o h&aacute; forma de parar o sistema elegantemente, uma vez
      que este problema se manifestou.  A &uacute;nica solu&ccedil;&atilde;o &eacute;,
      freq&uuml;entemente, reinicializar o cliente, porque a situa&ccedil;&atilde;o do
      NFS n&atilde;o pode ser resolvida.</para>

      <para>Apesar da solu&ccedil;&atilde;o <quote>correta</quote> ser a de obter um
      adaptador de maior desempenho e capacidade para o sistema
      FreeBSD, h&aacute; um contorno simples que vai permitir a opera&ccedil;&atilde;o
      satisfat&oacute;ria.  Se o sistema FreeBSD for o 
      <emphasis>servidor</emphasis>, inclua a op&ccedil;&atilde;o 
      <option>-w=1024</option> na montagem a partir do cliente.  Se o
      sistema FreeBSD &eacute; o <emphasis>cliente</emphasis>, ent&atilde;o monte o
      sistema de arquivo NFS com a op&ccedil;&atilde;o <option>-r=1024</option>.
      Estas op&ccedil;&otilde;es podem ser especificadas usando o quarto campo da
      entrada <filename>fstab</filename> no cliente para montagens
      autom&aacute;ticas, ou, usando o par&acirc;metro <option>-o</option> do
      comando mount para montagens manuais.</para>

      <para>Deve ser observado que h&aacute; um problema diferente, algumas
      vezes confundido com este, quando os servidores e clientes NFS
      est&atilde;o em redes diferentes.  Se for este o caso, esteja
      <emphasis>certo</emphasis> de que seus roteadores est&atilde;o roteando
      a informa&ccedil;&atilde;o UDP necess&aacute;ria, ou voc&ecirc; n&atilde;o vai chegar a lugar
      algum, n&atilde;o importando o que mais voc&ecirc; estiver fazendo.</para>

      <para>Nos seguintes exemplos, <hostid>fastws</hostid> &eacute; o
      nome do sistema (interface) de uma esta&ccedil;&atilde;o de trabalho de alto
      desempenho, e <hostid>freebox</hostid> &eacute; o nome do sistema
      (interface) de um sistema FreeBSD com um adaptador Ethernet de
      baixo desempenho.  Tamb&eacute;m, <filename>/sharedfs</filename> ser&aacute;
      o sistema de arquivo NFS exportado (veja &man.exports.5;), e
      <filename>/project</filename> ser&aacute; o ponto de montagem no
      cliente para o sistema exportado.  Em todos os casos, note que
      op&ccedil;&otilde;es adicionais, como <option>hard</option> ou
      <option>soft</option> e <option>bg</option> podem ser desej&aacute;veis
      em sua aplica&ccedil;&atilde;o.</para>

      <para>Exemplos para o sistema FreeBSD (<hostid>freebox</hostid>)
      como sendo o cliente no <filename>/etc/fstab</filename> de 
      freebox:</para>

      <programlisting>fastws:/sharedfs /project nfs rw,-r=1024 0 0</programlisting>

      <para>Como um comando para montagem manual em 
      <hostid>freebox</hostid>:</para>

      <screen>&prompt.root; <userinput>mount -t nfs -o -r=1024 fastws:/sharedfs /project</userinput></screen>

      <para>Exemplos para o sistema FreeBSD como o servidor no
      <filename>/etc/fstab</filename> em <hostid>fastws</hostid>:</para>

      <programlisting>freebox:/sharedfs /project nfs rw,-w=1024 0 0</programlisting>

      <para>Como comando para montagem manual em 
      <hostid>fastws</hostid>:</para>

      <screen>&prompt.root; <userinput>mount -t nfs -o -w=1024 freebox:/sharedfs /project</userinput></screen>

      <para>Quase qualquer adaptador Ethernet permitir&aacute; opera&ccedil;&atilde;o sem
      as restri&ccedil;&otilde;es acima no tamanho de leitura ou escrita.</para>

      <para>Para qualquer um que se importe, aqui est&aacute; o que acontece
      quando a falha ocorre, o que tamb&eacute;m explica porque &eacute;
      irrecuper&aacute;vel.  O NFS trabalha tipicamente com um tamanho de
      <quote>bloco</quote> de 8&nbsp;k (apesar de que pode criar
      fragmentos de tamanhos menores).  Uma vez que o tamanho m&aacute;ximo
      do quadro Ethernet &eacute; em torno de 1500&nbsp;bytes, o 
      <quote>bloco</quote> NFS &eacute; dividido em m&uacute;ltiplos quadros
      Ethernet, mesmo que ainda seja uma &uacute;nica unidade para o c&oacute;digo 
      de n&iacute;vel superior, e precisa ser recebido, montado e 
      <emphasis>confirmado (acknowledged)</emphasis> como uma
      unidade.  As esta&ccedil;&otilde;es de alto desempenho podem bombear os
      pacotes que comp&otilde;em a unidade NFS para fora, um ap&oacute;s o outro,
      t&atilde;o pr&oacute;ximos quanto permitido pelo padr&atilde;o.  Nas interfaces
      menores, de baixa capacidade, os &uacute;ltimos pacotes ultrapassam 
      os primeiros pacotes da mesma unidade antes que possam ser
      reconstru&iacute;dos ou confirmados.  Como resultado, a esta&ccedil;&atilde;o de
      trabalho vai expirar e tentar novamente, mas tentar&aacute; novamente
      com a unidade de 8&nbsp;K inteira, e o processo se repetir&aacute;, ao
      infinito.</para>

      <para>Mantendo o tamanho da unidade menor que a limita&ccedil;&atilde;o do 
      tamanho do quadro Ethernet, garantimos que qualquer quadro
      Ethernet completo recebido pode ser confirmado individualmente,
      evitando a situa&ccedil;&atilde;o de congelamento (deadlock).</para>

      <para>Ultrapassagens ainda poder&atilde;o ocorrer quando uma esta&ccedil;&otilde;es 
      de alto desempenho estiverem golpeando dados para um sistema 
      PC, mas com placas melhores, tais ultrapassagens n&atilde;o s&atilde;o
      garantidas nas <quote>unidades</quote> NFS.  Quando uma
      ultrapassagem acontecer, as unidades afetadas ser&atilde;o
      retransmitidas, e haver&aacute; uma boa chance de que ser&atilde;o recebidas,
      montadas e confirmadas.</para>
    </sect2>
  </sect1>

  <sect1 id="network-diskless">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Jean-Fran&ccedil;ois</firstname>
	  <surname>Dock&egrave;s</surname>
	  <contrib>Atualizado por </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Opera&ccedil;&atilde;o Sem Disco (Diskless Operation)</title>

    <indexterm><primary>diskless workstation</primary></indexterm>
    <indexterm><primary>diskless operation</primary></indexterm>

    <para>Uma m&aacute;quina FreeBSD pode ser inicializada pela rede e operar
    sem um disco local, usando sistemas de arquivos montados de um
    servidor NFS.  Nenhuma modifica&ccedil;&atilde;o &eacute; necess&aacute;ria no sistema, al&eacute;m
    dos arquivos de configura&ccedil;&atilde;o.  Tal sistema &eacute; f&aacute;cil de configurar
    porque todos os elementos necess&aacute;rios est&atilde;o prontamente
    dispon&iacute;veis:</para>

    <itemizedlist>
      <listitem>
	<para>Existem pelo menos dois m&eacute;todos poss&iacute;veis para carregar
	o kernel atrav&eacute;s da rede:</para>

	<itemizedlist>
	  <listitem>
	    <para><emphasis>PXE</emphasis>: O sistema Ambiente de
	    Execu&ccedil;&atilde;o Pr&eacute;-inicializa&ccedil;&atilde;o (Preboot Execution Environment)
	    &eacute; uma forma de ROM de partida inteligente embutida em
	    algumas placas de rede ou placas-m&atilde;e.  Veja
	    &man.pxeboot.8; para maiores detalhes.</para>
	  </listitem>
	  <listitem>
	    <para>O port <application>etherboot</application>
	    (<filename role="package">net/etherboot</filename>)
	    produz c&oacute;digo grav&aacute;vel em ROM para inicializar kernels
	    atrav&eacute;s da rede.  O c&oacute;digo pode ser gravado em uma PROM de
	    inicializa&ccedil;&atilde;o em uma interface de rede, ou carregada de
	    um leitor de disquetes (ou disco r&iacute;gido) local, ou de um
	    sistema rodando &ms-dos;.  Muitas placas de rede s&atilde;o
	    suportadas.</para>

	  </listitem>
	</itemizedlist>
	</listitem>

      <listitem>
	<para>Um script de amostra 
	(<filename>/usr/share/examples/diskless/clone_root</filename>)
	facilita a cria&ccedil;&atilde;o e manuten&ccedil;&atilde;o do sistema de arquivo raiz da
	esta&ccedil;&atilde;o de trabalho no servidor.  O script provavelmente vai
	requerer uma pequena personaliza&ccedil;&atilde;o, mas vai lhe permitir
	come&ccedil;ar muito rapidamente.</para>
      </listitem>

      <listitem>
	<para>Os arquivos de inicializa&ccedil;&atilde;o padr&atilde;o do sistema est&atilde;o em
	<filename>/etc</filename> para detectar e suportar a partida
	de um sistema sem disco.</para>
      </listitem>

      <listitem>
	<para>Se necess&aacute;rio fazer swapping, poder&aacute; ser feito em um
	arquivo NFS ou em um disco local.</para>
      </listitem>
    </itemizedlist>

    <para>Existem muitas formas de configurar esta&ccedil;&otilde;es sem disco.
    Muitos elementos est&atilde;o envolvidos, e a maioria pode ser
    personalizada para atender uma prefer&ecirc;ncia local.  A seguir ser&aacute;
    descrita a configura&ccedil;&atilde;o de um sistema completo, enfatizando a
    simplicidade e compatibilidade com os scripts padr&atilde;o do FreeBSD.
    O sistema descrito tem as seguintes caracter&iacute;sticas:</para>

    <itemizedlist>
      <listitem>
	<para>As esta&ccedil;&otilde;es sem disco usam sistemas de arquivos
	<filename>raiz</filename> e <filename>/usr</filename>
	 somente-leitura compartilhados.</para>

	<para>O sistema de arquivo <filename>raiz</filename> &eacute; uma
	c&oacute;pia de uma raiz padr&atilde;o do FreeBSD (tipicamente a do
	servidor), com alguns arquivos de configura&ccedil;&atilde;o cancelados por
	alguns espec&iacute;ficos para opera&ccedil;&atilde;o sem disco ou, possivelmente,
	para a esta&ccedil;&atilde;o de trabalho &agrave; qual pertencem.</para>

	<para>As partes da <filename>raiz</filename> que precisam ser
	grav&aacute;veis s&atilde;o cobertas com sistemas de arquivos &man.mfs.8;.
	Quaisquer mudan&ccedil;as ser&atilde;o perdidas quando o sistema for
	reinicializado.</para>

      </listitem>
      <listitem>
	<para>O kernel &eacute; carregado pelo
	<application>etherboot</application>, usando DHCP (ou BOOTP) e
	TFTP.</para>
      </listitem>
    </itemizedlist>

    <caution><para> Como descrito, este sistema &eacute; inseguro.  Ele deve
    morar em uma &aacute;rea protegida da rede, e n&atilde;o ser confiado por outras
    m&aacute;quinas.</para></caution>

    <sect2>
      <title>Instru&ccedil;&otilde;es de Configura&ccedil;&atilde;o</title>

      <sect3>
	<title>Configurando o DHCP/BOOTP</title>
	<indexterm>
	  <primary>diskless operation</primary>
	  <secondary>booting</secondary>
	</indexterm>

	<para>Existem dois protocolos que s&atilde;o comumente usados para
	inicializar uma esta&ccedil;&atilde;o de trabalho que recupera seus arquivos
	de configura&ccedil;&atilde;o atrav&eacute;s da rede: BOOTP e DHCP.  Eles s&atilde;o
	usados em diversos pontos na partida da esta&ccedil;&atilde;o de trabalho:</para>

	<itemizedlist>
	  <listitem><para>O <application>etherboot</application> usa o 
	  DHCP (por padr&atilde;o) ou BOOTP (precisa de uma op&ccedil;&atilde;o de
	  configura&ccedil;&atilde;o) para encontrar o kernel.  (PXE usa DHCP).
	  </para></listitem>

	  <listitem><para>O kernel usa BOOTP para localizar a raiz NFS.</para>
	  </listitem>
	</itemizedlist>

	<para>&Eacute; poss&iacute;vel configurar um sistema para usar somente
	BOOTP.  O programa servidor &man.bootpd.8; est&aacute; inclu&iacute;do no
	sistema base do FreeBSD.</para>

	<para>Entretanto, o DHCP tem diversas vantagens sobre o BOOTP
	(melhores arquivos de configura&ccedil;&atilde;o, possibilidade de usar PXE,
	mais muitas outras n&atilde;o diretamente relacionadas &agrave; opera&ccedil;&atilde;o sem
	disco), e n&oacute;s vamos descrever ambas as configura&ccedil;&otilde;es, BOOTP
	puro e BOOTP+DHCP, com &ecirc;nfase no &uacute;ltimo, o qual vai usar o
	pacote de software DHCP da ISC.</para>

	<sect4>
	  <title>Configura&ccedil;&atilde;o Usando o DHCP da ISC</title>
	  <indexterm>
	    <primary>DHCP</primary>
	    <secondary>diskless operation</secondary>
	  </indexterm>

	  <para>O servidor <application>isc-dhcp</application> pode
	  responder tanto requisi&ccedil;&otilde;es BOOTP como DHCP.</para>

	  <para>Desde o lan&ccedil;amento (release) 4.4, o 
	  <application>isc-dhcp 3.0</application> n&atilde;o &eacute; parte do
	  sistema base.  Voc&ecirc; primeiro vai precisar instalar o port
	  <filename role="package">net/isc-dhcp3</filename> ou o
	  pacote (package) correspondente.  Por favor, veja <xref
	  linkend="ports"> para informa&ccedil;&otilde;es gerais sobre ports e
	  packages.</para>

	  <para>Uma vez que o <application>isc-dhcp</application> 
	  estiver instalado, ele precisa de um arquivo de 
	  configura&ccedil;&atilde;o para rodar, (normalmente chamado 
	  <filename>/usr/local/etc/dhcpd.conf</filename>).  Aqui segue
	  um exemplo comentado:</para>

	  <programlisting>
	  default-lease-time 600;
	  max-lease-time 7200;
	  authoritative;

	  option domain-name "exemplo.com";
	  option domain-name-servers 192.168.4.1;
	  option routers 192.168.4.1;

	  subnet 192.168.4.0 netmask 255.255.255.0 {
	    use-host-decl-names on; <co id="co-dhcp-host-name">
	    option subnet-mask 255.255.255.0;
	    option broadcast-address 192.168.4.255;

	    host margaux {
	      hardware ethernet 01:23:45:67:89:ab;
	      fixed-address margaux.exemplo.com;
	      next-server 192.168.4.4;<co id="co-dhcp-next-server">
	      filename "/tftpboot/kernel.diskless";<co id="co-dhcp-filename">
	      option root-path "192.168.4.4:/data/misc/diskless";<co id="co-dhcp-root-path">
	    }
	  }
	  </programlisting>

	  <calloutlist>
	    <callout arearefs="co-dhcp-host-name"><para>Esta op&ccedil;&atilde;o diz ao 
	    <command>dhcpd</command> para enviar o valor nas
	    declara&ccedil;&otilde;es <literal>host</literal> como o nome do sistema
	    para a m&aacute;quina sem disco.  Uma alternativa seria adicionar
	    um <literal>option host-name <replaceable>margaux</replaceable>
	    </literal> dentro das declara&ccedil;&otilde;es host.</para></callout>

	    <callout arearefs="co-dhcp-next-server"><para>A diretiva 
	    <literal>next-server</literal> designa o servidor TFTP (o
	    padr&atilde;o &eacute; usar o mesmo sistema que o servidor DHCP).</para>
	    </callout>

	    <callout arearefs="co-dhcp-filename"><para>A diretiva 
	    <literal>filename</literal> define que o arquivo que o 
	    <application>etherboot</application> vai carregar como o 
	    kernel.
	    <note><para>O PXE parece preferir um nome de arquivo
	    relativo, e ele carrega <command>pxeboot</command>, n&atilde;o 
	    o kernel (<literal>option filename "pxeboot"</literal>).
	    </para></note>
	    </para></callout> 

	    <callout arearefs="co-dhcp-root-path"><para>A op&ccedil;&atilde;o 
	    <literal>root-path</literal> define o caminho do sistema
	    de arquivo raiz, na nota&ccedil;&atilde;o NFS usual.</para></callout>
	  </calloutlist>

	</sect4>
	<sect4>
	  <title>Configura&ccedil;&atilde;o Usando o BOOTP</title>
	  <indexterm>
	    <primary>BOOTP</primary>
	    <secondary>diskless operation</secondary>
	  </indexterm>

	  <para>Aqui segue uma configura&ccedil;&atilde;o <command>bootpd</command>
	  equivalente.  Isto seria encontrado em 
	  <filename>/etc/bootptab</filename>.</para>

	  <para>Por favor, note que o 
	  <application>etherboot</application> precisa ser compilado
	  com a op&ccedil;&atilde;o n&atilde;o padr&atilde;o <literal>NO_DHCP_SUPPORT</literal>
	   para usar o BOOTP, e que o PXE <emphasis>precisa</emphasis>
	   do DHCP.  A &uacute;nica vantagem &oacute;bvia do 
	   <application>bootpd</application> &eacute; que ele existe no
	   sistema base.</para>

	  <programlisting>
	  .def100:\
	    :hn:ht=1:sa=192.168.4.4:vm=rfc1048:\
	    :sm=255.255.255.0:\
	    :ds=192.168.4.1:\
	    :gw=192.168.4.1:\
	    :hd="/tftpboot":\
	    :bf="/kernel.diskless":\
	    :rp="192.168.4.4:/data/misc/diskless":

	  margaux:ha=0123456789ab:tc=.def100
	  </programlisting>
	</sect4>
      </sect3>

      <sect3>
	<title>Preparando um Programa de Boot com 
	<application>Etherboot</application></title>

	<indexterm>
	  <primary>Etherboot</primary>
	</indexterm>

	<para><ulink url="http://etherboot.sourceforge.net">O S&iacute;tio 
	Web do Etherboot</ulink> cont&eacute;m <ulink
	url="http://etherboot.sourceforge.net/doc/html/userman/t1.html">
	extensa documenta&ccedil;&atilde;o</ulink> direcionada principalmente a 
	sistemas Linux, mas apesar de tudo, contendo informa&ccedil;&otilde;es 
	&uacute;teis.  O texto a seguir vai apenas delinear como voc&ecirc; usaria 
	o <application>etherboot</application> em um sistema FreeBSD.
	</para>

	<para>Primeiro voc&ecirc; precisa instalar o port ou pacote 
	<filename role="package">net/etherboot</filename>.  O port
	<application>etherboot</application> pode normalmente ser 
	encontrado em <filename>/usr/ports/net/etherboot</filename>.
	Se a &aacute;rvore dos ports est&aacute; instalada em seu sistema, apenas
	digitando <literal>make</literal> neste diret&oacute;rio deve
	resolver tudo.  Do contr&aacute;rio, veja <xref linkend="ports"> para
	informa&ccedil;&otilde;es sobre ports e pacotes (packages).</para>

	<para>Para nossa configura&ccedil;&atilde;o, usaremos um disquete de
	inicializa&ccedil;&atilde;o.  Para outros m&eacute;todos (PROM, ou programa DOS),
	veja, por favor, a documenta&ccedil;&atilde;o do 
	<application>etherboot</application>.</para>

	<para>Para fazer um disquete de inicializa&ccedil;&atilde;o, insira o
	disquete no leitor na m&aacute;quina onde voc&ecirc; instalou o
	<application>etherboot</application>, ent&atilde;o mude seu diret&oacute;rio
	atual para o diret&oacute;rio <filename>src</filename> na &aacute;rvore 
	<application>etherboot</application> e digite:</para>

	<screen>
	  &prompt.root; <userinput>gmake bin32/<replaceable>devicetype</replaceable>.fd0</userinput>
	</screen>

	<para>O <replaceable>devicetype</replaceable> depende do tipo
	de interface Ethernet na esta&ccedil;&atilde;o de trabalho sem disco.  Veja
	o arquivo <filename>NIC</filename> no mesmo diret&oacute;rio para
	determinar o <replaceable>devicetype</replaceable> correto.</para>

      </sect3>


      <sect3>
	<title>Configurando os Servidores TFTP e NFS</title>

	<indexterm>
	  <primary>TFTP</primary>
	  <secondary>diskless operation</secondary>
	</indexterm>
	<indexterm>
	  <primary>NFS</primary>
	  <secondary>diskless operation</secondary>
	</indexterm>

	<para>voc&ecirc; precisa ativar o <command>tftpd</command> no
	servidor TFTP:</para>
	<procedure>
	  <step>
	    <para>Crie um diret&oacute;rio de onde o 
	    <command>tftpd</command> vai fornecer arquivos, p.ex. 
	    <filename>/tftpboot</filename>.</para>
	  </step>

	  <step>
	    <para>Adicione esta linha ao seu 
	    <filename>/etc/inetd.conf</filename>:</para>

	    <programlisting>tftp    dgram   udp     wait    root  /usr/libexec/tftpd    tftpd -s /tftpboot</programlisting>

	    <note><para>Parece que pelo menos algumas vers&otilde;es de PXE
	    querem a vers&atilde;o TCP do TFTP.  Neste caso, adicione a
	    segunda linha, substituindo <literal>dgram udp</literal> por 
	    <literal>stream tcp</literal>.</para></note>
	  </step>
	  <step>
	    <para>Diga ao <command>inetd</command> para reler seu
	    arquivo de configura&ccedil;&atilde;o:</para>
	    <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/inetd.pid`</userinput></screen>
	  </step>
	</procedure>

	<para>Voc&ecirc; pode colocar o diret&oacute;rio 
	<filename>tftpboot</filename> em qualquer lugar no servidor.
	Certifique-se de que a localiza&ccedil;&atilde;o est&aacute; configurada em ambos
	<filename>inetd.conf</filename> e 
	<filename>dhcpd.conf</filename>.</para>

	<para>Voc&ecirc; tamb&eacute;m precisa ativar o NFS e exportar o sistema de
	arquivo adequado no servidor NFS.</para>

	<procedure>
	  <step>
	    <para>Adicione isto ao <filename>/etc/rc.conf</filename>:</para>
	    <programlisting>nfs_server_enable="YES"</programlisting>
	  </step>

	  <step>
	    <para>Exporte o sistema de arquivo onde est&aacute; localizado o
	    diret&oacute;rio raiz da esta&ccedil;&atilde;o de trabalho sem disco,
	    adicionando o seguinte ao <filename>/etc/exports</filename>
	     (ajuste o ponto de montagem do volume e troque 
	     <replaceable>margaux</replaceable> pelo nome da esta&ccedil;&atilde;o
	     de trabalho sem disco):</para>

	    <programlisting><replaceable>/data/misc</replaceable> -alldirs -ro <replaceable>margaux</replaceable></programlisting>
	  </step>
	  <step>
	    <para>Diga ao <command>mountd</command> para reler seu
	    arquivo de configura&ccedil;&atilde;o.  Se voc&ecirc; realmente precisasse
	    ativar o NFS no <filename>/etc/rc.conf</filename> no 
	    primeiro passo, voc&ecirc; provavelmente iria preferir
	    reinicializar.</para>
	    <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/mountd.pid`</userinput></screen>
	  </step>
	</procedure>

      </sect3>

      <sect3>
	<title>Construindo um Kernel Sem Disco</title>

	<indexterm>
	  <primary>diskless operation</primary>
	  <secondary>kernel configuration</secondary>
	</indexterm>

	<para>Crie um arquivo de configura&ccedil;&atilde;o de kernel para o cliente
	sem disco com as seguintes op&ccedil;&otilde;es (em acr&eacute;scimo &agrave;s op&ccedil;&otilde;es
	usuais):</para>

	<programlisting>
	  options     BOOTP	     # Use BOOTP to obtain IP address/hostname
	  options     BOOTP_NFSROOT  # NFS mount root filesystem using BOOTP info
	  options     BOOTP_COMPAT   # Workaround for broken bootp daemons.
	</programlisting>

	<para>Voc&ecirc; tamb&eacute;m pode querer usar <literal>BOOTP_NFSV3</literal> e 
	<literal>BOOTP_WIRED_TO</literal> (veja o
	<filename>LINT</filename>).</para>

	<para>Construa o kernel (Veja <xref linkend="kernelconfig">),
	 e copie-o para o diret&oacute;rio do tftp, sob o nome listado em 
	 <filename>dhcpd.conf</filename>.</para>

      </sect3>

      <sect3>
	  <title>Preparando o Sistema de Arquivo Raiz</title>

	<indexterm>
	  <primary>root file system</primary>
	  <secondary>diskless operation</secondary>
	</indexterm>

	<para>voc&ecirc; precisa criar um sistema de arquivo raiz para as
	esta&ccedil;&otilde;es de trabalho sem disco, no local listado como 
	<literal>root-path</literal> no 
	<filename>dhcpd.conf</filename>.</para>

	<para>A forma mais f&aacute;cil de faz&ecirc;-lo &eacute; usar o shell script
	<filename>/usr/share/examples/diskless/clone_root</filename>.
	 Este script precisa ser personalizado, pelo menos para
	 ajustar o lugar onde o sistema de arquivo ser&aacute; criado (a
	 vari&aacute;vel <literal>DEST</literal>).</para>

	<para>Refira aos coment&aacute;rios no topo do script para
	instru&ccedil;&otilde;es.  Elas explicam como o sistema de arquivo base &eacute;
	constru&iacute;do, e como os arquivos podem ser seletivamente
	cancelados por vers&otilde;es espec&iacute;ficas para opera&ccedil;&atilde;o sem disco,
	para uma subrede ou, para uma esta&ccedil;&atilde;o de trabalho individual. 
	 Eles tamb&eacute;m d&atilde;o exemplos para os arquivos  
	<filename>/etc/fstab</filename> e 
	<filename>/etc/rc.conf</filename> para opera&ccedil;&atilde;o sem disco.
	</para>

	  <para>Os arquivos <filename>README</filename> em 
	  <filename>/usr/share/examples/diskless</filename> cont&ecirc;m
	  muitas informa&ccedil;&otilde;es t&eacute;cnicas , mas, juntamente com outros
	  exemplos no diret&oacute;rio <filename>diskless</filename>, eles na
	  realidade documentam um m&eacute;todo de configura&ccedil;&atilde;o que &eacute;
	  diferente do usado por <filename>clone_root</filename> e
	  <filename>/etc/rc.diskless[12]</filename>, o que &eacute; um pouco
	  confuso.  Use-os apenas para refer&ecirc;ncia, exceto se voc&ecirc;
	  preferir o m&eacute;todo por eles descrito, sendo que, neste caso,
	  voc&ecirc; vai precisar de scripts <filename>rc</filename> 
	  modificados.</para>

      </sect3>

      <sect3>
	<title>Configurando o Arquivo de Troca (Swap)</title>

	<para>Se necess&aacute;rio, um arquivo de troca (swap) localizado no
	servidor pode ser acessado via NFS.  As op&ccedil;&otilde;es exatas 
	do <filename>bootptab</filename> ou 
	<filename>dhcpd.conf</filename> n&atilde;o s&atilde;o claramente
	documentadas neste momento.  As seguintes sugest&otilde;es de
	configura&ccedil;&atilde;o foram reportadas como funcionais em algumas
	instala&ccedil;&otilde;es usando o isc-dhcp 3.0rc11.</para>

	<procedure>
	  <step><para>Adicione as seguintes linhas ao 
	  <filename>dhcpd.conf</filename>:</para>
	    <programlisting>
	      # Global section
	      option swap-path code 128 = string;
	      option swap-size code 129 = integer 32;

	      host margaux {
		... # Standard lines, see above
		option swap-path <replaceable>"192.168.4.4:/netswapvolume/netswap"</replaceable>;
		option swap-size <replaceable>64000</replaceable>;
	      }
	    </programlisting>
	    <para>A id&eacute;ia &eacute; que, pelo menos para o cliente FreeBSD, a
	    op&ccedil;&atilde;o c&oacute;digo 128 &eacute; o caminho para o arquivo de troca
	    (swap) do NFS, e a op&ccedil;&atilde;o c&oacute;digo 129 &eacute; o tamanho do 
	    arquivo de troca, em kilobytes.  Vers&otilde;es anteriores do 
	    <command>dhcpd</command> permitiam uma sintaxe 
	    <literal>option option-128 "...</literal>, que parece
	    n&atilde;o mais funcionar.</para>

	    <para>O <filename>/etc/bootptab</filename>, ao inv&eacute;s,
	    usaria a seguinte sintaxe:</para>

	    <para><literal>T128="192.168.4.4:/netswapvolume/netswap":T129=64000
	      </literal></para>
	  </step>

	  <step>
	    <para>No servidor de arquivo de troca (swap), crie o(s)
	    arquivo(s) de troca:</para>
	    <screen>
	      &prompt.root; <userinput>mkdir <replaceable>/netswapvolume/netswap</replaceable></userinput>
	      &prompt.root; <userinput>cd <replaceable>/netswapvolume/netswap</replaceable></userinput>
	      &prompt.root; <userinput>dd if=/dev/zero bs=1024 count=<replaceable>64000</replaceable> of=swap.<replaceable>192.168.4.6</replaceable></userinput>
	      &prompt.root; <userinput>chmod 0600 swap.<replaceable>192.168.4.6</replaceable></userinput>
	    </screen>
	    <para><replaceable>192.168.4.6</replaceable> &eacute; o endere&ccedil;o
	    IP do cliente sem disco.</para>
	  </step>

	  <step>
	    <para>No servidor de arquivo de troca (swap) NFS, adicione
	    a seguinte linha ao <filename>/etc/exports</filename>:</para>
	    <programlisting>
	      <replaceable>/netswapvolume</replaceable>  -maproot=0:10 -alldirs <replaceable>margaux</replaceable>
	    </programlisting>
	    <para>Ent&atilde;o diga ao <application>mountd</application> 
	    para reler o arquivo exports, como acima.</para>
	  </step>
	</procedure>

      </sect3>

      <sect3>
	<title>Casos Diversos</title>

	<sect4>
	  <title>Rodando com um <filename>/usr</filename>
	  Somente-Leitura</title>

	  <indexterm>
	    <primary>diskless operation</primary>
	    <secondary>/usr read-only</secondary>
	  </indexterm>

	    <para>Se esta&ccedil;&atilde;o de trabalho sem disco est&aacute; configurada
	    para rodar X, voc&ecirc; precisar&aacute; ajustar o arquivo de
	    configura&ccedil;&atilde;o xdm, o qual coloca o registro (log) de erros
	    em <filename>/usr</filename>, por padr&atilde;o.</para>
	</sect4>
	<sect4>
	  <title>Usando um Servidor N&atilde;o-FreeBSD</title>

	  <para>Quando o servidor do sistema de arquivo raiz n&atilde;o roda
	  FreeBSD, voc&ecirc; ter&aacute; que criar o sistema de arquivo raiz em
	  uma m&aacute;quina FreeBSD e depois copi&aacute;-lo para seu destino,
	  usando o <command>tar</command> ou <command>cpio</command>.
	  </para>

	  <para>Nesta situa&ccedil;&atilde;o, &agrave;s vezes existem alguns problemas com
	  arquivos especiais em <filename>/dev</filename>, por causa
	  de tamanhos inteiros maior/menor (major/minor) diferentes.
	  A solu&ccedil;&atilde;o para este problema &eacute; exportar um diret&oacute;rio da
	  m&aacute;quina n&atilde;o-FreeBSD para criar as entradas de dispositivos
	  corretas (FreeBSD 5.0 e posteriores usam &man.devfs.5; para
	  alocar n&oacute;s de dispositivos - device nodes -
	  transparentemente para o usu&aacute;rio, executar
	  <command>MAKEDEV</command> nestas vers&otilde;es &eacute; in&uacute;til).</para>

	</sect4>

      </sect3>

    </sect2>
  </sect1>

  <sect1 id="network-isdn">
    <title>Rede Digital de Servi&ccedil;os Integrados - RDSI (ISDN)</title>

    <indexterm>
      <primary>ISDN</primary>
    </indexterm>

    <para>Uma boa fonte de informa&ccedil;&otilde;es sobre a tecnologia e o
    hardware ISDN &eacute; a <ulink url="http://alumni.caltech.edu/~dank/isdn/">
    p&aacute;gina sobre ISDN de Dan Kegel</ulink>.</para>

    <para>Um simples e r&aacute;pido mapa para o ISDN est&aacute; a seguir:</para>

    <itemizedlist>
      <listitem>
	<para>Se voc&ecirc; vive na Europa, pode querer investigar a se&ccedil;&atilde;o
	de placas ISDN.</para>
      </listitem>

      <listitem>
	<para>Se voc&ecirc; estiver planejando usar ISDN primariamente para
	se conectar &agrave; Internet atrav&eacute;s de um Provedor de forma discada
	n&atilde;o permanente, voc&ecirc; pode pode olhar os Adaptadores de
	Terminais.  Assim voc&ecirc; ter&aacute; maior flexibilidade e menos
	problemas se voc&ecirc; trocar de provedores.</para>
      </listitem>

      <listitem>
	<para>Se voc&ecirc; estiver conectando duas Redes Locais ou &agrave;
	Internet com uma conex&atilde;o ISDN dedicada, voc&ecirc; pode considerar a
	op&ccedil;&atilde;o de um roteador/ponte dedicado.</para>
      </listitem>
    </itemizedlist>

    <para>O custo &eacute; um fator significativo na determina&ccedil;&atilde;o de qual
    solu&ccedil;&atilde;o voc&ecirc; vai escolher.  As seguintes op&ccedil;&otilde;es s&atilde;o listadas da
    menos para a mais cara.</para>

    <sect2 id="network-isdn-cards">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Hellmuth</firstname>
	    <surname>Michaelis</surname>
	    <contrib>Contribu&iacute;do por </contrib>
	  </author>
	</authorgroup>
      </sect2info>
      <title>Placas ISDN</title>

      <indexterm>
	<primary>ISDN</primary>
	<secondary>cards</secondary>
      </indexterm>

      <para>A implementa&ccedil;&atilde;o ISDN do FreeBSD suporta somente o padr&atilde;o
      DSS1/Q.931 (ou Euro-ISDN) usando placas passivas.  A partir do
      FreeBSD&nbsp;4.4, algumas placas ativas s&atilde;o suportadas nas quais
      o firmware tamb&eacute;m suporta outros protocolos de sinaliza&ccedil;&atilde;o;
      isto tamb&eacute;m inclui a primeira placa ISDN de Acesso Prim&aacute;rio (Primary
      Rate - PRI) suportada.</para>

      <para>O <application>Isdn4bsd</application> lhe permite conectar
      a outros roteadores ISDN usando IP sobre HDLC ou PPP s&iacute;ncrono:
      tanto usando um kernel contendo PPP com isppp - um driver
      modificado a partir do sppp - ou usando o comando de usu&aacute;rio
      &man.ppp.8;.  Usando o comando &man.ppp.8;, &eacute; poss&iacute;vel agregar
      dois ou mais canais B ISDN.  Uma aplica&ccedil;&atilde;o de secret&aacute;ria
      eletr&ocirc;nica telef&ocirc;nica tamb&eacute;m est&aacute; dispon&iacute;vel, bem como muitos
      utilit&aacute;rios, como um modem de 300 Baud em software.</para>

      <para>Um crescente n&uacute;mero de placas ISDN para PC s&atilde;o suportadas
      pelo FreeBSD e os relatos mostram que ele &eacute; usado com sucesso por
      toda a Europa e em muitas outras partes do mundo.</para>

      <para>As placas ISDN passivas suportadas s&atilde;o na maioria as que
      possuem os chipsets Infineon (anteriormente Siemens) ISAC/HSCX/IPAC,
      mas tamb&eacute;m placas ISDN com chips da Cologne Chip (somente
      barramento ISA), placas PCI com chips Winbond W6692, algumas
      placas com combina&ccedil;&otilde;es do chipset Tiger300/320/ISAC e algumas
      placas com chipsets de fabricantes espec&iacute;ficos como as placas
      AVM Fritz!Card PCI V.1.0 e a AVM Fritz!Card PnP.</para>

      <para>Atualmente as placas ISDN ativas suportadas s&atilde;o as
      AVM B1 (ISA e PCI) e as AVM T1 PCI PRI.</para>

      <para>Para documenta&ccedil;&atilde;o sobre
      <application>isdn4bsd</application>, veja o diret&oacute;rio
      <filename>/usr/share/examples/isdn/</filename> em seu sistema
      FreeBSD ou em <ulink url="http://www.freebsd-support.de/i4b/">
      homepage of isdn4bsd</ulink> que tamb&eacute;m tem ponteiros para
      dicas, erratas e muito mais documenta&ccedil;&atilde;o como o <ulink
      url="http://people.FreeBSD.org/~hm/">isdn4bsd handbook</ulink>.
      </para>

      <para>No caso de voc&ecirc; estar interessado em adicionar suporte
      para um protocolo ISDN diferente, uma placa PC ISDN atualmente
      n&atilde;o suportada ou de alguma forma melhorar o
      <application>isdn4bsd</application>, por favor, entre em contato
      com &a.hm;.</para>

      <para>Para quest&otilde;es referentes &agrave; instala&ccedil;&atilde;o, configura&ccedil;&atilde;o e
      resolu&ccedil;&atilde;o de problemas com <application>isdn4bsd</application>,
      est&aacute; dispon&iacute;vel uma lista de discuss&atilde;o &a.isdn.name;.</para>
    </sect2>

    <sect2>
      <title>Adaptadores de Terminal ISDN</title>

      <para>Adaptadores de Terminal (AT), s&atilde;o para o ISDN o que os
      modems s&atilde;o para as linhas telef&ocirc;nicas normais.</para>
      <indexterm><primary>modem</primary></indexterm>
      <para>A maioria dos ATs usam o conjunto de comandos padr&atilde;o dos
      modems hayes, e podem ser usados como substitutos de modems.</para>

      <para>Um AT vai operar basicamente da mesma forma que um modem
      exceto pelas velocidades de conex&atilde;o e vaz&atilde;o ser&atilde;o muito mais
      r&aacute;pidas que seu antigo modem.  Voc&ecirc; vai precisar configurar o
      <link linkend="ppp">PPP</link> exatamente da mesma forma que
      configura um modem.  Certifique-se de configurar a velocidade
      serial para a maior poss&iacute;vel.</para>
      <indexterm><primary>PPP</primary></indexterm>
      <para>A principal vantagem de usar um AT para conectar a um
      Provedor Internet &eacute; que voc&ecirc; pode usar PPP Din&acirc;mico.  Enquanto o
      espa&ccedil;o de endere&ccedil;amento IP se torna cada vez mais escasso, a
      maioria dos provedores n&atilde;o desejam mais te fornecer um endere&ccedil;o
      IP est&aacute;tico.  A maioria dos roteadores dedicados n&atilde;o s&atilde;o capazes
      de suportar aloca&ccedil;&atilde;o din&acirc;mica de IP.</para>

      <para>ATs contam completamente com o daemon PPP que voc&ecirc; est&aacute;
      executando para suas caracter&iacute;sticas e estabilidade de conex&atilde;o.
      Isto permite a voc&ecirc; facilmente fazer atualiza&ccedil;&atilde;o de usar um modem
      para ISDN em uma m&aacute;quina FreeBSD, se voc&ecirc; j&aacute; possui o PPP
      configurado.  Entretanto, quaisquer problemas que voc&ecirc; j&aacute;
      experimentou com o programa PPP ir&atilde;o persistir.</para>

      <para>Se voc&ecirc; quer estabilidade m&aacute;xima, use a op&ccedil;&atilde;o de kernel
      <link linkend="ppp">PPP</link>, n&atilde;o o
      <link linkend="userppp">iijPPP</link> de contexto de usu&aacute;rio.
      </para>

      <para>&Eacute; sabido que os seguintes ATs funcionam com o FreeBSD.</para>

      <itemizedlist>
	<listitem>
	  <para>Motorola BitSurfer e Bitsurfer Pro</para>
	</listitem>

	<listitem>
	  <para>Adtran</para>
	</listitem>
      </itemizedlist>

      <para>A maioria dos outros ATs provavelmente tamb&eacute;m v&atilde;o
      funcionar, uma vez que os fornecedores de ATs tentam garantir
      que seu produto pode aceitar a maior parte do conjunto de
      comandos padr&atilde;o AT dos modems.</para>

      <para>O verdadeiro problema com os ATs externos &eacute; que, como os
      modems, voc&ecirc; vai precisar de uma boa placa serial em seu
      computador.</para>

      <para>Voc&ecirc; deve ler o tutorial <ulink
      url="../../articles/serial-uart/index.html">FreeBSD Serial
      Hardware</ulink> para uma compreens&atilde;o detalhada dos dispositivos
      seriais e as diferen&ccedil;as entre portas seriais ass&iacute;ncronas e
      s&iacute;ncronas.</para>

      <para>Um AT executando em uma porta serial de um PC padr&atilde;o
      (ass&iacute;ncrona) limita voc&ecirc; a 115.2&nbsp;Kbps, mesmo que voc&ecirc; tenha
      uma conex&atilde;o de 128&nbsp;Kbps. Para utilizar completamente os
      128&nbsp;Kbps que o ISDN &eacute; capaz, voc&ecirc; precisa mover os AT para
      uma placa serial s&iacute;ncrona.</para>

      <para>N&atilde;o fa&ccedil;a a tolice de comprar um AT interno pensando que
      voc&ecirc; evitou o assunto s&iacute;ncrono/ass&iacute;ncrono.  Os ATs internos
      simplesmente possuem um chip de porta serial padr&atilde;o PC
      embutidos.  Tudo que isto far&aacute; &eacute; poup&aacute;-lo de comprar outro cabo
      serial e encontrar outra tomada el&eacute;trica dispon&iacute;vel.</para>

      <para>Uma placa s&iacute;ncrona com um AT &eacute; pelo menos t&atilde;o r&aacute;pida
      quanto um roteador dedicado, e com uma simples caixa 386 com
      FreeBSD gerenciando-a, provavelmente mais flex&iacute;vel.</para>

      <para>A escolha de AT/s&iacute;ncrono ou roteador dedicado &eacute; um amplo
      assunto religioso.  Houve algumas debates sobre isto nas listas
      de discuss&atilde;o.  Eu sugiro que voc&ecirc; busque os <ulink
      url="../../../../search/index.html">arquivos</ulink> para a
      discuss&atilde;o completa.</para>
    </sect2>

    <sect2>
      <title>Roteadores/Pontes Dedicados</title>
      <indexterm>
	<primary>ISDN</primary>
	<secondary>stand-alone bridges/routers</secondary>
      </indexterm>
      <para>Pontes ou roteadores ISDN n&atilde;o s&atilde;o nada espec&iacute;ficos ao
      FreeBSD ou qualquer outro sistema operacional.  Para uma
      descri&ccedil;&atilde;o mais completa da tecnologia de roteamento e liga&ccedil;&atilde;o,
      por favor consulte um livro de refer&ecirc;ncia em Redes de
      Comunica&ccedil;&atilde;o de Dados.</para>

      <para>No contexto desta p&aacute;gina, os termos roteador e ponte ser&atilde;o
      usados de forma intercambi&aacute;vel.</para>

      <para>Enquanto o custo de roteadores/pontes ISDN de poucos
      recursos diminui, tornam-se cada vez mais escolhas populares.
      Um roteador ISDN &eacute; uma pequena caixa que se conecta diretamente
      em sua rede local Ethernet e gerencia sua pr&oacute;pria conex&atilde;o a
      outro roteador/ponte.  Possui embutido software para comunica&ccedil;&atilde;o
      via PPP e outros protocolos populares.</para>

      <para>Um roteador vai lhe permitir vaz&atilde;o muito mais r&aacute;pida que
      um AT padr&atilde;o, uma vez que estar&aacute; usando uma conex&atilde;o ISDN
      totalmente s&iacute;ncrona.</para>

      <para>O principal problema com roteadores e pontes ISDN &eacute; que a
      interoperabilidade entre fabricantes ainda pode ser um problema.
      Se voc&ecirc; estiver planejando se conectar a um provedor Internet,
      voc&ecirc; deve conversar suas necessidades com eles.</para>

      <para>Se voc&ecirc; est&aacute; planejando conectar dois segmentos de Redes
      Locais, como sua Rede Local dom&eacute;stica e a do escrit&oacute;rio, esta &eacute;
      a solu&ccedil;&atilde;o mais simples e de mais baixo custo de manuten&ccedil;&atilde;o.  Uma
      vez que voc&ecirc; est&aacute; adquirindo o equipamento para as duas pontas
      da conex&atilde;o, voc&ecirc; pode estar seguro de que o enlace ir&aacute;
      funcionar.</para>

      <para>Por exemplo, para conectar um computador dom&eacute;stico ou
      rede de escrit&oacute;rio filial &agrave; rede do escrit&oacute;rio principal, a
      seguinte configura&ccedil;&atilde;o pode ser usada.</para>

      <example>
	<title>Escrit&oacute;rio Filial ou Rede Dom&eacute;stica</title>

	<indexterm><primary>10 base 2</primary></indexterm>
	<para>A rede usa uma topologia em barra com Ethernet 10 base 2
	(<quote>thinnet</quote>). Conecte o roteador ao cabo de rede
	com transceptor AUI/10BT, se necess&aacute;rio.</para>

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="advanced-networking/isdn-bus">
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">---Sun workstation
|
---FreeBSD box
|
---Windows 95 (Do not admit to owning it)
|
Stand-alone router
   |
ISDN BRI line</literallayout>
	  </textobject>

	  <textobject>
	    <phrase>Ethernet 10 Base 2</phrase>
	  </textobject>
	</mediaobject>

	<para>Se seu escrit&oacute;rio dom&eacute;stico/filial &eacute; somente um
	computador, voc&ecirc; pode usar um cabo de par tran&ccedil;ado crossover
	para conect&aacute;-lo diretamente ao roteador dedicado.</para>
      </example>

      <example>
	<title>Escrit&oacute;rio Principal ou Outra Rede Local</title>

	<indexterm><primary>10 base T</primary></indexterm>
	<para>A rede usa uma topologia em estrela, com Ethernet 10
	base T (<quote>Par Tran&ccedil;ado</quote>).</para>

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="advanced-networking/isdn-twisted-pair">
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">    -------Servidor Novell
    | H |
    |   ---Sun
    |   |
    | U ---FreeBSD
    |   |
    |   ---Windows 95
    | B |
    |___---roteador dedicado
		|
	Linha ISDN BRI</literallayout>
	  </textobject>

	  <textobject>
	    <phrase>Diagrama de Rede ISDN</phrase>
	  </textobject>
	</mediaobject>
      </example>

      <para>Uma grande vantagem da maioria dos roteadores/pontes &eacute; que
      eles lhe permitem ter 2 conex&otilde;es PPP <emphasis>separadas e
      independentes</emphasis> a 2 s&iacute;tios separados ao
      <emphasis>mesmo</emphasis> tempo.  Isto n&atilde;o &eacute; suportado na
      maioria dos ATs, exceto em modelos espec&iacute;ficos (geralmente
      caros) que possuem duas portas seriais.  N&atilde;o confundir isto com
      agrega&ccedil;&atilde;o de canais, MPP etc.</para>

      <para>Isto pode ser uma caracter&iacute;stica muito &uacute;til se, por
      exemplo, voc&ecirc; possuir uma conex&atilde;o ISDN dedicada em seu
      escrit&oacute;rio e desejar se conectar atrav&eacute;s dela, mas n&atilde;o quer ter
      mais uma linha ISDN no trabalho.  Um roteador no local do
      escrit&oacute;rio pode gerenciar uma conex&atilde;o dedicada de canal B
      (64&nbsp;Kbps) para a Internet e usar o outro canal B para uma
      conex&atilde;o de dados separada.  O segundo canal B pode ser usado
      para receber ou realizar acesso discado ou agrega&ccedil;&atilde;o din&acirc;mica
      (MPP etc.) com o primeiro canal B para obter mais largura de
      banda.</para>

      <indexterm><primary>IPX/SPX</primary></indexterm>
      <para>Uma ponte Ethernet tamb&eacute;m vai lhe permitir transmitir mais
      do que tr&aacute;fego IP.  Voc&ecirc; tamb&eacute;m pode transmitir IPX/SPX ou
      quaisquer outros protocolos que voc&ecirc; usa.</para>
    </sect2>
  </sect1>

  <sect1 id="network-nis">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Bill</firstname>
      	  <surname>Swingle</surname>
	  <contrib>Escrito por </contrib>
	 </author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Eric</firstname>
	  <surname>Ogren</surname>
	  <contrib>Aumentado por </contrib>
	</author>
	<author>
	  <firstname>Udo</firstname>
	  <surname>Erdelhoff</surname>
	</author>
      </authorgroup>
    </sect1info>
    <title>NIS/YP</title>

    <sect2>
      <title>O Que &Eacute;?</title>
      <indexterm><primary>NIS</primary></indexterm>
      <indexterm><primary>Solaris</primary></indexterm>
      <indexterm><primary>HP-UX</primary></indexterm>
      <indexterm><primary>AIX</primary></indexterm>
      <indexterm><primary>Linux</primary></indexterm>
      <indexterm><primary>NetBSD</primary></indexterm>
      <indexterm><primary>OpenBSD</primary></indexterm>
      <para>O NIS, que quer dizer Servi&ccedil;os de Informa&ccedil;&otilde;es de Rede
      (Network Information Services), foi desenvolvido pela Sun
      Microsystems para centralizar a administra&ccedil;&atilde;o de sistemas &unix;
      (originalmente &sunos;).  Ele tornou-se, essencialmente, um
      padr&atilde;o da ind&uacute;stria; todos os maiores sistemas tipo &unix;
      (&solaris;, HP-UX, &aix;, Linux, NetBSD, OpenBSD, FreeBSD etc)
      suportam NIS.</para>

      <indexterm><primary>yellow pages</primary><see>NIS</see></indexterm>
      <para>O NIS era anteriormente conhecido por P&aacute;ginas Amarelas
      (Yellow Pages), mas por causa de quest&otilde;es de marcas registradas,
      a Sun trocou o nome.  O antigo termo (e yp) ainda &eacute; muitas 
      vezes visto e usado.</para>

      <indexterm>
	<primary>NIS</primary>
	<secondary>domains</secondary>
      </indexterm>
      <para>&Eacute; um sistema cliente/servidor baseado em RPC que permite
      a um grupo de m&aacute;quinas dentro de um dom&iacute;nio NIS, compartilhar um
      conjunto comum de arquivos de configura&ccedil;&atilde;o.  Isto permite que um
      administrador de sistemas configure sistemas clientes NIS com um
      m&iacute;nimo de dados de configura&ccedil;&otilde;es a partir de um ponto 
      central.</para>

      <indexterm><primary>Windows NT</primary></indexterm>
      <para>&Eacute; similar ai sistema de dom&iacute;nio do &windowsnt;; apesar da
      implementa&ccedil;&atilde;o interna de ambos n&atilde;o ser nada parecida, a
      funcionalidade b&aacute;sica pode ser comparada.</para>
    </sect2>

    <sect2>
      <title>Termos/Processos Que Voc&ecirc; Deve Saber</title>

      <para>Existem diversos termos e v&aacute;rios processos de usu&aacute;rio
      importantes que voc&ecirc; vai encontrar quando tentar implementar NIS
      no FreeBSD, esteja voc&ecirc; tentando criar um servidor NIS ou
      atuando como um cliente NIS:</para>

      <indexterm>
	<primary><application>portmap</application></primary>
      </indexterm>

      <informaltable>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Termo</entry>
	      <entry>Descri&ccedil;&atilde;o</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Nome de Dom&iacute;nio NIS</entry>
	      <entry>Um servidor mestre NIS e todos os seus clientes
	      (incluindo seus servidores escravos) possuem um nome de
	      dom&iacute;nio NIS.  Similar a um nome de dom&iacute;nio &windowsnt;,
	      o nome de dom&iacute;nio NIS n&atilde;o tem nada a ver com DNS.</entry>
	    </row>
	    <row>
	      <entry>portmap</entry>
	      <entry>Precisa estar rondando para ativar o RPC (Remote
	      Procedure Call, um protocolo de rede usado pelo NIS).
	      Se o <command>portmap</command> n&atilde;o estiver rodando,
	      ser&aacute; imposs&iacute;vel rodar um servidor NIS, ou atuar como um
	      cliente NIS.</entry>
	    </row>
	    <row>
	      <entry>ypbind</entry>

	      <entry><quote>Associa</quote> um cliente NIS a seu
	      servidor.  Vai receber o nome de dom&iacute;nio NIS do sistema
	      e, usando RPC, conectar&aacute; ao servidor.  O 
	      <command>ypbind</command> &eacute; o centro da comunica&ccedil;&atilde;o
	      cliente-servidor em um ambiente NIS; se o
	      <command>ypbind</command> morrer em uma m&aacute;quina
	      cliente, ela n&atilde;o ser&aacute; capaz de acessar o servidor
	      NIS.</entry>
	    </row>
	    <row>
	      <entry>ypserv</entry>
	      <entry>Deve ser rodado somente em servidores NIS; este &eacute;
	      o pr&oacute;prio processo servidor NIS.  Se o &man.ypserv.8;
	      morrer, ent&atilde;o o servidor n&atilde;o ser&aacute; mais capaz de
	      responder a solicita&ccedil;&otilde;es NIS (felizmente, existe um
	      servidor escravo que pode assumir em seu lugar).
	      Existem algumas implementa&ccedil;&otilde;es de NIS (mas n&atilde;o a do
	      FreeBSD), que n&atilde;o tentam reconectar a outro servidor se
	      o servidor anteriormente usado morre.  Freq&uuml;entemente, 
	      a &uacute;nica coisa que ajuda neste caso &eacute; reiniciar o
	      processo servidor (ou mesmo o servidor inteiro) ou o
	      processo <command>ypbind</command> no cliente.</entry>
	    </row>
	    <row>
	      <entry>rpc.yppasswdd</entry>
	      <entry>Outro processo que deve rodar somente nos
	      servidores mestre NIS; este &eacute; um daemon que permitir&aacute;
	      aos clientes NIS mudarem suas senhas NIS.  Se este
	      daemon n&atilde;o estiver rodando, os usu&aacute;rios ter&atilde;o que
	      acessar (fazer login) no servidor mestre NIS e mudar
	      suas senhas nele.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
      <!-- XXX Missing: rpc.ypxfrd (not important, though) May only run
      on the master -->

    </sect2>

    <sect2>
      <title>Como Funciona?</title>

      <para>Existem tr&ecirc;s tipos de sistemas em um ambiente NIS:
      servidores mestre, servidores escravos e clientes.  Servidores
      atuam como reposit&oacute;rios centrais para informa&ccedil;&otilde;es de 
      configura&ccedil;&otilde;es de sistemas.  Servidores mestres guardam a c&oacute;pia
      autoritativa desta informa&ccedil;&atilde;o, enquanto servidores escravos
      espelham estas informa&ccedil;&otilde;es para redund&acirc;ncia.  Clientes contam
      com os servidores para lhes fornecerem estas informa&ccedil;&otilde;es.</para>

      <para>Informa&ccedil;&otilde;es em muitos arquivos podem ser compartilhados
      desta forma.  Os arquivos <filename>master.passwd</filename>,
       <filename>group</filename> e <filename>hosts</filename> s&atilde;o
       normalmente compartilhados via NIS.  Quando um processo em um
       cliente precisa de informa&ccedil;&atilde;o que normalmente seria encontrada
       nestes arquivos localmente, em vez disso, ele faz uma pergunta 
       ao servidor NIS ao qual est&aacute; conectado.</para>

      <sect3>
	<title>Tipos de M&aacute;quinas</title>

	<itemizedlist>
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>master server</secondary>
	  </indexterm>
	  <listitem>
	    <para>Um <emphasis>servidor NIS mestre</emphasis>.  Este
	    servidor, de forma an&aacute;loga a um controlador prim&aacute;rio de
	    dom&iacute;nio &windowsnt;, mant&eacute;m os arquivos usados por todos
	    os clientes NIS.  Os arquivos <filename>passwd</filename>, 
	     <filename>group</filename>, e diversos outros usados
	     pelos clientes NIS residem no servidor NIS mestre.</para>

	    <note><para>&Eacute; poss&iacute;vel para uma m&aacute;quina ser um servidor
	    NIS mestre para mais de um dom&iacute;nio NIS.  Entretanto, isto
	    n&atilde;o ser&aacute; abordado nesta introdu&ccedil;&atilde;o, que assume um ambiente
	    NIS de escala relativamente pequena.</para></note>

	  </listitem>
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>slave server</secondary>
	  </indexterm>
	  <listitem>
	    <para><emphasis>Servidores NIS escravos</emphasis>.
	    Similar aos controladores de dom&iacute;nio secund&aacute;rios do
	    &windowsnt;, o servidores NIS escravos mant&ecirc;m c&oacute;pias dos
	    arquivos de dados do mestre.  Os servidores NIS escravos
	    fornecem redund&acirc;ncia, que &eacute; necess&aacute;ria em ambientes
	    importantes.  Eles tamb&eacute;m ajudam a balancear a carga no
	    servidor mestre: os clientes NIS sempre se conectam ao
	    servidor NIS do qual primeiro receberem uma resposta, e
	    isto inclui as respostas do servidor escravo.</para>
	  </listitem>
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>client</secondary>
	  </indexterm>
	  <listitem>
	    <para><emphasis>Clientes NIS</emphasis>.  Clientes NIS,
	    como a maioria das esta&ccedil;&otilde;es de trabalho &windowsnt; se
	    autenticam contra o servidor NIS (ou o controlador de
	    dom&iacute;nio &windowsnt; no caso de esta&ccedil;&otilde;es de trabalho
	    &windowsnt;) para obterem acesso (log on).</para>
	  </listitem>
	</itemizedlist>
      </sect3>
    </sect2>

    <sect2>
      <title>Usando NIS/YP</title>

      <para>Esta se&ccedil;&atilde;o vai tratar de configurar um ambiente NIS de
      exemplo.</para>

      <note><para>Esta se&ccedil;&atilde;o assume que voc&ecirc; est&aacute; rodando o
      FreeBSD&nbsp;3.3 ou mais recente.  As instru&ccedil;&otilde;es aqui mostradas
      <emphasis>provavelmente</emphasis> funcionar&atilde;o para qualquer
      vers&atilde;o do FreeBSD maior que 3.0, mas n&atilde;o h&aacute; garantias de que
      isto seja verdadeiro.</para></note>

      <sect3>
	<title>Planejamento</title>

	<para>Vamos assumir que voc&ecirc; &eacute; o administrador de um pequeno
	laborat&oacute;rio universit&aacute;rio.  Neste laborat&oacute;rio, que consiste de
	15 m&aacute;quinas FreeBSD, atualmente n&atilde;o h&aacute; ponto centralizado de
	administra&ccedil;&atilde;o; cada m&aacute;quina t&ecirc;m seu pr&oacute;prio
	<filename>/etc/passwd</filename> e 
	<filename>/etc/master.passwd</filename>.  Estes arquivos s&atilde;o
	mantidos em sincronia entre si atrav&eacute;s de interven&ccedil;&otilde;es
	manuais; atualmente, quando voc&ecirc; adiciona um usu&aacute;rio no lab,
	voc&ecirc; precisa rodar <command>adduser</command> em todas as 15
	m&aacute;quinas.  Claramente, isto precisa mudar, ent&atilde;o voc&ecirc; decidiu
	converter o lab para usar NIS, usando duas das m&aacute;quinas como
	servidores.</para>

	<para>Ent&atilde;o, a configura&ccedil;&atilde;o do lab agora parece com algo como:</para>

	<informaltable>
	  <tgroup cols="3">
	    <thead>
	      <row>
		<entry>Nome da m&aacute;quina</entry>
		<entry>Endere&ccedil;o IP</entry>
		<entry>Papel da m&aacute;quina</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry><hostid>ellington</hostid></entry>
		<entry><hostid role="ipaddr">10.0.0.2</hostid></entry>
		<entry>mestre NIS</entry>
	      </row>
	      <row>
		<entry><hostid>coltrane</hostid></entry>
		<entry><hostid role="ipaddr">10.0.0.3</hostid></entry>
		<entry>escravo NIS</entry>
	      </row>
	      <row>
		<entry><hostid>basie</hostid></entry>
		<entry><hostid role="ipaddr">10.0.0.4</hostid></entry>
		<entry>Esta&ccedil;&atilde;o de trabalho da faculdade</entry>
	      </row>
	      <row>
		<entry><hostid>bird</hostid></entry>
		<entry><hostid role="ipaddr">10.0.0.5</hostid></entry>
		<entry>M&aacute;quina cliente</entry>
	      </row>
	      <row>
		<entry><hostid>cli[1-11]</hostid></entry>
		<entry><hostid role="ipaddr">10.0.0.[6-17]</hostid></entry>
		<entry>Outras m&aacute;quinas clientes</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>Se voc&ecirc; est&aacute; configurando um esquema NIS pela primeira
	vez, &eacute; uma boa id&eacute;ia pensar muito bem como voc&ecirc; quer fazer.
	N&atilde;o importa qual o tamanho da sua rede, existem algumas poucas
	decis&otilde;es que precisam ser tomadas.</para>

	<sect4>
	  <title>Escolhendo um Nome de Dom&iacute;nio NIS</title>

	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>domainname</secondary>
	  </indexterm>
	  <para>Isto pode n&atilde;o ser o <quote>nome de dom&iacute;nio</quote> 
	  com o qual voc&ecirc; est&aacute; acostumado.  Ele &eacute; mais corretamente
	  chamado de <quote>nome de dom&iacute;nio NIS</quote>.  Quando um
	  cliente anuncia suas solicita&ccedil;&otilde;es por informa&ccedil;&otilde;es via 
	  broadcasts, ele inclui o nome do dom&iacute;nio NIS ao qual
	  pertence.  Assim &eacute; como m&uacute;ltiplos servidores em uma rede
	  podem saber qual deve responder qual solicita&ccedil;&atilde;o.  Pense no
	  nome de dom&iacute;nio NIS como o nome de um grupo de sistemas
	  relacionados de alguma forma.</para>


	  <para>Algumas organiza&ccedil;&otilde;es escolhem usar seu nome de dom&iacute;nio
	  Internet para ser seu nome de dom&iacute;nio NIS.  Isto n&atilde;o &eacute;
	  recomendado porque pode confundir ao se tentar resolver
	  problemas de rede.  O nome de dom&iacute;nio NIS deve ser &uacute;nico
	  dentro de sua rede e &eacute; &uacute;til que descreva o grupo de m&aacute;quinas
	  que representa.  Por exemplo, o departamento  de Arte da
	  Acme Ltda. pode estar no dom&iacute;nio NIS 
	  <quote>acme-arte</quote>. Para este exemplo, assuma que voc&ecirc;
	  escolheu o nome <emphasis>dom&iacute;nio-teste</emphasis>.</para>

	  <indexterm><primary>SunOS</primary></indexterm>
	  <para>Entretanto, alguns sistemas operacionais (notadamente
	  o &sunos;) usam seu nome de dom&iacute;nio NIS como seu nome de
	  dom&iacute;nio Internet.  Se uma ou mais m&aacute;quinas em sua rede
	  possuem esta restri&ccedil;&atilde;o, voc&ecirc; <emphasis>precisa</emphasis>  
	  usar o nome de dom&iacute;nio Internet como seu nome de dom&iacute;nio
	  NIS.</para>

	</sect4>

	<sect4>
	  <title>Requerimentos F&iacute;sicos do Servidor</title>

	  <para>Existem diversas coisas a serem mantidas em mente quando
	  se for escolher uma m&aacute;quina para usar como servidor NIS.
	  Uma das infelicidades do NIS &eacute; o n&iacute;vel de depend&ecirc;ncia
	  que os clientes t&ecirc;m do servidor.  Se um cliente n&atilde;o puder
	  fazer contato com o servidor de seu dom&iacute;nio NIS, muito
	  freq&uuml;entemente a m&aacute;quina se torna inutilizada.  A falta de
	  informa&ccedil;&otilde;es de usu&aacute;rios e grupos causa congelamento na 
	  maioria dos sistemas.  Com isto em mente, voc&ecirc; deve se
	  certificar de escolher uma m&aacute;quina que n&atilde;o estar&aacute; sujeita a
	  ser reinicializada regularmente, ou uma que pode ser usada
	  para desenvolvimento.  O servidor NIS idealmente deve ser
	  uma m&aacute;quina isolada, cujo &uacute;nico prop&oacute;sito na vida &eacute; ser um
	  servidor NIS.  Se voc&ecirc; tem uma rede que n&atilde;o &eacute; pesadamente
	  utilizada, &eacute; aceit&aacute;vel colocar o servidor NIS em uma m&aacute;quina
	  rodando outros servi&ccedil;os, apenas tenha em mente que se o
	  servidor NIS se tornar indispon&iacute;vel, afetar&aacute; adversamente
	  <emphasis>todos</emphasis> os clientes NIS.</para>

	</sect4>
      </sect3>

      <sect3>
	<title>Servidores NIS</title>

	<para>As c&oacute;pias can&ocirc;nicas de todas as informa&ccedil;&otilde;es NIS s&atilde;o
	armazenadas em uma &uacute;nica m&aacute;quina chamada servidor NIS mestre.
	As bases de dados usadas para armazenar as informa&ccedil;&otilde;es s&atilde;o
	chamadas de mapas NIS.  No FreeBSD, estes mapas s&atilde;o
	armazenados em <filename>/var/yp/[dom&iacute;nio]</filename> onde 
	<filename>[dom&iacute;nio]</filename> &eacute; o nome de dom&iacute;nio NIS sendo
	servido.  Um &uacute;nico servidor NIS pode suportar diversos
	dom&iacute;nios de uma vez, ent&atilde;o &eacute; poss&iacute;vel ter diversos dom&iacute;nios
	destes diret&oacute;rios, um para cada dom&iacute;nio suportado.  Cada
	dom&iacute;nio ter&aacute; seu pr&oacute;prio conjunto independente de mapas.</para>

	<para>Os servidores mestre e escravo NIS tratam de todas as
	solicita&ccedil;&otilde;es NIS com o daemon <command>ypserv</command>.  O 
	<command>ypserv</command> &eacute; respons&aacute;vel por receber
	solicita&ccedil;&otilde;es entrantes dos clientes NIS, traduzindo o dom&iacute;nio
	solicitado e mapeando o nome a um caminho para o arquivo de 
	banco de dados correspondente e transmitindo dados da base de
	volta para o cliente.</para>

	<sect4>
	  <title>Configurando Um Servidor NIS Mestre</title>
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>server configuration</secondary>
	  </indexterm>
	  <para>Configurar um servidor NIS mestre pode ser
	  relativamente simples, dependendo de suas necessidades.  O
	  FreeBSD possui suporte nativo para NIS.  Tudo que voc&ecirc;
	  precisa &eacute; adicionar as seguintes linhas ao
	  <filename>/etc/rc.conf</filename>, e o FreeBSD ir&aacute; fazer o
	  resto para voc&ecirc;.</para>

	  <procedure>
	    <step>
	      <para><programlisting>nisdomainname="dominio-teste"</programlisting>
	      Esta linha vai configurar o nome de dom&iacute;nio NIS para 
	      <emphasis>dominio-teste</emphasis> na configura&ccedil;&atilde;o de
	      rede (p.ex. depois de uma inicializa&ccedil;&atilde;o).</para>
	    </step>
	    <step>
	      <para><programlisting>nis_server_enable="YES"</programlisting>
	      Isto dir&aacute; ao FreeBSD para iniciar os processos
	      servidores NIS quando a rede for a pr&oacute;xima a ser
	      ativada.</para>
	    </step>
	    <step>
	      <para><programlisting>nis_yppasswdd_enable="YES"</programlisting>
	      Isto vai ativar o daemon <command>rpc.yppasswdd</command>
	       que, como mencionado acima, permitir&aacute; aos usu&aacute;rios
	       mudarem suas senhas NIS a partir de uma m&aacute;quina
	       cliente.</para>
	    </step>
	  </procedure>

	  <note>
	    <para>Dependendo de sua configura&ccedil;&atilde;o NIS, voc&ecirc; pode
	    precisar incluir entradas adicionais.  Veja a 
	    <link linkend="network-nis-server-is-client">se&ccedil;&atilde;o 
	    sobre servidores NIS que tamb&eacute;m s&atilde;o clientes NIS</link>, 
	    abaixo, para detalhes.</para>
	  </note>

	  <para>Agora, tudo que voc&ecirc; precisa fazer &eacute; rodar o comando
	  <command>/etc/netstart</command> como superusu&aacute;rio.  Ele ir&aacute;
	  configurar tudo para voc&ecirc;, usando os valores que voc&ecirc;
	  definiu no <filename>/etc/rc.conf</filename>.</para>
	</sect4>

	<sect4>
	  <title>Inicializando os Mapas NIS</title>
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>maps</secondary>
	  </indexterm>
	  <para>Os <emphasis>mapas NIS</emphasis> s&atilde;o arquivos de
	  bancos de dados, mantidos no diret&oacute;rio 
	  <filename>/var/yp</filename>.  Eles s&atilde;o gerados de arquivos
	  de configura&ccedil;&atilde;o no diret&oacute;rio <filename>/etc</filename> do 
	  servidor NIS mestre, com uma exce&ccedil;&atilde;o: o arquivo 
	  <filename>/etc/master.passwd</filename>.  Isto &eacute; por uma boa
	  raz&atilde;o;  voc&ecirc; n&atilde;o quer propagar senhas de sua conta
	  <username>root</username> e de outras contas administrativas
	  para todos os servidores no dom&iacute;nio NIS.  Ent&atilde;o, antes de
	  inicializar os mapas NIS, voc&ecirc; deve:</para>

	  <screen>&prompt.root; <userinput>cp /etc/master.passwd /var/yp/master.passwd</userinput>
&prompt.root; <userinput>cd /var/yp</userinput>
&prompt.root; <userinput>vi master.passwd</userinput></screen>

	  <para>Voc&ecirc; deve remover todas as entradas referentes a
	  contas de sistema (<username>bin</username>, 
	  <username>tty</username>, <username>kmem</username>,
	  <username>games</username> etc), bem como quaisquer contas
	  que voc&ecirc; n&atilde;o quer que sejam propagadas aos clientes NIS
	  (por exemplo, <username>root</username> e qualquer outra
	  conta com UID 0 (superusu&aacute;rio).</para>

	  <note><para>Tenha certeza de que o arquivo 
	  <filename>/var/yp/master.passwd</filename> n&atilde;o pode ser
	  acessado por grupo (group) ou pelo mundo (world) (modo 600)!
	  Use o comando <command>chmod</command>, se necess&aacute;rio.</para>
	  </note>

	  <indexterm><primary>Tru64 UNIX</primary></indexterm>
	  <para>Quando voc&ecirc; tiver terminado, &eacute; hora de inicializar os
	  mapas NIS! O FreeBSD inclui um script chamado 
	  <command>ypinit</command> para fazer isto por voc&ecirc; (veja sua
	  p&aacute;gina de manual para mais informa&ccedil;&otilde;es).  Note que este
	  script est&aacute; dispon&iacute;vel na maioria dos Sistemas Operacionais
	  UNIX, mas n&atilde;o em todos.  No UNIX Digital UNIX/Compaq Tru64 &eacute;
	  chamado <command>ypsetup</command>.  Porque estamos gerando
	  mapas para um mestre NIS, estamos passando a op&ccedil;&atilde;o 
	  <option>-m</option> ao <command>ypinit</command>.  Para
	  gerar estes mapas NIS, assumindo que voc&ecirc; j&aacute; executou os
	  passos acima, rode:</para>

	  <screen>ellington&prompt.root; <userinput>ypinit -m dominio-teste</userinput>
Server Type: MASTER Domain: dominio-teste
Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.
Do you want this procedure to quit on non-fatal errors? [y/n: n] <userinput>n</userinput>
Ok, please remember to go back and redo manually whatever fails.
If you don't, something might not work.
At this point, we have to construct a list of this domains YP servers.
rod.darktech.org is already known as master server.
Please continue to add any slave servers, one per line.  When you are
done with the list, type a &lt;control D&gt;.
master server   :  ellington
next host to add:  <userinput>coltrane</userinput>
next host to add:  <userinput>^D</userinput>
The current list of NIS servers looks like this:
ellington
coltrane
Is this correct?  [y/n: y] <userinput>y</userinput>

[..output from map generation..]

NIS Map update completed.
ellington has been setup as an YP master server without any errors.</screen>

	  <para>O <command>ypinit</command> deve ter criado 
	  <filename>/var/yp/Makefile</filename> do 
	  <filename>/var/yp/Makefile.dist</filename>.  Quando criado,
	  este arquivo assume que voc&ecirc; est&aacute; operando em um ambiente de
	  servidor &uacute;nico, somente com m&aacute;quinas FreeBSD.  Uma vez que 
	  o <emphasis>dominioi-teste</emphasis>tamb&eacute;m tem um servidor
	  escravo, voc&ecirc; precisa editar o 
	  <filename>/var/yp/Makefile</filename>:</para>

	  <screen>ellington&prompt.root; <userinput>vi /var/yp/Makefile</userinput></screen>

	  <para>Voc&ecirc; deve comentar a linha que diz</para>

	  <programlisting>NOPUSH = "True"</programlisting>

	  <para>(se ainda n&atilde;o estiver comentada).</para>
	</sect4>

	<sect4>
	  <title>Configurando um Servidor NIS Escravo</title>
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>slave server</secondary>
	  </indexterm>
	  <para>configurando um servidor NIS escravo &eacute; ainda mais
	  simples que configurar o mestre.  Acesse o servidor escravo
	  e edite o arquivo <filename>/etc/rc.conf</filename> como fez
	  anteriormente.  A &uacute;nica diferen&ccedil;a &eacute; que agora precisamos
	  usar a op&ccedil;&atilde;o <option>-s</option> quando rodarmos o 
	  <command>ypinit</command>.  A op&ccedil;&atilde;o <option>-s</option> 
	  requer que o nome do mestre NIS tamb&eacute;m lhe seja passada, de
	  forma que nossa linha de comando fique parecida com 
	  esta:</para>

  <screen>coltrane&prompt.root; <userinput>ypinit -s ellington dominio-teste</userinput>

Server Type: SLAVE Domain: dominio-teste Master: ellington

Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.

Do you want this procedure to quit on non-fatal errors? [y/n: n]  <userinput>n</userinput>

Ok, please remember to go back and redo manually whatever fails.
If you don't, something might not work.
There will be no further questions.  The remainder of the procedure
should take a few minutes, to copy the databases from ellington.
Transferring netgroup...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byuser...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byhost...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring group.bygid...
ypxfr: Exiting: Map successfully transferred
Transferring group.byname...
ypxfr: Exiting: Map successfully transferred
Transferring services.byname...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.byname...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.byname...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring netid.byname...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring ypservers...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byname...
ypxfr: Exiting: Map successfully transferred

coltrane has been setup as an YP slave server without any errors.
Don't forget to update map ypservers on ellington.</screen>

	  <para>Agora voc&ecirc; deve ter um diret&oacute;rio chamado 
	  <filename>/var/yp/dominio-teste</filename>.  C&oacute;pias dos
	  mapas do servidor mestre NIS devem estar neste diret&oacute;rio.
	  Voc&ecirc; vai precisar estar certo de que estes sejam mantidos
	  atualizados.  As seguintes entradas no 
	  <filename>/etc/crontab</filename> dos servidores escravos
	  devem resolver:</para>

	  <programlisting>20      *       *       *       *       root   /usr/libexec/ypxfr passwd.byname
21      *       *       *       *       root   /usr/libexec/ypxfr passwd.byuid</programlisting>

	  <para>Estas duas linhas for&ccedil;am o escravo a sincronizar seus
	  mapas com os mapas do servidor mestre.  Apesar destas
	  entradas n&atilde;o serem obrigat&oacute;rias, uma vez que o servidor
	  mestre tenta garantir que quaisquer mudan&ccedil;as aos seus mapas
	  NIS sejam comunicadas aos seus escravos e porque a
	  informa&ccedil;&atilde;o de senhas &eacute; vital para os sistemas dependentes do
	  servidor, &eacute; uma boa id&eacute;ia for&ccedil;ar as atualiza&ccedil;&otilde;es.  Isto &eacute;
	  mais importantes em redes com alta utiliza&ccedil;&atilde;o, onde
	  atualiza&ccedil;&otilde;es de mapas podem nem sempre ser completadas.</para>

	  <para>Agora, rode o comando <command>/etc/netstart</command> 
	  tamb&eacute;m no servidor escravo, o qual reinicia o servidor NIS.</para>
	</sect4>
      </sect3>

      <sect3>
	<title>clientes NIS</title>

	<para>Um cliente NIS estabelece o que &eacute; chamado de uma 
	associa&ccedil;&atilde;o (ou liga&ccedil;&atilde;o) a um servidor NIS espec&iacute;fico, usando
	o  daemon <command>ypbind</command>.  O 
	<command>ypbind</command> verifica o dom&iacute;nio padr&atilde;o do sistema
	(como configurado pelo comando <command>domainname</command>),
	e come&ccedil;a a fazer difus&atilde;o (envio de broadcasts) de solicita&ccedil;&otilde;es
	RPC na rede local.  Estas solicita&ccedil;&otilde;es especificam o nome do
	dom&iacute;nio para o qual o <command>ypbind</command> est&aacute; tentando
	estabelecer uma associa&ccedil;&atilde;o.  Se um servidor que foi
	configurado para atender &agrave;s solicita&ccedil;&otilde;es receber um dos
	broadcasts, ele responder&aacute; ao <command>ypbind</command>, que
	vai gravar o endere&ccedil;o do servidor.  Se existirem diversos
	servidores dispon&iacute;veis (um mestre e diversos escravos, por
	exemplo), o <command>ypbind</command> vai usar o endere&ccedil;o do
	primeiro que lhe responder.  Deste ponto em diante, o sistema
	cliente vai direcionar todas as suas solicita&ccedil;&otilde;es NIS para
	aquele servidor.  O <command>ypbind</command> ir&aacute;
	ocasionalmente fazer <quote>ping</quote> no servidor para
	certificar-se de que ele est&aacute; ativo e operando.  Se houver
	falha na recep&ccedil;&atilde;o de uma resposta a um dos pings dentro de um
	per&iacute;odo razo&aacute;vel de tempo, o <command>ypbind</command>
	marcar&aacute; o dom&iacute;nio como desassociado (unbound) e vai come&ccedil;ar
	novamente a fazer difus&atilde;o na esperan&ccedil;a de localizar outro
	servidor.</para>

	<sect4>
	  <title>Configurando Um Cliente NIS</title>
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>client configuration</secondary>
	  </indexterm>
	  <para>Configurando uma m&aacute;quina FreeBSD para ser um cliente
	  NIS &eacute; bastante simples.</para>

	  <procedure>
	    <step>
	      <para>Edite o arquivo <filename>/etc/rc.conf</filename> e
	      adicione as seguintes linhas para configurar o nome de
	      dom&iacute;nio NIS e inicie o <command>ypbind</command> durante
	      a inicializa&ccedil;&atilde;o da rede:</para>

	      <programlisting>nisdomainname="dominio-teste"
nis_client_enable="YES"</programlisting>
	    </step>

	    <step>
	      <para>Para importar todas as poss&iacute;veis entradas de
	      senhas do servidor NIS, remova todas as contas de
	      usu&aacute;rios de seu arquivo 
	      <filename>/etc/master.passwd</filename> e use o 
	      <command>vipw</command> para adicionar a seguinte linha
	      ao final do arquivo:</para>

	      <programlisting>+:::::::::</programlisting>

	      <note>
		<para>Esta linha ir&aacute; proporcionar uma conta a qualquer 
		um com uma conta v&aacute;lida nos mapas do servidor NIS.  
		Existem muitas formas de configurar seu cliente NIS
		alterando esta linha.  Veja a <link
		linkend="network-netgroups">se&ccedil;&atilde;o netgroups</link> 
		abaixo para mais informa&ccedil;&otilde;es.  Para leitura mais
		detalhada veja o livro da O'Reilly sobre 
		<literal>Gerenciando NFS e NIS (Managing NFS and 
		NIS)</literal>.</para>
	      </note>

	      <note>
		<para>Voc&ecirc; deve manter pelo menos uma conta local
		(p.ex. n&atilde;o importada via NIS) em seu
		<filename>/etc/master.passwd</filename> e esta conta
		tamb&eacute;m deve ser membro do grupo
		<groupname>wheel</groupname>.  Se acontecer algo
		errado com o NIS, esta conta pode ser usada para
		acessar remotamente, tornar-se root, e fazer
		manuten&ccedil;&otilde;es.</para>
	      </note>
	    </step>

	    <step>
	      <para>Para importar todos as poss&iacute;veis entradas de
	      grupos do servidor NIS, adicione esta linha ao seu
	      arquivo <filename>/etc/group</filename>:</para>

	      <programlisting>+:*::</programlisting>
	    </step>
	  </procedure>

	  <para>Ap&oacute;s completar estes passos, voc&ecirc; deve ser capaz de
	  rodar <command>ypcat passwd</command> e ver o mapa de senhas
	  do servidor NIS.</para>
	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Seguran&ccedil;a do NIS</title>

      <para>Em geral, qualquer usu&aacute;rio remoto pode emitir uma RPC
      ao &man.ypserv.8; e recuperar os conte&uacute;dos dos mapas NIS, desde
      que os usu&aacute;rios remotos saibam o nome do dom&iacute;nio.  Para evitar 
      tais transa&ccedil;&otilde;es n&atilde;o-autorizadas, o &man.ypserv.8; suporta uma
      caracter&iacute;stica chamada securenets que pode ser usada para
      restringir acesso a um conjunto de sistemas.  Na inicializa&ccedil;&atilde;o,
      o &man.ypserv.8; ir&aacute; tentar carregar as informa&ccedil;&otilde;es de
      securenets de um arquivo chamado 
      <filename>/var/yp/securenets</filename>.</para>

      <note>
	<para>Este caminho varia dependendo do caminho especificado
	com a op&ccedil;&atilde;o <option>-p</option>.  Este arquivo contem entradas
	que consistem na especifica&ccedil;&atilde;o da rede e de uma m&aacute;scara de
	rede separadas por um espa&ccedil;o em branco.  Linhas iniciando com
	<quote>#</quote> s&atilde;o consideradas coment&aacute;rios.  Um arquivo
	securenets de amostra se parece com este:</para>
      </note>

      <programlisting># permite conexoes do sistema local -- obrigatorio
127.0.0.1     255.255.255.255
# permite conex&otilde;es de qualquer sistema
# na rede 192.168.128.0 
192.168.128.0 255.255.255.0
# permite conex&otilde;es de qualquer sistema
# entre 10.0.0.0 e 10.0.15.255
# isto inclui as m&aacute;quinas no laborat&oacute;rio de testes
10.0.0.0      255.255.240.0</programlisting>

      <para>Se o &man.ypserv.8; receber uma solicita&ccedil;&atilde;o de um endere&ccedil;o
      que se enquadra (match) a uma destas regras, ele ir&aacute; processar a
      solicita&ccedil;&atilde;o normalmente.  Se o endere&ccedil;o falhar em se enquadrar 
      a uma das regras, a solicita&ccedil;&atilde;o ser&aacute; ignorada e uma mensagem de
      alerta ser&aacute; registrada.  Se o arquivo 
      <filename>/var/yp/securenets</filename> n&atilde;o existir, o 
      <command>ypserv</command> permitir&aacute; conex&otilde;es vindas de qualquer
      sistema.</para>

      <para>O programa <command>ypserv</command> tamb&eacute;m tem suporte ao
      pacote <application>tcpwrapper</application> de Wietse Venema.
      Isto permite ao administrador utilizar os arquivos de
      configura&ccedil;&atilde;o do <application>tcpwrapper</application> para 
      controle de acesso, ao inv&eacute;s do 
      <filename>/var/yp/securenets</filename>.</para>

      <note>
	<para>Enquanto ambos os mecanismos de controle fornecem alguma
	seguran&ccedil;a, eles, como o teste de porta privilegiada, est&atilde;o
	vulner&aacute;veis a ataques de <quote>falsifica&ccedil;&atilde;o de IP (IP
	spoofing)</quote>.  Todo o tr&aacute;fego relativo a NIS deve ser
	bloqueado em seu firewall.</para>

	<para>Servidores usando <filename>/var/yp/securenets</filename> 
	podem falhar em atender clientes NIS leg&iacute;timos com
	implementa&ccedil;&otilde;es arcaicas de TCP/IP.  Algumas destas
	implementa&ccedil;&otilde;es configuram todos os bits de sistemas (hosts) 
	para zero quando fazem difus&atilde;o (broadcasts) e/ou falham em
	observar a m&aacute;scara de subrede quando calculam o endere&ccedil;o de
	broadcast.  Enquanto alguns destes problemas podem ser
	consertados mudando a configura&ccedil;&atilde;o do cliente, outros
	problemas podem for&ccedil;ar a aposentadoria dos sistemas clientes
	em quest&atilde;o ou o abandono do 
	<filename>/var/yp/securenets</filename>.</para>

	<para>Usando <filename>/var/yp/securenets</filename> em um
	servidor com tal implementa&ccedil;&atilde;o arcaica de TCP/IP &eacute; realmente
	uma m&aacute; id&eacute;ia e levar&aacute; &agrave; perda de funcionalidade NIS para
	grandes partes de sua rede.</para>

	<indexterm><primary>tcpwrapper</primary></indexterm>
	<para>O uso do pacote <application>tcpwrapper</application>
	aumenta a lat&ecirc;ncia no seu servidor NIS.  O retardo (delay)
	adicional pode ser longo o suficiente para causar expira&ccedil;&atilde;o 
	em programas clientes, especialmente em rede congestionadas ou
	com servidores NIS lentos.  Se um ou mais de seus sistemas
	clientes sofrerem destes sintomas, voc&ecirc; deve converter os
	sistemas em quest&atilde;o em servidores NIS escravos e for&ccedil;&aacute;-los a
	associarem-se a si pr&oacute;prios.</para>
      </note>
    </sect2>

    <sect2>
      <title>Impedindo Alguns Usu&aacute;rios de Fazer Log On</title>

      <para>Em nosso lab, h&aacute; uma m&aacute;quina <hostid>basie</hostid> que &eacute;
      suposta para ser uma esta&ccedil;&atilde;o de trabalho somente de professores.  
      N&atilde;o queremos retirar esta m&aacute;quina do dom&iacute;nio NIS, ainda assim, o
      arquivo <filename>passwd</filename> no servidor NIS mestre
      contem contas para ambos professores e alunos.  O que podemos
      fazer?</para>

      <para>H&aacute; uma forma de impedir usu&aacute;rios espec&iacute;ficos de acessarem
      uma m&aacute;quina, mesmo que estejam presentes na base de dados NIS.
      Para isto, tudo o que voc&ecirc; precisa fazer &eacute; adicionar 
      <emphasis>-<replaceable>nome_usuario</replaceable></emphasis> 
      ao final do arquivo <filename>/etc/master.passwd</filename> na 
      m&aacute;quina cliente, onde <replaceable>nome_usuario</replaceable> 
      &eacute; o nome de usu&aacute;rio do usu&aacute;rio que voc&ecirc; deseja impedir de
      acessar o sistema.  Isto deve ser preferivelmente feito usando o 
      <command>vipw</command>, uma vez que o 
      <command>vipw</command> ir&aacute; verificar suas altera&ccedil;&otilde;es no 
      <filename>/etc/master.passwd</filename>, bem como
      automaticamente reconstruir a base de dados de senhas quando
      voc&ecirc; terminar a edi&ccedil;&atilde;o.  Por exemplo, se n&oacute;s quisermos impedir o
      usu&aacute;rio <emphasis>bill</emphasis> de acessar 
      <hostid>basie</hostid> faremos:</para>

	<screen>basie&prompt.root; <userinput>vipw</userinput>
<userinput>[adcionar -bill ao final, e sair]</userinput>
vipw: rebuilding the database...
vipw: done

basie&prompt.root; <userinput>cat /etc/master.passwd</userinput>

root:[password]:0:0::0:0:The super-user:/root:/bin/csh
toor:[password]:0:0::0:0:The other super-user:/root:/bin/sh
daemon:*:1:1::0:0:Owner of many system processes:/root:/sbin/nologin
operator:*:2:5::0:0:System &:/:/sbin/nologin
bin:*:3:7::0:0:Binaries Commands and Source,,,:/:/sbin/nologin
tty:*:4:65533::0:0:Tty Sandbox:/:/sbin/nologin
kmem:*:5:65533::0:0:KMem Sandbox:/:/sbin/nologin
games:*:7:13::0:0:Games pseudo-user:/usr/games:/sbin/nologin
news:*:8:8::0:0:News Subsystem:/:/sbin/nologin
man:*:9:9::0:0:Mister Man Pages:/usr/share/man:/sbin/nologin
bind:*:53:53::0:0:Bind Sandbox:/:/sbin/nologin
uucp:*:66:66::0:0:UUCP pseudo-user:/var/spool/uucppublic:/usr/libexec/uucp/uucico
xten:*:67:67::0:0:X-10 daemon:/usr/local/xten:/sbin/nologin
pop:*:68:6::0:0:Post Office Owner:/nonexistent:/sbin/nologin
nobody:*:65534:65534::0:0:Unprivileged user:/nonexistent:/sbin/nologin
+:::::::::
-bill

basie&prompt.root;</screen>
    </sect2>

    <sect2 id="network-netgroups">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Udo</firstname>
	    <surname>Erdelhoff</surname>
	    <contrib>Contribu&iacute;do por </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Usando Netgroups</title>
      <indexterm><primary>netgroups</primary></indexterm>

      <para>O m&eacute;todo mostrado na se&ccedil;&atilde;o anterior funciona razoavelmente
      bem se voc&ecirc; precisa de regras especiais para uma pequena
      quantidade de usu&aacute;rios e/ou m&aacute;quinas.  Em redes maiores, voc&ecirc;
      <emphasis>vai</emphasis> esquecer de bloquear alguns usu&aacute;rios
      de acessarem m&aacute;quinas sens&iacute;veis, ou pode at&eacute; ter que modificar
      cada m&aacute;quina separadamente, perdendo assim, o maior benef&iacute;cio do
      NIS, a administra&ccedil;&atilde;o <emphasis>centralizada</emphasis>.</para>

      <para>A solu&ccedil;&atilde;o dos desenvolvedores do NIS para este problema &eacute;
      chamada de <emphasis>netgroups</emphasis>.  Seu prop&oacute;sito e
      sem&acirc;ntica podem ser comparados aos grupos normais usados pelos
      sistemas de arquivos &unix;.  As principais diferen&ccedil;as s&atilde;o uma
      falta de id num&eacute;rico e a capacidade de definir um netgoup
      incluindo tanto contas de usu&aacute;rios e outros netgroups.</para>

      <para>Os netgroups foram desenvolvidos para lidar com redes
      grandes e complexas, com centenas de usu&aacute;rios e m&aacute;quinas.  Por
      um lado, isto &eacute; uma Coisa Boa, se voc&ecirc; &eacute; for&ccedil;ado a lidar com tal
      situa&ccedil;&atilde;o.  Por outro lado, esta complexidade torna quase
      imposs&iacute;vel explicar netgroups com exemplos realmente simples.  O
      exemplo usado no restante desta se&ccedil;&atilde;o demonstra este 
      problema.</para>

      <para>Vamos assumir que sua introdu&ccedil;&atilde;o bem sucedida ao NIS em
      laborat&oacute;rio chamou a aten&ccedil;&atilde;o de seus superiores.  Seu pr&oacute;ximo
      trabalho ser&aacute; estender seu dom&iacute;nio NIS para cobrir algumas
      outras m&aacute;quinas no campus.  As duas tabelas cont&ecirc;m os nomes dos
      novos usu&aacute;rios, bem como novas m&aacute;quinas e breve descri&ccedil;&otilde;es 
      delas.</para>

      <informaltable>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Nome(s) de Usu&aacute;rio(s)</entry>
	      <entry>Descri&ccedil;&Atilde;o</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>alpha, beta</entry>
	      <entry>Empregados normais do departamento de TI</entry>
	    </row>

	    <row>
	      <entry>charlie, delta</entry>
	      <entry>Os novos aprendizes do departamento de TI</entry>
	    </row>

	    <row>
	      <entry>echo, foxtrott, golf, ...</entry>
	      <entry>Funcion&aacute;rios comuns</entry>
	    </row>

	    <row>
	      <entry>able, baker, ...</entry>
	      <entry>Os atuais estagi&aacute;rios</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <informaltable>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Nomes das M&aacute;quina(s)</entry>
	      <entry>Descri&ccedil;&atilde;o</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <!--  Names taken from "Good Omens" by Neil Gaiman and Terry
		    Pratchett.  Many thanks for a brilliant book.  -->
	      <entry>war, death, famine, pollution</entry>
	      <entry>Seus servidores mais importantes.  Somente os
	      funcion&aacute;rios de TI t&ecirc;m permiss&atilde;o para acessar estas
	      m&aacute;quinas.</entry>
	    </row>
	    <row>
	      <!-- gluttony was omitted because it was too fat -->
	      <entry>pride, greed, envy, wrath, lust, sloth</entry>
	      <entry>Servidores menos importantes.  Todos os membros
	      do departamento de TI t&ecirc;m permiss&atilde;o de acesso nestes
	      servidores.</entry>
	    </row>

	    <row>
	      <entry>one, two, three, four, ...</entry>
	      <entry>Esta&ccedil;&otilde;es de trabalho ordin&aacute;rias.  Somente os
	      funcion&aacute;rios <emphasis>reais</emphasis> t&ecirc;m permiss&atilde;o
	      para usar estas m&aacute;quinas.</entry>
	    </row>

	    <row>
	      <entry>trashcan</entry>
	      <entry>Uma m&aacute;quina muito velha, sem qualquer dado
	      cr&iacute;tico.  Mesmo o residente pode acessar esta m&aacute;quina.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Se voc&ecirc; tentasse implementar estas restri&ccedil;&otilde;es
      separadamente bloqueando cada usu&aacute;rio, voc&ecirc; teria que adicionar
      uma linha -<replaceable>usu&aacute;rio</replaceable> no 
      <filename>passwd</filename> de cada sistema, para cada usu&aacute;rio
      que n&atilde;o est&aacute; permitido acessar &agrave;quele sistema.  Se voc&ecirc; esquecer
      apenas uma entrada, voc&ecirc; pode estar em apuros.  Pode ser vi&aacute;vel
      fazer isto corretamente durante a configura&ccedil;&atilde;o inicial,
      entretanto, voc&ecirc; eventualmente <emphasis>vai</emphasis> 
      esquecer de adicionar linhas para novos usu&aacute;rios durante as
      opera&ccedil;&otilde;es di&aacute;rias.  Apesar de tudo, Murphy era um 
      otimista.</para>

      <para>Lidar com esta situa&ccedil;&atilde;o com netgroups oferece diversas
      vantagens.  Cada usu&aacute;rio n&atilde;o precisa ser tratado separadamente;
      voc&ecirc; designa um usu&aacute;rio para um ou mais netgroups e permite ou
      pro&iacute;be logins para todos os membros do netgroup.  Se voc&ecirc;
      adicionar uma nova m&aacute;quina, voc&ecirc; ter&aacute; somente que definir as
      restri&ccedil;&otilde;es de acesso para os netgroups.  Se um novo usu&aacute;rio for
      adicionado, voc&ecirc; ter&aacute; somente que adicionar o usu&aacute;rio a um ou
      mais netgroups.  Estas mudan&ccedil;as s&atilde;o independentes umas das
      outras; nada mais de <quote>para cada combina&ccedil;&atilde;o de usu&aacute;rio e
      m&aacute;quina, fa&ccedil;a...</quote> se a sua configura&ccedil;&atilde;o de NIS &eacute;
      cuidadosamente planejada, voc&ecirc; somente ter&aacute; que modificar 
      exatamente um arquivo de configura&ccedil;&atilde;o central para conceder ou
      negar acesso &agrave;s m&aacute;quinas.</para>

      <para>O primeiro passo &eacute; a inicializa&ccedil;&atilde;o do mapa NIS do
      netgroup.  O &man.ypinit.8; do FreeBSD n&atilde;o cria este mapa por
      padr&atilde;o, mas sua implementa&ccedil;&atilde;o de NIS vai suport&aacute;-lo quando for
      criado.  Para criar um mapa vazio, digite</para>

      <screen>ellington&prompt.root; <userinput>vi /var/yp/netgroup</userinput></screen>

      <para>e comece a adicionar conte&uacute;do.  Para nosso exemplo,
      precisamos de pelo menos quatro netgroups: Funcion&aacute;rios de TI,
      aprendizes de TI, funcion&aacute;rios normais e estagi&aacute;rios.</para>

      <programlisting>IT_EMP  (,alpha,dominio-teste)    (,beta,dominio)
IT_APP  (,charlie,dominio-teste)  (,delta,dominio-teste)
USERS   (,echo,dominio-teste)     (,foxtrott,dominio-teste) \
	(,golf,dominio-teste)
INTERNS (,able,dominio-teste)     (,baker,dominio-teste)</programlisting>

      <para><literal>IT_EMP</literal>, <literal>IT_APP</literal> etc.
      s&atilde;o nomes de netgroups.  Cada grupo entre colchetes adiciona um
      ou mais contas de usu&aacute;rio a ele.  Os tr&ecirc;s campos dentro de um
      grupo s&atilde;o:</para>

      <orderedlist>
	<listitem>
	  <para>O nome do(s) sistema(s) onde os seguintes itens s&atilde;o
	  v&aacute;lidos.  Se voc&ecirc; n&atilde;o especificar um nome de sistema, a
	  entrada &eacute; v&aacute;lida em todos os sistemas (hosts).  Se voc&ecirc;
	  especificar um sistema, voc&ecirc; vai entrar em uma mundo de
	  escurid&atilde;o, horror e total confus&atilde;o.</para>
	</listitem>

	<listitem>
	  <para>O nome da conta que pertence a este netgroup.</para>
	</listitem>

	<listitem>
	  <para>O dom&iacute;nio NIS para a conta.  Voc&ecirc; pode importar contas
	  de outros dom&iacute;nios NIS para seu netgroup se voc&ecirc; &eacute; um dos
	  camaradas sem sorte, com mais de um dom&iacute;nio NIS.</para>
	</listitem>
      </orderedlist>

      <para>Cada um destes campos pode conter curingas.  Veja
      &man.netgroup.5; para detalhes.</para>

      <note>
	<indexterm><primary>netgroups</primary></indexterm>
	<para>Nomes de netgroup mais longos que 8 caracteres n&atilde;o devem
	ser usados, especialmente se voc&ecirc; tem m&aacute;quinas rodando outros
	sistemas operacionais em seu dom&iacute;nio NIS.  Os nomes s&atilde;o
	sens&iacute;veis &agrave; diferen&ccedil;as entre mai&uacute;sculas e min&uacute;sculas; usar
	mai&uacute;sculas para nomes de netgroups &eacute; uma forma f&aacute;cil de
	distinguir entre usu&aacute;rio, m&aacute;quina e nomes de netgroups.</para>

	<para>Alguns clientes NIS (diferentes do FreeBSD) n&atilde;o
	conseguem lidar com netgroups com grande n&uacute;mero de entradas.
	Por exemplo, algumas antigas vers&otilde;es do &sunos; come&ccedil;am a
	causar problemas se um netgoup cont&eacute;m mais de 15 
	<emphasis>entradas</emphasis>.  Voc&ecirc; pode contornar este limite
	criando v&aacute;rios sub-netgroups com 15 ou menos usu&aacute;rios e um
	netgroup real que consiste dos sub-netgroups:</para>

	<programlisting>BIGGRP1  (,joe1,dominio)  (,joe2,dominio)  (,joe3,dominio) [...]
BIGGRP2  (,joe16,dominio)  (,joe17,dominio) [...]
BIGGRP3  (,joe31,dominio)  (,joe32,dominio)
BIGGROUP BIGGRP1 BIGGRP2 BIGGRP3</programlisting>

	<para>Voc&ecirc; pode repetir este processo se precisar de mais que
	225 usu&aacute;rios dentro de um &uacute;nico netgroup.</para>
      </note>

      <para>Ativar e distribuir seu novo mapa NIS &eacute; f&aacute;cil:</para>

      <screen>ellington&prompt.root; <userinput>cd /var/yp</userinput>
ellington&prompt.root; <userinput>make</userinput></screen>

      <para>Isto vai gerar os tr&ecirc;s mapas NIS 
      <filename>netgroup</filename>
      <filename>netgroup.byhost</filename>
      e <filename>netgroup.byuser</filename>.  Use &man.ypcat.1; 
      para verificar se seus novos mapas NIS est&atilde;o dispon&iacute;veis:</para>

      <screen>ellington&prompt.user; <userinput>ypcat -k netgroup</userinput>
ellington&prompt.user; <userinput>ypcat -k netgroup.byhost</userinput>
ellington&prompt.user; <userinput>ypcat -k netgroup.byuser</userinput></screen>

      <para>A sa&iacute;da do primeiro comando deve parecer-se com o conte&uacute;do
      do <filename>/var/yp/netgroup</filename>.  O segundo comando n&atilde;o
      produzir&aacute; sa&iacute;da, se voc&ecirc; n&atilde;o especificou netgroups espec&iacute;ficos
      para sistemas (hosts).  O terceiro comando pode ser usado para
      obter a lista de netgroups para um usu&aacute;rio.</para>

      <para>A configura&ccedil;&atilde;o do cliente &eacute; bem simples.  Para configurar
      o servidor <replaceable>war</replaceable>, voc&ecirc; somente ter&aacute; que
      iniciar o &man.vipw.8; e substituir a linha</para>

      <programlisting>+:::::::::</programlisting>

      <para>por</para>

      <programlisting>+@IT_EMP:::::::::</programlisting>

      <para>Agora, somente o dado para usu&aacute;rios definidos no
      netgroup <replaceable>IT_EMP</replaceable> &eacute; importado na base
      de dados de <replaceable>war</replaceable> e somente a estes
      usu&aacute;rios &eacute; permitido o acesso (login).</para>

      <para>Infelizmente, esta limita&ccedil;&atilde;o tamb&eacute;m se aplica &agrave; fun&ccedil;&atilde;o ~
      do shell e todas as rotinas convertendo entre nomes de usu&aacute;rios
      e IDs num&eacute;ricos de usu&aacute;rios.  Em outras palavras, <command>
      cd ~<replaceable>usu&aacute;rio</replaceable></command> n&atilde;o vai
      funcionar, <command>ls -l</command> vai mostrar o id num&eacute;rico ao
      inv&eacute;s do nome do usu&aacute;rio, e <command>find . -user joe 
      -print</command> ir&aacute; falhar com <errorname>No such 
      user</errorname>. Para consertar isto, voc&ecirc; vai precisar
      importar todas as entradas de usu&aacute;rios <emphasis>sem permitir 
      que eles acessem seus servidores.</emphasis></para>

      <para>ISto pode ser feito adicionando outra linha ao 
      <filename>/etc/master.passwd</filename>.  Esta linha deve
      conter:</para>

      <para><literal>+:::::::::/sbin/nologin</literal>, significando 
      <quote>Importe todas as entradas mas substitua o shell por 
      <filename>/sbin/nologin</filename> nas entradas 
      importadas.</quote>  Voc&ecirc; pode substituir qualquer campo na entrada
      passwd colocando um valor padr&atilde;o em seu arquivo 
      <filename>/etc/master.passwd</filename>.</para>


      <!-- Been there, done that, got the scars to prove it - ue -->
      <warning>  
        <para> Certifique-se que a linha
	<literal>+:::::::::/sbin/nologin</literal> est&aacute; ap&oacute;s 
	<literal>+@IT_EMP:::::::::</literal>.  Caso contr&aacute;rio, todas
	as contas de usu&aacute;rios importadas do NIS ter&atilde;o /sbin/nologin
	como seu shell de acesso.</para>
      </warning>

      <para>Ap&oacute;s esta mudan&ccedil;a, voc&ecirc; ter&aacute; somente que modificar um mapa
      NIS se um novo funcion&aacute;rio juntar-se ao departamento de TI.  
      Voc&ecirc; pode usar uma abordagem similar para os servidores menos
      importantes substituindo a antiga <literal>+:::::::::</literal>
      em sua vers&atilde;o local do <filename>/etc/master.passwd</filename> 
      por algo como isto:</para>

      <programlisting>+@IT_EMP:::::::::
+@IT_APP:::::::::
+:::::::::/sbin/nologin</programlisting>

      <para>As linhas correspondentes para opera&ccedil;&atilde;o normal de esta&ccedil;&otilde;es
      de trabalho podem ser:</para>

      <programlisting>+@IT_EMP:::::::::
+@USERS:::::::::
+:::::::::/sbin/nologin</programlisting>

      <para>E tudo estaria bem at&eacute; que aconte&ccedil;a uma mudan&ccedil;a na
      pol&iacute;tica algumas mudan&ccedil;as depois:  o departamento de TI come&ccedil;a
      contratando estagi&aacute;rios.  Os estagi&aacute;rios em TI s&atilde;o permitidos de
      acessarem as esta&ccedil;&otilde;es de trabalho normais e os servidores menos
      importantes; e os aprendizes de TI s&atilde;o permitidos acessar os 
      servidores principais.  Voc&ecirc; adiciona um novo netgroup,
      IT_INTERN, adiciona os novos estagi&aacute;rios a este netgroup e
      come&ccedil;a a mudar a configura&ccedil;&atilde;o em cada uma e em todas as
      m&aacute;quinas... Como diz o velho ditado: <quote>Erros no
      planejamento centralizado levam &agrave; bagun&ccedil;a geral</quote>.</para>

      <para>A capacidade do NIS de criar netgroups de outros netgroups
      pode ser usada para evitar situa&ccedil;&otilde;es como esta.  Uma
      possibilidade &eacute; a cria&ccedil;&atilde;o de netgroups baseados em atividades.
      Por exemplo, voc&ecirc; pode criar um netgroup chamado 
      <replaceable>BIGSRV</replaceable> para definir as restri&ccedil;&otilde;es de
      acesso para os servidores importantes, outro netgroup chamado
      <replaceable>SMALLSRV</replaceable> para os servidores menos
      importantes e um terceiro netgroup chamado
      <replaceable>USERBOX</replaceable> para as esta&ccedil;&otilde;es de trabalho
      normais.  Cada um desses netgroups cont&ecirc;m os netgroups que s&atilde;o
      permitidos acessarem estas m&aacute;quinas.  As novas entradas para
      seu mapa NIS do netgroup deve ser parecer com este:</para>

      <programlisting>BIGSRV    IT_EMP IT_APP
SMALLSRV IT_EMP IT_APP ITINTERN
USERBOX   IT_EMP ITINTERN USERS</programlisting>

      <para>Este m&eacute;todo de definir restri&ccedil;&otilde;es para acesso funcionam
      razoavelmente bem se voc&ecirc; puder definir grupos de m&aacute;quinas com
      restri&ccedil;&otilde;es id&ecirc;nticas.  Infelizmente, esta &eacute; a exce&ccedil;&atilde;o e n&atilde;o a
      regra.  Na maior parte do tempo, voc&ecirc; vai precisar da capacidade
      de definir acesso (login) em cada m&aacute;quina.</para>

      <para>Defini&ccedil;&otilde;es de netgroup espec&iacute;fico por m&aacute;quina, s&atilde;o a outra
      possibilidade para tratar com a mudan&ccedil;a de pol&iacute;tica delineada
      acima.  Neste cen&aacute;rio, o <filename>/etc/master.passwd</filename> 
      de cada caixa cont&ecirc;m duas linhas come&ccedil;ando por <quote>+</quote>.  
      A primeira delas adiciona um netgroup com contas com
      permiss&atilde;o de acesso nesta m&aacute;quina, a segunda adiciona todas as
      demais contas com <filename>/sbin/nologin</filename> como shell.  
      &Eacute; uma boa id&eacute;ia usar a vers&atilde;o em mai&uacute;sculas do nome da m&aacute;quina
      como nome do netgroup.  Em outras palavras, as linhas devem
      ficar parecidas com estas:

      <programlisting>+@<replaceable>BOXNAME</replaceable>:::::::::
+:::::::::/sbin/nologin</programlisting>

      <para>Uma vez que voc&ecirc; tenha completado esta tarefa para todas
      as suas m&aacute;quinas, voc&ecirc; n&atilde;o ter&aacute; que modificar as vers&otilde;es locais
      do <filename>/etc/master.passwd</filename> nunca mais.  Todas as
      altera&ccedil;&otilde;es subseq&uuml;entes podem ser tratadas modificando o mapa
      NIS.  Eis um exemplo de um poss&iacute;vel mapa de netgroup para este
      cen&aacute;rio com alguns brindes adicionais.</para>


      <programlisting># Primeiro, defina grupos de usu&aacute;rios 
IT_EMP    (,alpha,dominio-teste)    (,beta,dominio-teste)
IT_APP    (,charlie,dominio-teste)  (,delta,dominio-teste)
DEPT1     (,echo,dominio-teste)     (,foxtrott,dominio-teste)
DEPT2     (,golf,dominio-teste)     (,hotel,dominio-teste)
DEPT3     (,india,dominio-teste)    (,juliet,dominio-teste)
ITINTERN  (,kilo,dominio-teste)     (,lima,dominio-teste)
D_INTERNS (,able,dominio-teste)     (,baker,dominio-teste)
#
# Agora, defina alguns grupos baseados em fun&ccedil;&otilde;es
USERS     DEPT1   DEPT2     DEPT3
BIGSRV    IT_EMP IT_APP
SMALLSRV IT_EMP IT_APP    ITINTERN
USERBOX   IT_EMP ITINTERN USERS
#
# Adicione grupos para tarefas especiais
# Permite acesso echo e golf acessarem nossa m&aacute;quina de antiv&iacute;rus
SECURITY IT_EMP  (,echo,dominio-teste)  (,golf,dominio-teste)
#
# netgroups baseados em m&aacute;quinas 
# Nossos principais servidores
WAR       BIGSRV
FAMINE    BIGSRV
# Usu&aacute;rio india precisa de acesso a este servidor
POLLUTION BIGSRV  (,india,dominio-teste)
#
# Este e' realmente importante e precisa de mais restri&ccedil;&otilde;es de acesso
DEATH     IT_EMP
#
# A maquina antiv&iacute;rus mencionada acima 
ONE       SECURITY
#
# Restrinja a m&aacute;quina a um &uacute;nico usu&aacute;rio
TWO       (,hotel,dominio-teste)
# [...more groups to follow]</programlisting>

      <para>Se voc&ecirc; estiver usando algum tipo de banco de dados para
      gerenciar suas contas de usu&aacute;rio, voc&ecirc; deve ser capaz de criar a
      primeira parte do mapa com as ferramentas de relat&oacute;rios de seu
      banco de dados.  Desta forma, novos usu&aacute;rios ter&atilde;o,
      automaticamente, acesso &agrave;s m&aacute;quinas.</para>

      <para>Uma &uacute;ltima palavra de precau&ccedil;&atilde;o: Pode nem sempre ser
      recomend&aacute;vel usar netgroups baseados em m&aacute;quinas.  Se voc&ecirc;
      estiver implantando um par, uma d&uacute;zia ou mesmo centenas de
      m&aacute;quinas id&ecirc;nticas para laborat&oacute;rios de estudantes, voc&ecirc; deve
      usar netgroups baseados em fun&ccedil;&otilde;es ao inv&eacute;s de netgroups 
      baseados em m&aacute;quinas para manter o tamanho dos mapas NIS dentro
      de limites razo&aacute;veis.</para>
    </sect2>

    <sect2>
      <title>Coisas Importantes para Lembrar-se</title>

      <para>Existem ainda um par de coisas que voc&ecirc; vai precisar fazer
      de forma diferente, agora que voc&ecirc; est&aacute; em um ambiente NIS.</para>

      <itemizedlist>
	<listitem>
	  <para>Cada vez que voc&ecirc; desejar adicionar um usu&aacute;rio ao lab,
	  voc&ecirc; precisa adicion&aacute;-lo <emphasis>somente</emphasis> no 
	  servidor NIS mestre, e <emphasis>voc&ecirc; precisa lembrar-se de
	  reconstruir os mapas NIS</emphasis>.  Se voc&ecirc; esquecer de
	  fazer isto, o novo usu&aacute;rio n&atilde;o ser&aacute; capaz de acessar em
	  nenhum lugar, exceto no mestre NIS. Por exemplo, se
	  precis&aacute;ssemos adicionar um novo usu&aacute;rio 
	  <quote>jsmith</quote> ao lab, poder&iacute;amos fazer:</para>

	  <screen>&prompt.root; <userinput>pw useradd jsmith</userinput>
&prompt.root; <userinput>cd /var/yp</userinput>
&prompt.root; <userinput>make test-domain</userinput></screen>

	  <para>Voc&ecirc; tamb&eacute;m pode rodar 
	  <command>adduser jsmith</command> ao inv&eacute;s do 
	  <command>pw useradd jsmith</command>.</para>
	</listitem>
	<listitem>
	  <para><emphasis>Mantenha as contas de administra&ccedil;&atilde;o fora dos
	  mapas NIS</emphasis>.  Voc&ecirc; n&atilde;o quer propagar contas
	  administrativas e senhas para as m&aacute;quinas que v&atilde;o ter
	  usu&aacute;rios que n&atilde;o devem ter acesso a estas contas.</para>
	</listitem>
	<listitem>
	  <para><emphasis>Mantenha o mestre e o escravo NIS seguros, e
	  minimize seus tempos de paradas</emphasis>.  Se algu&eacute;m
	  invadir ou simplesmente desligar estas m&aacute;quinas, eles ter&atilde;o
	  efetivamente deixaram muitas pessoas sem a capacidade de
	  acessar o lab.</para>

	  <para>Este &eacute; a principal fraqueza de qualquer sistema de 
	  administra&ccedil;&atilde;o centralizada.  Se voc&ecirc; n&atilde;o proteger seus
	  servidores NIS, voc&ecirc; ter&aacute; muitos usu&aacute;rios zangados!</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Compatibilidade com NIS v1</title>

      <para>O <application>ypserv</application> do FreeBSD tem algum
      suporte para atender clientes NIS v1.  A implementa&ccedil;&atilde;o NIS do
      FreeBSD usa somente o protocolo NIS v2, entretanto, outras
      implementa&ccedil;&otilde;es incluem suporte para a v1 do protocolo, para
      manter compatibilidade com sistemas antigos.  Os daemons 
      <application>ypbind</application> fornecidos com estes sistemas
      tentar&atilde;o estabelecer uma associa&ccedil;&atilde;o (liga&ccedil;&atilde;o) com um servidor
      NIS v1 mesmo que eles nunca precisem dele (e eles podem insistir
      em fazer difus&atilde;o na busca por um, mesmo depois de terem recebido
      uma resposta de um servidor v2).  Note que enquanto o suporte
      para chamadas normais de clientes &eacute; fornecida, esta vers&atilde;o do
      ypserv n&atilde;o trata requisi&ccedil;&otilde;es de transfer&ecirc;ncia de mapas v1;
      conseq&uuml;entemente, ele n&atilde;o pode ser usado como um mestre ou
      escravo em conjunto com servidores NIS mais antigos que suportam
      somente o protocolo v1.  Felizmente, n&atilde;o devem mais haver
      tais servidores em uso nos dias atuais.</para>
    </sect2>

    <sect2 id="network-nis-server-is-client">
      <title>Servidores NIS Que Tamb&eacute;m S&atilde;o Clientes NIS</title>

      <para>Cuidados devem ser tomados quando rodar o ypserv em um
      dom&iacute;nio multi-servidor onde as m&aacute;quinas servidoras tamb&eacute;m s&atilde;o
      clientes NIS.  Geralmente &eacute; uma boa id&eacute;ia for&ccedil;ar os servidores a
      associarem-se a si pr&oacute;prios ao inv&eacute;s de permitir que fa&ccedil;am
      difus&atilde;o (broadcast) de solicita&ccedil;&otilde;es para associa&ccedil;&otilde;es e
      possivelmente associem-se mutuamente.  Estranhos modos de 
      falhas podem resultar se um servidor sair do ar e outros 
      forem dependentes dele.  Eventualmente todos os clientes v&atilde;o 
      ter seu acesso expirado e tentar&atilde;o se associar a outros 
      servidores, mas o retardo envolvido pode ser consider&aacute;vel e o 
      modo de falha ainda est&aacute; presente, uma vez que os servidores 
      podem associar-se mutuamente de novo.</para>

      <para>Voc&ecirc; pode for&ccedil;ar um sistema a associar-se a um servidor em
      particular rodando o <command>ypbind</command> com o par&acirc;metro
      <option>-S</option>.  Se voc&ecirc; n&atilde;o quiser fazer isto manualmente
      cada vez que inicializar o seu servidor NIS, voc&ecirc; pode adicionar
      as seguintes linhas ao seu <filename>/etc/rc.conf</filename>:</para>

      <programlisting>nis_client_enable="YES"	# run client stuff as well
nis_client_flags="-S <replaceable>NIS domain</replaceable>,<replaceable>server</replaceable>"</programlisting>

      <para>Veja &man.ypbind.8; para maiores informa&ccedil;&otilde;es.</para>
    </sect2>

    <sect2>
      <title>Formatos de Senhas</title>
      <indexterm>
	<primary>NIS</primary>
	<secondary>password formats</secondary>
      </indexterm>
      <para>Uma das quest&otilde;es mais comuns que as pessoas enfrentam 
      quando tentam implementar o NIS, &eacute; a compatibilidade de
      formatos de senhas.  Se o seu servidor NIS est&aacute; usando senhas
      criptografadas com DES, ele somente suportar&aacute; clientes que
      tamb&eacute;m estejam usando DES.  Por exemplo, se voc&ecirc; tem clientes
      NIS &solaris; em sua rede, ent&atilde;o voc&ecirc; quase certamente precisa
      usar senhas criptografadas com DES.</para>

      <para>Para verificar qual o formato seus servidores e
      clientes est&atilde;o usando, olhe no <filename>/etc/login.conf</filename>.  
      Se o sistema (host) est&aacute; configurado para usar senhas
      criptografadas com DES, ent&atilde;o a classe <literal>padr&atilde;o 
      (default)</literal> vai conter uma entrada como esta:</para>

      <programlisting>default:\
	:passwd_format=des:\
	:copyright=/etc/COPYRIGHT:\
	[Entradas adicionais omitidas]</programlisting>

      <para>Outros poss&iacute;veis valores para a capacidade
      <literal>passwd_format</literal>, incluem 
      <literal>blf</literal> e <literal>md5</literal> (para senhas
      criptografadas com Blowfish e MD5, respectivamente).</para>

      <para>Se voc&ecirc; fez mudan&ccedil;as no 
      <filename>/etc/login.conf</filename>, voc&ecirc; tamb&eacute;m vai precisar
      reconstruir a base dedados de capacidade de login, a qual &eacute;
      feita executando o seguinte comando como 
      <username>root</username>:</para>

      <screen>&prompt.root; <userinput>cap_mkdb /etc/login.conf</userinput></screen>

      <note><para>O formato de senhas j&aacute; presentes no 
      <filename>/etc/master.passwd</filename> n&atilde;o ser&aacute; atualizado at&eacute;
      que um usu&aacute;rio modifique sua senha pela primeira vez 
      <emphasis>depois</emphasis> da reconstru&ccedil;&atilde;o da base de dados de
      capacidade.</para></note>

      <para>Em seguida, para garantir que senhas est&atilde;o criptografadas
      com o formato que voc&ecirc; escolheu, voc&ecirc; tamb&eacute;m deve verificar que
      o <literal>crypt_default</literal> no 
      <filename>/etc/auth.conf</filename> d&aacute; preced&ecirc;ncia para o
      formato de senha da sua escolha.  Para fazer isto, coloque o
      formato que voc&ecirc; escolheu em primeiro na lista.  Por exemplo,
      quando usar senhas criptografadas com DES, a entrada deve 
      ser:</para>

      <programlisting>crypt_default	=	des blf md5</programlisting>

      <para>Tendo seguido os passos acima em cada um dos servidores e
      clientes NIS baseados em &os;, voc&ecirc; pode estar certo de que
      todos eles concordam em qual formato de senha &eacute; usado na sua
      rede.  Se voc&ecirc; tem problemas com autentica&ccedil;&atilde;o em um cliente NIS,
      este &eacute; um bom lugar para come&ccedil;ar a procurar por poss&iacute;veis
      problemas.  Lembre-se: se voc&ecirc; quer implementar um servidor NIS
      em uma rede heterog&ecirc;nea, voc&ecirc; provavelmente ter&aacute; que usar DES em
      todos os seus sistemas, porque &eacute; o padr&atilde;o de menor denominador
      comum.</para>
    </sect2>
  </sect1>

  <sect1 id="network-dhcp">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Greg</firstname>
      	  <surname>Sutter</surname>
	  <contrib>Escrito por </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>DHCP</title>

    <sect2>
      <title>O Que &Eacute; DHCP?</title>
      <indexterm>
	<primary>Dynamic Host Configuration Protocol</primary>
	<see>DHCP</see>
      </indexterm>
      <indexterm>
	<primary>Internet Software Consortium (ISC)</primary>
      </indexterm>

      <para>DHCP, o Protocolo de Configura&ccedil;&atilde;o Din&acirc;mica de Servidor (Dynamic
      Host Configuration Protocol, Descreve os meios pelo qual um sistema
      pode se conectar a uma rede e obter a informa&ccedil;&atilde;o necess&aacute;ria para
      comunica&ccedil;&atilde;o naquela rede.  O FreeBSD usa a implementa&ccedil;&atilde;o de DHCP
      da ISC (Internet Systems Consortium), ent&atilde;o toda informa&ccedil;&atilde;o
      dependente de implementa&ccedil;&atilde;o aqui dispon&iacute;vel &eacute; para ser utilizada com a
      distribui&ccedil;&atilde;o da ISC.</para>
    </sect2>

    <sect2>
      <title>O Que Esta Se&ccedil;&atilde;o Cobre</title>

      <para>Esta se&ccedil;&atilde;o descreve os componentes cliente e servidor do sistema
      DHCP da ISC.  O programa cliente, <command>dhclient</command>, j&aacute; vem
      integrado no FreeBSD e a parte servidor est&aacute; dispon&iacute;vel do port
      <filename role="package">net/isc-dhcp3</filename>.  As p&aacute;ginas
      de manual &man.dhclient.8;, &man.dhcp-options.5;, e
      &man.dhclient.conf.5;, adicionalmente &agrave;s refer&ecirc;ncias dispon&iacute;veis
      abaixo, s&atilde;o recursos &uacute;teis.</para>
    </sect2>

    <sect2>
      <title>Como Funciona</title>
      <indexterm><primary>UDP</primary></indexterm>
      <para>Quando o <command>dhclient</command>, o cliente DHCP, &eacute;
	executado na m&aacute;quina cliente, ele come&ccedil;a a transmiss&atilde;o por
	difus&atilde;o de requisi&ccedil;&otilde;es de informa&ccedil;&otilde;es de configura&ccedil;&atilde;o.  Por
	padr&atilde;o, estas solicita&ccedil;&otilde;es est&atilde;o s&atilde;o na porta UDP 68.  O
	servidor responde na UDP 67, dando ao cliente um endere&ccedil;o IP e
	outras informa&ccedil;&otilde;es de rede, como a m&aacute;scara de rede, roteador e
	servidores DNS.  Toda esta informa&ccedil;&atilde;o &eacute; fornecida na forma de
	um <quote>arrendamento (lease)</quote> e &eacute; v&aacute;lido somente por um
	determinado per&iacute;odo (configurado pelo mantenedor do servidor
	DHCP).  Desta forma, endere&ccedil;os IP atribu&iacute;dos a clientes
	que n&atilde;o est&atilde;o mais conectados &agrave; rede, podem ser reaproveitados
	automaticamente.<para>

      <para>Clientes DHCP podem obter uma grande quantidade de
      informa&ccedil;&otilde;es do servidor.  Uma lista completa pode ser encontrada
      em &man.dhcp-options.5;.</para>
    </sect2>

    <sect2>
      <title>Integra&ccedil;&atilde;o com o FreeBSD</title>

      <para>O FreeBSD integra totalmente o cliente DHCP da ISC, o
      <command>dhclient</command>.  O suporte ao cliente DHCP &eacute;
      fornecido tanto no instalador quanto no sistema base,
      evitando a necessidade de conhecimento detalhado das
      configura&ccedil;&otilde;es em qualquer rede que tenha um servidor
      DHCP.  O <command>dhclient</command> foi inclu&iacute;do em todas as
      distribui&ccedil;&otilde;es do FreeBSD, desde a vers&atilde;o 3.2</para>
	<indexterm>
	  <primary><application>sysinstall</application></primary>
	</indexterm>

	<para>O DHCP &eacute; suportado pelo
	<application>sysinstall</application>.  Quando configurar
	uma interface de rede atrav&eacute;s do sysinstall, a primeira
	pergunta feita &eacute;, <quote>Do you want to try DHCP configuration
	of this interface? ("Voc&ecirc; deseja tentar configura&ccedil;&atilde;o DHCP
	nesta interface?")</quote> Respondendo afirmativamente, ser&aacute;
	executado o <command>dhclient</command>, e se funcionar, as
	informa&ccedil;&otilde;es da configura&ccedil;&atilde;o de rede ser&atilde;o preenchidas
	automaticamente.</para>

	<para>Existem duas coisas que voc&ecirc; precisa fazer para ter seu
	sistema usando DHCP na inicializa&ccedil;&atilde;o:</para>
	<indexterm>
	  <primary>DHCP</primary>
	  <secondary>requirements</secondary>
	</indexterm>
	<itemizedlist>
	  <listitem>
	    <para>Certifique-se de que o dispositivo
	    <devicename>bpf</devicename> est&aacute; compilado no seu kernel.
	    Para fazer isso, adicione o <literal>pseudo-device bpf</literal>
	    no seu arquivo de configura&ccedil;&atilde;o do kernel e reconstrua o
	    kernel.  Para maiores informa&ccedil;&otilde;es sobre constru&ccedil;&atilde;o de
	    kernels, veja <xref linkend="kernelconfig">.</para>

	    <para>O dispositivo <devicename>bpf</devicename> j&aacute; &eacute; parte
	    do kernel <filename>GENERIC</filename> fornecido com o
	    FreeBSD, desta forma, se voc&ecirc; n&atilde;o tem um kernel adaptado,
	    voc&ecirc; n&atilde;o precisa criar um para ter o DHCP funcionando.</para>
	    <note>
	      <para>Para os que s&atilde;o particularmente preocupados com
	      seguran&ccedil;a, voc&ecirc; deve estar ciente de que o
	      <devicename>bpf</devicename> tamb&eacute;m &eacute; o dispositivo que
	      permite o funcionamento correto de analizadores de pacotes
	      (embora ainda precisem ser executados pelo usu&aacute;rio
	      <username>root</username>).  O <devicename>bpf</devicename>
	      <emphasis>&eacute;</emphasis> obrigat&oacute;rio para usar DHCP, mas
	      se voc&ecirc; &eacute; muito sens&iacute;vel com rela&ccedil;&atilde;o a seguran&ccedil;a, voc&ecirc;
	      provavelmente n&atilde;o deve adicionar o
	      <devicename>bpf</devicename> ao seu kernel na
	      expectativa de que em algum momento no futuro voc&ecirc; vai
	      utilizar DHCP.</para>
	    </note>
	  </listitem>
	  <listitem>
	    <para>Edite o seu <filename>/etc/rc.conf</filename> para
	    incluir o seguinte:</para>

	    <programlisting>ifconfig_fxp0="DHCP"</programlisting>

	    <note>
	      <para>Certifique-se de substituir
	      <literal>fxp0</literal> pela designa&ccedil;&atilde;o da interface que
	      voc&ecirc; deseja configurar automaticamente, como descrito
	      em <xref linkend="config-network-setup">.</para>
	    </note>

	    <para>Se voc&ecirc; est&aacute; usando um local diferente para o
	    <command>dhclient</command>, ou se voc&ecirc; deseja passar
	    par&acirc;metros adicionais para o comando, inclua tamb&eacute;m o
	    seguinte (editando, se necess&aacute;rio):</para>

	    <programlisting>dhcp_program="/sbin/dhclient"
dhcp_flags=""</programlisting>
	  </listitem>
	</itemizedlist>

	<indexterm>
	  <primary>DHCP</primary>
	  <secondary>server</secondary>
	</indexterm>
	<para>O servidor DHCP, <command>dhcpd</command>, &eacute; inclu&iacute;do
	como parte do port
	<filename role="package">net/isc-dhcp3</filename> na cole&ccedil;&atilde;o
	de ports.  Este port contem a distribui&ccedil;&atilde;o completa do DHCP da
	ISC, contendo o cliente, servidor, agente de relay e
	documenta&ccedil;&atilde;o.</para>
    </sect2>

    <sect2>
      <title>Arquivos</title>
      <indexterm>
	<primary>DHCP</primary>
	<secondary>configuration files</secondary>
      </indexterm>
      <itemizedlist>
	<listitem><para><filename>/etc/dhclient.conf</filename></para>
	  <para>O <command>dhclient</command> requer um arquivo de
	  configura&ccedil;&atilde;o <filename>/etc/dhclient.conf</filename>.
	  Tipicamente o arquivo contem somente coment&aacute;rios e o padr&otilde;es
	  mais razo&aacute;veis definidos.  Este arquivo de configura&ccedil;&atilde;o &eacute;
	  descrito pela p&aacute;gina de manual &man.dhclient.conf.5;
	</listitem>

	<listitem><para><filename>/sbin/dhclient</filename></para>
	  <para>O <command>dhclient</command> &eacute; compilado estaticamente e
	    reside em <filename>/sbin</filename>.  A p&aacute;gina de manual
	    &man.dhclient.8; fornece mais informa&ccedil;&otilde;es sobre o
	    <command>dhclient</command>.</para>
	</listitem>

	<listitem><para><filename>/sbin/dhclient-script</filename></para>
	  <para>O <command>dhclient-script</command> &eacute; o script de
	  configura&ccedil;&atilde;o do cliente DHCP espec&iacute;fico do FreeBSD.  &Eacute;
	  descrito em &man.dhclient-script.8;, mas voc&ecirc; n&atilde;o deve
	  precisar de qualquer modifica&ccedil;&atilde;o de usu&aacute;rio para seu
	  funcionamento.
	</listitem>

	<listitem><para><filename>/var/db/dhclient.leases</filename></para>
	  <para>O cliente DHCP mant&eacute;m uma base de dados de
	  arrendamentos neste arquivo, que &eacute; gravado como um registro
	  (log).  &man.dhclient.leases.5; oferece uma descri&ccedil;&atilde;o um
	  pouco mais longa.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Leitura Complementar</title>

      <para>O protocolo DHCP &eacute; descrito totalmente na
      <ulink url="http://www.freesoft.org/CIE/RFC/2131/">RFC 2131</ulink>.
      Um recurso de informa&ccedil;&otilde;es tamb&eacute;m foi montado em
      <ulink url="http://www.dhcp.org/">dhcp.org</ulink>.</para>
    </sect2>

    <sect2 id="network-dhcp-server">
	<title>Instalando e Configurando um Servidor DHCP</title>

	<sect3>
	  <title>O Que Esta Se&ccedil;&atilde;o Cobre</title>

	  <para>Esta se&ccedil;&atilde;o fornece informa&ccedil;&otilde;es sobre como configurar
	  um sistema FreeBSD para atuar como servidor DHCP usando a
	  implementa&ccedil;&atilde;o da ISC da su&iacute;te DHCP.</para>

	  <para>A parte servidora da su&iacute;te n&atilde;o &eacute; fornecida no
	  FreeBSD, ent&atilde;o voc&ecirc; vai precisar instalar o port
	  <filename role="package">net/isc-dhcp3</filename> para
	  ativar este servi&ccedil;o.  Veja <xref linkend="ports"> para mais
	  informa&ccedil;&otilde;es sobre uso da cole&ccedil;&atilde;o de ports.</para>
	</sect3>

	<sect3>
	  <title>Instala&ccedil;&atilde;o do Servidor DHCP</title>
	  <indexterm>
	    <primary>DHCP</primary>
	    <secondary>installation</secondary>
	  </indexterm>
	  <para>Para configurar seu sistema servidor FreeBSD como um
	  servidor DHCP, voc&ecirc; vai precisar garantir que o
	  dispositivo &man.bpf.4; est&aacute; compilado no seu kernel.  Para
	  isto, adicione o <literal>pseudo-device bpf</literal> ao seu
	  arquivo de configura&ccedil;&atilde;o do kernel e reconstrua o kernel.
	  Para mais informa&ccedil;&otilde;es sobre constru&ccedil;&atilde;o de kernels, veja
	  <xref linkend="kernelconfig">.</para>

	  <para>O dispositivo <devicename>bpf</devicename> j&aacute; &eacute; parte
	  do kernel <filename>GENERIC</filename>, fornecido com o
	  FreeBSD, assim voc&ecirc; n&atilde;o precisa criar um kernel adaptado
	  para ter o DHCP funcionando.</para>

	    <note>
	      <para>Aqueles particularmente preocupados com
	      seguran&ccedil;a, devem observar que o
	      <devicename>bpf</devicename> tamb&eacute;m &eacute; o dispositivo que
	      permite aos analizadores de pacotes executarem seu
	      trabalho (apesar de tais programas precisarem de acesso
	      privilegiado).  O <devicename>bpf</devicename>
	      <emphasis>&eacute;</emphasis> exigido para uso do DHCP, mas se
	      voc&ecirc; &eacute; muito preocupado com quest&otilde;es de seguran&ccedil;a, voc&ecirc;
	      provavelmente n&atilde;o deve incluir o
	      <devicename>bpf</devicename> em seu kernel simplesmente
	      por supor que vai usar DHCP em algum momento no futuro.</para>
	    </note>

	  <para>A pr&oacute;xima coisa que voc&ecirc; vai precisar fazer &eacute; editar o
	  exemplo <filename>dhcpd.conf</filename> que foi inclu&iacute;do
	  pelo port <filename role="package">net/isc-dhcp3</filename>.
	  Por padr&atilde;o, este ser&aacute; o arquivo
	  <filename>/usr/local/etc/dhcpd.conf.sample</filename>, e
	  voc&ecirc; deve copiar este arquivo para
	  <filename>/usr/local/etc/dhcpd.conf</filename> antes de
	  modific&aacute;-lo.
	  </para>
	</sect3>

	<sect3>
	  <title>Configurando o Servidor DHCP</title>
	  <indexterm>
	    <primary>DHCP</primary>
	    <secondary>dhcpd.conf</secondary>
	  </indexterm>
	  <para> O arquivo <filename>dhcpd.conf</filename> &eacute;
	  composto de declara&ccedil;&otilde;es relativas a subredes e servidores, e
	  &eacute;, talvez, melhor explicado usando um exemplo:</para>

	  <programlisting>option domain-name "exemplo.com";<co id="domain-name">
option domain-name-servers 192.168.4.100;<co id="domain-name-servers">
option subnet-mask 255.255.255.0;<co id="subnet-mask">

default-lease-time 3600;<co id="default-lease-time">
max-lease-time 86400;<co id="max-lease-time">
ddns-update-style none;<co id="ddns-update-style">

subnet 192.168.4.0 netmask 255.255.255.0 {
  range 192.168.4.129 192.168.4.254;<co id="range">
  option routers 192.168.4.1;<co id="routers">
}

host mailhost {
  hardware ethernet 02:03:04:05:06:07;<co id="hardware">
  fixed-address mailhost.exemplo.com;<co id="fixed-address">
}</programlisting>

	  <calloutlist>
	    <callout arearefs="domain-name">
	      <para>Esta op&ccedil;&atilde;o especifica o dom&iacute;nio que ser&aacute; fornecido
	      aos clientes como o principal dom&iacute;nio de busca.  Veja
	      &man.resolv.conf.5; para mais informa&ccedil;&otilde;es sobre o que
	      isso significa.</para>
	    </callout>

	    <callout arearefs="domain-name-servers">
	      <para>Esta op&ccedil;&atilde;o especifica uma lista separada por
	      v&iacute;rgulas de servidores DNS que o cliente deve utilizar.</para>
	    </callout>

	    <callout arearefs="subnet-mask">
	      <para>A m&aacute;scara de rede que ser&aacute; fornecida aos clientes.</para>
	    </callout>

	    <callout arearefs="default-lease-time">
	      <para>Um cliente pode requerer um per&iacute;odo de tempo
	      espec&iacute;fico v&aacute;lido para um arrendamento.  Sen&atilde;o o
	      servidor dever&aacute; fazer um arrendamento com este prazo de
	      expira&ccedil;&atilde;o (em segundos).</para>
	    </callout>

	    <callout arearefs="max-lease-time">
	      <para>Este &eacute; o maior per&iacute;odo de tempo permitido que o
	      servidor dever&aacute; permitir um arrendamento.  Se um cliente
	      solicitar um per&iacute;odo maior, um arrendamento ser&aacute;
	      efetuado, entretanto, ser&aacute; v&aacute;lido somente por
	      <literal>max-lease-time</literal> segundos.</para>
	    </callout>

	    <callout arearefs="ddns-update-style">
	      <para>Esta op&ccedil;&atilde;o especifica se o servidor DHCP dever&aacute;
	      tentar atualizar o DNS quando um arrendamento &eacute; aceito
	      ou devolvido.   Na implementa&ccedil;&atilde;o da ISC, esta op&ccedil;&atilde;o &eacute;
	      <emphasis>obrigat&oacute;ria</emphasis>.</para>
	    </callout>

	    <callout arearefs="range">
	      <para>Isto estipula quais endere&ccedil;os IP devem ser usados
	      no conjunto reservado para aloca&ccedil;&atilde;o aos clientes.
	      Endere&ccedil;os IP dentro da faixa inclusive os discriminados
	      s&atilde;o distribu&iacute;dos aos clientes.</para>
	    </callout>

	    <callout arearefs="routers">
	      <para>Declara o gateway padr&atilde;o que ser&aacute; fornecido aos
	      clientes.</para>
	    </callout>

	    <callout arearefs="hardware">
	      <para>O endere&ccedil;o MAC de um sistema (de forma que o
	      servidor DHCP possa reconhec&ecirc;-lo quando dele receber
	      uma solicita&ccedil;&atilde;o).</para>
	    </callout>

	    <callout arearefs="fixed-address">
	      <para>Especifica que o sistema sempre deve receber o
	      mesmo endere&ccedil;o IP.  Note que um hostname funciona aqui,
	      desde que o servidor DHCP seja capaz de resolver o
	      nome via DNS antes de responder &agrave; solicita&ccedil;&atilde;o com as
	      informa&ccedil;&otilde;es do arrendamento.</para>
	    </callout>
	  </calloutlist>

	  <para>Quando voc&ecirc; terminar de escrever o seu
	  <filename>dhcpd.conf</filename> voc&ecirc; pode dar
	  prosseguimento, iniciando o servidor com o seguinte
	  comando:</para>

	  <screen>&prompt.root; <userinput>/usr/local/etc/rc.d/isc-dhcpd.sh start</userinput></screen>

	  <para>Se futuramente voc&ecirc; precisar realizar altera&ccedil;&otilde;es na
	  configura&ccedil;&atilde;o de seu servidor, &eacute; importante notar que enviar
	  um sinal<literal>SIGHUP</literal> para o
	  <application>dhcpd</application> <emphasis>n&atilde;o</emphasis>
	  ir&aacute; recarregar as configura&ccedil;&otilde;es, como na maioria dos
	  daemons.  Voc&ecirc; precisa enviar um 
	  sinal <literal>SIGTERM</literal> para parar o processo, e 
	  ent&atilde;o, reinici&aacute;-lo com o comando acima.</para>
	</sect3>

	<sect3>
	  <title>Arquivos</title>
	  <indexterm>
	    <primary>DHCP</primary>
	    <secondary>configuration files</secondary>
	  </indexterm>
	  <itemizedlist>
	    <listitem><para><filename>/usr/local/sbin/dhcpd</filename></para>
	      <para>O <application>dhcpd</application> &eacute;
	      compilado estaticamente e reside em
	      <filename>/usr/local/sbin</filename>.  A p&aacute;gina de
	      manual &man.dhcpd.8; instalada com o port fornece mais
	      informa&ccedil;&otilde;es sobre o
	      <application>dhcpd</application>.</para>
	    </listitem>

	    <listitem><para><filename>/usr/local/etc/dhcpd.conf</filename></para>
	      <para>O <application>dhcpd</application> requer um
	      arquivo de configura&ccedil;&atilde;o,
	      <filename>/usr/local/etc/dhcpd.conf</filename> antes de
	      come&ccedil;ar a prestar servi&ccedil;os para os clientes.  O arquivo
	      precisa conter todas as informa&ccedil;&otilde;es que devem ser
	      fornecidas aos clientes sendo atendidos, juntamente com
	      informa&ccedil;&otilde;es sobre a opera&ccedil;&atilde;o do servidor.  Este arquivo
	      de configura&ccedil;&atilde;o &eacute; descrito pela p&aacute;gina de manual
	      &man.dhcpd.conf.5;, instalada pelo port.</para>
	    </listitem>

	    <listitem><para><filename>/var/db/dhcpd.leases</filename></para>
	      <para>O servidor DHCP mant&eacute;m uma base de dados de
	      arrendamentos que distribuiu neste arquivo, o qual &eacute;
	      escrito como um arquivo de registro (log).  A p&aacute;gina de
	      manual &man.dhcpd.leases.5;, instalada pelo port
	      fornece uma descri&ccedil;&atilde;o um pouco mais longa.</para>
	    </listitem>

	    <listitem><para><filename>/usr/local/sbin/dhcrelay</filename></para>
	      <para>O <application>dhcrelay</application> &eacute; usado em
	      ambientes avan&ccedil;ados onde um servidor DHCP repassa uma
	      solicita&ccedil;&atilde;o de um cliente para outro servidor DHCP em
	      uma rede separada.  A p&aacute;gina de manual &man.dhcrelay.8;
	      fornecida com o port cont&eacute;m mais detalhes.</para>
	    </listitem>
	  </itemizedlist>
	</sect3>

      </sect2>

  </sect1>

  <sect1 id="network-dns">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Chern</firstname>
	  <surname>Lee</surname>
	  <contrib>Contribu&iacute;do por </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>DNS</title>

    <sect2>
      <title>Vis&atilde;o Geral</title>
      <indexterm><primary>BIND</primary></indexterm>

      <para>O FreeBSD usa, por padr&atilde;o, uma vers&atilde;o do BIND (Berkeley
      Internet Name Domain), que &eacute; a implementa&ccedil;&atilde;o mais comum do
      protocolo DNS.  O DNS &eacute; o protocolo pelo qual nomes s&atilde;o mapeados
      para endere&ccedil;os IP e vice-versa.  Por exemplo, uma pergunta por
      <hostid>www.FreeBSD.org</hostid> receber&aacute; uma resposta com o
      endere&ccedil;o IP do servidor web do Projeto FreeBSD, ao passo que,
      uma pergunta por <hostid>ftp.FreeBSD.org</hostid> retornar&aacute; o
      endere&ccedil;o IP da m&aacute;quina FTP correspondente.  Da mesma forma, o
      oposto pode ocorrer.  Uma pergunta pelo endere&ccedil;o IP pode
      resolver seu nome de sistema.  N&atilde;o &eacute; necess&aacute;rio rodar um
      servidor de nomes para efetuar pesquisas DNS em um sistema.</para>

      <indexterm><primary>DNS</primary></indexterm>

      <para>O DNS &eacute; coordenado atrav&eacute;s da Internet atrav&eacute;s de um
      sistema um tanto complexo de servidores de nome raiz
      autoritativos, e outros servidores de nome de menor escala que
      abrigam e fazem cache de informa&ccedil;&otilde;es de dom&iacute;nios individuais.</para>

      <para>Este documento refere-se ao BIND 8.x, como ele &eacute; a vers&atilde;o
      est&aacute;vel usada no FreeBSD.  O BIND 9.x no FreeBSD pode ser
      instalado atrav&eacute;s do port
      <filename role="package">net/bind9</filename>.</para>

      <para>As RFC1034 e RFC1035 ditam o protocolo DNS.</para>

      <para>Atualmente, o BIND &eacute; mantido pelo
      <ulink url="http://www.isc.org/">Internet Software Consortium
      (www.isc.org)</ulink>.</para>
    </sect2>

    <sect2>
      <title>Terminologia</title>

      <para>Para compreender este documento, alguns termos relativos
      ao DNS precisam ser entendidos.</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Termo</entry>
	      <entry>Defini&ccedil;&atilde;o</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>DNS Direto</entry>
	      <entry>Mapeamento de nomes para endere&ccedil;os IP</entry>
	    </row>

	    <row>
	      <entry>Origem</entry>
	      <entry>Refere-se ao dom&iacute;nio abrangido em um determinado
	      arquivo de zona</entry>
	    </row>

	    <row>
	      <entry><application>named</application>, BIND, servidor
	      de nome</entry>
	      <entry>Nomes comuns para o pacote do servidor de nomes
	      BIND, incluso no FreeBSD</entry>
	    </row>

	    <indexterm><primary>resolver</primary></indexterm>
	    <row>
	      <entry>Resolver</entry>
	      <entry>Um processo do sistema atrav&eacute;s do qual uma
	      m&aacute;quina pesquisa num servidor de nomes por informa&ccedil;&otilde;es
	      sobre zonas</entry>
	    </row>

	    <indexterm><primary>reverse DNS</primary></indexterm>
	    <row>
	      <entry>DNS reverso</entry>
	      <entry>O oposto do DNS direto; mapeamento de endere&ccedil;os
	      IP para nomes</entry>
	    </row>

	    <indexterm><primary>root zone</primary></indexterm>
	    <row>
	      <entry>Zona Raiz (Root Zone)</entry>

	      <entry>O in&iacute;cio da hierarquia de zona da Internet. Todas
	      as zonas recaem sob a zona raiz, similar a como todos os
	      arquivos em um sistema de arquivos localizam-se abaixo do
	      diret&oacute;rio raiz.</entry>
	    </row>

	    <row>
	      <entry>Zona</entry>
	      <entry>Um dom&iacute;nio individual, subdom&iacute;nio, ou parte de um
	      DNS administrado por uma mesma autoridade</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <indexterm>
	<primary>zones</primary>
	<secondary>examples</secondary>
      </indexterm>

      <para>Exemplos de zonas:
</para>
      <itemizedlist>
	<listitem>
	  <para><hostid>.</hostid> &eacute; a zona raiz</para>
	</listitem>
	<listitem>
	  <para><hostid>org.</hostid> &eacute; a zona sob a zona raiz</para>
	</listitem>
	<listitem>
	  <para><hostid>exemplo.org</hostid> &eacute; a zona sob a zona
	  <hostid>org.</hostid></para>
	</listitem>
	<listitem>
	  <para><hostid>foo.exemplo.org.</hostid> &eacute; um subdom&iacute;nio, uma
	    zona sob a zona <hostid>exemplo.org.</hostid></para>
	</listitem>
	<listitem>
	  <para>
	    <hostid>1.2.3.in-addr.arpa</hostid> &eacute; a zona referenciando
	    todos os endere&ccedil;os IP que recaem sob o espa&ccedil;o IP 3.2.1.*
	  </para>
	</listitem>
      </itemizedlist>

      <para>Como se pode ver, a parte mais espec&iacute;fica de um nome de
      sistema aparece &agrave; sua esquerda.  Por exemplo,
      <hostid>exemplo.org</hostid> &eacute; mais espec&iacute;fico que
      <hostid>org.</hostid>, como <hostid>org.</hostid> &eacute; mais
      espec&iacute;fico que a zona raiz.  O esbo&ccedil;o de cada parte de um nome
      de sistema &eacute; muito parecido com um sistema de arquivos: o
      diret&oacute;rio <filename>/dev</filename> fica sob o raiz, e assim por
      diante.</para>

    </sect2>

    <sect2>
      <title>Raz&otilde;es para Rodar um Servidor de Nome</title>

      <para>Servidores de nome normalmente aparecem em duas formas:
      como servidor de nome autoritativo e, como um servidor de nome
      para fazer cache.</para>

      <para>Um servidor de nome autoritativo &eacute; necess&aacute;rio quando:</para>

      <itemizedlist>
	<listitem>
	  <para>algu&eacute;m quer servir informa&ccedil;&atilde;o DNS para o mundo,
	  respondendo de forma autoritativa a pesquisas.</para>
	</listitem>
	<listitem>
	  <para>um dom&iacute;nio, como <hostid>exemplo.org</hostid>, &eacute;
	  registrado e endere&ccedil;os IP precisam ser designados a nomes de
	  sistemas sob ele.</para>
	</listitem>
	<listitem>
	  <para>um bloco de endere&ccedil;os IP requerem entradas DNS
	  reversas (IP para nomes de sistema).</para>
	</listitem>
	<listitem>
	  <para>um servidor de nome de seguran&ccedil;a, chamado de escravo,
	  precisa responder a pesquisas quando o prim&aacute;rio est&aacute; fora do
	  ar ou inacess&iacute;vel.</para>
	  </listitem>
      </itemizedlist>

      <para>Um servidor de nome para fazer cache &eacute; necess&aacute;rio quando:</para>

      <itemizedlist>
	<listitem>
	  <para>um servidor DNS local pode fazer cache e responder
	  mais rapidamente do que pesquisar em um servidor de nome
	  externo.</para>
	</listitem>
	<listitem>
	  <para>uma redu&ccedil;&atilde;o no tr&aacute;fego de rede de uma forma geral &eacute;
	  desejada (o tr&aacute;fego DNS foi contabilizado como 5% ou mais do
	  tr&aacute;fego total da Internet).</para>
	</listitem>
      </itemizedlist>

      <para>Quando algu&eacute;m pesquisa por
      <hostid>www.FreeBSD.org</hostid>, o resolver normalmente
      pesquisa o servidor de nomes do provedor de n&iacute;vel superior e
      recupera a resposta.  Com um servidor DNS local fazendo cache, a
      pesquisa precisa ser feita uma vez para o mundo exterior.  Cada
      pesquisa adicional n&atilde;o vai precisar buscar fora da rede local,
      uma vez que h&aacute; uma c&oacute;pia local da informa&ccedil;&atilde;o no cache.</para>
    </sect2>

    <sect2>
      <title>Como Funciona</title>

      <para>No FreeBSD, o daemon BIND &eacute; chamado
      <application>named</application> por raz&otilde;es &oacute;bvias.</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Arquivo</entry>
	      <entry>Descri&ccedil;&atilde;o</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><application>named</application></entry>
	      <entry>o daemon do BIND</entry>
	    </row>

	    <row>
	      <entry><command>ndc</command></entry>
	      <entry>programa de controle do daemon de nome (name
	      daemon control)</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/namedb</filename></entry>
	      <entry>diret&oacute;rio onde reside a informa&ccedil;&atilde;o de zona
	      do BIND</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/namedb/named.conf</filename></entry>
	      <entry>arquivo de configura&ccedil;&atilde;o do daemon</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>
        Arquivos de zona normalmente pertencem ao diret&oacute;rio
	<filename>/etc/namedb</filename>, e cont&eacute;m a informa&ccedil;&atilde;o de
	zona DNS fornecida pelo servidor de nomes.
</para>
    </sect2>

    <sect2>
      <title>Iniciando o BIND</title>
      <indexterm>
	<primary>BIND</primary>
	<secondary>starting</secondary>
      </indexterm>
      <para>Uma vez que o BIND &eacute; instalado por padr&atilde;o, configur&aacute;-lo &eacute;
	relativamente simples.</para>

      <para>Para assegurar que o daemon named &eacute; executado durante a
	inicializa&ccedil;&atilde;o, coloque as seguintes modifica&ccedil;&otilde;es no
	<filename>/etc/rc.conf</filename>:</para>

      <programlisting>named_enable="YES"</programlisting>

      <para>Para iniciar o daemon manualmente (ap&oacute;s configur&aacute;-lo)</para>

      <screen>&prompt.root; <userinput>ndc start</userinput></screen>
    </sect2>

    <sect2>
      <title>Arquivos de Configura&ccedil;&atilde;o</title>
      <indexterm>
	<primary>BIND</primary>
	<secondary>configuration files</secondary>
      </indexterm>
      <sect3>
	<title>Usando <command>make-localhost</command></title>
	<para>Certifique-se de fazer:</para>

	<screen>&prompt.root; <userinput>cd /etc/namedb</userinput>
&prompt.root; <userinput>sh make-localhost</userinput></screen>

	<para>para criar adequadamente o arquivo de zona DNS reverso local
	no <filename>/etc/namedb/localhost.rev</filename>.</para>
      </sect3>

      <sect3>
	<title><filename>/etc/namedb/named.conf</filename></title>

	<programlisting>// &dollar;FreeBSD$
//
// Consulte a p&aacute;gina de manual do named(8) para detalhes.  Se voc&ecirc;
// alguma vez for configurar um servidor prim&aacute;rio, certifique-se de
// que compreendeu os detalhes cabeludos de como o DNS est&aacute;
// funcionando.  Mesmo com simples enganos, voc&ecirc; pode quebrar a
// conectividade de grupos atingidos, ou causar enormes quantidades de
// tr&aacute;fego in&uacute;til na Internet.

options {
	directory "/etc/namedb";

// Adicionalmente &agrave; cl&aacute;usula "forwarders", voc&ecirc; pode for&ccedil;ar seu
// servidor de nomes a nunca iniciar pesquisas por conta pr&oacute;pria, mas
// sempre consultar somente seus despachantes, ativando a linha
// abaixo:
//
//      forward only;

// Se voc&ecirc; tem um servidor DNS por perto em seu provedor de acesso,
// entre seu endere&ccedil;o IP aqui, e ative a linha abaixo.  Isto far&aacute; com
// que voc&ecirc; se beneficie de seu cache, reduzindo o tr&aacute;fego DNS na
// Internet em geral.

/*
	forwarders {
		127.0.0.1;
	};
*/</programlisting>

	<para>Como diz o coment&aacute;rio, para se beneficiar de um cache de
	acesso, <literal>despachantes (forwarders)</literal> podem ser
	ativados aqui.  Em circunst&acirc;ncias normais, um servidor de nome
	ir&aacute; pesquisar a Internet de forma recursiva em determinados
	servidores de nomes at&eacute; que encontre a resposta que procura.
	Com este recurso ativado, ele ter&aacute; que consultar o servidor de
	nome do provedor de acesso (ou o servidor de nome configurado)
	primeiro, tirando vantagem de seu cache.  Se o servidor de
	nome em quest&atilde;o estiver com acessos de alta velocidade,
	um servidor de nomes r&aacute;pido, ativar este recurso pode valer a
	pena.</para>

	<warning><para><hostid role="ipaddr">127.0.0.1</hostid>
	    <emphasis>n&atilde;o</emphasis> vai funcionar aqui.  Mude este
	    endere&ccedil;o IP para um servidor de nome localizado em seu
	    provedor de acesso.</para>
	</warning>

	<programlisting>	/*
	 * Se existe um firewall entre voc&ecirc; e os servidores de nome
	 * com os quais deseja falar, voc&ecirc; pode precisar remover os
	 * coment&aacute;rios da diretiva query-source abaixo.  Vers&otilde;es
	 * anteriores do BIND sempre fizeram pesquisas usando a porta
	 * 53, mas o BIND 8.1 usa uma porta n&atilde;o priviliegada por
	 * padr&atilde;o.
	 */
	// query-source address * port 53;

	/*
	 * se estiver executando em um ambiente restrito (sandbox),
	 * voc&ecirc; pode ter que especificar uma localiza&ccedil;&atilde;o diferente
	 * para o arquivo de despejo de mem&oacute;ria (dumpfile).
	 */
	// dump-file "s/named_dump.db";
};

// Nota: os comandos a seguir ser&atilde;o suportados em uma vers&atilde;o futura.
/*
host { any; } {
	topology {
		127.0.0.0/8;
	};
};
*/

// Configurar secund&aacute;rios &eacute; muito mais f&aacute;cil e um esbo&ccedil;o da
// configura&ccedil;&atilde;o &eacute; explicado a seguir.
//
// Se voc&ecirc; ativar um servidor de nome local, n&atilde;o esque&ccedil;a de colocar o
// 127.0.0.1 no seu /etc/resolv.conf para que este servidor seja
// consultado primeiro.
// Tamb&eacute;m certifique-se de ativ&aacute;-lo no /etc/rc.conf.

zone "." {
	type hint;
	file "named.root";
};

zone "0.0.127.IN-ADDR.ARPA" {
	type master;
	file "localhost.rev";
};

zone
"0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.IP6.INT" {
	type master;
	file "localhost.rev";
};

// Nota: N&atilde;o use os endere&ccedil;os IP abaixo, eles s&atilde;o apenas exemplos e
// servem somente para prop&oacute;sitos de demonstra&ccedil;&atilde;o e documenta&ccedil;&atilde;o!
//
// Exemplo de entradas de configura&ccedil;&atilde;o de servidor secund&aacute;rio.  Pode ser
// interessante se tornar o secund&aacute;rio pelo menos da zona de seu
// pr&oacute;prio dom&iacute;nio.  Solicite a seu administrador de rede o
// endere&ccedil;o IP do servidor prim&aacute;rio respons&aacute;vel.
//
// Nunca esque&ccedil;a de incluir a zona de busca reversa (IN-ADDR.ARPA)!
// (Estes s&atilde;o os primeiros bytes do respectivo endere&ccedil;o IP, em ordem
// invertida, com ".IN-ADDR.ARPA" anexado.)
//
// Entretanto, antes de iniciar a configurar a zona prim&aacute;ria, &eacute; bom ter
// compreendido completamente como o DNS e o BIND trabalham.  Algumas
// vezes, existem ciladas ocultas.  Em compara&ccedil;&atilde;o, &eacute; mais f&aacute;cil
// configurar um secund&aacute;rio.
//
// NB: N&atilde;o ative cegamente os exemplos abaixo. :-)  Ao inv&eacute;s, use
// nomes e endere&ccedil;os reais.
//
// NOTA!!! O FreeBSD roda bind em uma sandbox (veja named_flags no
// rc.conf).  O diret&oacute;rio contendo as zonas secund&aacute;rias devem possuir
// acesso de grava&ccedil;&atilde;o permitido para o bind.  &Eacute; sugerida a seguinte
// seq&uuml;&ecirc;ncia:
//
//      mkdir /etc/namedb/s
//      chown bind:bind /etc/namedb/s
//      chmod 750 /etc/namedb/s</programlisting>

	<para>Para mais informa&ccedil;&otilde;es sobre como rodar o BIND numa
	sandbox, veja <link linkend="network-named-sandbox">Rodando
	o named em uma sandbox</link>.</para>

	<programlisting>/*
zone "exemplo.com" {
	type slave;
	file "s/exemplo.com.bak";
	masters {
		192.168.1.1;
	};
};

zone "0.168.192.in-addr.arpa" {
	type slave;
	file "s/0.168.192.in-addr.arpa.bak";
	masters {
		192.168.1.1;
	};
};
*/</programlisting>
	<para>No <filename>named.conf</filename> existem exemplos de
	entradas secund&aacute;rias para as zonas direta e reversa.</para>

	<para>Para cada nova zona servida, uma nova entrada de zona
	precisa ser adicionada ao <filename>named.conf</filename></para>

	<para>Por exemplo, a entrada mais simples para a zona
	<hostid role="domainname">exemplo.org</hostid> pode ficar
	assim:</para>

	<programlisting>zone "exemplo.org" {
	type master;
	file "exemplo.org";
};</programlisting>

	<para>A zona &eacute; prim&aacute;ria, como indicado pela declara&ccedil;&atilde;o
	<option>type</option>, mantendo a informa&ccedil;&atilde;o da zona no
	<filename>/etc/namedb/exemplo.org</filename>  indicado pela
	declara&ccedil;&atilde;o <option>file</option>.</para>

	<programlisting>zone "exemplo.org" {
	type slave;
	file "exemplo.org";
};</programlisting>

	<para>No caso do secund&aacute;rio, a informa&ccedil;&atilde;o da zona &eacute;
	transferida do servidor de nomes prim&aacute;rio de uma zona em
	particular, e salvo no arquivo especificado.  Se e quando o
	servidor prim&aacute;rio morrer, ou estiver fora de alcance, o
	servidor de nomes secund&aacute;rio ter&aacute; a informa&ccedil;&atilde;o da zona
	transferida e ser&aacute; capaz de servi-la.</para>
      </sect3>

      <sect3>
	<title>Arquivos de Zona</title>

	<para>Um exemplo de arquivo de zona prim&aacute;rio para
	<hostid>exemplo.org</hostid> (existente no
	<filename>/etc/namedb/example.org</filename>) segue abaixo: </para>

	<programlisting>$TTL 3600

exemplo.org.  IN SOA ns1.exemplo.org.  admin.exemplo.org. (
			5	 ; Serial
			10800	 ; Refresh
			3600	 ; Retry
			604800	 ; Expire
			86400 )	 ; Minimum TTL

; Servidores DNS
@            IN NS      ns1.exemplo.org.
@            IN NS      ns2.exemplo.org.

; Nomes de M&aacute;quinas
localhost    IN A       127.0.0.1
ns1	     IN A       3.2.1.2
ns2	     IN A       3.2.1.3
mail	     IN A       3.2.1.10
@	     IN A       3.2.1.30

; Apelidos (aliases)
www	     IN CNAME	@

; Registro MX (MX Record)
@	     IN MX  10  mail.exemplo.org.</programlisting>

	<para>Note que cada nome de sistema que termina com um
	<quote>.</quote> &eacute; um nome exato, ao passo que tudo sem um
	<quote>.</quote> no final &eacute; referenciado &agrave; origem.
	Por exemplo, <literal>www</literal> &eacute; traduzido para
	<literal>www + origem</literal>.  Em nosso arquivo de zona
	fict&iacute;cio, nossa origem &eacute; <hostid>exemplo.org.</hostid>, ent&atilde;o
	<literal>www</literal> ser&aacute; traduzido para
	<hostid>www.exemplo.org.</hostid>.</para>

	<para>O formato de um arquivo de zona &eacute; como segue:</para>

	<programlisting>nomedoregistro      IN tipodoregistro  valor</programlisting>

	<indexterm>
	  <primary>DNS</primary>
	  <secondary>records</secondary>
	</indexterm>
	<para>Os registros DNS mais freq&uuml;entemente usados:</para>

	<variablelist>
	  <varlistentry>
	    <term>SOA</term>

	    <listitem><para>in&iacute;cio da zona de autoridade</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>NS</term>

	    <listitem><para>um servidor de nome
	    autoritativo</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>A</term>

	    <listitem><para>Um endere&ccedil;o de sistema (host address)</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>CNAME</term>

	    <listitem><para>o nome can&ocirc;nico para um apelido
	    (alias)</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>MX</term>

	    <listitem><para>servidor de correio (mail exchanger)</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>PTR</term>

	    <listitem><para>um ponteiro de nome de dom&iacute;nio (usado em
	    DNS reverso)</para></listitem>
	  </varlistentry>
	</variablelist>

	<programlisting>
exemplo.org.  IN SOA ns1.exemplo.org.  admin.exemplo.org. (
			5	 ; Serial
			10800	 ; Atualizar ap&oacute;s 3 horas
			3600	 ; Tentar novamente ap&oacute;s 1 hora
			604800	 ; Expirar ap&oacute;s 1 semana
			86400 )	 ; TTL m&iacute;nimo de 1 dia</programlisting>



	<variablelist>
	  <varlistentry>
	    <term><hostid>exemplo.org.</hostid></term>

	    <listitem><para>o nome de dom&iacute;nio, que tamb&eacute;m &eacute; a origem
	    para este arquivo de zona</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><hostid>ns1.exemplo.org.</hostid></term>

	    <listitem><para>o servidor de nome prim&aacute;rio/autoritativo
	    para esta zona</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><literal>admin.exemplo.org.</literal></term>

	    <listitem><para>o endere&ccedil;o de correio eletr&ocirc;nico da pessoa
	    respons&aacute;vel por esta zona, com a @ trocada.  (
	    <email>admin@exemplo.org</email> &eacute; substitu&iacute;do por
	    <literal>admin.exemplo.org</literal>)</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><literal>5</literal></term>

	      <listitem><para>o n&uacute;mero de s&eacute;rie do arquivo.  Deve ser
	      incrementado toda vez que o arquivo de zona &eacute; alterado.
	      Hoje em dia, muitos administradores preferem o formato
	      <literal>aaaammddii</literal> para o n&uacute;mero de s&eacute;rie.
	      2001041002 quer dizer que a &uacute;ltima modifica&ccedil;&atilde;o foi feita
	      em 10/04/2001, e os d&iacute;gitos 02 ao final, significam que
	      foi a segunda vez que o arquivo de zona foi alterado
	      nesse dia.</para></listitem>
	  </varlistentry>
	</variablelist>

	<programlisting>
@       IN NS	   ns1.exemplo.org.</programlisting>

	<para>Esta &eacute; uma entrada <varname>NS</varname>.  Cada servidor
	de nome que responder&aacute; autoritativamente pela zona deve ter
	uma destas entradas.  A <literal>@</literal> como aqui
	mostrada poderia ter sido 
	<hostid role="domainname">exemplo.org.</hostid>  A 
	<literal>@</literal> &eacute; traduzida pela origem.</para>

	<programlisting>
localhost    IN A    127.0.0.1
ns1	     IN A    3.2.1.2
ns2	     IN A    3.2.1.3
mail	     IN A    3.2.1.10
@	     IN A    3.2.1.30</programlisting>

	<para>O registro A indica nomes de m&aacute;quinas.  Como mostrado
	acima, <hostid>ns1.exemplo.org</hostid> resolveria para 
	<hostid role="ipaddr">3.2.1.2</hostid>.  De novo, o s&iacute;mbolo da
	origem, <literal>@</literal>, &eacute; usado aqui, significando que o 
	<hostid>exemplo.org</hostid> resolveria para 
	<hostid role="ipaddr">3.2.1.30</hostid>.</para>

	<programlisting>
www	     IN CNAME	@</programlisting>

	<para>O registro de nome can&ocirc;nico &eacute; geralmente usado para dar
	apelidos (aliases) para uma m&aacute;quina.  No exemplo, 
	<hostid>www</hostid> &eacute; apelidado como a m&aacute;quina endere&ccedil;ada
	para a origem, ou <hostid>exemplo.org</hostid> 
	(<hostid role="ipaddr">3.2.1.30</hostid>).
	<varname>CNAME</varname>s podem ser usados para fornecer
	apelidos a nomes de sistemas, ou efetuar rotatividade
	(round-robin) de um nome de sistema entre v&aacute;rias 
	m&aacute;quinas.</para>

	<programlisting>
@	       IN MX   10      mail.exemplo.org.</programlisting>

	<para>O registro <varname>MX</varname> indica quais servidores
	de correio s&atilde;o respons&aacute;veis por tratar correspond&ecirc;ncia 
	de entrada para a zona.  
	<hostid role="fqdn">mail.exemplo.org</hostid> &eacute; o nome do
	servidor de correio, e 10 a prioridade daquele servidor de
	correio.</para>

	<para>Algu&eacute;m pode ter v&aacute;rios servidores de correio, com
	prioridades de 3, 2 e 1.  Um servidor de correio tentando
	fazer uma entrega para 
	<hostid role="domainname">exemplo.org</hostid> tentaria
	primeiro o MX de maior prioridade, depois o de segunda maior e
	assim por diante, at&eacute; que o correio seja entregue
	corretamente.</para>

	<para>Para arquivos de zona in-addr.arpa (DNS reverso), o
	mesmo formato &eacute; usado, exceto pelo fato de conter entradas 
	<varname>PTR</varname> ao inv&eacute;s de <varname>A</varname> ou
	<varname>CNAME</varname>.</para>

	<programlisting>$TTL 3600

1.2.3.in-addr.arpa.  IN SOA ns1.exemplo.org.  admin.exemplo.org. (
			5	  ; Serial
			10800	  ; Refresh
			3600	  ; Retry
			604800	  ; Expire
			3600 )	  ; Minimum

@       IN NS   ns1.exemplo.org.
@       IN NS   ns2.exemplo.org.

2       IN PTR  ns1.exemplo.org.
3       IN PTR  ns2.exemplo.org.
10      IN PTR  mail.exemplo.org.
30      IN PTR  exemplo.org.</programlisting>

	<para>Este arquivo fornece o endere&ccedil;o IP adequado aos
	mapeamentos de nomes de sistemas de nosso dom&iacute;nio fict&iacute;cio
	acima.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Servidor Cache de Nomes</title>
      <indexterm>
	<primary>BIND</primary>
	<secondary>caching name server</secondary>
      </indexterm>

      <para>Um servidor de nome para cache &eacute; um tipo de servidor de
      nome que n&atilde;o &eacute; autoritativo autoritativo para nenhuma zona.  Ele
      simplesmente efetua buscas por conta pr&oacute;pria e se recorda delas
      para uso futuro.  Para configurar um, apenas configure o
      servidor de nome normalmente, omitindo quaisquer inclus&otilde;es de
      zonas.</para>

    </sect2>

    <sect2 id="network-named-sandbox">
      <title>Rodando o <application>named</application> Restrito a Um Diret&oacute;rio (Sandbox)</title>
      <indexterm>
	<primary>BIND</primary>
	<secondary>running in a sandbox</secondary>
      </indexterm>

      <indexterm>
	<primary><command>chroot</command></primary>
      </indexterm>

      <para>Para seguran&ccedil;a adicional, voc&ecirc; pode querer rodar o
      &man.named.8; com um usu&aacute;rio n&atilde;o privilegiado e configur&aacute;-lo
      para fazer &man.chroot.8; dentro de um diret&oacute;rio restrito 
      (sandbox).  Isto torna tudo fora da sandbox inacess&iacute;vel para o
      daemon <application>named</application>.  Caso o 
      <application>named</application> seja atacado, isto ajudar&aacute; 
      a reduzir os danos que podem ser causados.  Por padr&atilde;o, o
      FreeBSD tem um usu&aacute;rio e um grupo chamados
      <groupname>bind</groupname>, planejado para este uso.</para>

      <note><para>Diversas pessoas recomendariam que ao inv&eacute;s de
      configurar o <application>named</application> para fazer
      <command>chroot</command>, voc&ecirc; deveria rod&aacute;-lo dentro de um
      &man.jail.8;.  Esta se&ccedil;&atilde;o n&atilde;o tenta abordar esta situa&ccedil;&atilde;o.
      </para></note>


      <para>Uma vez que o <application>named</application> n&atilde;o ser&aacute;
      capaz de acessar nada fora da sandbox, (como bibliotecas
      compartilhadas, sockets de logs e assim por diante), h&aacute; uma
      s&eacute;rie de passos que devem ser seguidos para permitir o correto
      funcionamento do <application>named</application>.  Na seguinte
      lista de verifica&ccedil;&atilde;o, &eacute; assumido que o caminho para a sandbox &eacute;
      <filename>/etc/namedb</filename> e que voc&ecirc; n&atilde;o fez modifica&ccedil;&otilde;es
      pr&eacute;vias ao conte&uacute;do deste diret&oacute;rio.  Execute os seguintes
      passos como usu&aacute;rio <username>root</username>.</para>

      <itemizedlist>
	<listitem>
	  <para>Crie todos os diret&oacute;rios que o
	  <application>named</application> espera encontrar:</para>

	  <screen>&prompt.root; <userinput>cd /etc/namedb</userinput>
&prompt.root; <userinput>mkdir -p bin dev etc var/tmp var/run master slave</userinput>
&prompt.root; <userinput>chown bind:bind slave var/*</userinput><co id="chown-slave"></screen>



	  <calloutlist>
	    <callout arearefs="chown-slave">
	      <para>O <application>named</application> precisa de
	      acesso para grava&ccedil;&atilde;o somente nestes diret&oacute;rios, ent&atilde;o &eacute;
	      tudo que vamos lhe fornecer.</para>
	    </callout>
	  </calloutlist>
	</listitem>

	<listitem>
	  <para>Rearrume e crie uma zona b&aacute;sica e arquivos de
	  configura&ccedil;&atilde;o:</para>
	  <screen>&prompt.root; <userinput>cp /etc/localtime etc</userinput><co id="localtime">
&prompt.root; <userinput>mv named.conf etc && ln -sf etc/named.conf</userinput>
&prompt.root; <userinput>mv named.root master</userinput>
<!-- I don't like this next bit -->
&prompt.root; <userinput>sh make-localhost && mv localhost.rev localhost-v6.rev master</userinput>
&prompt.root; <userinput>cat > master/named.localhost
$ORIGIN localhost.
$TTL 6h
@	IN	SOA	localhost.  postmaster.localhost. (
			1	; serial
			3600	; refresh
			1800	; retry
			604800	; expiration
			3600 )	; minimum
	IN	NS	localhost.
	IN	A	127.0.0.1
^D</userinput></screen>

	  <calloutlist>
	    <callout arearefs="localtime">
	      <para>Isto permite ao <application>named</application> 
	      registrar a hora correta ao &man.syslogd.8;</para>
	    </callout>
	  </calloutlist>
	</listitem>

	<listitem>
	  <para>Se voc&ecirc; estiver rodando a vers&atilde;o de &os; anterior &agrave;
	  4.9-RELEASE, construa uma c&oacute;pia estaticamente compilada do 
	  <application>named-xfer</application> e a copie na sandbox:</para>

	      <screen>&prompt.root; <userinput>cd /usr/src/lib/libisc</userinput>
&prompt.root; <userinput>make cleandir && make cleandir && make depend && make all</userinput>
&prompt.root; <userinput>cd /usr/src/lib/libbind</userinput>
&prompt.root; <userinput>make cleandir && make cleandir && make depend && make all</userinput>
&prompt.root; <userinput>cd /usr/src/libexec/named-xfer</userinput>
&prompt.root; <userinput>make cleandir && make cleandir && make depend && make NOSHARED=yes all</userinput>
&prompt.root; <userinput>cp named-xfer /etc/namedb/bin && chmod 555 /etc/namedb/bin/named-xfer</userinput><co id="clean-cruft"></screen>

	  <para>Ap&oacute;s a instala&ccedil;&atilde;o do seu <command>named-xfer</command>
	   compilado estaticamente, uma faxina se faz necess&aacute;ria, para
	   evitar deixar c&oacute;pias envelhecidas de bibliotecas ou
	   programas na sua &aacute;rvore de fontes:</para>

	  <screen>&prompt.root; <userinput>cd /usr/src/lib/libisc</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>cd /usr/src/lib/libbind</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>cd /usr/src/libexec/named-xfer</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

	  <calloutlist>
	    <callout arearefs="clean-cruft">
	      <para>J&aacute; houveram relatos de que este passo pode
	      ocasionalmente falhar.  Se isto acontecer com voc&ecirc;,
	      ent&atilde;o use o comando:</para>

	      <screen>&prompt.root; <userinput>cd /usr/src && make cleandir && make cleandir</userinput></screen>

	      <para>and delete your <filename>/usr/obj</filename> tree:</para>

	      <screen>&prompt.root; <userinput>rm -fr /usr/obj && mkdir /usr/obj</userinput></screen>

		<para>Isto limpar&aacute; quaisquer <quote>restos</quote> de sua 
		&aacute;rvore de fontes, e, tentar novamente os passos acima
		dever&aacute; funcionar.</para>
	    </callout>
	  </calloutlist>

	  <para>Se voc&ecirc; est&aacute; rodando o &os; vers&atilde;o 4.9-RELEASE ou
	  posterior, ent&atilde;o a c&oacute;pia do <command>named-xfer</command> em
	  <filename>/usr/libexec</filename> &eacute; compilada estaticamente
	  por padr&atilde;o, e voc&ecirc; pode simplesmente usar &man.cp.1; para
	  copi&aacute;-la dentro da sua sandbox.</para>
	</listitem>

	<listitem>
	  <para>Crie um <devicename>dev/null</devicename> o qual o  
	  <application>named</application> possa ver e escrever:</para>

	  <screen>&prompt.root; <userinput>cd /etc/namedb/dev && mknod null c 2 2</userinput>
&prompt.root; <userinput>chmod 666 null</userinput></screen>
	</listitem>

	<listitem>
	  <para>Crie um link simb&oacute;lico <filename>/var/run/ndc</filename>
	   para <filename>/etc/namedb/var/run/ndc</filename>:</para>

	  <screen>&prompt.root; <userinput>ln -sf /etc/namedb/var/run/ndc /var/run/ndc</userinput></screen>

	  <note>
	    <para>Isto evita, de forma simples, ter que especificar a
	    op&ccedil;&atilde;o <option>-c</option> para o &man.ndc.8; cada vez que
	    voc&ecirc; execut&aacute;-lo.  Uma vez que o conte&uacute;do do /var/run s&atilde;o
	    apagados na inicializa&ccedil;&atilde;o (boot), se isto for algo que
	    voc&ecirc; considera &uacute;til voc&ecirc; pode adicionar este comando ao
	    crontab do root, usando a op&ccedil;&atilde;o <option>@reboot</option>.  
	    Veja &man.crontab.5; para mais informa&ccedil;&otilde;es a este
	    respeito.</para>
	  </note>

	</listitem>

	<listitem>
	  <para>Configure &man.syslogd.8; para criar mais um socket
	  de <devicename>log</devicename> no qual o 
	  <application>named</application> pode gravar.  Para isto,
	  adicione <literal>-l /etc/namedb/dev/log</literal> na
	  vari&aacute;vel <varname>syslogd_flags</varname> no 
	  <filename>/etc/rc.conf</filename>.</para>
	</listitem>

	<listitem>
	  <para>Configure para que o <application>named</application> 
	  seja inicializado e restrinja-se com 
	  <command>chroot</command> &agrave; sandbox adicionando o seguinte
	  ao <filename>/etc/rc.conf</filename>:</para>

	  <programlisting>named_enable="YES"
named_flags="-u bind -g bind -t /etc/namedb /etc/named.conf"</programlisting>

	  <note>
	    <para>Note que o arquivo de configura&ccedil;&atilde;o 
	    <replaceable>/etc/named.conf</replaceable> &eacute; declarado por
	    um caminho completo <emphasis>relativo &agrave; sandbox</emphasis>, 
	    p.ex.:  na linha acima, o arquivo referenciado &eacute;, na
	    verdade, <filename>/etc/namedb/etc/named.conf</filename>.</para>
	  </note>
	</listitem>
      </itemizedlist>

      <para>O pr&oacute;ximo passo &eacute; editar o
      <filename>/etc/namedb/etc/named.conf</filename> de forma que o 
      <application>named</application> saiba quais zonas carregar e
      onde encontr&aacute;-las no disco.  A seguir, um exemplo comentado
      (qualquer coisa n&atilde;o especificamente comentada aqui n&atilde;o &eacute;
      diferente da configura&ccedil;&atilde;o de um servidor DNS que n&atilde;o est&aacute;
      rodando dentro de uma sandbox):</para>

	<programlisting>options {
	directory "/";<co id="directory">
	named-xfer "/bin/named-xfer";<co id="named-xfer">
	version "";		// N&atilde;o revele a vers&atilde;o do BIND
	query-source address * port 53;
};
// socket de controle ndc
controls {
	unix "/var/run/ndc" perm 0600 owner 0 group 0;
};
// Zones a seguir:
zone "localhost" IN {
	type master;
	file "master/named.localhost";<co id="master">
	allow-transfer { localhost; };
	notify no;
};
zone "0.0.127.in-addr.arpa" IN {
	type master;
	file "master/localhost.rev";
	allow-transfer { localhost; };
	notify no;
};
zone "0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.int" {
	type master;
	file "master/localhost-v6.rev";
	allow-transfer { localhost; };
	notify no;
};
zone "." IN {
	type hint;
	file "master/named.root";
};
zone "private.example.net" in {
	type master;
	file "master/private.example.net.db";
	allow-transfer { 192.168.10.0/24; };
};
zone "10.168.192.in-addr.arpa" in {
	type slave;
	masters { 192.168.10.2; };
	file "slave/192.168.10.db";<co id="slave">
};</programlisting>

      <calloutlist>
	<callout arearefs="directory">
	  <para>A declara&ccedil;&atilde;o <literal>directory</literal> &eacute;
	  especificada como <filename>/</filename>, uma vez que todos
	  os arquivos que o <application>named</application> precisa
	  est&atilde;o dentro deste diret&oacute;rio (lembre-se de que isto equivale
	  ao <filename>/etc/namedb</filename> de um usu&aacute;rio 
	  <quote>normal</quote>).</para>
	</callout>

	<callout arearefs="named-xfer">
	  <para>Especifica o caminho completo para o arquivo bin&aacute;rio
	  <command>named-xfer</command> (do sistema de refer&ecirc;ncia do 
	  <application>named</application>).  Isto &eacute; necess&aacute;rio, uma
	  vez que o <application>named</application> &eacute; compilado para,
	  por padr&atilde;o, buscar o <command>named-xfer</command> no 
	  <filename>/usr/libexec</filename>.</para>
	</callout>
	<callout arearefs="master">
	  <para>Especifica o nome do arquivo (relativo &agrave; declara&ccedil;&atilde;o  
	  <literal>directory</literal> acima) onde o 
	  <application>named</application> pode encontrar o arquivo de
	  zona para esta zona.</para>
	</callout>
	<callout arearefs="slave">
	    <para>Especifica o nome do arquivo (relativo &agrave; declara&ccedil;&atilde;o
	     <literal>directory</literal> acima, onde o 
	     <application>named</application> deve gravar uma c&oacute;pia do
	     arquivo de zona para esta zona ap&oacute;s transferir a mesma
	     com sucesso do servidor mestre.  Por isto que precisamos
	     mudar a posse do diret&oacute;rio <filename>slave</filename> para 
	     <groupname>bind</groupname> nos passos de configura&ccedil;&atilde;o
	     acima.</para>
	</callout>
      </calloutlist>

      <para>Ap&oacute;s completar os passos acima, reinicie seu servidor ou o
      &man.syslogd.8; e inicie o &man.named.8;, certificando-se de
      usar as novas op&ccedil;&otilde;es especificadas em 
      <varname>syslogd_flags</varname> e
      <varname>named_flags</varname>.  Voc&ecirc; agora deve estar rodando
      uma c&oacute;pia restrita do <application>named</application>!</para>

    </sect2>

    <sect2>
      <title>Seguran&ccedil;a</title>

      <para>Apesar do BIND ser a implementa&ccedil;&atilde;o mais comum do DNS,
      sempre h&aacute; a quest&atilde;o da seguran&ccedil;a.  Furos poss&iacute;veis e
      explor&aacute;veis de seguran&ccedil;a s&atilde;o encontrados de vez em quando.</para>

      <para>&Eacute; uma boa id&eacute;ia assinar 
      <ulink url="http://www.cert.org/">CERT</ulink> e 
      <ulink
      url="../handbook/eresources.html#ERESOURCES-MAIL">freebsd-security-notifications</ulink> para se manter atualizado sobre as atuais quest&otilde;es 
      de seguran&ccedil;a na Internet e do FreeBSD.</para>

      <tip>
        <para>Se um problema surgir, manter os fontes atualizados e ter
      uma compila&ccedil;&atilde;o recente do named n&atilde;o &eacute; m&aacute; id&eacute;ia.</para>
      </tip>
    </sect2>

    <sect2>
      <title>Leitura adicional</title>
      <para>
	P&aacute;ginas de manual do BIND/named: &man.ndc.8; &man.named.8; &man.named.conf.5;
</para>

      <itemizedlist>
	<listitem>
	  <para><ulink
	   url="http://www.isc.org/products/BIND/">P&aacute;gina Oficial do ISC Bind</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink
	  url="http://www.nominum.com/getOpenSourceResource.php?id=6">
	  BIND FAQ</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink url="http://www.oreilly.com/catalog/dns4/">O'Reilly
	 DNS and BIND 4th Edition</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink
	      url="ftp://ftp.isi.edu/in-notes/rfc1034.txt">RFC1034
	      - Domain Names - Concepts and Facilities</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink
	      url="ftp://ftp.isi.edu/in-notes/rfc1035.txt">RFC1035
	      - Domain Names - Implementation and Specification</ulink></para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="network-ntp">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Hukins</surname>
	  <contrib>Contribu&iacute;do por </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>NTP</title>

    <indexterm><primary>NTP</primary></indexterm>

    <sect2>
      <title>Vis&atilde;o Geral</title>

      <para>Ao longo do tempo, o rel&oacute;gio de um computador tende
      a variar.  Enquanto o tempo passa, o rel&oacute;gio do computador se
      torna menos preciso.  O NTP (Network Time Protocol) &eacute; uma forma
      de assegurar que o seu rel&oacute;gio est&aacute; correto.</para>

      <para>Muitos servi&ccedil;os Internet dependem, ou muito se beneficiam,
      da precis&atilde;o do rel&oacute;gio do computador estar correto.  Por
      exemplo, um servidor Web pode receber solicita&ccedil;&otilde;es para enviar
      um arquivo se ele foi modificado desde uma certa hora.  Servi&ccedil;os
      como o &man.cron.8; executam comandos em uma hora espec&iacute;fica.
      Se o rel&oacute;gio est&aacute; errado, estes comandos podem n&atilde;o ser
      executados no momento esperado.</para>

      <indexterm>
	<primary>NTP</primary>
	<secondary>ntpd</secondary>
      </indexterm>
      <para>O FreeBSD &eacute; disponibilizado com o servidor &man.ntpd.8;
      que pode ser usado para consultar outros servidores NTP para
      ajustar o rel&oacute;gio em sua m&aacute;quina ou fornecer servi&ccedil;os de hora
      para outros.</para>
    </sect2>

    <sect2>
      <title>Escolhendo os Servidores NTP Adequados</title>

      <indexterm>
	<primary>NTP</primary>
	<secondary>choosing servers</secondary>
      </indexterm>

      <para>Para sincronizar seu rel&oacute;gio, voc&ecirc; vai precisar encontrar
      um ou mais servidores NTP para usar.  Seu administrador de rede
      ou Provedor de Servi&ccedil;os Internet podem ter configurado um
      servidor NTP para este prop&oacute;sito&mdash;verifique sua
      documenta&ccedil;&atilde;o para confirmar se este &eacute; o caso.  Existe uma
      <ulink
      url="http://www.eecis.udel.edu/~mills/ntp/servers.html">lista
      de servidores NTP publicamente acess&iacute;veis</ulink> os quais
      podem ser usados para encontrar um servidor NTP pr&oacute;ximo a voc&ecirc;.
      Certifique-se de estar ciente da pol&iacute;tica de qualquer
      servidor escolhido e, se necess&aacute;rio, solicite permiss&atilde;o para
      uso.</para>

      <para>Escolher alguns servidores NTP n&atilde;o conectados &eacute; uma boa
      id&eacute;ia no caso de algum dos servidores que voc&ecirc; estiver usando
      se tornar inalcan&ccedil;&aacute;vel ou seu rel&oacute;gio n&atilde;o for confi&aacute;vel.
      &man.ntpd.8; usa as respostas recebidas de outros servidores de
      forma inteligente&mdash;ele vai favorecer os servidores mais
      confi&aacute;veis em detrimento dos menos confi&aacute;veis.</para>
    </sect2>

    <sect2>
      <title>Configurando Sua M&aacute;quina</title>

      <indexterm>
	<primary>NTP</primary>
	<secondary>configuration</secondary>
      </indexterm>

      <sect3>
	<title>Configura&ccedil;&atilde;o B&aacute;sica</title>
	<indexterm><primary>ntpdate</primary></indexterm>

	<para>Se voc&ecirc; somente deseja sincronizar seu rel&oacute;gio quando a
	m&aacute;quina for inicializada, voc&ecirc; pode usar &man.ntpdate.8;.
	Isto pode ser adequado para algumas m&aacute;quinas desktop as quais
	s&atilde;o freq&uuml;entemente reinicializadas e necessitam somente de
	sincroniza&ccedil;&otilde;es esparsas, mas a maioria das m&aacute;quinas deveria
	executar &man.ntpd.8;.<para>

	<para>Usando &man.ntpdate.8; na inicializa&ccedil;&atilde;o tamb&eacute;m &eacute; uma boa
	id&eacute;ia para m&aacute;quinas que rodam &man.ntpd.8;.  O programa
	&man.ntpd.8; altera o rel&oacute;gio gradualmente, ao passo que o
	&man.ntpdate.8; ajusta o rel&oacute;gio, qualquer que seja a
	diferen&ccedil;a entre a hora atual do rel&oacute;gio e a hora correta.</para>

	<para>Para ativar o &man.ntpdate.8; durante a inicializa&ccedil;&atilde;o,
	adicione <literal>ntpdate_enable="YES"</literal> ao
	<filename>/etc/rc.conf</filename>.  Voc&ecirc; tamb&eacute;m vai precisar
	especificar todos os servidores com os quais deseja
	sincronizar e quaisquer par&acirc;metros a serem passados ao
	&man.ntpdate.8; em <varname>ntpdate_flags</varname>.</para>
      </sect3>

      <sect3>
	<indexterm>
	  <primary>NTP</primary>
	  <secondary>ntp.conf</secondary>
	</indexterm>

	<title>Configura&ccedil;&atilde;o Geral</title>

	<para>O NTP &eacute; configurado pelo arquivo
	<filename>/etc/ntp.conf</filename> no formato descrito em
	&man.ntp.conf.5;.  Aqui est&aacute; um exemplo simples:</para>

	<programlisting>server ntplocal.exemplo.com prefer
server timeserver.example.org
server ntp2a.example.net

driftfile /var/db/ntp.drift</programlisting>

	<para>A op&ccedil;&atilde;o <literal>server</literal> especifica quais
	servidores devem ser usados, com um servidor por linha.  Se um
	servidor &eacute; especificado com o argumento
	<literal>prefer</literal>, como em <hostid
	role="fqdn">ntplocal.exemplo.com</hostid>, este servidor &eacute;
	preferido sobre os demais servidores.  Uma resposta de um servidor
	preferido ser&aacute; descartada se ela diferir muito das respostas
	dos demais servidores, caso contr&aacute;rio ser&aacute; usada
	desconsiderando as outras respostas.  O argumento
	<literal>prefer</literal> normalmente &eacute; usado para servidores
	NTP que s&atilde;o reconhecidamente de alta precis&atilde;o, como os que
	possuem hardware especial para monitoramento da hora.</para>

	<para>A op&ccedil;&atilde;o <literal>driftfile</literal> especifica qual
	arquivo &eacute; usado para armazenar a compensa&ccedil;&atilde;o de freq&uuml;&ecirc;ncia do
	rel&oacute;gio do sistema.  O programa &man.ntpd.8; usa isto para
	compensar automaticamente as varia&ccedil;&otilde;es naturais do
	rel&oacute;gio, permitindo que seja mantida uma configura&ccedil;&atilde;o correta
	mesmo que seja cortada a conex&atilde;o de todas as fontes externas
	de hora durante um per&iacute;odo de tempo.</para>

	<para>A op&ccedil;&atilde;o <literal>driftfile</literal> especifica qual
	arquivo &eacute; usado para armazenar informa&ccedil;&otilde;es sobre as respostas
	recebidas anteriormente dos servidores NTP que voc&ecirc; estiver
	usando.  Este arquivo cont&eacute;m informa&ccedil;&otilde;es internas para o NTP.
	Ele n&atilde;o deve ser alterado por nenhum outro processo.</para>

      </sect3>

      <sect3>
	<title>Controlando acesso ao Seu Servidor</title>

	<para>Por padr&atilde;o, seu servidor NTP ser&aacute; acess&iacute;vel a todos os
	sistemas na Internet.  A op&ccedil;&atilde;o <literal>restrict</literal> em
	<filename>/etc/ntp.conf</filename> permite que voc&ecirc; controle
	quais m&aacute;quinas podem acessar seu servidor.</para>

	<para>Se voc&ecirc; quer negar acesso a todas as m&aacute;quinas ao seu
	servidor NTP, adicione a seguinte linha ao
	<filename>/etc/ntp.conf</filename>:</para>

	<programlisting>restrict default ignore</programlisting>

	<para>Se voc&ecirc; quer permitir que somente m&aacute;quinas em sua
	rede sincronizem seus rel&oacute;gios com seu servidor, mas
	assegurar que n&atilde;o lhes seja permitido configurar o servidor ou
	usada como pares (peers) de sincronismo, adicione</para>

	<programlisting>restrict 192.168.1.0 mask 255.255.255.0 notrust nomodify notrap</programlisting>

	<para>onde <hostid role="ipaddr">192.168.1.0</hostid>
	&eacute; um endere&ccedil;o IP em sua rede e <hostid
	role="netmask">255.255.255.0</hostid> &eacute; a m&aacute;scara de subrede
	de sua rede.</para>

	<para><filename>/etc/ntp.conf</filename> pode conter
	m&uacute;ltiplas op&ccedil;&otilde;es <literal>restrict</literal>.  Para mais
	detalhes, veja a subse&ccedil;&atilde;o <literal>Access Control Support</literal>
	de &man.ntp.conf.5;.</para>

      </sect3>
    </sect2>

    <sect2>
      <title>Executando o Servidor NTP</title>

      <para>Para assegurar que o servidor NTP &eacute; iniciado durante a
      inicializa&ccedil;&atilde;o, adicione a linha
      <literal>xntpd_enable="YES"</literal>.  Se voc&ecirc; deseja passar
      par&acirc;metros adicionais ao &man.ntpd.8;, edite o par&acirc;metro
      <varname>xntpd_flags</varname> no
      <filename>/etc/rc.conf</filename>.</para>

      <para>Para iniciar o servidor sem reinicializar a m&aacute;quina, rode
      <command>ntpd</command> certificando de especificar quaisquer
      par&acirc;metros adicionais de <varname>xntpd_flags</varname> em
      <filename>/etc/rc.conf</filename>.  Por exemplo:</para>
      <screen>&prompt.root;
      <userinput>ntpd -p /var/run/ntpd.pid</userinput></screen>

      <note>
	<para>No &os;&nbsp;5.X, v&aacute;rias op&ccedil;&otilde;es foram renomeadas no
	<filename>/etc/rc.conf</filename>.  Assim, voc&ecirc; vai ter que
	trocar cada ocorr&ecirc;ncia de <literal>xntpd</literal> por
	<literal>ntpd</literal> nas op&ccedil;&otilde;es acima.</para></note>
    </sect2>

    <sect2>
      <title>Usando o ntpd com uma Conex&atilde;o Internet Tempor&aacute;ria</title>

      <para>O programa &man.ntpd.8; n&atilde;o precisa de uma conex&atilde;o
      permanente &agrave; Internet para funcionar corretamente.
      Entretanto, se voc&ecirc; tem uma conex&atilde;o tempor&aacute;ria que est&aacute;
      configurada para discar por demanda, &eacute; uma boa id&eacute;ia evitar que
      o tr&aacute;fego NTP de disparar uma conex&atilde;o discada ou de manter a
      conex&atilde;o ativa.  Se voc&ecirc; estiver usando o usu&aacute;rio PPP, voc&ecirc; pode
      usar diretrizes <literal>filter</literal> em
      <filename>/etc/ppp/ppp.conf</filename>.  Por exemplo:</para>

      <programlisting> set filter dial 0 deny udp src eq 123
 # Prevent NTP traffic from initiating dial out
 set filter dial 1 permit 0 0
 set filter alive 0 deny udp src eq 123
 # Prevent incoming NTP traffic from keeping the connection open
 set filter alive 1 deny udp dst eq 123
 # Prevent outgoing NTP traffic from keeping the connection open
 set filter alive 2 permit 0/0 0/0</programlisting>

      <para>Para maiores detalhes, veja a se&ccedil;&atilde;o <literal>FILTRAGEM DE
      PACOTES</literal> em &man.ppp.8; e os exemplos em
      <filename>/usr/share/examples/ppp/</filename>.</para>

      <note>
	<para>Alguns provedores de acesso Internet bloqueiam portas de
	n&uacute;meros baixos impedindo o NTP de funcionar, uma vez que as
	respostas nunca alcan&ccedil;am sua m&aacute;quina.</para>
      </note>
    </sect2>

    <sect2>
      <title>Mais Informa&ccedil;&otilde;es</title>

      <para>Documenta&ccedil;&atilde;o para o servidor NTP podem ser encontradas em
      <filename>/usr/share/doc/ntp/</filename> em formato HTML.</para>
    </sect2>
  </sect1>

  <sect1 id="network-natd">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Chern</firstname>
	  <surname>Lee</surname>
	  <contrib>Contribu&iacute;do por </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>NAT - Tradu&ccedil;&atilde;o de Endere&ccedil;o de Rede</title>

    <sect2 id="network-natoverview">
      <title>Vis&atilde;o Geral</title>
      <indexterm>
	<primary><application>natd</application></primary>
      </indexterm>
      <para>O daemon de Tradu&ccedil;&atilde;o de Endere&ccedil;o de Rede do FreeBSD,
      geralmente conhecido como &man.natd.8; &eacute; o daemon que aceita
      pacotes IP entrantes n&atilde;o modificados, altera a origem para a
      m&aacute;quina local e re-injeta estes pacotes de volta ao fluxo de
      pacotes IP que saem.  &man.natd.8; faz isso mudando o endere&ccedil;o IP
      de origem e a porta, de forma que, quando o dado &eacute; recebido de
      volta, &eacute; capaz de determinar sua localiza&ccedil;&atilde;o original e
      repass&aacute;-lo ao seu solicitante original.</para>

      <indexterm><primary>Internet connection sharing</primary></indexterm>
      <indexterm><primary>IP masquerading</primary></indexterm>
      <para>O uso mais comum do NAT &eacute; executar o que &eacute; mais geralmente
      conhecido como Compartilhamento de Conex&atilde;o Internet.</para>
    </sect2>

    <sect2 id="network-natsetup">
      <title>Estrutura</title>
      <para>Dada a redu&ccedil;&atilde;o do espa&ccedil;o de endere&ccedil;amento IP no IPv4, e o
      elevado n&uacute;mero de usu&aacute;rios em linhas de alta velocidade para
      consumidores, como cabo ou DSL, as pessoas est&atilde;o
      progressivamente precisando de uma solu&ccedil;&atilde;o de Compartilhamento
      de Conex&atilde;o Internet.  A capacidade de conectar v&aacute;rios
      computadores em linha (online) atrav&eacute;s de uma conex&atilde;o e endere&ccedil;o 
      IP torna o &man.natd.8; uma escolha razo&aacute;vel.</para>


      <para>Freq&uuml;entemente, um usu&aacute;rio tem uma m&aacute;quina conectada a uma
      linha DSL ou cabo com um endere&ccedil;o IP e deseja usar este
      computador conectado para oferecer acesso Internet a diversos
      mais atrav&eacute;s de uma rede local.</para>

      <para>Para isto, a m&aacute;quina FreeBSD na Internet precisa atuar
      como um gateway.  Esta m&aacute;quina precisa ter duas placas de rede
      &mdash;uma para conectar ao roteador Internet, a outra para
      conectar a uma rede local.  Todas as m&aacute;quinas na rede local s&atilde;o
      conectadas atrav&eacute;s de um concentrador ou comutador.</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="advanced-networking/natd">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced">  _______       __________       ________
 |       |     |	  |     |	|
 |  Hub  |-----| Client B |-----| Router |----- Internet
 |_______|     |__________|     |________|
     |
 ____|_____
|	  |
| Client A |
|__________|</literallayout>
	</textobject>

	<textobject>
	  <phrase>Diagrama da Rede</phrase>
	</textobject>
      </mediaobject>

      <para>Uma configura&ccedil;&atilde;o como esta &eacute; geralmente usada para
      compartilhar uma conex&atilde;o Internet.  Uma das m&aacute;quinas da
      <acronym>LAN</acronym> est&aacute; conectada &agrave; Internet.  As demais
      m&aacute;quinas acessam a Internet atrav&eacute;s daquela m&aacute;quina
      <quote>gateway</quote>.</para>
    </sect2>

    <sect2 id="network-natdkernconfiguration">
      <indexterm>
	<primary>kernel</primary>
	<secondary>configuration</secondary>
      </indexterm>
      <title>Configura&ccedil;&atilde;o</title>
      <para>As seguintes op&ccedil;&otilde;es precisam estar no arquivo de
      configura&ccedil;&atilde;o do kernel:</para>
      <programlisting>options IPFIREWALL
options IPDIVERT</programlisting>

      <para>Adicionalmente, por escolha, o seguinte tamb&eacute;m pode ser
      apropriado:</para>
      <programlisting>options IPFIREWALL_DEFAULT_TO_ACCEPT
options IPFIREWALL_VERBOSE</programlisting>

      <para>As seguintes linhas precisam estar no
      <filename>/etc/rc.conf</filename>:</para>

      <programlisting>gateway_enable="YES"
firewall_enable="YES"
firewall_type="OPEN"
natd_enable="YES"
natd_interface="<replaceable>fxp0</replaceable>"
natd_flags=""</programlisting>

      <informaltable frame="none">
	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry>gateway_enable="YES"</entry>
	      <entry>Configura a m&aacute;quina parar atuar como um gateway.
	      Executando
	      <command>sysctl net.inet.ip.forwarding=1</command>
	      causaria o mesmo efeito.</entry>
	    </row>
	    <row><entry>firewall_enable="YES"</entry>
	     <entry>Ativa as regras do firewall em
	     <filename>/etc/rc.firewall</filename> durante a
	     inicializa&ccedil;&atilde;o.</entry>
	    </row>
	    <row><entry>firewall_type="OPEN"</entry>
	      <entry>Isto especifica um conjunto predefinido de
	      regras do firewall, permitindo a entrada de qualquer
	      coisa.  Veja <filename>/etc/rc.firewall</filename>
	      para tipos adicionais.</entry>
	    </row>
	    <row>
	      <entry>natd_interface="fxp0"</entry>
	      <entry>Indica a qual interface repassar pacotes (a
	      interface conectada &agrave; Internet).</entry>
	    </row>
	    <row>
	      <entry>natd_flags=""</entry>
	      <entry>Qualquer das op&ccedil;&otilde;es de configura&ccedil;&atilde;o passadas ao
	      &man.natd.8; durante a inicializa&ccedil;&atilde;o.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Tendo as op&ccedil;&otilde;es anteriores definidas em
      <filename>/etc/rc.conf</filename> seria executado
      <command>natd -interface fxp0</command> durante a inicializa&ccedil;&atilde;o.
      Ele tamb&eacute;m pode ser executado manualmente.</para>

      <para>Cada m&aacute;quina e interface na rede local deveria ter
      n&uacute;meros de endere&ccedil;os IP atribu&iacute;dos no espa&ccedil;o de rede privado
      como definido por <ulink
      url="ftp://ftp.isi.edu/in-notes/rfc1918.txt">RFC 1918</ulink>
      e ter como o gateway padr&atilde;o, o endere&ccedil;o IP interno da
      m&aacute;quina <application>natd</application>.</para>

      <para>Por exemplo, o cliente <hostid>A</hostid> e
      <hostid>B</hostid> na rede local possuem endere&ccedil;os IP
      <hostid role="ipaddr">192.168.0.2</hostid> e
      <hostid role="ipaddr">192.168.0.3</hostid>, enquanto a
      interface de rede local da m&aacute;quina executando o natd possui o
      endere&ccedil;o IP <hostid role="ipaddr">192.168.0.1</hostid>.  O
      gateway padr&atilde;o dos clientes <hostid>A</hostid> e
      <hostid>B</hostid> precisa ser o da m&aacute;quina com natd, <hostid
      role="ipaddr">192.168.0.1</hostid>.  A interface externa, ou
      Internet, da m&aacute;quina com natd n&atilde;o requer nenhuma modifica&ccedil;&atilde;o
      especial para o funcionamento do &man.natd.8;.</para>
    </sect2>

    <sect2 id="network-natdport-redirection">
      <title>Redirecionamento de Porta</title>

      <para>A desvantagem do &man.natd.8; &eacute; que os clientes da rede
      local n&atilde;o s&atilde;o diretamente acess&iacute;veis a partir da Internet.  Os
      clientes dentro da rede local podem fazer conex&otilde;es saindo para o
      mundo, mas n&atilde;o podem receber conex&otilde;es vindas de fora.  Isto
      apresenta um problema ao se tentar executar servi&ccedil;os Internet em
      uma das m&aacute;quinas cliente da rede local.  Uma forma simples de
      contornar isto &eacute; redirecionando certas portas Internet na
      m&aacute;quina com <application>natd</application> para um cliente da
      rede local.</para>

      <para>Por exemplo, um servidor IRC roda em um cliente
      <hostid>A</hostid>, e um servidor web em um cliente
      <hostid>B</hostid>.  Para que isto funcione corretamente, as conex&otilde;es
      recebidas nas portas 6667 (IRC) e 80 (web) precisam ser
      redirecionadas para as respectivas m&aacute;quinas.</para>

      <para>Um <option>-redirect_port</option> precisa ser passado ao
      &man.natd.8; com as op&ccedil;&otilde;es adequadas.  A sintaxe &eacute; a seguinte:</para>
      <programlisting>     -redirect_port proto targetIP:targetPORT[-targetPORT]
		 [aliasIP:]aliasPORT[-aliasPORT]
		 [remoteIP[:remotePORT[-remotePORT]]]</programlisting>

      <para>No exemplo acima, o argumento deve ser:</para>

	<programlisting>    -redirect_port tcp 192.168.0.2:6667 6667
    -redirect_port tcp 192.168.0.3:80 80</programlisting>

      <para>Isto ir&aacute; direcionar as portas <emphasis>tcp</emphasis>
      corretas para as m&aacute;quinas clientes da rede local.</para>

      <para>Um argumento <option>-redirect_port</option> pode ser
      usado para indicar faixas de portas al&eacute;m de portas individuais.
      Por exemplo, <replaceable>tcp 192.168.0.2:2000-3000
      2000-3000</replaceable> redirecionaria todas as conex&otilde;es
      recebidas nas portas 2000 a 3000 para portas 2000 a 3000 no
      cliente <hostid>A</hostid>.</para>

      <para>Estas op&ccedil;&otilde;es podem ser usadas executando diretamente o
      &man.natd.8;, ou inseridas na op&ccedil;&atilde;o
      <literal>natd_flags=""</literal> em
      <filename>/etc/rc.conf</filename>.</para>

      <para>Para mais op&ccedil;&otilde;es de configura&ccedil;&atilde;o, consulte &man.natd.8;.</para>
    </sect2>

    <sect2 id="network-natdaddress-redirection">
      <title>Redirecionamento de Endere&ccedil;o</title>
      <indexterm><primary>address redirection</primary></indexterm>
      <para>Redirecionamento de endere&ccedil;o &eacute; &uacute;til se v&aacute;rios endere&ccedil;os IP
      est&atilde;o dispon&iacute;veis, mesmo que eles precisem estar em uma m&aacute;quina.
      Com isto, o &man.natd.8; pode designar cada cliente da rede local
      com seu pr&oacute;prio endere&ccedil;o externo.  O &man.natd.8; ent&atilde;o
      reescreve os pacotes de sa&iacute;da dos clientes da rede local com o
      endere&ccedil;o IP externo apropriado e redireciona todo o tr&aacute;fego de
      entrada para aquele endere&ccedil;o IP de volta ao cliente da rede
      local espec&iacute;fico.  Isto tamb&eacute;m &eacute; conhecido como NAT est&aacute;tico.
      Por exemplo, os endere&ccedil;os IP
      <hostid role="ipaddr">128.1.1.1</hostid>,
      <hostid role="ipaddr">128.1.1.2</hostid> e
      <hostid role="ipaddr">128.1.1.3</hostid> pertencem &agrave; maquina
      gateway com <application>natd</application>.  O <hostid
      role="ipaddr">128.1.1.1</hostid> pode ser usado como o
      endere&ccedil;o IP externo da m&aacute;quina gateway, enquanto
      <hostid role="ipaddr">128.1.1.2</hostid> e
      <hostid role="ipaddr">128.1.1.3</hostid> s&atilde;o repassados de volta
      aos clientes <hostid>A</hostid> e <hostid>B</hostid> da rede
      local.</para>

      <para>A sintaxe de <option>-redirect_address</option> &eacute; a
      seguinte:</para>

      <programlisting>-redirect_address IPlocal IPp&uacute;blico</programlisting>


      <informaltable frame="none">
	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry>IPlocal</entry>
	      <entry>O endere&ccedil;o IP interno do cliente da rede local.</entry>
	    </row>
	    <row>
	      <entry>IPp&uacute;blico</entry>
	      <entry>O endere&ccedil;o IP externo correspondente ao cliente
	      da rede local.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>No exemplo, este argumento seria escrito:</para>

      <programlisting>-redirect_address 192.168.0.2 128.1.1.2
-redirect_address 192.168.0.3 128.1.1.3</programlisting>

      <para>Como <option>-redirect_port</option>, estes argumentos
      tamb&eacute;m s&atilde;o inseridos na op&ccedil;&atilde;o <literal>natd_flags=""</literal> do
      <filename>/etc/rc.conf</filename>.  Com redirecionamento de
      endere&ccedil;o, n&atilde;o h&aacute; necessidade de redirecionamento de porta, uma
      vez que todos os dados recebidos em um endere&ccedil;o IP em particular
      s&atilde;o redirecionados.</para>

      <para>Os endere&ccedil;os IP externos na m&aacute;quina com
      <application>natd</application> precisam ser ativos como
      secund&aacute;rios na interface externa.  Veja como fazer em
      &man.rc.conf.5;.</para>
    </sect2>
  </sect1>

  <sect1 id="network-inetd">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Chern</firstname>
	  <surname>Lee</surname>
	  <contrib>Contribu&iacute;do por </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>O <quote>Super-Servidor</quote> <application>inetd</application></title>

    <sect2 id="network-inetd-overview">
      <title>Vis&atilde;o Geral</title>

      <para>O &man.inetd.8; &eacute; chamado de <quote>Super-Servidor
      Internet</quote> porque ele gerencia conex&otilde;es para diversos
      daemons.  O <application>inetd</application> atua como um
      servidor gerenciador para outros daemons.  Quando uma conex&atilde;o &eacute;
      recebida pelo <application>inetd</application>, ele determina
      para qual daemon a conex&atilde;o &eacute; destinada e executa o daemon
      correspondente e a ele delega o socket.  Executar uma inst&acirc;ncia
      do <application>inetd</application> reduz a carga no sistema de
      forma geral, comparado a se executar cada daemon
      individualmente.</para>


      <para>Primariamente, o <application>inetd</application> &eacute; usado
      para executar outros daemons, mas diversos protocolos simples
      s&atilde;o tratados diretamente, como
      <application>chargen</application>,
      <application>auth</application> e
      <application>daytime</application>.</para>

      <para>Esta se&ccedil;&atilde;o vai abordar as configura&ccedil;&otilde;es b&aacute;sicas do
      <application>inetd</application> atrav&eacute;s de seus par&acirc;metros de
      linha de comando e seu arquivo de configura&ccedil;&atilde;o
      <filename>/etc/inetd.conf</filename>.</para>
    </sect2>

    <sect2 id="network-inetd-settings">
      <title>Configura&ccedil;&otilde;es</title>

      <para>O <application>inetd</application> &eacute; inicializado atrav&eacute;s
      do sistema <filename>/etc/rc.conf</filename>.  A op&ccedil;&atilde;o
      <literal>inetd_enable</literal> &eacute; ajustada para
      <quote>NO</quote>, por padr&atilde;o, mas &eacute; muitas vezes ativada pelo
      <application>sysinstall</application> com o perfil de
      seguran&ccedil;a m&eacute;dio.  Colocando:
	<programlisting>inetd_enable="YES"</programlisting> or
	<programlisting>inetd_enable="NO"</programlisting> no
	<filename>/etc/rc.conf</filename> pode ativar ou desativar a
	execu&ccedil;&atilde;o do <application>inetd</application> na inicializa&ccedil;&atilde;o
	do sistema.</para>

      <para>Adicionalmente, par&acirc;metros de linha de comando
      podem ser passados para o <application>inetd</application>
      atrav&eacute;s da op&ccedil;&atilde;o <literal>inetd_flags</literal>.</para>
    </sect2>

    <sect2 id="network-inetd-cmdline">
      <title>Op&ccedil;&otilde;es de Linha de Comando</title>

      <para>Sinopse do <application>inetd</application>:</para>

      <para><option>     inetd [-d] [-l] [-w] [-W] [-c m&aacute;ximo]
      [-C taxa] [-a endere&ccedil;o | nome-do-sistema] [-p nome do arquivo]
      [-R taxa] [arquivo de configura&ccedil;&atilde;o]</option></para>

      <variablelist>
	<varlistentry>
	  <term>-d</term>

	  <listitem>
	    <para>Ativa a depura&ccedil;&atilde;o.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-l</term>

	  <listitem>
	    <para>Ativa o registro das conex&otilde;es bem sucedidas.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-w</term>

	  <listitem>
	    <para>Ativa o encapsulamento TCP para servi&ccedil;os externos
	    (ativado por padr&atilde;o).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-W</term>

	  <listitem>
	    <para>Ativa o encapsulamento do TCP para servi&ccedil;os internos
	    que s&atilde;o embutidos no <application>inetd</application>
	    (ativado por padr&atilde;o).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-c m&aacute;ximo</term>

	  <listitem>
	    <para>Especifica o n&uacute;mero m&aacute;ximo padr&atilde;o de invoca&ccedil;&otilde;es
	    simult&acirc;neas de cada servi&ccedil;o; o padr&atilde;o &eacute; ilimitado.  Pode
	    ser anulado em cada servi&ccedil;o com o par&acirc;metro
	    <option>max-child</option>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-C taxa</term>

	  <listitem>
	    <para>Especifica o n&uacute;mero m&aacute;ximo padr&atilde;o de vezes que um
	    servi&ccedil;o pode ser invocado a partir de um &uacute;nico endere&ccedil;o IP
	    em um minuto; o padr&atilde;o &eacute; ilimitado.  Pode ser cancelado,
	    por servi&ccedil;o, com o par&acirc;metro
	    <option>max-conex&otilde;es-por-ip-por-minuto</option>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-R taxa</term>

	  <listitem>
	    <para>Especifica o n&uacute;mero m&aacute;ximo de vezes que um servi&ccedil;o
	    pode ser invocado em um minuto; o padr&atilde;o &eacute; 256.  Uma taxa
	    de 0 permite um n&uacute;mero ilimitado de invoca&ccedil;&otilde;es.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-a</term>

	  <listitem>
	    <para>Especifica um &uacute;nico endere&ccedil;o IP para ser unido.
	    Alternativamente, um nome de sistema pode ser
	    especificado, e neste caso, o endere&ccedil;o IPv4 ou IPV6 que
	    corresponder &agrave;quele nome &eacute; usado. Habitualmente um nome de
	    sistema &eacute; especificado quando o
	    <application>inetd</application> &eacute; executado dentro de um
	    &man.jail.8;, e neste caso, o nome do sistema corresponde
	    ao ambiente do &man.jail.8;.</para>

	    <para>Quando o &eacute; usado o nome do sistema e uni&atilde;o com ambos
	    endere&ccedil;os IPv4 e IPv6 &eacute; desejada, uma entrada com o
	    tipo apropriado de protocolo para cada uni&atilde;o &eacute; exigida
	    para cada servi&ccedil;o, no
	    <filename>/etc/inetd.conf</filename>.  Por exemplo, um
	    servi&ccedil;o baseado em TCP precisaria de duas entradas, uma
	    usando <quote>tcp4</quote> para o protocolo e outra usando
	    <quote>tcp6</quote>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-p</term>

	  <listitem>
	    <para>Especifica um arquivo alternativo para armazenar o
	    ID do processo.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Estas op&ccedil;&otilde;es podem ser passadas ao
      <application>inetd</application> usando a op&ccedil;&atilde;o
      <literal>inetd_flags</literal> no
      <filename>/etc/rc.conf</filename>. Por padr&atilde;o, o
      <literal>inetd_flags</literal> &eacute; ajustado para <quote>-wW</quote>,
      que ativa o encapsulamento TCP para os servi&ccedil;os
      <application>inetd</application> internos e externos.  Para
      usu&aacute;rios novatos, estes par&acirc;metros geralmente n&atilde;o precisam ser
      modificados ou mesmo inclu&iacute;dos no
      <filename>/etc/rc.conf</filename>.</para>

      <note>
	<para>Um servi&ccedil;o externo &eacute; um daemon fora do
	<application>inetd</application>, que &eacute; invocado quando uma
	conex&atilde;o &eacute; recebida para ele.  Por outro lado, um servi&ccedil;o
	interno &eacute; um que o <application>inetd</application> possui os
	meios de fornecer por si pr&oacute;prio.</para>
      </note>

    </sect2>

    <sect2 id="network-inetd-conf">
      <title><filename>inetd.conf</filename></title>

      <para>A configura&ccedil;&atilde;o do <application>inetd</application> &eacute;
      controlada atrav&eacute;s do arquivo
      <filename>/etc/inetd.conf</filename>.</para>

      <para>Quando uma modifica&ccedil;&atilde;o &eacute; feita no
      <filename>/etc/inetd.conf</filename>, o
      <application>inetd</application> pode ser for&ccedil;ado a reler seu
      arquivo de configura&ccedil;&atilde;o enviando um sinal HangUP ao processo
      <application>inetd</application>, como mostrado:</para>

      <example id="network-inetd-hangup">
	<title>Enviando um Sinal HangUP ao <application>inetd</application></title>

	<screen>&prompt.root; <userinput>kill -HUP `cat /var/run/inetd.pid`</userinput></screen>
      </example>

      <para>Cada linha do arquivo de configura&ccedil;&atilde;o especifica um daemon
      individual.  Coment&aacute;rios no arquivo s&atilde;o precedidos por um
      <quote>#</quote>.  O formato do
      <filename>/etc/inetd.conf</filename> &eacute; o seguinte:</para>

      <programlisting>nome-do-servi&ccedil;o
tipo-de-socket
protocolo
{wait|nowait}[/max-de-filhos[/max-de-conex&otilde;es-por-ip-por-minuto]]
usu&aacute;rio[:grupo][/classe-de-login]
programa-servidor
argumentos-do-programa-servidor</programlisting>

      <para>Uma entrada de exemplo para o daemon
      <application>ftpd</application> usando IPv4:</para>

      <programlisting>ftp     stream tcp     nowait root    /usr/libexec/ftpd       ftpd -l</programlisting>

      <variablelist>
	<varlistentry>
	  <term>nome-do-servi&ccedil;o</term>

	  <listitem>
	    <para>Este &eacute; o nome do servi&ccedil;o do daemon em quest&atilde;o.  Ele
	    precisa corresponder ao servi&ccedil;o listado no
	    <filename>/etc/services</filename>.  Isto determina qual
	    porta o <application>inetd</application> precisa escutar.
	    Se um novo servi&ccedil;o est&aacute; sendo criado, ele precisa ser
	    colocado primeiro no <filename>/etc/services</filename>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>tipo-de-socket</term>

	  <listitem>
	    <para>Pode ser <literal>stream</literal>,
	      <literal>dgram</literal>, <literal>raw</literal>, ou
	      <literal>seqpacket</literal>.  <literal>stream</literal>
	      precisa ser usado para daemons TCP baseados em conex&atilde;o,
	      enquanto <literal>dgram</literal> &eacute; usado para daemons
	      usando o protocolo de transporte UDP.
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>protocolo</term>

	  <listitem>
	    <para>Um dos seguintes:</para>

	    <informaltable>
	      <tgroup cols="2">
		<thead>
		  <row>
		    <entry>Protocolo</entry>
		    <entry>Descri&ccedil;&atilde;o</entry>
		  </row>
		</thead>
		<tbody>
		  <row>
		    <entry>tcp, tcp4</entry>
		    <entry>TCP IPv4</entry>
		  </row>
		  <row>
		    <entry>udp, udp4</entry>
		    <entry>UDP IPv4</entry>
		  </row>
		  <row>
		    <entry>tcp6</entry>
		    <entry>TCP IPv6</entry>
		  </row>
		  <row>
		    <entry>udp6</entry>
		    <entry>UDP IPv6</entry>
		  </row>
		  <row>
		    <entry>tcp46</entry>
		    <entry>Ambos TCP IPv4 e v6</entry>
		  </row>
		  <row>
		    <entry>udp46</entry>
		    <entry>Ambos UDP IPv4 e v6</entry>
		  </row>
		</tbody>
	      </tgroup>
	    </informaltable>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>{wait|nowait}[/max-de-filhos[/max-de-conex&otilde;es-por-ip-por-minuto]]</term>

	  <listitem>
	    <para><option>wait|nowait</option> indica se o daemon
	    invocado pelo <application>inetd</application> &eacute; capaz de
	    lidar com seu pr&oacute;prio socket ou n&atilde;o.
	    Sockets do tipo <option>dgram</option> precisam usar a
	    op&ccedil;&atilde;o wait, enquanto daemons de sockets tipo stream, os
	    quais geralmente s&atilde;o multi-threaded, devem usar a op&ccedil;&atilde;o
	    <option>nowait</option>.  <option>wait</option> geralmente
	    repassa m&uacute;ltiplos sockets para um &uacute;nico daemon, enquanto
	    <option>nowait</option> dispara um daemon filho para cada
	    novo socket.</para>

	    <para>O n&uacute;mero m&aacute;ximo de daemons filho que o
	    <application>inetd</application> pode disparar pode ser
	    ajustado usando a op&ccedil;&atilde;o <option>max-de-filhos</option>.
	    Se um limite de dez inst&acirc;ncias de um daemon em particular
	    &eacute; necess&aacute;ria, um <literal>/10</literal> deve ser colocado
	    ap&oacute;s a op&ccedil;&atilde;o <option>nowait</option>.</para>

	    <para>Al&eacute;m de <option>max-de-filhos</option>, outra op&ccedil;&atilde;o
	    pode ser ativada para limitar o n&uacute;mero m&aacute;ximo de conex&otilde;es
	    a partir de um &uacute;nico lugar para um daemon em particular.
	    O <option>max-conex&otilde;es-por-ip-por-minuto</option> faz
	    justamente isto.  Um valor de dez nesta op&ccedil;&atilde;o limitaria
	    qualquer endere&ccedil;o IP a se conectar a determinado servi&ccedil;o a
	    dez tentativas por minuto.  Isto &eacute; &uacute;til para evitar
	    consumo de recursos intencional ou n&atilde;o e ataques de
	    Nega&ccedil;&atilde;o de Servi&ccedil;o (Denial of service - DoS) para
	    a m&aacute;quina.</para>

	    <para>Neste campo, <option>wait</option> ou
	    <option>max-de-filhos</option> e
	    <option>max-conex&otilde;es-por-ip-por-minuto</option> s&atilde;o
	    opcionais.</para>


	    <para>Um daemon multi-threaded do tipo stream sem qualquer
	    limites <option>max-de-filhos</option> ou
	    <option>max-conex&otilde;es-por-ip-por-minuto</option> seria
	    simplesmente: <literal>nowait</literal>.</para>

	    <para>O mesmo daemon com um limite m&aacute;ximo de dez daemons
	    seria: <literal>nowait/10</literal></para>

	    <para>Adicionalmente, a mesma configura&ccedil;&atilde;o com um limite
	    de vinte conex&otilde;es por endere&ccedil;o IP por minuto e um limite
	    total m&aacute;ximo de dez daemons filhos seria:
	    <literal>nowait/10/20</literal>.</para>

	    <para>Estas op&ccedil;&otilde;es s&atilde;o todas utilizadas pela configura&ccedil;&atilde;o
	    padr&atilde;o do daemon <application>fingerd</application>, como
	    visto aqui:</para>

	    <programlisting>finger stream tcp     nowait/3/10 nobody /usr/libexec/fingerd fingerd -s</programlisting>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>usu&aacute;rio</term>

	  <listitem>
	    <para>O usu&aacute;rio &eacute; o nome do usu&aacute;rio atrav&eacute;s do qual o daemon
	    espec&iacute;fico deve ser executado.  Mais freq&uuml;entemente,
	    daemons rodam com o usu&aacute;rio <username>root</username>.  Por
	    prop&oacute;sito de seguran&ccedil;a, &eacute; comum encontrar alguns
	    servidores rodando como o usu&aacute;rio
	    <username>daemon</username>, ou o usu&aacute;rio com menos
	    privil&eacute;gios, <username>nobody</username>.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>programa-servidor</term>

	  <listitem>
	    <para>O caminho completo do daemon a ser executado quando
	    uma conex&atilde;o &eacute; recebida.  Se o daemon &eacute; um servi&ccedil;o a ser
	    fornecido internamente pelo
	    <application>inetd</application>, ent&atilde;o
	    <option>internal</option> deve ser utilizado.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>argumentos-do-programa-servidor</term>

	  <listitem>
	    <para>Este funciona em conjunto com
	    <option>program-servidor</option> especificando os
	    argumentos, iniciando com o argv[0], passado ao daemon no
	    momento da invoca&ccedil;&atilde;o.  Se
	    <application>meudaemon -d</application> &eacute; a linha de
	    comando, <literal>meudaemon -d</literal> seria o valor de
	    <option>argumentos do programa servidor</option>.
	    Novamente, se o daemon &eacute; um servi&ccedil;o interno, use
	    <option>internal</option> aqui.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="network-inetd-security">
      <title>Seguran&ccedil;a</title>

      <para>Dependendo do perfil de seguran&ccedil;a selecionado durante a
      instala&ccedil;&atilde;o, muitos daemons do <application>inetd</application>
      podem ser ativados por padr&atilde;o.  Se n&atilde;o h&aacute; necessidade aparente
      para um daemon em particular, desative-o!  Coloque um
      <quote>#</quote> na frente do daemon em quest&atilde;o e envie um
      <link linkend="network-inetd-hangup">sinal de hangup para o
      inetd</link>.  Alguns daemons como o
      <application>fingerd</application>, podem ser totalmente
      indesej&aacute;veis, porque eles fornecem muita informa&ccedil;&atilde;o para um
      atacante.</para>

      <para>Alguns daemons n&atilde;o s&atilde;o conscientes com a seguran&ccedil;a e
      possuem longos ou inexistentes tempos de expira&ccedil;&atilde;o (timeouts) 
      para tentativas de conex&atilde;o.  Isto permite um atacante enviar 
      conex&otilde;es lentamente para um daemon em particular, 
      saturando os recursos dispon&iacute;veis.  Pode ser uma boa id&eacute;ia 
      colocar limita&ccedil;&otilde;es <option>ip-por-minuto</option> e 
      <option>max-filhos</option> em certos daemons.</para>

      <para>Por padr&atilde;o, o encapsulamento TCP &eacute; ativado.  Consulte a
      p&aacute;gina de manual &man.hosts.access.5; para mais informa&ccedil;&otilde;es
      sobre como colocar restri&ccedil;&otilde;es TCP em v&aacute;rios daemons
      invocados pelo <application>inetd</application>.</para>

    </sect2>

    <sect2 id="network-inetd-misc">
      <title>Miscel&acirc;nea</title>

      <para><application>daytime</application>,
	<application>time</application>,
	<application>echo</application>,
	<application>discard</application>,
	<application>chargen</application>, e
	<application>auth</application> s&atilde;o todos servi&ccedil;os fornecidos
	internamente pelo <application>inetd</application>.</para>

      <para>O servi&ccedil;o <application>auth</application> fornece servi&ccedil;os
      de identidade (ident, identd) de rede, e &eacute; configur&aacute;vel at&eacute;
      certo ponto.</para>

      <para>Consulte a p&aacute;gina de manual &man.inetd.8; para informa&ccedil;&otilde;es
      mais aprofundadas.</para>
    </sect2>
  </sect1>

  <sect1 id="network-plip">
    <title>PLIP - IP em Linha Paralela</title>

    <indexterm><primary>PLIP</primary></indexterm>
    <indexterm><primary>Parallel Line IP</primary></indexterm>

    <para>PLIP nos permite usar TCP/IP entre portas paralelas.  &Eacute; &uacute;til
    em m&aacute;quinas sem placas de rede, ou para instalar em laptops.
    Nesta se&ccedil;&atilde;o vamos examinar:</para>

    <itemizedlist>
      <listitem>
	<para>Criando um cabo paralelo (laplink).</para>
      </listitem>

      <listitem>
	<para>Conectando dois computadores com PLIP.</para>
      </listitem>
    </itemizedlist>

    <sect2 id="network-create-parallel-cable">
      <title>Criando um Cabo Paralelo</title>

      <para>Voc&ecirc; pode comprar um cabo paralelo na maioria das lojas de
      suprimentos de inform&aacute;tica.  Se voc&ecirc; n&atilde;o puder fazer isso, ou
      voc&ecirc; apenas quer saber como um cabo &eacute; feito, a tabela a seguir
      mostra como fazer um a partir de um cabo paralelo para
      impressora.</para>

      <table>
	<title>Conectando um Cabo Paralelo para Conex&atilde;o em Rede</title>

	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry>A-name</entry>

	      <entry>A-End</entry>

	      <entry>B-End</entry>

	      <entry>Descr.</entry>

	      <entry>Post/Bit</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><literallayout>DATA0
-ERROR</literallayout></entry>

	      <entry><literallayout>2
15</literallayout></entry>

	      <entry><literallayout>15
2</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x01
1/0x08</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA1
+SLCT</literallayout></entry>

	      <entry><literallayout>3
13</literallayout></entry>

	      <entry><literallayout>13
3</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x02
1/0x10</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA2
+PE</literallayout></entry>

	      <entry><literallayout>4
12</literallayout></entry>

	      <entry><literallayout>12
4</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x04
1/0x20</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA3
-ACK</literallayout></entry>

	      <entry><literallayout>5
10</literallayout></entry>

	      <entry><literallayout>10
5</literallayout></entry>

	      <entry>Strobe</entry>

	      <entry><literallayout>0/0x08
1/0x40</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA4
BUSY</literallayout></entry>

	      <entry><literallayout>6
11</literallayout></entry>

	      <entry><literallayout>11
6</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x10
1/0x80</literallayout></entry>
	    </row>

	    <row>
	      <entry>GND</entry>

	      <entry>18-25</entry>

	      <entry>18-25</entry>

	      <entry>GND</entry>

	      <entry>-</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>

    <sect2 id="network-plip-setup">
      <title>Configurando o PLIP</title>

      <para>Primeiro, voc&ecirc; precisa obter um cabo laplink.  Depois,
      certifique-se de que ambos os computadores possuem um kernel com
      suporte do gerenciador de dispositivos &man.lpt.4;:</para>

      <screen>&prompt.root; <userinput>grep lp /var/run/dmesg.boot</userinput>
lpt0: &lt;Printer&gt; on ppbus0
lpt0: Interrupt-driven port</screen>

      <para>A porta paralela precisa ser uma porta gerenciada por
      interrup&ccedil;&otilde;es.  No &os;&nbsp;4.X, voc&ecirc; deve ter uma linha similar
      &agrave; seguinte em seu arquivo de configura&ccedil;&atilde;o do kernel:</para>

      <programlisting>device ppc0 at isa?  irq 7</programlisting>

      <para>No &os;&nbsp;5.X, o arquivo
      <filename>/boot/device.hints</filename> deve conter as seguintes
      linhas:</para>

      <programlisting>hint.ppc.0.at="isa"
      hint.ppc.0.irq="7"</programlisting>

      <para>Ent&atilde;o verifique se o arquivo de configura&ccedil;&atilde;o do kernel tem
      uma linha <literal>device plip</literal> ou se o m&oacute;dulo de
      kernel <filename>plip.ko</filename> est&aacute; carregado.  Em ambos os
      casos, a interface de rede paralela deve aparecer quando voc&ecirc;
      usar diretamente o comando &man.ifconfig.8;. No &os;&nbsp;4.X,
      seria assim:</para>

      <screen>&prompt.root; <userinput>ifconfig lp0</userinput>
lp0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500</screen>

      <para>e no &os;&nbsp;5.X:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0</userinput>
plip0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500</screen>

      <note><para>O nome do dispositivo usado para a interface
      paralela &eacute; diferente entre o &os;&nbsp;4.X
      (<devicename>lp<replaceable>X</replaceable></devicename>)
      e o &os;&nbsp;5.X
      (<devicename>plip<replaceable>X</replaceable></devicename>).</para></note>

      <para>Conecte o cabo laplink na interface paralela em ambos os
      computadores.</para>

      <para>Configure os par&acirc;metros da interface de rede nos dois
      s&iacute;tios como <username>root</username>.  Por exemplo, se voc&ecirc;
      quer conectar o sistema <hostid>host1</hostid> executando
      &os;&nbsp;4.X com <hostid>host2</hostid> executando &os;&nbsp;5.X:</para>

      <programlisting>		 host1 &lt;-----&gt; host2
IP Address    10.0.0.1      10.0.0.2</programlisting>

      <para>Configure a interface no <hostid>host1</hostid> com o comando:</para>

      <screen>&prompt.root; <userinput>ifconfig lp0 10.0.0.1 10.0.0.2</userinput></screen>

      <para>Configure a interface no <hostid>host2</hostid> fazendo:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0 10.0.0.2 10.0.0.1</userinput></screen>


      <para>Voc&ecirc; agora deve ter uma conex&atilde;o funcionando.  Por favor
      leia as p&aacute;ginas de manual &man.lp.4; e &man.lpt.4; para mais
      detalhes.</para>

      <para>Voc&ecirc; deve tamb&eacute;m adicionar ambas os sistemas ao
      <filename>/etc/hosts</filename>:</para>

      <programlisting>127.0.0.1	       localhost.my.domain localhost
10.0.0.1		host1.my.domain host1
10.0.0.2		host2.my.domain</programlisting>

      <para>Para confirmar que a conex&atilde;o funciona, v&aacute; a cada sistema e
      fa&ccedil;a um ping para o outro.  Por exemplo, no
      <hostid>host1</hostid>:</para>

	  <screen>&prompt.root; <userinput>ifconfig lp0</userinput>
lp0: flags=8851&lt;UP,POINTOPOINT,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
	inet 10.0.0.1 --&gt; 10.0.0.2 netmask 0xff000000
&prompt.root; <userinput>netstat -r</userinput>
Routing tables

Internet:
Destination	Gateway	  Flags     Refs     Use      Netif Expire
host2	      host1	      UH	  0       0       lp0
&prompt.root; <userinput>ping -c 4 host2</userinput>
PING host2 (10.0.0.2): 56 data bytes
64 bytes from 10.0.0.2: icmp_seq=0 ttl=255 time=2.774 ms
64 bytes from 10.0.0.2: icmp_seq=1 ttl=255 time=2.530 ms
64 bytes from 10.0.0.2: icmp_seq=2 ttl=255 time=2.556 ms
64 bytes from 10.0.0.2: icmp_seq=3 ttl=255 time=2.714 ms

--- host2 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 2.530/2.643/2.774/0.103 ms</screen>

    </sect2>
  </sect1>

  <sect1 id="network-ipv6">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Aaron</firstname>
	  <surname>Kaplan</surname>
	  <contrib>Originalmente Escrito por </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Reestruturado e Adicionado por </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>IPv6</title>
    <para>IPv6 (tamb&eacute;m conhecido como IPng <quote>IP next
    generation</quote>) &eacute; a nova vers&atilde;o do bem conhecido protocolo
    IP (tamb&eacute;m conhecido como <acronym>IPv4</acronym>).  Como outros
    sistemas *BSD atuais, o FreeBSD inclui a implementa&ccedil;&atilde;o de
    refer&ecirc;ncia <acronym>KAME</acronym>.  Ent&atilde;o o seu sistema FreeBSD
    vem com tudo o que voc&ecirc; via precisar para experi&ecirc;ncias com IPv6.
    Esta se&ccedil;&atilde;o enfoca na configura&ccedil;&atilde;o e ativa&ccedil;&atilde;o do IPv6.</para>

    <para>No in&iacute;cio dos anos 90, as pessoas tomaram conhecimento do
    r&aacute;pido esgotamento do espa&ccedil;o de endere&ccedil;amento do IPv4.  Dada a
    taxa de expans&atilde;o da Internet, haviam duas preocupa&ccedil;&otilde;es principais: </para>

    <itemizedlist>
      <listitem>
	<para>Esgotamento de endere&ccedil;os.  Hoje isto n&atilde;o &eacute; uma
	preocupa&ccedil;&atilde;o t&atilde;o grande, uma vez que espa&ccedil;os de endere&ccedil;os
	privados (<hostid role="ipaddr">10.0.0.0/8</hostid>,
	  <hostid role="ipaddr">192.168.0.0/24</hostid>,
	  etc.) e a Tradu&ccedil;&atilde;o de Endere&ccedil;os de Rede (Network Address
	  Translation - <acronym>NAT</acronym>) est&atilde;o sendo empregados.</para>
      </listitem>

      <listitem>
	<para>Entrada nas tabelas de roteadores estavam ficando
	grandes demais.  Hoje isto ainda &eacute; uma preocupa&ccedil;&atilde;o.</para>
      </listitem>
    </itemizedlist>

    <para>IPv6 trata destas e muitas outras quest&otilde;es:</para>

    <itemizedlist>
      <listitem>
	<para>Espa&ccedil;o de endere&ccedil;amento de 128 bits.  Em outras
	palavras, existem te&oacute;ricos
	  340,282,366,920,938,463,463,374,607,431,768,211,456
	  endere&ccedil;os dispon&iacute;veis.  Isto significa que s&atilde;o
	  aproximadamente 6.67 * 10^27 endere&ccedil;os IPv6 por metro
	  quadrado em nosso planeta.</para>
      </listitem>

      <listitem>
	<para>Roteadores armazenar&atilde;o somente endere&ccedil;os agregados de
	redes em suas tabelas de roteamento, reduzindo assim, o espa&ccedil;o
	m&eacute;dio de uma tabela de roteamento para 8192 entradas.</para>
      </listitem>
    </itemizedlist>

    <para>Tamb&eacute;m existem muitas outras caracter&iacute;sticas &uacute;teis do IPv6
    como:</para>

    <itemizedlist>
      <listitem>
	<para>Autoconfigura&ccedil;&atilde;o de endere&ccedil;o (RFC2462)</para>
      </listitem>

      <listitem>
	<para>Endere&ccedil;os anycast (<quote>um dentre muitos</quote>)</para>
      </listitem>

      <listitem>
	<para>Endere&ccedil;os multicast obrigat&oacute;rios</para>
      </listitem>

      <listitem>
	<para>IPsec (IP security)</para>
      </listitem>

      <listitem>
	<para>Estrutura simplificada de cabe&ccedil;alho</para>
      </listitem>

      <listitem>
	<para><acronym>IP</acronym> M&oacute;vel</para>
      </listitem>

      <listitem>
	<para>Mecanismos de transi&ccedil;&atilde;o IPv4-para-IPv6</para>
      </listitem>
    </itemizedlist>


    <para>Para maiores informa&ccedil;&otilde;es veja:</para>

    <itemizedlist>
      <listitem>
	<para>IPv6 overview at <ulink url="http://www.sun.com">Sun.com</ulink></para>
      </listitem>

      <listitem>
	<para><ulink url="http://www.ipv6.org">IPv6.org</ulink></para>
      </listitem>

      <listitem>
	<para><ulink url="http://www.kame.net">KAME.net</ulink></para>
      </listitem>

      <listitem>
	<para><ulink url="http://www.6bone.net">6bone.net</ulink></para>
      </listitem>
    </itemizedlist>

    <sect2>
      <title>Fundamentos em Endere&ccedil;os IPv6</title>
      <para>Existem diferentes tipos de endere&ccedil;os IPv6: Unicast,
      Anycast e Multicast.</para>

      <para>Endere&ccedil;os Unicast s&atilde;o os endere&ccedil;os conhecidos.  Um pacote
      enviado a um endere&ccedil;o unicast chega exatamente &agrave; interface
      pertencente ao endere&ccedil;o.</para>

      <para>Endere&ccedil;os anycast s&atilde;o sintaticamente indistingu&iacute;veis de
      endere&ccedil;os unicast, mas eles endere&ccedil;am um grupo de interfaces.
      Um pacote destinado para um endere&ccedil;o anycast vai chegar na
      interface mais pr&oacute;xima (em m&eacute;trica de roteador).  Endere&ccedil;os
      anycast somente podem ser usados por roteadores.</para>

      <para>Endere&ccedil;os multicast identificam um grupo de interfaces.
      Um pacote destinado a um endere&ccedil;o multicast vai chegar em todas
      as interfaces pertencentes ao grupo multicast.</para>

	<note><para>O endere&ccedil;o de difus&atilde;o (broadcast) IPv4
	(normalmente <hostid role="ipaddr">xxx.xxx.xxx.255</hostid>)
	&eacute; expresso por endere&ccedil;os multicast em IPv6.</para></note>

      <para>Endere&ccedil;os IPv6 Reservados:</para>

<screen>ipv6-address 	prefixlength(Bits)	description	Notes

	::			128 Bits			n&atilde;o especificado cf.  0.0.0.0 em endere&ccedil;o IPv4
	::1			128 Bits			endere&ccedil;o loopback cf.  127.0.0.1 em IPv4
	::00:xx:xx:xx:xx	96 Bits				IPv4 embutido	Os 32 bits mais baixos s&atilde;o os
								endere&ccedil;os	IPv4.  Tamb&eacute;m chamado
								<quote>Endere&ccedil;o IPv4 compat&iacute;vel com IPv6
								</quote>
	::ff:xx:xx:xx:xx	96 Bits		IPv4 mapeado    Os 32 bits mais baixos s&atilde;o os
						IPv6 address	endere&ccedil;os IPv4.  Para sistemas
								que n&atilde;o suportam IPv6
	fe80:: - feb::		10 Bits		link-local	cf.  endere&ccedil;o loopback em
						IPv4
	fec0:: - fef::		10 Bits		locais ao s&iacute;tio
	ff::			8 Bits		multicast
	001 (base 2)		3 Bits		unicast globais	Todos os endere&ccedil;os unicast globais
								s&atilde;o atribu&iacute;dos deste
								conjunto.  Os 3 primeiros Bits
								s&atilde;o <quote>001</quote>.</screen>

    </sect2>

    <sect2>
      <title>Lendo Endere&ccedil;os IPv6</title>
      <para>A forma can&ocirc;nica &eacute; representada como: <hostid
      role="ip6addr">x:x:x:x:x:x:x:x</hostid>, cada
      <quote>x</quote> sendo um valor hexadecimal de 16
      Bits.  Por exemplo <hostid
      role="ip6addr">FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</hostid></para>

      <para>Freq&uuml;entemente um endere&ccedil;o ter&aacute; longas subs&eacute;ries
      compostas por zeros, ent&atilde;o cada subs&eacute;rie pode ser abreviada por
      <quote>::</quote>. Por exemplo <hostid
      role="ip6addr">fe80::1</hostid> corresponde &agrave; forma can&ocirc;nica
      <hostid
      role="ip6addr">fe80:0000:0000:0000:0000:0000:0000:0001</hostid></para>

      <para>Uma terceira forma &eacute; escrever a &uacute;ltima parte de 32 Bits na
      forma conhecida (decimal), estilo IPv4, com pontos
      <quote>.</quote> como separadores.  Por exemplo,
      <hostid role="ip6addr">2002::10.0.0.1</hostid> corresponde &agrave;
      representa&ccedil;&atilde;o can&ocirc;nica (hexadecimal)
      <hostid role="ip6addr">2002:0000:0000:0000:0000:0000:0a00:0001</hostid>
       que por sua vez equivale a escrever
       <hostid role="ip6addr">2002::a00:1</hostid></para>


      <para>Agora, os leitores devem ser capazes de compreender o
      seguinte:</para>

      <screen>&prompt.root; <userinput>ifconfig</userinput></screen>

      <programlisting>rl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
	 inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
	 inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
	 ether 00:00:21:03:08:e1
	 media: Ethernet autoselect (100baseTX )
	 status: active</programlisting>

      <para><hostid role="ip6addr">fe80::200:21ff:fe03:8e1%rl0</hostid>
      &eacute; um endere&ccedil;o autoconfigurado tipo enlace-local.  Ele inclui o
      MAC Ethernet misturado como parte da autoconfigura&ccedil;&atilde;o.</para>

      <para>Para maiores informa&ccedil;&otilde;es sobre a estrutura dos endere&ccedil;os
      IPv6, veja a RFC2373.</para>
    </sect2>

    <sect2>
      <title>Conectando-se</title>

      <para>Atualmente existem quatro formas de se conectar a outros
      sistemas e redes IPv6:</para>

      <itemizedlist>
	<listitem>
	  <para>Associar-se ao 6bone experimental</para>
	</listitem>

	<listitem>
	  <para>Obtendo uma rede IPv6 de seu provedor de
	  conectividade.  Procure seu provedor Internet para
	  instru&ccedil;&otilde;es.</para>
	</listitem>

	<listitem>
	  <para>Tunelamento via 6-para-4</para>
	</listitem>

	<listitem>
	  <para>Usar o port freenet6 se estiver em uma conex&atilde;o
	  discada.</para>
	</listitem>
      </itemizedlist>

      <para>Aqui vamos falar sobre como se conectar ao 6bone uma vez
      que atualmente parece ser a forma mais popular.</para>

      <para>Primeiro, veja a p&aacute;gina do 6bone e encontre a conex&atilde;o para
      o 6bone mais pr&oacute;xima de voc&ecirc;.  Escreva para a pessoa respons&aacute;vel
      e com um pouco de sorte voc&ecirc; receber&aacute; instru&ccedil;&otilde;es sobre como
      configurar sua conex&atilde;o.  Geralmente isto envolve preparar um
      t&uacute;nel GRE (gif).</para>

      <para>Aqui est&aacute; um exemplo t&iacute;pico de como preparar um t&uacute;nel
      &man.gif.4;:</para>

      <screen>&prompt.root; <userinput>ifconfig gif0 create</userinput>
&prompt.root; <userinput>ifconfig gif0</userinput>
gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
&prompt.root; <userinput>ifconfig gif0 tunnel <replaceable>MEU_END_IPv4</replaceable>  <replaceable>END_IPv4_DELE</replaceable></userinput>
&prompt.root; <userinput>ifconfig gif0 inet6 alias <replaceable>MEU_END_IPv6_ATRIBUIDO_COMO_PONTO_FINAL_DO_T&Uacute;NEL</replaceable></userinput></screen>

      <para>Substitua as palavras em mai&uacute;sculas pela informa&ccedil;&atilde;o
      recebida do n&oacute; 6bone de n&iacute;vel superior.</para>

      <para>Isto estabelece o t&uacute;nel.  Verifique se o t&uacute;nel est&aacute;
      funcionando usando &man.ping6.8; <hostid
      role="ip6addr">ff02::1%gif0</hostid>.  Voc&ecirc; deve receber duas
      respostas do ping.</para>

	<note><para>Em caso de voc&ecirc; estar intrigado pelo endere&ccedil;o
	<hostid role="ip6addr">ff02:1%gif0</hostid>, isto &eacute; um
	endere&ccedil;o multicast.  <literal>%gif0</literal> indica que o
	endere&ccedil;o multicast na interface de rede
	<devicename>gif0</devicename> deve ser usado.  Uma vez que
	n&oacute;s usamos <command>ping</command> para um endere&ccedil;o multicast,
	o outro ponto final do t&uacute;nel deve responder tamb&eacute;m).</para></note>

      <para>Agora, configurar a rota para sua conex&atilde;o ao 6bone deve
      ser bem clara:</para>

      <screen>&prompt.root; <userinput>route add -inet6 default -interface gif0</userinput>
&prompt.root; <userinput>ping6 -n <replaceable>MINHA_CONEX&Atilde;O</replaceable></userinput></screen>

      <screen>&prompt.root; <userinput>traceroute6 www.jp.FreeBSD.org</userinput>
(3ffe:505:2008:1:2a0:24ff:fe57:e561) from 3ffe:8060:100::40:2, 30 hops max, 12 byte packets
     1 atnet-meta6 14.147 ms 15.499 ms 24.319 ms
     2 6bone-gw2-ATNET-NT.ipv6.tilab.com 103.408 ms 95.072 ms *
     3 3ffe:1831:0:ffff::4 138.645 ms 134.437 ms 144.257 ms
     4 3ffe:1810:0:6:290:27ff:fe79:7677 282.975 ms 278.666 ms 292.811 ms
     5 3ffe:1800:0:ff00::4 400.131 ms 396.324 ms 394.769 ms
     6 3ffe:1800:0:3:290:27ff:fe14:cdee 394.712 ms 397.19 ms 394.102 ms</screen>

      <para>Esta sa&iacute;da vai ser diferente de m&aacute;quina para m&aacute;quina.
      Agora voc&ecirc; deve ser capaz de alcan&ccedil;ar o s&iacute;tio IPv6 <ulink
      url="http://www.kame.net">www.kame.net</ulink> e ver a tartaruga
      dan&ccedil;ante &mdash; se voc&ecirc; tiver um navegador pronto para IPv6,
      como o <filename role="package">www/mozilla</filename>.</para>

    </sect2>

    <sect2>
      <title>DNS no Mundo IPv6</title>
      <para>Existem duas novas formas de registros DNS para IPv6:</para>

      <itemizedlist>
	<listitem>
	  <para>Registros AAAA,</para>
	</listitem>

	<listitem>
	  <para>Registros A6</para>
	</listitem>
      </itemizedlist>

      <para>Usar registros AAAA &eacute; bem direto.  Atribua seu nome de
      sistema ao novo endere&ccedil;o IPv6 que voc&ecirc; rec&eacute;m obteve
      adicionando:</para>

      <programlisting>MEUNOMEDESISTEMA	   AAAA    MEUENDIPv6</programlisting>

      <para>ao seu arquivo DNS de zona prim&aacute;ria.  No caso de voc&ecirc; n&atilde;o
      servir suas pr&oacute;prias zonas <acronym>DNS</acronym> pe&ccedil;a ao seu
      provedor <acronym>DNS</acronym>.  Vers&otilde;es atuais do
      <application>bind</application> (vers&otilde;es 8.3 e 9) suportam
      registros AAAA.</para>
    </sect2>
  </sect1>

</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
<!--  LocalWords:  config mnt www -->
