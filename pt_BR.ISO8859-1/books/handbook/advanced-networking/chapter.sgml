<!--
     The FreeBSD Documentation Project

     $FreeBSD: doc/en_US.ISO8859-1/books/handbook/advanced-networking/chapter.sgml,v 1.251 2003/11/23 17:52:10 ceri Exp $
-->

<chapter id="advanced-networking">
  <title>Rede Avan&ccedil;ado</title>

  <sect1 id="advanced-networking-synopsis">
    <title>&Iacute;ndice</title>

    <para>Este cap&iacute;tulo aborda alguns dos servi&ccedil;os de redes 
    usados com mais frequ&ecirc;ncia em sistemas &unix;.  Vamos
    abordar como definir, configurar, testar e manter todos
    os servi&ccedil;os de rede que o FreeBSD usa.  Adicionalmente,
    existem exemplos de arquivos de configura&ccedil;&atilde;o
    inclusos pelo cap&iacute;tulo para seu usufruto.</para>

    <para>Ap&oacute;s a leitura deste cap&iacute;tulo, voc&ecirc; saber&aacute;:</para>

    <itemizedlist>
      <listitem>
	<para>O b&aacute;sico sobre gateways e rotas.</para>
      </listitem>

      <listitem>
	<para>Como fazer o FreeBSD atuar como uma
	ponte.</para>
      </listitem>

      <listitem>
	<para>Como ativar um sistema de arquivos em
	rede.</para>
      </listitem>

      <listitem>
	<para>Como ativar inicializa&ccedil;&atilde;o remota em uma
	m&aacute;quina sem disco.</para>
      </listitem>

      <listitem>
	<para>Como ativar um servidor de informa&ccedil;&atilde;o de
	rede.</para>
      </listitem>

      <listitem>
	<para>Como ativar configura&ccedil;&otilde;es autom&aacute;ticas de rede
	usando DHCP.</para>
      </listitem>

      <listitem>
	<para>Como ativar um servidor de nome de
	dom&iacute;nio.</para>
      </listitem>

      <listitem>
	<para>Como sincronizar a hora e data, e ativar um servidor
	de hora com o protocolo NTP.</para>
      </listitem>

      <listitem>
	<para>Como ativar tradu&ccedil;&atilde;o de endere&ccedil;o de rede.</para>
      </listitem>

      <listitem>
	<para>Como gerenciar o daemon <application>inetd</application>.</para>
      </listitem>

      <listitem>
	<para>Como conectar dois computadores via PLIP.</para>
      </listitem>

      <listitem>
	<para>Como ativar o IPv6 em uma m&aacute;quina FreeBSD.</para>
      </listitem>
    </itemizedlist>

    <para>Antes de ler este cap&iacute;tulo, voc&ecirc; deve:</para>

    <itemizedlist>
      <listitem>
	<para>Compreender os princ&iacute;pios dos scripts 
	<filename>/etc/rc</filename> .</para>
      </listitem>

      <listitem>
	<para>Estar familiarizado com a terminologia b&aacute;sica de
	redes.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="network-routing">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Coranth</firstname>
      	  <surname>Gryphon</surname>
	  <contrib>Contribui&ccedil;&atilde;o de </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Gateways e Rotas</title>

    <indexterm><primary>routing</primary></indexterm>
    <indexterm><primary>gateway</primary></indexterm>
    <indexterm><primary>subrede</primary></indexterm>
    <para>Para uma m&aacute;quina ser capaz de encontrar outra atrav&eacute;s de uma
    rede, &eacute; necess&aacute;rio um mecanismo que descreva como ir de uma
    para a outra.  Isto &eacute; chamado
      <firstterm>roteamento</firstterm>.  Uma <quote>rota</quote> &eacute; um
      par definido de endere&ccedil;os: um <quote>destino</quote> e um
      <quote>gateway</quote>.  O par indica que se voc&ecirc; estiver
      tentando alcan&ccedil;ar este <emphasis>destino</emphasis>, deve se
      comunicar atrav&eacute;s deste <emphasis>gateway</emphasis>.
      Existem tr&ecirc;s tipos de destinos: m&aacute;quinas individuais,
      subredes e <quote>padr&atilde;o</quote> .  A <quote>rota padr&atilde;o</quote> &eacute;
      usada se nenhuma das outras rotas for aplic&aacute;vel.  Vamos falar um
      pouco mais sobre rotas padr&atilde;o mais tarde.  Tamb&eacute;m existem tr&ecirc;s
      tipos de gateways: m&aacute;quinas individuais, interfaces (tamb&eacute;m
      chamadas de <quote>enlaces</quote>) e endere&ccedil;os f&iacute;sicos de
      hardware Ethernet (endere&ccedil;os MAC).
</para>

    <sect2>
      <title>Um Exemplo</title>

      <para>Para ilustrar diferentes aspectos do roteamento, vamos usar o
	seguinte exemplo do <command>netstat</command>:</para>

      <screen>&prompt.user; <userinput>netstat -r</userinput>
Routing tables

Destination      Gateway	    Flags     Refs     Use     Netif Expire

default		 outside-gw	    UGSc       37      418      ppp0
localhost	 localhost	    UH		0      181       lo0
test0		 0:e0:b5:36:cf:4f   UHLW	5    63288       ed0     77
10.20.30.255     link#1		    UHLW	1     2421
example.com      link#1		    UC		0	 0
host1		 0:e0:a8:37:8:1e    UHLW	3     4601       lo0
host2		 0:e0:a8:37:8:1e    UHLW	0	 5	 lo0 =>
host2.example.com link#1	    UC		0	 0
224		 link#1		    UC		0	 0</screen>

      <indexterm><primary>default route</primary></indexterm>
      <para>As duas primeiras linhas especificam a rota padr&atilde;o (a qual
      ser&aacute; abordada na <link linkend="network-routing-default">pr&oacute;xima
      se&ccedil;&atilde;o</link>) e a rota para <hostid>localhost</hostid> (a
      pr&oacute;pria m&aacute;quina).</para>

      <indexterm><primary>loopback device</primary></indexterm>
      <para>A interface (coluna <literal>Netif</literal> ) que esta
      tabela de roteamento usa para especificar o
	<literal>localhost</literal> &eacute; <devicename>lo0</devicename>,
	tamb&eacute;m conhecido como o dispositivo de loopback.  Isto quer
	dizer para manter interno todo o tr&aacute;fego para este destino,
	ao inv&eacute;s de envi&aacute;-lo para fora pela rede local, uma vez que
	simplesmente dever&aacute; retornar ao local de origem.</para>

      <indexterm>
	<primary>Ethernet</primary>
	<secondary>MAC address</secondary>
      </indexterm>
      <para>A pr&oacute;xima coisa que chama a aten&ccedil;&atilde;o s&atilde;o os endere&ccedil;os
      come&ccedil;ando com <hostid role="mac">0:e0:</hostid>.  Estes s&atilde;o
      endere&ccedil;os de hardware Ethernet, tamb&eacute;m conhecidos como
      endere&ccedil;os MAC.  O FreeBSD ir&aacute; identificar automaticamente
      quaisquer m&aacute;quinas (no exemplo <hostid>test0</hostid>) na
      Ethernet local e adicionar uma rota direta para aquela m&aacute;quina
      pela interface Ethernet, <devicename>ed0</devicename>.  H&aacute; tamb&eacute;m
      um tempo de expira&ccedil;&atilde;o (timeout) associado a este tipo de rota,
      que &eacute; usado em caso de n&atilde;o se receber mais transmiss&otilde;es da m&aacute;quina
      dentro de um prazo espec&iacute;fico de tempo.  Quando isto acontece, a
      rota para esta m&aacute;quina ser&aacute; automaticamente removida.  Estas
      m&aacute;quinas s&atilde;o identificadas usando um mecanismo conhecido como
      RIP (Protocolo de Informa&ccedil;&atilde;o de Roteamento - Routing Information
      Protocol), que calcula rotas para as m&aacute;quinas locais baseado na
      determina&ccedil;&atilde;o do menor caminho.</para>

      <indexterm><primary>subnet</primary></indexterm>
      <para>O FreeBSD tamb&eacute;m adicionar&aacute; rotas de subrede para a subrede
      local (<hostid role="ipaddr">10.20.30.255</hostid> &eacute; o endere&ccedil;o
      de difus&atilde;o (broadcast) para a subrede
      <hostid role="ipaddr">10.20.30</hostid>, e
      <hostid role="domainname">example.com</hostid> &eacute; o nome de dom&iacute;nio
      associado &agrave;quela subrede).  A designa&ccedil;&atilde;o <literal>link#1</literal>
      refere-se &agrave; primeira placa Ethernet na m&aacute;quina.  Voc&ecirc; ir&aacute; notar que
      nenhuma interface adicional &eacute; especificada para aquelas.</para>

      <para>Ambos os grupos (m&aacute;quinas de rede local e subredes locais) t&ecirc;m
	suas rotas configuradas automaticamente por um daemon chamado
	<application>routed</application>.  Se ele n&atilde;o estiver sendo
	executado, ent&atilde;o somente existir&atilde;o rotas definidas estaticamente
	(p.ex.  configuradas explicitamente).</para>

      <para>A linha <literal>host1</literal> refere-se &agrave; nossa m&aacute;quina,
	conhecida pelo endere&ccedil;o Ethernet.  Uma vez que somos a m&aacute;quina
	transmissora, o FreeBSD sabe fazer uso da interface loopback
	(<devicename>lo0</devicename>) ao inv&eacute;s de transmitir pela interface
	Ethernet afora.</para>

      <para>As duas linhas <literal>host2</literal> s&atilde;o um exemplo do
	que acontece quando usamos um apelido &man.ifconfig.8; (veja a
	se&ccedil;&atilde;o sobre Ethernet por raz&otilde;es pelas quais far&iacute;amos isso).  O
	s&iacute;mbolo <literal>=&gt;</literal> ap&oacute;s a interface
	<devicename>lo0</devicename> diz que n&atilde;o somente estamos
	usando a loopback (uma vez que este endere&ccedil;o tamb&eacute;m refere-se
	&agrave; maquina local), mas especificamente que &eacute; um apelido.  Tais
	rotas somente surgem nas m&aacute;quinas que suportam o apelido;
	todas as outras m&aacute;quinas na rede local simplesmente ter&atilde;o uma
	linha <literal>link#1</literal> para tais rotas.</para>

      <para>A &uacute;ltima linha (subrede de destino <literal>224</literal>) trata
	do uso de multicast, que ser&aacute; abordado em outra se&ccedil;&atilde;o.</para>

      <para>Finalmente, dversos atributos de cada rota pode ser vistos
	na coluna <literal>Flags</literal>.  Abaixo est&aacute; uma breve
	tabela contendo algumas destas flags e seus significados:</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry>U</entry>
	      <entry>Up: A rota &eacute; ativa.</entry>
	    </row>

	    <row>
	      <entry>H</entry>
	      <entry>Host: O destino da rota &eacute; uma &uacute;nica m&aacute;quina.</entry>
	    </row>

	    <row>
	      <entry>G</entry>
	      <entry>Gateway: Envie qualquer coisa para este destino
	      por este sistema remoto, que o mesmo ir&aacute; calcular a
	      partir de l&aacute; para onde envi&aacute;-la.
		it.</entry>
	    </row>

	    <row>
	      <entry>S</entry>
	      <entry>Static: Esta rota foi configurada manualmente, e n&atilde;o
		gerada automaticamente pelo sistema.</entry>
	    </row>

	    <row>
	      <entry>C</entry>
	      <entry>Clone: Gera uma nova rota baseada nesta rota para
	      m&aacute;quinas a quem nos conectarmos.  Este tipo de rota
	      normalmente &eacute; usada em redes locais.</entry>
	    </row>

	    <row>
	      <entry>W</entry>
	      <entry>WasCloned: Indica uma rota que foi auto-configurada
		baseada em uma rota (Clone) da rede local.</entry>
	    </row>

	    <row>
	      <entry>L</entry>
	      <entry>Link: Rota envolve refer&ecirc;ncias ao hardware
	      Ethernet.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2 id="network-routing-default">
      <title>Rotas Padr&atilde;o</title>

      <indexterm><primary>default route</primary></indexterm>
      <para>Quando um sistema local precisa fazer uma conex&atilde;o a um
      sistema remoto, ele verifica a tabela de roteamento para
      determinar se existe um caminho conhecido.  Se o sistema remoto
      estiver em uma das subredes que j&aacute; sabemos como alcan&ccedil;ar (rotas
      Clonadas), ent&atilde;o o sistema verifica se pode se conectar por
      aquela interface.</para>

      <para>Se falharem todos os caminhos conhecidos, o sistema
      tem uma &uacute;ltima op&ccedil;&atilde;o: a rota <quote>padr&atilde;o</quote>.  Esta rota &eacute;
      um tipo especial rota de sa&iacute;da,  ou gateway (normalmente a
      &uacute;nica presente no sistema), e &eacute; sempre indicada por um
      <literal>c</literal> no campo flags.  Para sistemas em uma rede
      local, este gateway &eacute; configurado para qualquer m&aacute;quina que
      tenha uma conex&atilde;o direta para o mundo exterior (seja via enlace
      PPP, DSL, modem a cabo, T1 ou outra interface de rede).</para>

      <para>Se voc&ecirc; estiver configurando a rota padr&atilde;o em uma m&aacute;quina
      que esteja funcionando como o gateway para o mundo exterior,
      ent&atilde;o a rota padr&atilde;o ser&aacute; a m&aacute;quina gateway localizada no seu
      Provedor de Servi&ccedil;os Internet (PSI).</para>

      <para>Vamos dar uma olhada em um exemplo de rotas padr&atilde;o.  Esta &eacute;
      uma configura&ccedil;&atilde;o comum:</para>

      <literallayout>
[Local2]  &lt;--ether--&gt;  [Local1]  &lt;--PPP--&gt; [ISP-Serv]  &lt;--ether--&gt;  [T1-GW]
      </literallayout>

      <para>Os sistemas <hostid>Local1</hostid> and
	<hostid>Local2</hostid> est&atilde;o em seu s&iacute;tio local.
	<hostid>Local1</hostid> est&aacute; conectado a um PSI por uma conex&atilde;o
	PPP discada.  Este servidor PPP est&aacute; conectado por uma rede
	local a outro computador gateway atrav&eacute;s de uma interface
	externa ao canal Internet do PSI.</para>

      <para>As rotas padr&atilde;o para cada uma das suas m&aacute;quinas ser&atilde;o:</para>

      <informaltable frame="none">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Sistema</entry>
	      <entry>Gateway Padr&atilde;o</entry>
	      <entry>Interface</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>Local2</entry>
	      <entry>Local1</entry>
	      <entry>Ethernet</entry>
	    </row>

	    <row>
	      <entry>Local1</entry>
	      <entry>T1-GW</entry>
	      <entry>PPP</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Uma pergunta comum &eacute; <quote>Por que (ou como)
      n&oacute;s configuramos o <hostid>T1-GW</hostid> para ser o gateway
      padr&atilde;o para <hostid>Local1</hostid>, ao inv&eacute;s do servidor do PSI
      ao qual est&aacute; conectado?</quote>.</para>

      <para>Lembre-se, uma vez que a interface PPP est&aacute; usando um
      endere&ccedil;o da rede local do PSI para o seu lado da conex&atilde;o, rotas
      para qualquer outra m&aacute;quina na rede local do PSI ser&atilde;o criadas
      automaticamente.  Assim, uma vez que voc&ecirc; j&aacute; sabe como alcan&ccedil;ar
      a m&aacute;quina <hostid>T1-GW</hostid>, ent&atilde;o n&atilde;o h&aacute; necessidade do
      passo intermedi&aacute;rio de enviar tr&aacute;fego para o servidor do PSI.</para>

      <para>Como observa&ccedil;&atilde;o final, &eacute; comum usar o endere&ccedil;o
      <hostid role="IPADDR">X.X.X.1</hostid> como o endere&ccedil;o do gateway
      para sua rede local.  Ent&atilde;o (usando o mesmo exemplo), se o seu
      espa&ccedil;o de endere&ccedil;amento classe-C era
      <hostid role="IPADDR">10.20.30</hostid> e seu PSI estava usando
      <hostid role="IPADDR">10.9.9</hostid> ent&atilde;o as rotas padr&atilde;o
      seriam:</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Sistema</entry>
	      <entry>Rota Padr&atilde;o</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Local2 (10.20.30.2)</entry>
	      <entry>Local1 (10.20.30.1)</entry>
	    </row>
	    <row>
	      <entry>Local1 (10.20.30.1, 10.9.9.30)</entry>
	      <entry>T1-GW (10.9.9.1)</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>Sistemas Duplamente Conectados</title>
      <indexterm><primary>dual homed hosts</primary></indexterm>
      <para>Existe um outro tipo de configura&ccedil;&atilde;o que devemos abordar,
       que se trata de um sistema pertencente a duas redes diferentes.
       Tecnicamente, qualquer m&aacute;quina funcionando como um gateway
       (no exemplo acima, usando uma conex&atilde;o PPP) conta como um
       sistema duplamente conectado.  Mas, na verdade, o termo somente
       &eacute; usado para se referir a uma m&aacute;quina conectada a duas redes locais
       diferentes.</para>

      <para>Em um caso, a m&aacute;quina tem duas placas Ethernet, cada uma
      possuindo um endere&ccedil;o em subredes separadas.  Alternativamente,
      a m&aacute;quina pode ter somente uma placa Ethernet e estar usando um
      apelido &man.ifconfig.8;.  O primeiro caso &eacute; usado se duas redes
      Ethernet fisicamente separadas est&atilde;o em uso, e o segundo se h&aacute;
      somente um segmento f&iacute;sico Ethernet, mas duas subredes separadas
      logicamente.</para>

      <para>De um jeito ou de outro, as tabelas de roteamento s&atilde;o
      configuradas de forma que cada subrede saiba que esta m&aacute;quina &eacute;
      o gateway definido (rota de entrada) para a outra subrede.  Esta
      configura&ccedil;&atilde;o, com a m&aacute;quina atuando como um roteador entre duas
      subredes, &eacute; muitas vezes usado quando precisamos implementar
      filtragem de pacotes ou um firewall de seguran&ccedil;a em cada uma ou
      em ambas as dire&ccedil;&otilde;es.</para>

      <para>Se voc&ecirc; deseja que esta m&aacute;quina na pr&aacute;tica passe adiante
      pacotes entre as duas interfaces, voc&ecirc; precisa dizer ao FreeBSD
      para permitir esta capacidade.</para>
    </sect2>

    <sect2 id="network-dedicated-router">
      <title>Construindo um Roteador</title>

      <indexterm><primary>router</primary></indexterm>

      <para>Um roteador de rede &eacute; simplesmente um sistema que repassa
      pacotes de uma interface para outra.  Padr&otilde;es da Internet e boas
      pr&aacute;ticas de engenharia impedem o Projeto FreeBSD de permitir
      isto por padr&atilde;o no FreeBSD.  Voc&ecirc; pode permitir esta
      caracter&iacute;stica alterando a seguinte vari&aacute;vel para
      <literal>YES</literal> no &man.rc.conf.5;:</para>

      <programlisting>gateway_enable=YES	  # Set to YES if this host will be a gateway</programlisting>

      <para>Esta op&ccedil;&atilde;o ir&aacute; ajustar a vari&aacute;vel do &man.sysctl.8;
      chamada <varname>net.inet.ip.forwarding</varname> para
	<literal>1</literal>.  Se voc&ecirc; precisar parar o roteamento
	temporariamente, voc&ecirc; voc&ecirc; pode reajust&aacute;-la para
	<literal>0</literal>.</para>

      <para>Seu novo roteador precisar&aacute; de rotas para saber aonde
      enviar o tr&aacute;fego.  Se sua rede for simples o suficiente voc&ecirc;
      pode usar rotas est&aacute;ticas.  O FreeBSD tamb&eacute;m vem com o daemon
      de roteamento padr&atilde;o do BSD &man.routed.8;, o qual fala RIP
      (ambas as vers&otilde;es 1 e 2) e IRDP.  O suporte para BGP v4, OSPF v2
      e outros protocolos de roteamento sofisticados est&atilde;o dispon&iacute;veis
      com o pacote <filename role="package">net/zebra</filename>.
      Produtos comerciais como o gated tamb&eacute;m est&atilde;o dispon&iacute;veis para
      solu&ccedil;&otilde;es mais complexas de roteamento.</para>

<indexterm><primary>BGP</primary></indexterm>
<indexterm><primary>RIP</primary></indexterm>
<indexterm><primary>OSPF</primary></indexterm>

      <para>Mesmo quando o FreeBSD &eacute; configurado desta forma, ele
      ainda n&atilde;o cumpre completamente com os requisitos padr&otilde;es da
      Internet para roteadores.  Mas chega bem perto para uso
      normal, entretanto.</para>
    </sect2>

    <sect2>
      <title>Propaga&ccedil;&atilde;o do Roteamento</title>
      <indexterm><primary>routing propagation</primary></indexterm>
      <para>N&oacute;s j&aacute; falamos sobre como definimos nossas rotas para o
      mundo exterior, mas n&atilde;o sobre como o mundo exterior nos
      encontra.</para>

      <para>J&aacute; sabemos como as tabelas de roteamento podem ser
      configuradas de forma que todo o tr&aacute;fego para um espa&ccedil;o de
      endere&ccedil;amento em particular (nos nossos exemplos, uma subrede
      classe-C) pode ser enviado a um determinado sistema naquela
      rede, o qual ir&aacute; repassar os pacotes para dentro.</para>

      <para>Quando voc&ecirc; obtiver a designa&ccedil;&atilde;o de um espa&ccedil;o de
      endere&ccedil;amento para seu s&iacute;tio, seu provedor de servi&ccedil;os ir&aacute;
      configurar suas tabelas de roteamento de forma que todo o
      tr&aacute;fego para sua subrede ser&aacute; enviado atrav&eacute;s do seu enlace PPP
      ao seu s&iacute;tio.  Mas como os s&iacute;tios atrav&eacute;s do pa&iacute;s saber&atilde;o enviar
      ao seu PSI?</para>

      <para>H&aacute; um sistema (muito parecido com a informa&ccedil;&atilde;o DNS
      disttribu&iacute;da) que mant&eacute;m resgistros de todos os espa&ccedil;os de
      endere&ccedil;amento designados, e que define seu ponto de conex&atilde;o &agrave;
      Espinha Dorsal Internet.  A <quote>Espinha Dorsal</quote> s&atilde;o
      os principais canais que carregam o tr&aacute;fego da Internet atrav&eacute;s
      do pa&iacute;s e ao redor do mundo.  Cada m&aacute;quina de espinha dorsal t&ecirc;m
      uma c&oacute;pia de um conjunto mestre de tabelas, as quais direcionam
      tr&aacute;fego a uma determinada rede e a um provedor de espinha dorsal
      espec&iacute;fico e, de l&aacute;, abaixo na cadeia de provedores de servi&ccedil;os
      at&eacute; atingir a sua rede.</para>

      <para>&Eacute; a tarefa do seu provedor de servi&ccedil;os anunciar para os
      s&iacute;tios da espinha dorsal que eles s&atilde;o o ponto de conex&atilde;o (e,
      assim, o caminho de entrada) para seu s&iacute;tio.  Isto &eacute; conhecido
      como propaga&ccedil;&atilde;o de rotas.</para>
    </sect2>

    <sect2>
      <title>Resolu&ccedil;&atilde;o de Problemas</title>
      <indexterm>
	<primary><command>traceroute</command></primary>
      </indexterm>
      <para>&Agrave;s vezes, h&aacute; um problema com propaga&ccedil;&atilde;o de rotas, e alguns
      s&iacute;tios ficam incapazes de se conectar a voc&ecirc;.  Talvez o comando
      mais &uacute;til para tentar descobrir onde o roteamento est&aacute; em pane &eacute;
      o &man.traceroute.8;.  Ele &eacute; igualmente &uacute;til se voc&ecirc; n&atilde;o parece
      conseguir realizar uma conex&atilde;o a uma m&aacute;quina remota (p.ex.  o
      &man.ping.8; falhou).</para>

      <para>O comando &man.traceroute.8; &eacute; executado com o nome do
      sistema remoto que voc&ecirc; est&aacute; tentando se conectar.  Ele vai
      mostrar os sistemas gateway ao longo do caminho da tentativa,
      eventualmente alcan&ccedil;ando o sistema-alvo, ou terminando por falta
      de conectividade.</para>

      <para>Para maiores informa&ccedil;&otilde;es, veja a p&aacute;gina do manual do
      &man.traceroute.8;.</para>
    </sect2>

    <sect2>
      <title>Roteamento Multicast</title>
      <indexterm>
	<primary>multicast</primary>
	<secondary>options MROUTING</secondary>
      </indexterm>
      <para>O FreeBSD suporta aplica&ccedil;&otilde;es multicast e roteamento multicast
	de forma nativa.  Aplica&ccedil;&otilde;es multicast n&atilde;o requerem qualquer
	configura&ccedil;&atilde;o especial no FreeBSD; aplica&ccedil;&otilde;es geralmente ir&atilde;o
	funcionar sem necessidade de ajustes.  O roteamento multicast
	requer que o suporte seja compilado no n&uacute;cleo, ou kernel:</para>

      <programlisting>options MROUTING</programlisting>

      <para>Al&eacute;m disso, o daemon de roteamento multicast 
      &man.mrouted.8; precisa ser configurado para ativar t&uacute;neis e
      DVMRP atrav&eacute;s do <filename>/etc/mrouted.conf</filename>.  Mais
      detalhes sobre a configura&ccedil;&atilde;o multicast podem ser encontradas
      nas p&aacute;gina de manual do mrouted.</para>
    </sect2>
  </sect1>

  <sect1 id="network-wireless">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Eric</firstname>
	  <surname>Anderson</surname>
	  <contrib>Escrito por </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Rede Sem Fio (Wireless)</title>

   <indexterm><primary>wireless networking</primary></indexterm>
   <indexterm>
     <primary>802.11</primary>
     <see>wireless networking</see>
   </indexterm>

   <sect2>
      <title>Introdu&ccedil;&atilde;o</title>
      <para>Pode ser muito &uacute;til a possibilidade de usar um computador 
      sem o inc&ocirc;modo de ter um cabo de rede conectado o tempo todo.  O
      FreeBSD pode ser usado como um cliente sem fio e at&eacute; mesmo como
      um <quote>ponto de acesso</quote> sem fio.</para>
   </sect2>

   <sect2>
     <title>Modos de Opera&ccedil;&atilde;o Sem Fio</title>
     <para>H&aacute; duas formas diferentes de configurar dispositivos sem
     fio 802.11: BSS e IBSS.</para>

     <sect3>
       <title>Modo BSS</title>
       <para>BSS &eacute; o modo tipicamente utilizado.  O modo BSS &eacute;
	tamb&eacute;m chamado de modo infra-estrutura.  Neste modo, uma
	quantidade de pontos de acesso sem fio est&atilde;o conectados a uma
	rede cabeada.  Cada rede sem fio t&ecirc;m seu pr&oacute;prio nome.  Este
	nome &eacute; chamado SSID da rede.</para>
	
       <para>Clientes sem fio conectam-se a estes pontos de acesso.  
       O padr&atilde;o IEEE 802.11 define o protocolo que redes sem fio usam
       para conex&otilde;es.  Um cliente sem fio pode ser ligado a uma rede
       espec&iacute;fica, quando um SSID &eacute; configurado.  Um cliente sem fio
       tamb&eacute;m pode conectar-se a qualquer rede desde que n&atilde;o configure
       explicitamente um SSID.</para>
     </sect3>

     <sect3>
       <title>Modo IBSS</title>
       <para>O modo IBSS, tamb&eacute;m chamado modo ad-hoc, &eacute; projetado para
       conex&otilde;es ponto-a-ponto.  Existem, de fato, dois tipos de modo
       ad-hoc.  Um &eacute; o modo IBSS, tamb&eacute;m chamado de ad-hoc ou
       modo ad-hoc do IEEE.  Este modo &eacute; definido pelos padr&otilde;es IEEE
       802.11.  O segundo modo &eacute; chamado modo ad-hoc demo ou modo
       ad-hoc da Lucent (e, &agrave;s vezes, confusamente, modo ad-hoc).
       Este &eacute; o antigo modo ad-hoc, pr&eacute;-802.11 e somente deve ser
       usado em instala&ccedil;&otilde;es legadas.  N&atilde;o iremos abordar nenhum dos
       modos ad-hoc mais adiante.</para>
     </sect3>
   </sect2>

   <sect2>
     <title>Modo Infra-estrutura</title>
     <sect3>
       <title>Pontos de Acesso</title>

       <para>Pontos de acesso s&atilde;o dispositivos de rede sem fio que
       permitem um ou mais clientes sem fio utilizar o dispositivo
       como um concentrador central.  Ao usar um ponto de acesso, todos
       os clientes comunicam-se atrav&eacute;s do ponto de acesso.  M&uacute;ltiplos
       pontos de acesso s&atilde;o freq&uuml;entemente usados para cobrir uma &aacute;rea
       completa como uma casa, neg&oacute;cio ou parque, com uma rede sem
       fio.</para>

       <para>Pontos de acesso tipicamente possuem m&uacute;ltiplas conex&otilde;es
       de rede: o cart&atilde;o sem fio e um ou mais adaptadores Ethernet
       para conex&atilde;o ao resto da rede.</para>

       <para>Pontos de acesso podem ser comprados montados ou voc&ecirc;
       pode construir o seu pr&oacute;prio com FreeBSD e um cart&atilde;o sem fio
       suportado. Diversos fornecedores fazem pontos de acesso sem fio
       e cart&otilde;es sem fio com caracter&iacute;sticas variadas.</para>
     </sect3>

     <sect3>
       <title>Construindo um Ponto de Acesso FreeBSD</title>
       <indexterm><primary>wireless networking</primary>
	 <secondary>access point</secondary>
       </indexterm>

       <sect4><title>Requisitos</title>

	 <para>Para ativar um ponto de acesso com FreeBSD, voc&ecirc;
	 precisa ter uma placa sem fio compat&iacute;vel.  Atualmente,
	 somente s&atilde;o suportadas as placas com o chipset Prism.  Voc&ecirc;
	 tamb&eacute;m vai precisar de uma placa de rede com fio suportada
	 pelo FreeBSD (n&atilde;o deve ser dif&iacute;cil encontrar, o FreeBSD
	 suporta diversos dispositivos diferentes).  Neste guia, vamos
	 assumir que voc&ecirc; deseja fazer uma ponte (&man.bridge.4;) 
	 de todo o tr&aacute;fego entre o dispositivo sem fio e a rede 
	 conectada na placa de rede com fio.</para>

	 <para>A funcionalidade hostap que o FreeBSD usa para
	 implementar o ponto de acesso funciona melhor com certas
	 vers&otilde;es de firmware.  Placas Prism 2 devem usar o firmware
	 vers&atilde;o 1.3.4 ou mais recente.  Placas Prism 2.5 e Prism 3
	 devem usar o firmware 1.4.9. Vers&otilde;es anteriores de firmware
	 podem ou n&atilde;o funcionar corretamente.  Neste momento, a &uacute;nica
	 forma de atualizar placas &eacute; com ferramentas de atualiza&ccedil;&atilde;o
	 para &windows; disponibilizadas pelo fabricante de sua placa.</para>
       </sect4>

       <sect4>
	 <title>Ativando o Ponto de Acesso</title>
	 <para>Primeiro, certifique-se de que seu sistema reconhece a
	 placa sem fio:</para>
	 <screen>&prompt.root; <userinput>ifconfig -a</userinput>
wi0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
	inet6 fe80::202:2dff:fe2d:c938%wi0 prefixlen 64 scopeid 0x7
	inet 0.0.0.0 netmask 0xff000000 broadcast 255.255.255.255
	ether 00:09:2d:2d:c9:50
	media: IEEE 802.11 Wireless Ethernet autoselect (DS/2Mbps)
	status: no carrier
	ssid ""
	stationname "FreeBSD Wireless node"
	channel 10 authmode OPEN powersavemode OFF powersavesleep 100
	wepmode OFF weptxkey 1</screen>

	 <para>N&atilde;o se preocupe com os detalhes agora, apenas
	 certifique-se de que algo &eacute; mostrado, indicando que voc&ecirc; tem
	 uma placa sem fio instalada.  Se voc&ecirc; tiver problemas em
	 encontrar a interface sem fio e estiver usando um PC card,
	 voc&ecirc; pode querer verificar as p&aacute;ginas de manual
	 &man.pccardc.8; e &man.pccardd.8; para maiores informa&ccedil;&otilde;es.</para>

	 <para>A seguir, voc&ecirc; vai precisar carregar um m&oacute;dulo para
	 ter o FreeBSD funcionando como ponte e pronto para o ponto de
	 acesso. Para carregar o m&oacute;dulo &man.bridge.4;, simplesmente
	 execute o comando:</para>

	 <screen>&prompt.root; <userinput>kldload bridge</userinput></screen>

	 <para>N&atilde;o deve ser mostrado nenhum erro ao se carregar o 
	 m&oacute;dulo.  Se houve algum, talvez voc&ecirc; precise compilar o
	 c&oacute;digo &man.bridge.4; no kernel do seu sistema.  A se&ccedil;&atilde;o
	 <link linkend="network-bridging">Liga&ccedil;&atilde;o</link> do
	 handbook deve ajud&aacute;-lo a executar esta tarefa.</para>

	 <para>Agora que voc&ecirc; tem a parte de liga&ccedil;&atilde;o pronta,
	 precisamos dizer ao kernel do FreeBSD quais interfaces deve
	 ligar.  Fazemos isto usando &man.sysctl.8;:</para>

	 <screen>&prompt.root; <userinput>sysctl net.link.ether.bridge=1</userinput>
&prompt.root; <userinput>sysctl net.link.ether.bridge_cfg="wi0 xl0"</userinput>
&prompt.root; <userinput>sysctl net.inet.ip.forwarding=1</userinput></screen>

	 <para>Agora &eacute; a hora de configurar a placa sem fio.</para>
	 <para>O seguinte comando vai ativar a placa como um ponto de
	 acesso:</para>

	 <screen>
&prompt.root; <userinput>ifconfig wi0 ssid my_net channel 11 media DS/11Mbps mediaopt hostap up stationname "FreeBSD AP"</userinput>
	 </screen>

	 <para>A linha &man.ifconfig.8; ativa a interface 
	  <devicename>wi0</devicename>, configura seu SSID para
	  <literal>my_net</literal>, e ajusta o nome  da esta&ccedil;&atilde;o para
	  <literal>FreeBSD AP</literal>.  A op&ccedil;&atilde;o <option>media
	  DS/11Mbps</option> configura a placa em modo 11Mbps e &eacute;
	  necess&aacute;ria para qualquer par&acirc;metro <option>mediaopt</option> 
	  ter efeito.  A op&ccedil;&atilde;o <option>mediaopt hostap</option> coloca
	  a interface em modo ponto de acesso.  A p&aacute;gina de manual
	  &man.wicontrol.8; tem as op&ccedil;&otilde;es v&aacute;lidas para canais de seu
	  controlador de dom&iacute;nio.</para> 

	 <para>Agora voc&ecirc; deve ter um ponto de acesso completamente
	 funcional ativado e funcionando.  Recomendamos a leitura de 
	 &man.wicontrol.8;, &man.ifconfig.8;, e &man.wi.4; para maiores 
	 informa&ccedil;&otilde;es.</para>

	 <para>Tamb&eacute;m &eacute; sugerido que voc&ecirc; leia a se&ccedil;&atilde;o sobre
	 criptografia a seguir.</para>
       </sect4>

       <sect4>
	 <title>Inform&ccedil;&otilde;es de Estado</title>
	 <para>Uma vez que o ponto de acesso est&aacute; configurado e
	 operacional, os operadores v&atilde;o querer ver os clientes
	 associados ao ponto de acesso.  Em qualquer momento, o
	 operador pode digitar:</para>

	 <screen>&prompt.root; <userinput>wicontrol -l</userinput>
1 station:
00:09:b7:7b:9d:16 asid=04c0, flags=3&lt;ASSOC,AUTH&gt;, caps=1&lt;ESS&gt;, rates=f&lt;1M,2M,5.5M,11M&gt;, sig=38/15
</screen>

	 <para>Isto mostra que h&aacute; uma esta&ccedil;&atilde;o associada, junto com
	 seus par&acirc;metros.  O sinal indicado deve ser usado somente 
	 como uma indica&ccedil;&atilde;o relativa de pot&ecirc;ncia.  Sua tradu&ccedil;&atilde;o para
	 dBm ou outras unidades variam entre diferentes revis&otilde;es de
	 firmware.</para>
       </sect4>
     </sect3>

     <sect3>
       <title>Clientes</title>

       <para>Um cliente sem fio &eacute; um sistema que acessa um ponto de
       acesso ou outro cliente diretamente.</para>

       <para>Tipicamente, os clientes sem fio possuem somente um
       dispositivo de rede, a placa de rede sem fio.</para>

       <para>Existem algumas poucas formas diferentes de configurar 
       um cliente sem fio.  Estas configura&ccedil;&otilde;es s&atilde;o baseadas nos
       diferentes modos sem fio, geralmente BSS (modo infra-estrutura,
       que requer um ponto de acesso), e IBSS (ad-hoc, ou modo 
       ponto-a-ponto).  Em nosso exemplo, vamos usar o mais popular 
       dos dois, modo BSS, para comunica&ccedil;&atilde;o com um ponto de acesso.</para>

       <sect4>
       <title>Requisitos</title>
       <para>H&aacute; somente um &uacute;nico requisito real para ativar o FreeBSD
       como um cliente sem fio.  Voc&ecirc; precisa de uma placa sem fio
       suportada pelo FreeBSD.</para>
       </sect4>

       <sect4>
       <title>Ativando um Cliente Sem Fio FreeBSD</title>

       <para>Antes de come&ccedil;ar, precisa saber algumas coisas 
       sobre a rede sem fio &agrave; qual estar&aacute; se conectando.  Neste
       exemplo, estamos nos conectando a uma rede que tem o nome de 
       <literal>my_net</literal>, e criptografia desligada.</para>

       <para>Neste exemplo, n&atilde;o estamos usando criptografia o que &eacute;
       uma situa&ccedil;&atilde;o de perigo.  Na pr&oacute;xima se&ccedil;&atilde;o, voc&ecirc; aprender&aacute; 
       como ativar criptografia, porque &eacute; importante faz&ecirc;-lo e porque
       algumas tecnologias de criptografia ainda n&atilde;o o protegem
       completamente.</para>

       <para>Certifique-se de que sua placa &eacute; reconhecida pelo
       FreeBSD:</para>

       <screen>&prompt.root; <userinput>ifconfig -a</userinput>
wi0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
	inet6 fe80::202:2dff:fe2d:c938%wi0 prefixlen 64 scopeid 0x7
	inet 0.0.0.0 netmask 0xff000000 broadcast 255.255.255.255
	ether 00:09:2d:2d:c9:50
	media: IEEE 802.11 Wireless Ethernet autoselect (DS/2Mbps)
	status: no carrier
	ssid ""
	stationname "FreeBSD Wireless node"
	channel 10 authmode OPEN powersavemode OFF powersavesleep 100
	wepmode OFF weptxkey 1</screen>

       <para>Agora vamos configurar a placa com os par&acirc;metros corretos
       para nossa rede:</para>

       <screen>&prompt.root; <userinput>ifconfig wi0 inet 192.168.0.20 netmask 255.255.255.0 ssid my_net</userinput></screen>

       <para>Substitua <hostid role="IPADDR">192.168.0.20</hostid> e
       <hostid role="Netmask">255.255.255.0</hostid> com um endere&ccedil;o
       IP e m&aacute;scara de subrede v&aacute;lidos em sua rede com fio.  Lembre-se
       que nosso ponto de acesso est&aacute; fazendo a liga&ccedil;&atilde;o (ponte)
       de dados entre a rede sem fio e a rede com fio, de forma
       que vai parecer aos outros dispositivos na rede que voc&ecirc; est&aacute;
       na rede com fio, assim como eles.</para> 

       <para>Feito isto, voc&ecirc; deve ser capaz de usar ping nos sistemas
       na rede com fio assim como se estivesse conectado usando uma
       conex&atilde;o padr&atilde;o, com fio.</para>

       <para>Se estiver com problemas em sua conex&atilde;o sem fio,
       certifique-se que est&aacute; associado (conectado) ao ponto de
       acesso:</para>

       <screen>&prompt.root; <userinput>ifconfig wi0</userinput></screen>

       <para>deve retornar alguma informa&ccedil;&atilde;o, e voc&Ecirc; deve ver:</para>
       <screen>status: associated</screen>

       <para>Se n&atilde;o mostrar que est&aacute; associado, ent&atilde;o voc&ecirc; deve estar
       fora de alcance do ponto de acesso, estar sem criptografia
       ativada, ou possivelmente tem um problema de configura&ccedil;&atilde;o.</para>

       </sect4>
     </sect3>

     <sect3>
      <title>Criptografia</title>
      <indexterm>
	<primary>wireless networking</primary>
	<secondary>encryption</secondary>
      </indexterm>

      <para>Criptografia em uma rede sem fio &eacute; importante porque voc&ecirc;
      n&atilde;o mais ter&aacute; a capacidade de manter a rede contida em uma &aacute;rea
      bem protegida.  Seus dados sem fio ser&atilde;o transmitidos atrav&eacute;s de
      toda a sua vizinhan&ccedil;a, ent&atilde;o quem quiser poder&aacute; ler seus
      dados.  Aqui entra a criptografia.  Criptografando os dados
      transmitidos por ondas a&eacute;reas, voc&ecirc; torna muito mais dif&iacute;cil a 
      qualquer um capturar seus dados do ar.</para>

     <para>As duas formas mais comuns de criptografar os dados entre
     seu cliente e o ponto de acesso s&atilde;o WEP, e &man.ipsec.4;.</para>

     <sect4>
     <title>WEP</title>
      <indexterm><primary>WEP</primary></indexterm>

      <para>WEP &eacute; uma abrevia&ccedil;&atilde;o para Protocolo para Equival&ecirc;ncia em
      Fio (Wired Equivalency Protocol). WEP &eacute; uma tentativa de tornar
      as redes sem fio t&atilde;o seguras quanto uma rede com fio.
      Infelizmente, foi quebrado e &eacute; bem trivial quebr&aacute;-lo.  Isto
      tamb&eacute;m significa que n&atilde;o &eacute; uma coisa para se contar quando se
      trata de criptografar dados sens&iacute;veis.</para>

      <para>&Eacute; melhor que nada, ent&atilde;o fa&ccedil;a o seguinte para ativar WEP
      em seu novo ponto de acesso FreeBSD:</para>

      <screen>&prompt.root; <userinput>ifconfig wi0 inet up ssid my_net wepmode on wepkey 0x1234567890 media DS/11Mbps mediaopt hostap</userinput></screen>

      <para>E voc&ecirc; pode ativar WEP em um cliente com este comando:</para>

      <screen>&prompt.root; <userinput>ifconfig wi0 inet 192.168.0.20 netmask 255.255.255.0 ssid my_net wepmode on wepkey 0x1234567890</userinput></screen>

      <para>Note que voc&ecirc; deve substituir o
      <literal>0x1234567890</literal> por uma chave mais
      exclusiva.</para>

     </sect4>

     <sect4>
     <title>IPsec</title>

     <para>&man.ipsec.4; &eacute; uma ferramenta muito mais robusta e poderosa 
     para criptografar dados atrav&eacute;s de uma rede.  Esta &eacute;
     definitivamente a forma preferida de criptografar dados em uma 
     rede sem fio.  Voc&ecirc; pode ler mais sobre seguran&ccedil;a &man.ipsec.4; e
     como implement&aacute;-la na se&ccedil;&atilde;o <link linkend="ipsec">IPsec</link> do 
     handbook.</para>
     </sect4>
    </sect3>

    <sect3>
    <title>Ferramentas</title>

    <para>H&aacute; um pequeno n&uacute;mero de ferramentas dispon&iacute;vel para uso na
    determina&ccedil;&atilde;o de problemas e ativa&ccedil;&atilde;o de sua rede sem fio, e aqui
    vamos tentar descrever algumas delas e o que fazem.</para>

    <sect4>
    <title>O Pacote <application>bsd-airtools</application></title>

    <para>O pacote <application>bsd-airtools</application> &eacute; um
    conjunto de ferramentas completo que inclui ferramentas de
    auditoria sem fio para quebrar chaves WEP, detectar pontos de
    acesso etc.</para>

    <para>Os utilit&aacute;rios <application>bsd-airtools</application> podem 
    ser instalados a partir do port <filename
    role="package">net/bsd-airtools</filename>.  Informa&ccedil;&otilde;es sobre
    como instalar ports podem ser encontradas em <xref
    linkend="ports"> do handbook.</para>

    <para>O programa <command>dstumbler</command> &eacute; a ferramenta
    no pacote que permite a descoberta de pontos de acesso e
    representa&ccedil;&atilde;o gr&aacute;fica da raz&atilde;o entre sinal e ru&iacute;do. Se voc&ecirc;
    estiver com dificuldades para ativar seu ponto de acesso,
    <command>dstumbler</command> pode ajud&aacute;-lo a familiarizar-se.</para>

    <para>Para testar a seguran&ccedil;a de sua rede sem fio, voc&ecirc; pode
    escolher usar <quote>dweputils</quote> 
    (<command>dwepcrack</command>, <command>dwepdump</command> e 
    <command>dwepkeygen</command>) para ajud&aacute;-lo a determinar se WEP &eacute;
    a a solu&ccedil;&atilde;o adequada para suas necessidades de seguran&ccedil;a sem
    fio.</para>

    </sect4>

    <sect4>
    <title>Os Utilit&aacute;rios<application>wicontrol</application>, 
    <application>ancontrol</application> e 
    <application>raycontrol</application></title>

    <para>Estas s&atilde;o as ferramentas que voc&ecirc; deve usar para controlar
    como sua placa sem fio se comporta na rede sem fio.  Nos exemplos
    acima, escolhemos usar &man.wicontrol.8;, uma vez que nossa placa
    sem fio &eacute; uma interface <devicename>wi0</devicename>.  Se voc&ecirc;
    tivesse um dispositivo sem fio Cisco, ele apareceria como
    <devicename>an0</devicename>, e assim voc&ecirc; deveria usar
    &man.ancontrol.8;.</para>

    </sect4>

    <sect4>
    <title>O Comando <application>ifconfig</application></title>
    <indexterm><primary>ifconfig</primary></indexterm>

    <para>O &man.ifconfig.8; pode ser usado para fazer muitas das 
    mesmas configura&ccedil;&otilde;es que &man.wicontrol.8;, entretanto &eacute;
    desprovido de algumas poucas op&ccedil;&otilde;es.  Verifique &man.ifconfig.8;
    para op&ccedil;&otilde;es e par&acirc;metros de linha de comando.</para>

    </sect4>

    </sect3>

    <sect3>
    <title>Placas Suportadas</title>
    <sect4>
    <title>Pontos de Acesso</title>

    <para>As &uacute;nicas placas que s&atilde;o suportadas atualmente para modo BSS
    (como um ponto de acesso) s&atilde;o dispositivos baseados nos chipsets
    Prism 2, 2.5 ou 3.  Para uma lista completa, veja &man.wi.4;.</para>

    </sect4>

    <sect4>
    <title>Clientes</title>

    <para>Quase todas as placas sem fio 802.11b s&atilde;o suportadas
    atualmente pelo FreeBSD.  A maioria das placas baseadas em Prism,
    Spectrum24, Hermes, Aironet e Raylink v&atilde;o funcionar como uma placa
    de rede em modo IBSS (ad-hoc, ponto-a-ponto e BSS).</para>

    </sect4>
    </sect3>

   </sect2>
  </sect1>

  <sect1 id="network-bluetooth">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Pav</firstname>
	  <surname>Lucistnik</surname>
	  <contrib>Escrito por </contrib>
	  <affiliation>
	    <address><email>pav@oook.cz</email></address>
	  </affiliation>
	</author>
      </authorgroup>
    </sect1info>
    <title>Bluetooth</title>

    <indexterm><primary>Bluetooth</primary></indexterm>
    <sect2>
      <title>Introdu&ccedil;&atilde;o</title>
      <para>Bluetooth &eacute; uma teconologia sem fio para criar redes
      pessoais operando na na banda n&atilde;o licenciada de 2.4GHz , com um
      alcance de 10 metros.  Redes normalmente s&atilde;o formadas sob
      demanda por dispositivos port&aacute;teis, como telefones celulares,
      handhelds e laptops.  Diferente de outras populares tecnologias 
      sem fio, Wi-Fi, o Bluetooth oferece perfis de servi&ccedil;o de alto
      n&iacute;vel, p.ex.  servidores de arquivos tipo FTP, distribui&ccedil;&atilde;o de 
      arquivos, transporte de voz, emula&ccedil;&atilde;o de linha serial e mais.</para>

      <para>The Bluetooth stack in &os; is implemented using the Netgraph
	framework (see &man.netgraph.4;).  A broad variety of Bluetooth USB
	dongles is supported by the &man.ng.ubt.4; driver.  The Broadcom BCM2033
	chip based Bluetooth devices are supported via the &man.ubtbcmfw.4; and
	&man.ng.ubt.4; drivers.  The 3Com Bluetooth PC Card 3CRWB60-A is
	supported by the &man.ng.bt3c.4; driver.  Serial and UART based
	Bluetooth devices are supported via &man.sio.4;, &man.ng.h4.4;
	and &man.hcseriald.8;.  This chapter describes the use of the USB
	Bluetooth dongle.  Bluetooth support is available in &os; 5.0 and newer
	systems.</para>
    </sect2>

    <sect2>
      <title>Plugging in the Device</title>
      <para>By default Bluetooth device drivers are available as kernel modules.
	Before attaching a device, you will need to load the driver into the
	kernel.</para>

      <screen>&prompt.root; <userinput>kldload ng_ubt</userinput></screen>

      <para>If the Bluetooth device is present in the system during system
	startup, load the module from
	<filename>/boot/loader.conf</filename>.</para>

      <programlisting>ng_ubt_load="YES"</programlisting>

      <para>Plug in your USB dongle.  The output similar to the following will
	appear on the console (or in syslog).</para>

      <screen>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2
ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,
      wMaxPacketSize=49, nframes=6, buffer size=294</screen>

      <para>Copy
	<filename>/usr/share/examples/netgraph/bluetooth/rc.bluetooth</filename>
	into some convenient place, like <filename>/etc/rc.bluetooth</filename>.
	This script is used to start and stop the Bluetooth stack.  It is a good
	idea to stop the stack before unplugging the device, but it is not
	(usually) fatal.  When starting the stack, you will receive output similar
	to the following:</para>

      <screen>&prompt.root; <userinput>/etc/rc.bluetooth start ubt0</userinput>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO link&gt;
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max.  ACL packet size: 192 bytes
Number of ACL packets: 8
Max.  SCO packet size: 64 bytes
Number of SCO packets: 8</screen>

    </sect2>

    <indexterm><primary>HCI</primary></indexterm>
    <sect2>
      <title>Host Controller Interface (HCI)</title>

      <para>Host Controller Interface (HCI) provides a command interface to the
	baseband controller and link manager, and access to hardware status and
	control registers.  This interface provides a uniform method of accessing
	the Bluetooth baseband capabilities.  HCI layer on the Host exchanges
	data and commands with the HCI firmware on the Bluetooth hardware.
	The Host Controller Transport Layer (i.e.  physical bus) driver provides
	both HCI layers with the ability to exchange information with each
	other.</para>

      <para>A single Netgraph node of type <emphasis>hci</emphasis> is
	created for a single Bluetooth device.  The HCI node is normally
	connected to the Bluetooth device driver node (downstream) and
	the L2CAP node (upstream).  All HCI operations must be performed
	on the HCI node and not on the device driver node.  Default name
	for the HCI node is <quote>devicehci</quote>.
	For more details refer to the &man.ng.hci.4; man page.</para>

      <para>One of the most common tasks is discovery of Bluetooth devices in
	RF proximity.  This operation is called <emphasis>inquiry</emphasis>.
	Inquiry and other HCI realated operations are done with the
	&man.hccontrol.8; utility.  The example below shows how to find out
	which Bluetooth devices are in range.  You should receive the list of
	devices in a few seconds.  Note that a remote device will only answer
	the inquiry if it put into <emphasis>discoverable</emphasis>
	mode.</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci inquiry</userinput>
Inquiry result, num_responses=1
Inquiry result #0
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep.  Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete.  Status: No error [00]</screen>

      <para><literal>BD_ADDR</literal> is unique address of a Bluetooth
	device, similar to MAC addresses of a network card.  This address
	is needed for further communication with a device.  It is possible
	to assign human readable name to a BD_ADDR.
	The <filename>/etc/bluetooth/hosts</filename> file contains information
	regarding the known Bluetooth hosts.  The following example shows how
	to obtain human readable name that was assigned to the remote
	device.</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4</userinput>
BD_ADDR: 00:80:37:29:19:a4
Name: Pav's T39</screen>

      <para>If you perform an inquiry on a remote Bluetooth device, it will
	find your computer as <quote>your.host.name (ubt0)</quote>.  The name
	assigned to the local device can be changed at any time.</para>

      <para>The Bluetooth system provides a point-to-point connection (only two
	Bluetooth units involved), or a point-to-multipoint connection.  In the
	point-to-multipoint connection the connection is shared among several
	Bluetooth devices.  The following example shows how to obtain the list
	of active baseband connections for the local device.</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci read_connection_list</userinput>
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41 ACL    0 MAST    NONE       0     0 OPEN</screen>

      <para>A <emphasis>connection handle</emphasis> is useful when termination
	of the baseband connection is required.  Note, that it is normally not
	required to do it by hand.  The stack will automatically terminate
	inactive baseband connections.</para>

      <screen>&prompt.root; <userinput>hccontrol -n ubt0hci disconnect 41</userinput>
Connection handle: 41
Reason: Connection terminated by local host [0x16]</screen>

      <para>Refer to <command>hccontrol help</command> for a complete listing
	of available HCI commands.  Most of the HCI commands do not require
	superuser privileges.</para>

    </sect2>

    <indexterm><primary>L2CAP</primary></indexterm>
    <sect2>
      <title>Logical Link Control and Adaptation Protocol (L2CAP)</title>

      <para>Logical Link Control and Adaptation Protocol (L2CAP) provides
	connection-oriented and connectionless data services to upper layer
	protocols with protocol multiplexing capability and segmentation and
	reassembly operation.  L2CAP permits higher level protocols and
	applications to transmit and receive L2CAP data packets up to 64
	kilobytes in length.</para>

      <para>L2CAP is based around the concept of <emphasis>channels</emphasis>.
	Channel is a logical connection on top of baseband connection.  Each
	channel is bound to a single protocol in a many-to-one fashion.  Multiple
	channels can be bound to the same protocol, but a channel cannot be
	bound to multiple protocols.  Each L2CAP packet received on a channel is
	directed to the appropriate higher level protocol.  Multiple channels
	can share the same baseband connection.</para>

      <para>A single Netgraph node of type <emphasis>l2cap</emphasis> is
	created for a single Bluetooth device.  The L2CAP node is normally
	connected to the Bluetooth HCI node (downstream) and Bluetooth sockets
	nodes (upstream).  Default name for the L2CAP node is
	<quote>devicel2cap</quote>.  For more details refer to the
	&man.ng.l2cap.4; man page.</para>

      <para>A useful command is &man.l2ping.8;, which can be used to ping
	other devices.  Some Bluetooth implementations might not return all of
	the data sent to them, so <emphasis>0 bytes</emphasis> in the following
	example is normal.</para>

      <screen>&prompt.root; <userinput>l2ping -a 00:80:37:29:19:a4</userinput>
0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0</screen>

      <para>The &man.l2control.8; utility is used to perform various operations
	on L2CAP nodes.  This example shows how to obtain the list of logical
	connections (channels) and the list of baseband connections for the
	local device.</para>

      <screen>&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_channel_list</userinput>
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_connection_list</userinput>
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O	   0 OPEN</screen>

      <para>Another diagnostic tool is &man.btsockstat.1;.  It does a job
	similar to as &man.netstat.1; does, but for Bluetooth network-related
	data structures.  The example below shows the same logical connection as
	&man.l2control.8; above.</para>

      <screen>&prompt.user; <userinput>btsockstat</userinput>
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</screen>

    </sect2>

    <indexterm><primary>RFCOMM</primary></indexterm>
    <sect2>
      <title>RFCOMM Protocol</title>

      <para>The RFCOMM protocol provides emulation of serial ports over the
	L2CAP protocol.  The protocol is based on the ETSI standard TS 07.10.
	RFCOMM is a simple transport protocol, with additional provisions for
	emulating the 9 circuits of RS-232 (EIATIA-232-E) serial ports.  The
	RFCOMM protocol supports up to 60 simultaneous connections (RFCOMM
	channels) between two Bluetooth devices.</para>

      <para>For the purposes of RFCOMM, a complete communication path involves
	two applications running on different devices (the communication
	endpoints) with a communication segment between them.  RFCOMM is intended
	to cover applications that make use of the serial ports of the devices
	in which they reside.  The communication segment is a Bluetooth link from
	one device to another (direct connect).</para>

      <para>RFCOMM is only concerned with the connection between the devices in
	the direct connect case, or between the device and a modem in the
	network case.  RFCOMM can support other configurations, such as modules
	that communicate via Bluetooth wireless technology on one side and
	provide a wired interface on the other side.</para>

      <para>In &os; the RFCOMM protocol is implemented at the Bluetooth sockets
	layer.</para>
    </sect2>

    <indexterm><primary>pairing</primary></indexterm>
    <sect2>
      <title>Pairing of Devices</title>

      <para>By default, Bluetooth communication is not authenticated, and any
	device can talk to any other device.  A Bluetooth device (for example,
	cellular phone) may choose to require authentication to provide a
	particular service (for example, Dial-Up service).  Bluetooth
	authentication is normally done with <emphasis>PIN codes</emphasis>.
	A PIN code is an ASCII string up to 16 characters in length.  User is
	required to enter the same PIN code on both devices.  Once user has
	entered the PIN code, both devices will generate a
	<emphasis>link key</emphasis>.  After that the link key can be stored
	either in the devices themselves or in a persistent storage.  Next time
	both devices will use previously generated link key.  The described
	above procedure is called <emphasis>pairing</emphasis>.  Note that if
	the link key is lost by any device then pairing must be repeated.</para>

      <para>The &man.hcsecd.8; daemon is responsible for handling of all
	Bluetooth authentication requests.  The default configuration file is
	<filename>/etc/bluetooth/hcsecd.conf</filename>.  An example section for
	a cellular phone with the PIN code arbitrarily set to
	<quote>1234</quote> is shown below.</para>

      <programlisting>device {
	bdaddr 00:80:37:29:19:a4;
	name    "Pav's T39";
	key     nokey;
	pin     "1234";
      }</programlisting>

      <para>There is no limitation on PIN codes (except length).  Some devices
	(for example Bluetooth headsets) may have a fixed PIN code built in.
	The <option>-d</option> switch forces the &man.hcsecd.8; daemon to stay
	in the foreground, so it is easy to see what is happening.  Set the
	remote device to receive pairing and initiate the Bluetooth connection
	to the remote device.  The remote device should say that pairing was
	accepted, and request the PIN code.  Enter the same PIN code as you
	have in <filename>hcsecd.conf</filename>.  Now your PC and the remote
	device are paired.  Alternatively, you can initiate pairing on the remote
	device.  Below in the sample <command>hcsecd</command> output.</para>

<programlisting>hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4</programlisting>

    </sect2>

    <indexterm><primary>SDP</primary></indexterm>
    <sect2>
      <title>Service Discovery Protocol (SDP)</title>
      <para>The Service Discovery Protocol (SDP) provides the means for client
	applications to discover the existence of services provided by server
	applications as well as the attributes of those services.  The attributes
	of a service include the type or class of service offered and the
	mechanism or protocol information needed to utilize the service.</para>

      <para>SDP involves communication between a SDP server and a SDP client.
	The server maintains a list of service records that describe the
	characteristics of services associated with the server.  Each service
	record contains information about a single service.  A client may
	retrieve information from a service record maintained by the SDP server
	by issuing a SDP request.  If the client, or an application associated
	with the client, decides to use a service, it must open a separate
	connection to the service provider in order to utilize the service.
	SDP provides a mechanism for discovering services and their attributes,
	but it does not provide a mechanism for utilizing those services.</para>

      <para>Normally, a SDP client searches for services based on some desired
	characteristics of the services.  However, there are times when it is
	desirable to discover which types of services are described by an SDP
	server's service records without any a priori information about the
	services.  This process of looking for any offered services is called
	<emphasis>browsing</emphasis>.</para>

      <para>Currently Bluetooth SDP server and client are implemented in a
	third-party package <application>sdp-1.5</application> that can be
	downloaded from
	<ulink url="http://www.geocities.com/m_evmenkin/">here</ulink>.  The
	<application>sdptool</application> is a command line SDP client.
	The following example shows how to perform a SDP browse query.</para>

      <screen>&prompt.root; <userinput>sdptool browse 00:80:37:29:19:a4</userinput>
Browsing 00:80:37:29:19:A4 ...
Service Name: Dial-up Networking
Protocol Descriptor List:
 "L2CAP" (0x0100)
 "RFCOMM" (0x0003)
   Channel: 1

Service Name: Fax
Protocol Descriptor List:
 "L2CAP" (0x0100)
 "RFCOMM" (0x0003)
   Channel: 2

Service Name: Voice gateway
Service Class ID List:
 "Headset Audio Gateway" (0x1112)
 "Generic Audio" (0x1203)
Protocol Descriptor List:
 "L2CAP" (0x0100)
 "RFCOMM" (0x0003)
   Channel: 3
</screen>

      <para>...  and so on.  Note that each service has a list of attributes
	(RFCOMM channel for example).  Depending on the service you might need to
	make a note of some of the attributes.  Some Bluetooth implementations do
	not support service browsing and may return an empty list.  In this case
	it is possible to search for the specific service.  The example below
	shows how to search for the OBEX Object Push (OPUSH) service.</para>

      <screen>&prompt.root; <userinput>sdptool search --bdaddr 00:07:e0:00:0b:ca OPUSH</userinput></screen>

      <para>Offering services on &os; to Bluetooth clients is done with the
	<application>sdpd</application> server.</para>
      <screen>&prompt.root; <userinput>sdpd</userinput></screen>

      <para>The <application>sdptool</application> is also used to register
	a service with the local SDP server.  The example below shows how to
	register the Network Access with PPP (LAN) service.  Note that some
	services require attributes (RFCOMM channel for example).</para>

      <screen>&prompt.root; <userinput>sdptool add --channel=7 LAN</userinput></screen>

      <para>The list of services registered with local SDP server can be
	obtained by issuing SDP browse query to a <quote>special</quote>
	BD_ADDR.</para>

      <screen>&prompt.root; <userinput>sdptool browse ff:ff:ff:00:00:00</userinput></screen>

    </sect2>

    <sect2>
      <title>Dial-Up Networking (DUN) and Network Access with PPP (LAN)
	Profiles</title>

      <para>The Dial-Up Networking (DUN) profile is mostly used with modems
	and cellular phones.  The scenarios covered by this profile are the
	following:</para>

      <itemizedlist>
	<listitem><para>use of a cellular phone or modem by a computer as
	  a wireless modem for connecting to a dial-up internet access server,
	  or using other dial-up services;</para></listitem>

	<listitem><para>use of a cellular phone or modem by a computer to
	  receive data calls.</para></listitem>
      </itemizedlist>

      <para>Network Access with PPP (LAN) profile can be used in the following
	situations:</para>

      <itemizedlist>
	<listitem><para>LAN access for a single Bluetooth device;
</para></listitem>

	<listitem><para>LAN access for multiple Bluetooth devices;
</para></listitem>

	<listitem><para>PC to PC (using PPP networking over serial cable
	  emulation).</para></listitem>
      </itemizedlist>

      <para>In &os; both profiles are implemented with &man.ppp.8; and
	&man.rfcomm.pppd.8; - a wrapper that converts RFCOMM Bluetooth
	connection into something PPP can operate with.  Before any profile
	can be used, a new PPP label in <filename>/etc/ppp/ppp.conf</filename>
	must be created.  Consult &man.rfcomm.pppd.8; manual page for examples.
</para>

      <para>In the following example &man.rfcomm.pppd.8; will be used to open
	RFCOMM connection to remote device with BD_ADDR 00:80:37:29:19:a4 on
	DUN RFCOMM channel.  The actual RFCOMM channel number will be obtained
	from the remote device via SDP.  It is possible to specify RFCOMM channel
	by hand, and in this case &man.rfcomm.pppd.8; will not perform SDP
	query.  Use <application>sdptool</application> to find out RFCOMM
	channel on the remote device.</para>

      <screen>&prompt.root; <userinput>rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</userinput></screen>

      <para>In order to provide Network Access with PPP (LAN) service
	<application>sdpd</application> server must be running.  It is also
	required to register LAN service with the local SDP server.  Note that
	LAN service requires RFCOMM channel attribute.  A new entry for LAN
	clients must be created in <filename>/etc/ppp/ppp.conf</filename> file.
	Consult &man.rfcomm.pppd.8; manual page for examples.  Finally, RFCOMM
	PPP server must be running and listening on the same RFCOMM channel
	as registered with the local SDP server.  The example below shows how
	to start RFCOMM PPP server.</para>

      <screen>&prompt.root; <userinput>rfcomm_pppd -s -C 7 -l rfcomm-server</userinput></screen>

    </sect2>

    <indexterm><primary>OBEX</primary></indexterm>
    <sect2>
      <title>OBEX Push (OPUSH) Profile</title>
      <para>OBEX is a widely used protocol for simple file transfers between
	mobile devices.  Its main use is in infrared communication, where it is
	used for generic file transfers between notebooks or Palm handhelds,
	and for sending business cards or calendar entries between cellular
	phones and other devices with PIM applications.</para>

      <para>The OBEX server and client are implemented as a third-party package
	<application>obexapp-1.0</application> that can be downloaded from
	<ulink url="http://www.geocities.com/m_evmenkin/">here</ulink>.
	The package requires the <application>openobex</application> library
	(included) and the <filename role="package">devel/glib12</filename>
	port.  Note that <application>obexapp</application> does not require
	root privileges to operate.</para>

      <para>OBEX client is used to push and/or pull objects from the OBEX server.
	An object can, for example, be a business card or an appointment.
	The OBEX client can obtain RFCOMM channel number from the remote device
	via SDP.  This can be done by specifying service name instead of RFCOMM
	channel number.  Supported service names are: IrMC, FTRN and OPUSH.
	It is possible to specify RFCOMM channel as a number.  Below is an
	example of an OBEX session, where device information object is pulled
	from the cellular phone, and a new object (business card) is pushed
	into the phone's directory.</para>

      <screen>&prompt.user; <userinput>obexapp -a 00:80:37:29:19:a4 -C IrMC</userinput>
obex&gt; get
get: remote file&gt; telecom/devinfo.txt
get: local file&gt; devinfo-t39.txt
Success, response: OK, Success (0x20)
obex&gt; put
put: local file&gt; new.vcf
put: remote file&gt; new.vcf
Success, response: OK, Success (0x20)
obex&gt; di
Success, response: OK, Success (0x20)</screen>

      <para>In order to provide OBEX Push service,
	<application>sdpd</application> server must be running.  It is also
	required to register OPUSH service with the local SDP server.  Note that
	OPUSH service requires RFCOMM channel attribute.  A root folder, where
	all incoming objects will be stored, must be created.  The default path
	to the root folder is <filename>/var/spool/obex</filename>.  Finally,
	OBEX server must be running and listening on the same RFCOMM channel
	as registered with the local SDP server.  The example below shows how
	to start OBEX server.</para>

      <screen>&prompt.root; <userinput>obexapp -s -C 10</userinput></screen>
    </sect2>

    <sect2>
      <title>Serial Port (SP) Profile</title>
      <para>The Serial Port (SP) profile allows Bluetooth device to perform
	RS232 (or similar) serial cable emulation.  The scenario covered by this
	profile deals with legacy applications using Bluetooth as a cable
	replacement, through a virtual serial port abstraction.</para>

      <para>The &man.rfcomm.sppd.1; utility implements the Serial Port profile.
	Pseudo tty is used as a virtual serial port abstraction.  The example
	below shows how to connect to a remote device Serial Port service.
	Note that you do not have to specify RFCOMM channel -
	&man.rfcomm.sppd.1; can obtain it from the remote device via SDP.
	If you would like to override this, specify RFCOMM channel in the
	command line.</para>

      <screen>&prompt.root; <userinput>rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6</userinput>
rfcomm_sppd[94692]: Starting on /dev/ttyp6...</screen>

      <para>Once connected pseudo tty can be used as serial port.</para>

      <screen>&prompt.root; <userinput>cu -l ttyp6</userinput></screen>

    </sect2>

    <sect2>
      <title>Troubleshooting</title>

      <sect3>
	<title>A remote device cannot connect</title>
	<para>Some older Bluetooth devices do not support role switching.
	  By default, when &os; is accepting a new connection, it tries to
	  perform role switch and become a master.  Devices, which do not
	  support this will not be able to connect.  Note the role switching is
	  performed when a new connection is being established, so it is not
	  possible to ask the remote device if it does support role switching.
	  There is a HCI option to disable role switching on the local
	  side.</para>

	<screen>&prompt.root; <userinput>hccontrol -n ubt0hci write_node_role_switch 0</userinput></screen>

      </sect3>

      <sect3>
	<title>Something is going wrong, can I see what exactly is happening?</title>
	<para>Yes, you can.  Use the <application>hcidump-1.5</application>
	  third-party package that can be downloaded from
	  from <ulink url="http://www.geocities.com/m_evmenkin/">here</ulink>.
	  The <application>hcidump</application> utility is similar to
	  &man.tcpdump.1;.  It can used to display the content of the Bluetooth
	  packets on the terminal and to dump the Bluetooth packets to a
	  file.</para>
      </sect3>

    </sect2>

  </sect1>

  <sect1 id="network-bridging">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Steve</firstname>
      	  <surname>Peterson</surname>
	  <contrib>Escrito por</contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Liga&ccedil;&atilde;o (Bridging)</title>

    <sect2>
      <title>Introdu&ccedil;&atilde;o</title>
      <indexterm><primary>IP subnet</primary></indexterm>
      <indexterm><primary>bridge</primary></indexterm>
      <para>&Agrave;s vezes &eacute; &uacute;til dividir uma rede f&iacute;sica (como um segmento
      Ethernet) em dois segmentos sem ter que criar subredes IP e usar
      um roteador para conectar os segmentos.  Um dispositivo que
      conecta duas redes juntas desta maneira &eacute; chamado de
      <quote>liga&ccedil;&atilde;o</quote>, ou <quote>ponte</quote>.  Um sistema
      FreeBSD com duas interfaces de rede pode atuar como uma liga&ccedil;&atilde;o.</para>

      <para>A liga&ccedil;&atilde;o funciona aprendendo os endere&ccedil;os da camada MAC
      (endere&ccedil;os Ethernet) dos dispositivos em cada uma de suas
      interfaces de rede.  Ela repassa  o tr&aacute;fego entre duas redes
      somente quando sua origem e destino est&atilde;o em redes diferentes.</para>

      <para>Em muitos aspectos, uma liga&ccedil;&atilde;o &eacute; como um comutador
      Ethernet com muito poucas portas.</para>
    </sect2>

    <sect2>
      <title>Situa&ccedil;&otilde;es Convenientes Para Uso de Liga&ccedil;&atilde;o</title>

      <para>Atualmente, existem duas situa&ccedil;&otilde;es comuns nas quais
      liga&ccedil;&otilde;es s&atilde;o implementadas.</para>

      <sect3>
	<title>Alto Tr&aacute;fego em um Segmento</title>

	<para>A primeira situa&ccedil;&atilde;o &eacute; onde seu segmento de rede f&iacute;sico
	est&aacute; sobrecarregado com tr&aacute;fego mas voc&ecirc; n&atilde;o quer, por
	quaisquer raz&otilde;es, subdividir a rede e interconectar as
	subredes com um roteador.</para>

	<para>Vamos considerar um exemplo de um jornal onde os
	departamentos Editorial e de Produ&ccedil;&atilde;o est&atilde;o na mesma subrede.
	Todos os usu&aacute;rios do Editorial usam o servidor A para servir
	arquivos e os usu&atilde;rios de Produ&ccedil;&atilde;o est&atilde;o no servidor B.  Uma
	Ethernet &eacute; usada para conectar todos os usu&aacute;rios e altas
	cargas de tr&aacute;fego na rede est&atilde;o degradando o desempenho.</para>

	<para>Se o os usu&aacute;rios do Editorial pudessem ser segregados em
	um segmento de rede e os usu&aacute;rios da Produ&ccedil;&atilde;o em outra, ambos
	segmentos de rede podem ser conectador com uma liga&ccedil;&atilde;o.  Somente 
	o tr&aacute;fego destinado a interfaces no <quote>outro</quote> 
	lado da liga&ccedil;&atilde;o poderia ser enviado para a outra rede,
	reduzindo a congest&atilde;o em cada segmento de rede.</para>
	
      </sect3>

      <sect3>
	<title>Filtering/Traffic Shaping Firewall</title>
	<indexterm><primary>firewall</primary></indexterm>
	<indexterm><primary>IP Masquerading</primary></indexterm>

	<para>A segunda situa&ccedil;&atilde;o comum &eacute; aquela onde a funcionalidade
	de firewall &eacute; necess&aacute;ria sem uso de mascaramento de IP
	(NAT).</para>

	<para>Um exemplo &eacute; uma pequena companhia conectada via DSL ou
	ISDN ao seu PSI.  Eles possuem 13 endere&ccedil;os IP de seu PSI 
	globalmente acess&iacute;veis e 10 PCs em sua rede.  Nesta situa&ccedil;&atilde;o, 
	&eacute; dif&iacute;cil usar um firewall baseado em roteador por quest&otilde;es 
	de divis&otilde;es de subrede.</para>

	<indexterm><primary>router</primary></indexterm>
	<indexterm><primary>DSL</primary></indexterm>
	<indexterm><primary>ISDN</primary></indexterm>
	<para>Um firewall baseado em ponte (bridge) pode ser
	configurado e inserido no caminho somente de entrada do
	roteador DSL/ISDN sem quaisquer quest&otilde;es de numera&ccedil;&atilde;o IP.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Configurando uma Ponte (Bridge)</title>

      <sect3>
	<title>Sele&ccedil;&atilde;o de Placa Interface de Rede</title>

	<para>Uma ponte requer pelo menos duas interfaces de rede para
	funcionar.  Infelizmente, nem todas as placas interface de
	rede da &eacute;poca do FreeBSD&nbsp;4.0 suportam liga&ccedil;&otilde;es.  Leia
	&man.bridge.4; para detalhes sobre placas suportadas.</para>

	<para>Instale e teste as duas placas de rede antes de
	continuar.</para>
      </sect3>

      <sect3>
	<title>Altera&ccedil;&otilde;es nas Configura&ccedil;&otilde;es do Kernel</title>
	<indexterm>
	  <primary>kernel options</primary>
	  <secondary>options BRIDGE</secondary>
	</indexterm>

	<para>Para ativar suporte no kernel para liga&ccedil;&otilde;es, adicione:</para>

	<programlisting>options BRIDGE</programlisting>

	<para>ao seu arquivo de configura&ccedil;&atilde;o do kernel e recompile o
	mesmo.</para>
      </sect3>

      <sect3>
	<title>Suporte a Firewall</title>
	<indexterm><primary>firewall</primary></indexterm>
	<para>Se voc&ecirc; estiver planejando usar a ponte como firewall,
	voc&ecirc; tamb&eacute;m vai precisar adicionar a op&ccedil;&atilde;o 
	<varname>IPFIREWALL</varname>.  Leia <xref
	linkend="firewalls"> para informa&ccedil;&otilde;es gerais sobre
	configura&ccedil;&atilde;o de ponte como firewall.</para>

	<para>Se precisar permitir pacotes n&atilde;o-IP (como ARP)
	trafegarem atrav&eacute;s da ponte, h&aacute; uma op&ccedil;&atilde;o n&atilde;o documentada de
	firewall que precisa ser ativada.  Esta op&ccedil;&atilde;o &eacute; 
	<literal>IPFIREWALL_DEFAULT_TO_ACCEPT</literal>.  Note que
	isto altera a regra padr&atilde;o para que o firewall aceite qualquer
	pacote.  Certifique-se de que compreende como isto muda o
	sentido de seu conjunto de regras antes de ativ&aacute;-la.</para>
      </sect3>

      <sect3>
	<title>Suporte a Formata&ccedil;&atilde;o de Tr&aacute;fego (Traffic Shaping)</title>

	<para>Se voc&ecirc; desejar usar a ponte como formatador de tr&aacute;fego,
	voc&ecirc; vai precisar adicionar a op&ccedil;&atilde;o <literal>DUMMYNET</literal> 
	&agrave; sua configura&ccedil;&atilde;o de kernel.  Leia &man.dummynet.4; para
	maiores informa&ccedil;&otilde;es.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Ativando a Ponte</title>

      <para>Adicione a linha:</para>

      <programlisting>net.link.ether.bridge=1</programlisting>

      <para>ao <filename>/etc/sysctl.conf</filename> para ativar a
      ponte em tempo de execu&ccedil;&atilde;o, e a linha:</para>

      <programlisting>net.link.ether.bridge_cfg=<replaceable>if1</replaceable>,<replaceable>if2</replaceable></programlisting>

      <para>para ativar a liga&ccedil;&atilde;o nas interfaces especificadas
      (substitua <replaceable>if1</replaceable> e
      <replaceable>if2</replaceable> com os nomes de suas duas
      interfaces de rede).  Se quiser que os pacotes de liga&ccedil;&atilde;o sejam
      filtrados por &man.ipfw.8;, voc&ecirc; tamb&eacute;m deve adicionar:</para>

      <programlisting>net.link.ether.bridge_ipfw=1</programlisting>

      <para>ao arquivo de configura&ccedil;&atilde;o.</para>
    </sect2>

    <sect2>
      <title>Outras Informa&ccedil;&otilde;es</title>

      <para>Se voc&ecirc; precisar efetuar um telnet para a ponte a partir
      da rede, n&atilde;o h&aacute; problemas em se atribuir um endere&ccedil;o IP a uma
      das placas de interface de rede.  O consenso &eacute; que n&atilde;o &eacute; boa
      id&eacute;ia atribuir endere&ccedil;os a ambas as placas.</para>

      <para>Se voc&ecirc; tem m&uacute;ltiplas pontes em sua rede, n&atilde;o pode haver
      mais que um caminho entre duas esta&ccedil;&otilde;es de trabalho.
      Tecnicamente, isto significa que n&atilde;o h&aacute; suporte para
      gerenciamento de enlaces spanning tree.</para>

      <para>Uma ponte pode acrescentar lat&ecirc;ncia ao tempo de resposta
      de pings, especialmente no tr&aacute;fego entre segmentos.</para>

    </sect2>
  </sect1>

  <sect1 id="network-nfs">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Reorganized and enhanced by </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Bill</firstname>
      	  <surname>Swingle</surname>
	  <contrib>Written by </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>NFS</title>

    <indexterm><primary>NFS</primary></indexterm>
    <para>Among the many different filesystems that FreeBSD supports is
      the Network File System, also known as <acronym>NFS</acronym>.
      <acronym>NFS</acronym> allows a system to share directories and files
      with others over a network.  By using <acronym>NFS</acronym>, users and
      programs can access files on remote systems almost as if they were local
      files.</para>

    <para>Some of the most notable benefits that
      <acronym>NFS</acronym> can provide are:</para>

    <itemizedlist>
      <listitem>
	<para>Local workstations use less disk space because
	  commonly used data can be stored on a single machine and still
	  remain accessible to others over the network.</para>
      </listitem>

      <listitem>
	<para>There is no need for users to have separate home directories
	  on every network machine.  Home directories could be set up on the
	  <acronym>NFS</acronym> server and made available throughout
	  the network.</para>
      </listitem>

      <listitem>
	<para>Storage devices such as floppy disks, CDROM drives, and
	  ZIP drives can be used by other machines on the network.
	  This may reduce the number of removable media drives
	  throughout the network.</para>
      </listitem>
    </itemizedlist>

    <sect2>
      <title>How <acronym>NFS</acronym> Works</title>

      <para><acronym>NFS</acronym> consists of at least two main parts:
	a server and one or more clients.  The client remotely accesses
	the data that is stored
	on the server machine.  In order for this to function properly a few
	processes have to be configured and running:</para>

      <note><para>In &os; 5.X, the <application>portmap</application> utility
	has been replaced with the <command>rpcbind</command> utility.  Thus,
	in &os; 5.X the user is required to replace every instance of
	<application>portmap</application> with <command>rpcbind</command>
	in the forthcoming examples.</para></note>

      <para>The server has to be running the following daemons:</para>
      <indexterm>
	<primary>NFS</primary>
	<secondary>server</secondary>
      </indexterm>
      <indexterm>
	<primary><application>portmap</application></primary>
      </indexterm>
      <indexterm>
	<primary><application>mountd</application></primary>
      </indexterm>
      <indexterm>
	<primary><application>nfsd</application></primary>
      </indexterm>

      <informaltable frame="none">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Daemon</entry>
	      <entry>Description</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>nfsd</entry>
	      <entry>The <acronym>NFS</acronym> daemon which services requests from
	      the <acronym>NFS</acronym> clients.</entry>
	    </row>
	    <row>
	      <entry>mountd</entry>
	      <entry>The <acronym>NFS</acronym> mount daemon which carries out
		the requests that &man.nfsd.8; passes on to it.</entry>
	    </row>
	    <row>
	      <entry>portmap</entry>
	      <entry> The portmapper daemon
		allows <acronym>NFS</acronym> clients to discover which port the <acronym>NFS</acronym> server
		is using.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>The client can also run a daemon, known as
	<application>nfsiod</application>.  The
	<application>nfsiod</application> daemon services the requests
	from the <acronym>NFS</acronym> server.  This is optional, and
	improves performance, but is not required for normal and
	correct operation.  See the &man.nfsiod.8; manual page for
	more information.
</para>
    </sect2>

    <sect2 id="network-configuring-nfs">
      <title>Configuring <acronym>NFS</acronym></title>
      <indexterm>
	<primary>NFS</primary>
	<secondary>configuration</secondary>
      </indexterm>

      <para><acronym>NFS</acronym> configuration is a relatively
	straightforward process.  The processes that need to be
	running can all start at boot time with a few modifications to
	your <filename>/etc/rc.conf</filename> file.</para>

      <para>On the <acronym>NFS</acronym> server, make sure that the
	following options are configured in the
	<filename>/etc/rc.conf</filename> file:</para>

      <programlisting>portmap_enable="YES"
nfs_server_enable="YES"
mountd_flags="-r"</programlisting>

      <para><command>mountd</command> runs automatically whenever the
	<acronym>NFS</acronym> server is enabled.</para>

      <para>On the client, make sure this option is present in
	<filename>/etc/rc.conf</filename>:</para>

      <programlisting>nfs_client_enable="YES"</programlisting>

      <para>The <filename>/etc/exports</filename> file specifies which
	filesystems <acronym>NFS</acronym> should export (sometimes
	referred to as <quote>share</quote>).  Each line in
	<filename>/etc/exports</filename> specifies a filesystem to be
	exported and which machines have access to that filesystem.
	Along with what machines have access to that filesystem,
	access options may also be specified.  There are many such
	options that can be used in this file but only a few will be
	mentioned here.  You can easily discover other options by
	reading over the &man.exports.5; manual page.</para>

      <para>Here are a few example <filename>/etc/exports</filename>
	entries:</para>

      <indexterm>
	<primary>NFS</primary>
	<secondary>export examples</secondary>
      </indexterm>

      <para>The following examples give an idea of how to export filesystems,
	although the settings may be different depending on
	your environment and network configuration.
	For instance, to export the <filename>/cdrom</filename> directory to
	three example machines that have the same domain name as the server
	(hence the lack of a domain name for each) or have entries in your
	<filename>/etc/hosts</filename> file.  The <option>-ro</option>
	flag makes the exported filesystem read-only.  With this flag, the
	remote system will not be able to write any changes to the
	exported filesystem.</para>

      <programlisting>/cdrom -ro host1 host2 host3</programlisting>

      <para>The following line exports <filename>/home</filename> to
	three hosts by IP address.  This is a useful setup if you have
	a private network without a <acronym>DNS</acronym> server
	configured.  Optionally the <filename>/etc/hosts</filename>
	file could be configured for internal hostnames; please review
	&man.hosts.5; for more information.  The
	<option>-alldirs</option> flag allows the subdirectories to be
	mount points.  In other words, it will not mount the
	subdirectories but permit the client to mount only the
	directories that are required or needed.</para>

      <programlisting>/home  -alldirs 10.0.0.2 10.0.0.3 10.0.0.4</programlisting>

      <para>The following line exports <filename>/a</filename> so that
	two clients from different domains may access the filesystem.
	The <option>-maproot=root</option> flag allows the
	<username>root</username> user on the remote system to write
	data on the exported filesystem as <username>root</username>.
	If the <literal>-maproot=root</literal> flag is not specified,
	then even if a user has <username>root</username> access on
	the remote system, they will not be able to modify files on
	the exported filesystem.</para>

      <programlisting>/a  -maproot=root host.example.com box.example.org</programlisting>

      <para>In order for a client to access an exported filesystem,
	the client must have permission to do so.  Make sure the
	client is listed in your <filename>/etc/exports</filename>
	file.</para>

      <para>In <filename>/etc/exports</filename>, each line represents
	the export information for one filesystem to one host.  A
	remote host can only be specified once per filesystem, and may
	only have one default entry.  For example, assume that
	<filename>/usr</filename> is a single filesystem.  The
	following <filename>/etc/exports</filename> would be
	invalid:</para>

      <programlisting>/usr/src   client
/usr/ports client</programlisting>

      <para>One filesystem, <filename>/usr</filename>, has two lines
	specifying exports to the same host, <hostid>client</hostid>.
	The correct format for this situation is:</para>

      <programlisting>/usr/src /usr/ports client</programlisting>

      <para>The properties of one filesystem exported to a given host
	must all occur on one line.  Lines without a client specified
	are treated as a single host.  This limits how you can export
	filesystems, but for most people this is not an issue.</para>

      <para>The following is an example of a valid export list, where
	<filename>/usr</filename> and <filename>/exports</filename>
	are local filesystems:</para>

      <programlisting># Export src and ports to client01 and client02, but only
# client01 has root privileges on it
/usr/src /usr/ports -maproot=root    client01
/usr/src /usr/ports	       client02
# The client machines have root and can mount anywhere
# on /exports.  Anyone in the world can mount /exports/obj read-only
/exports -alldirs -maproot=root      client01 client02
/exports/obj -ro</programlisting>

      <para>You must restart
	<command>mountd</command> whenever you modify
	<filename>/etc/exports</filename> so the changes can take effect.
	This can be accomplished by sending the HUP signal
	to the <command>mountd</command> process:</para>

      <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/mountd.pid`</userinput></screen>

      <para>Alternatively, a reboot will make FreeBSD set everything
	up properly.  A reboot is not necessary though.
	Executing the following commands as <username>root</username>
	should start everything up.</para>

      <para>On the <acronym>NFS</acronym> server:</para>

      <screen>&prompt.root; <userinput>portmap</userinput>
&prompt.root; <userinput>nfsd -u -t -n 4</userinput>
&prompt.root; <userinput>mountd -r</userinput></screen>

      <para>On the <acronym>NFS</acronym> client:</para>

      <screen>&prompt.root; <userinput>nfsiod -n 4</userinput></screen>

      <para>Now everything should be ready to actually mount a remote file
	system.  In these examples the
	server's name will be <literal>server</literal> and the client's
	name will be <literal>client</literal>.  If you only want to
	temporarily mount a remote filesystem or would rather test the
	configuration, just execute a command like this as <username>root</username> on the
	client:</para>
      <indexterm>
	<primary>NFS</primary>
	<secondary>mounting</secondary>
      </indexterm>
      <screen>&prompt.root; <userinput>mount server:/home /mnt</userinput></screen>

      <para>This will mount the <filename>/home</filename> directory
	on the server at <filename>/mnt</filename> on the client.  If
	everything is set up correctly you should be able to enter
	<filename>/mnt</filename> on the client and see all the files
	that are on the server.</para>

      <para>If you want to automatically mount a remote filesystem
	each time the computer boots, add the filesystem to the
	<filename>/etc/fstab</filename> file.  Here is an example:</para>

      <programlisting>server:/home	/mnt	nfs	rw	0	0</programlisting>

      <para>The &man.fstab.5; manual page lists all the available options.</para>
    </sect2>

    <sect2>
      <title>Practical Uses</title>

      <para><acronym>NFS</acronym> has many practical uses.  Some of the more common
	ones are listed below:</para>

      <indexterm>
	<primary>NFS</primary>
	<secondary>uses</secondary>
      </indexterm>
      <itemizedlist>
	<listitem>
	  <para>Set several machines to share a CDROM or other media
	    among them.  This is cheaper and often a more convenient
	    method to install software on multiple machines.</para>
	</listitem>

	<listitem>
	  <para>On large networks, it might be more convenient to
	    configure a central <acronym>NFS</acronym> server in which
	    to store all the user home directories.  These home
	    directories can then be exported to the network so that
	    users would always have the same home directory,
	    regardless of which workstation they log in to.</para>
	</listitem>

	<listitem>
	  <para>Several machines could have a common
	    <filename>/usr/ports/distfiles</filename> directory.  That
	    way, when you need to install a port on several machines,
	    you can quickly access the source without downloading it
	    on each machine.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2 id="network-amd">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Wylie</firstname>
	    <surname>Stilwell</surname>
	    <contrib>Contributed by </contrib>
	  </author>
	</authorgroup>
	<authorgroup>
	  <author>
	    <firstname>Chern</firstname>
	    <surname>Lee</surname>
	    <contrib>Rewritten by </contrib>
	  </author>
	</authorgroup>
      </sect2info>
      <title>Automatic Mounts with <application>amd</application></title>

      <indexterm><primary>amd</primary></indexterm>
      <indexterm><primary>automatic mounter daemon</primary></indexterm>

      <para>&man.amd.8; (the automatic mounter daemon)
	automatically mounts a
	remote filesystem whenever a file or directory within that
	filesystem is accessed.  Filesystems that are inactive for a
	period of time will also be automatically unmounted by
	<application>amd</application>.  Using
	<application>amd</application> provides a simple alternative
	to permanent mounts, as permanent mounts are usually listed in
	<filename>/etc/fstab</filename>.</para>

      <para><application>amd</application> operates by attaching
	itself as an NFS server to the <filename>/host</filename> and
	<filename>/net</filename> directories.  When a file is accessed
	within one of these directories, <application>amd</application>
	looks up the corresponding remote mount and automatically mounts
	it.  <filename>/net</filename> is used to mount an exported
	filesystem from an IP address, while <filename>/host</filename>
	is used to mount an export from a remote hostname.</para>

      <para>An access to a file within
	<filename>/host/foobar/usr</filename> would tell
	<application>amd</application> to attempt to mount the
	<filename>/usr</filename> export on the host
	<hostid>foobar</hostid>.</para>

      <example>
	<title>Mounting an Export with <application>amd</application></title>

	<para>You can view the available mounts of a remote host with
	  the <command>showmount</command> command.  For example, to
	  view the mounts of a host named <hostid>foobar</hostid>, you
	  can use:</para>

	<screen>&prompt.user; <userinput>showmount -e foobar</userinput>
Exports list on foobar:
/usr			       10.10.10.0
/a				 10.10.10.0
&prompt.user; <userinput>cd /host/foobar/usr</userinput></screen>
      </example>

      <para>As seen in the example, the <command>showmount</command> shows
	<filename>/usr</filename> as an export.  When changing directories to
	<filename>/host/foobar/usr</filename>, <application>amd</application>
	attempts to resolve the hostname <hostid>foobar</hostid> and
	automatically mount the desired export.</para>

      <para><application>amd</application> can be started by the
	startup scripts by placing the following lines in
	<filename>/etc/rc.conf</filename>:</para>

      <programlisting>amd_enable="YES"</programlisting>

      <para>Additionally, custom flags can be passed to
      <application>amd</application> from the
      <varname>amd_flags</varname> option.  By default,
      <varname>amd_flags</varname> is set to:</para>

      <programlisting>amd_flags="-a /.amd_mnt -l syslog /host /etc/amd.map /net /etc/amd.map"</programlisting>

      <para>The <filename>/etc/amd.map</filename> file defines the
	default options that exports are mounted with.  The
	<filename>/etc/amd.conf</filename> file defines some of the more
	advanced features of <application>amd</application>.</para>

      <para>Consult the &man.amd.8; and &man.amd.conf.5; manual pages for more
	information.</para>
    </sect2>

    <sect2 id="network-nfs-integration">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>John</firstname>
	    <surname>Lind</surname>
	    <contrib>Contributed by </contrib>
	  </author>
	</authorgroup>
      </sect2info>
      <title>Problems Integrating with Other Systems</title>

      <para>Certain Ethernet adapters for ISA PC systems have limitations
	which can lead to serious network problems, particularly with NFS.
	This difficulty is not specific to FreeBSD, but FreeBSD systems
	are affected by it.</para>

      <para>The problem nearly always occurs when (FreeBSD) PC systems are
	networked with high-performance workstations, such as those made
	by Silicon Graphics, Inc., and Sun Microsystems, Inc.  The NFS
	mount will work fine, and some operations may succeed, but
	suddenly the server will seem to become unresponsive to the
	client, even though requests to and from other systems continue to
	be processed.  This happens to the client system, whether the
	client is the FreeBSD system or the workstation.  On many systems,
	there is no way to shut down the client gracefully once this
	problem has manifested itself.  The only solution is often to
	reset the client, because the NFS situation cannot be
	resolved.</para>

      <para>Though the <quote>correct</quote> solution is to get a higher
	performance and capacity Ethernet adapter for the FreeBSD system,
	there is a simple workaround that will allow satisfactory
	operation.  If the FreeBSD system is the
	<emphasis>server</emphasis>, include the option
	<option>-w=1024</option> on the mount from the client.  If the
	FreeBSD system is the <emphasis>client</emphasis>, then mount the
	NFS filesystem with the option <option>-r=1024</option>.  These
	options may be specified using the fourth field of the
	<filename>fstab</filename> entry on the client for automatic
	mounts, or by using the <option>-o</option> parameter of the mount
	command for manual mounts.</para>

      <para>It should be noted that there is a different problem,
	sometimes mistaken for this one, when the NFS servers and clients
	are on different networks.  If that is the case, make
	<emphasis>certain</emphasis> that your routers are routing the
	necessary UDP information, or you will not get anywhere, no matter
	what else you are doing.</para>

      <para>In the following examples, <hostid>fastws</hostid> is the host
	(interface) name of a high-performance workstation, and
	<hostid>freebox</hostid> is the host (interface) name of a FreeBSD
	system with a lower-performance Ethernet adapter.  Also,
	<filename>/sharedfs</filename> will be the exported NFS
	filesystem (see &man.exports.5;), and
	<filename>/project</filename> will be the mount point on the
	client for the exported filesystem.  In all cases, note that
	additional options, such as <option>hard</option> or
	<option>soft</option> and <option>bg</option> may be desirable in
	your application.</para>

      <para>Examples for the FreeBSD system (<hostid>freebox</hostid>) as
	the client in <filename>/etc/fstab</filename> on freebox:</para>

      <programlisting>fastws:/sharedfs /project nfs rw,-r=1024 0 0</programlisting>

      <para>As a manual mount command on <hostid>freebox</hostid>:</para>

      <screen>&prompt.root; <userinput>mount -t nfs -o -r=1024 fastws:/sharedfs /project</userinput></screen>

      <para>Examples for the FreeBSD system as the server in
	<filename>/etc/fstab</filename> on <hostid>fastws</hostid>:</para>

      <programlisting>freebox:/sharedfs /project nfs rw,-w=1024 0 0</programlisting>

      <para>As a manual mount command on <hostid>fastws</hostid>:</para>

      <screen>&prompt.root; <userinput>mount -t nfs -o -w=1024 freebox:/sharedfs /project</userinput></screen>

      <para>Nearly any 16-bit Ethernet adapter will allow operation
	without the above restrictions on the read or write size.</para>

      <para>For anyone who cares, here is what happens when the failure
	occurs, which also explains why it is unrecoverable.  NFS
	typically works with a <quote>block</quote> size of 8&nbsp;k (though it
	may do fragments of smaller sizes).  Since the maximum Ethernet
	packet is around 1500&nbsp;bytes, the NFS <quote>block</quote> gets
	split into multiple Ethernet packets, even though it is still a
	single unit to the upper-level code, and must be received,
	assembled, and <emphasis>acknowledged</emphasis> as a unit.  The
	high-performance workstations can pump out the packets which
	comprise the NFS unit one right after the other, just as close
	together as the standard allows.  On the smaller, lower capacity
	cards, the later packets overrun the earlier packets of the same
	unit before they can be transferred to the host and the unit as a
	whole cannot be reconstructed or acknowledged.  As a result, the
	workstation will time out and try again, but it will try again
	with the entire 8&nbsp;K unit, and the process will be repeated, ad
	infinitum.</para>

      <para>By keeping the unit size below the Ethernet packet size
	limitation, we ensure that any complete Ethernet packet received
	can be acknowledged individually, avoiding the deadlock
	situation.</para>

      <para>Overruns may still occur when a high-performance workstations
	is slamming data out to a PC system, but with the better cards,
	such overruns are not guaranteed on NFS <quote>units</quote>.  When
	an overrun occurs, the units affected will be retransmitted, and
	there will be a fair chance that they will be received, assembled,
	and acknowledged.</para>
    </sect2>
  </sect1>

  <sect1 id="network-diskless">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Jean-Fran&ccedil;ois</firstname>
	  <surname>Dock&egrave;s</surname>
	  <contrib>Updated by </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Diskless Operation</title>

    <indexterm><primary>diskless workstation</primary></indexterm>
    <indexterm><primary>diskless operation</primary></indexterm>

    <para>A FreeBSD machine can boot over the network and operate without a
      local disk, using filesystems mounted from an NFS server.  No system
      modification is necessary, beyond standard configuration files.
      Such a system is easy to set up because all the necessary elements
      are readily available:</para>
    <itemizedlist>
      <listitem>
	<para>There are at least two possible methods to load the kernel over
	  the network:</para>
	<itemizedlist>
	  <listitem>
	    <para><emphasis>PXE</emphasis>: The &intel; Preboot Execution
	      Environment system is a form of smart boot ROM built into some
	      networking cards or motherboards.  See &man.pxeboot.8; for more
	      details.</para>
	  </listitem>
	  <listitem>
	    <para><emphasis>The <application>etherboot</application>
	      port</emphasis> (<filename
	      role="package">net/etherboot</filename>) produces
	      ROM-able code to boot kernels over the network.  The
	      code can be either burnt into a boot PROM on a network
	      card, or loaded from a local floppy (or hard) disk
	      drive, or from a running &ms-dos; system.  Many network
	      cards are supported.</para>
	  </listitem>
	</itemizedlist>
	</listitem>

      <listitem>
	<para>A sample script
	  (<filename>/usr/share/examples/diskless/clone_root</filename>) eases
	  the creation and maintenance of the workstation's root filesystem
	  on the server.  The script will probably require a little
	  customization but it will get you started very quickly.</para>
      </listitem>

      <listitem>
	<para>Standard system startup files exist in <filename>/etc</filename>
	  to detect and support a diskless system startup.</para>
      </listitem>

      <listitem>
	<para>Swapping, if needed, can be done either to an NFS file or to
	  a local disk.</para>
      </listitem>
    </itemizedlist>

    <para>There are many ways to set up diskless workstations.  Many
      elements are involved, and most can be customized to suit local
      taste.  The following will describe the setup of a complete system,
      emphasizing simplicity and compatibility with the
      standard FreeBSD startup scripts.  The system described has the
      following characteristics:</para>

    <itemizedlist>
      <listitem>
	<para>The diskless workstations use a shared
	  read-only <filename>root</filename> filesystem, and a shared
	  read-only <filename>/usr</filename>.</para>
	<para>The <filename>root</filename> filesystem is a copy of a
	  standard FreeBSD root (typically the server's), with some
	  configuration files overridden by ones specific to diskless
	  operation or, possibly, to the workstation they belong to.</para>
	<para>The parts of the <filename>root</filename> which have to be
	  writable are overlaid with &man.mfs.8; filesystems.  Any changes
	  will be lost when the system reboots.</para>
      </listitem>
      <listitem>
	<para>The kernel is loaded by <application>etherboot
	  </application>, using DHCP (or BOOTP) and TFTP.</para>
      </listitem>
    </itemizedlist>

    <caution><para>As described, this system is insecure.  It should
	live in a protected area of a network, and be untrusted by
	other hosts.</para>
    </caution>


    <sect2>
      <title>Setup Instructions</title>

      <sect3>
	<title>Configuring DHCP/BOOTP</title>
	<indexterm>
	  <primary>diskless operation</primary>
	  <secondary>booting</secondary>
	</indexterm>

	<para>There are two protocols that are commonly used to boot a
	  workstation that retrieves its configuration over the network: BOOTP
	  and DHCP.  They are used at several points in the workstation
	  bootstrap:</para>
	<itemizedlist>
	  <listitem><para><application>etherboot</application> uses
	      DHCP (by default) or BOOTP (needs a configuration option) to
	      find the kernel.  (PXE uses DHCP).</para>
	  </listitem>
	  <listitem><para>The kernel uses BOOTP to locate the NFS
	      root.</para>
	  </listitem>
	</itemizedlist>

	<para>It is possible to configure a system to use only BOOTP.
	  The &man.bootpd.8; server program is included in the
	  base FreeBSD system.</para>

	<para>However, DHCP has a number of advantages over BOOTP (nicer
	  configuration files, possibility of using PXE, plus many others
	  not directly related to diskless operation), and we shall describe
	  both a pure BOOTP, and a BOOTP+DHCP configuration, with an
	  emphasis on the latter, which will use the ISC DHCP software
	  package.</para>

	<sect4>
	  <title>Configuration Using ISC DHCP</title>
	  <indexterm>
	    <primary>DHCP</primary>
	    <secondary>diskless operation</secondary>
	  </indexterm>

	  <para>The <application>isc-dhcp</application> server can answer
	    both BOOTP and DHCP requests.</para>

	  <para>As of release 4.4, <application>isc-dhcp
  	    3.0</application> is not part of the base
	    system.  You will first need to install the
	    <filename role="package">net/isc-dhcp3</filename> port or the
	    corresponding package.  Please refer to <xref linkend="ports">
	    for general information about ports and packages.</para>

	  <para>Once <application>isc-dhcp</application> is installed, it
	    needs a configuration file to run, (normally named
	    <filename>/usr/local/etc/dhcpd.conf</filename>).  Here follows
	    a commented example:</para>

	  <programlisting>
	  default-lease-time 600;
	  max-lease-time 7200;
	  authoritative;

	  option domain-name "example.com";
	  option domain-name-servers 192.168.4.1;
	  option routers 192.168.4.1;

	  subnet 192.168.4.0 netmask 255.255.255.0 {
	    use-host-decl-names on; <co id="co-dhcp-host-name">
	    option subnet-mask 255.255.255.0;
	    option broadcast-address 192.168.4.255;

	    host margaux {
	      hardware ethernet 01:23:45:67:89:ab;
	      fixed-address margaux.example.com;
	      next-server 192.168.4.4;<co id="co-dhcp-next-server">
	      filename "/tftpboot/kernel.diskless";<co id="co-dhcp-filename">
	      option root-path "192.168.4.4:/data/misc/diskless";<co id="co-dhcp-root-path">
	    }
	  }
	  </programlisting>

	  <calloutlist>
	    <callout arearefs="co-dhcp-host-name"><para>This option tells
		<command>dhcpd</command> to send the value in the
		<literal>host</literal> declarations as the hostname for the
		diskless host.  An alternate way would be to add an
		<literal>option host-name
		  <replaceable>margaux</replaceable></literal> inside the
		host declarations.</para>
	    </callout>

	    <callout arearefs="co-dhcp-next-server"><para>The
		<literal>next-server</literal> directive designates
		the TFTP server (the default is to use the same host as the
		DHCP server).</para>
	    </callout>

	    <callout arearefs="co-dhcp-filename"><para>The
		<literal>filename</literal> directive defines the file that
		<application>etherboot</application> will load as a
		kernel.
		<note><para>PXE appears to prefer a relative file
		    name, and it loads <command>pxeboot</command>, not the
		    kernel (<literal>option filename
		      "pxeboot"</literal>).</para>
		</note>
	</para>
	    </callout>

	    <callout arearefs="co-dhcp-root-path"><para>The
		<literal>root-path</literal> option defines the path to
		the root filesystem, in usual NFS notation.</para>
	    </callout>
	  </calloutlist>

	</sect4>
	<sect4>
	  <title>Configuration Using BOOTP</title>
	  <indexterm>
	    <primary>BOOTP</primary>
	    <secondary>diskless operation</secondary>
	  </indexterm>

	  <para>Here follows an equivalent <command>bootpd</command>
	    configuration.  This would be found in
	    <filename>/etc/bootptab</filename>.</para>

	  <para>Please note that <application>etherboot</application>
	    must be compiled with the non-default option
	    <literal>NO_DHCP_SUPPORT</literal> in order to use BOOTP,
	    and that PXE <emphasis>needs</emphasis> DHCP.  The only
	    obvious advantage of <application>bootpd</application> is
	    that it exists in the base system.</para>

	  <programlisting>
	  .def100:\
	    :hn:ht=1:sa=192.168.4.4:vm=rfc1048:\
	    :sm=255.255.255.0:\
	    :ds=192.168.4.1:\
	    :gw=192.168.4.1:\
	    :hd="/tftpboot":\
	    :bf="/kernel.diskless":\
	    :rp="192.168.4.4:/data/misc/diskless":

	  margaux:ha=0123456789ab:tc=.def100
	  </programlisting>
	</sect4>
      </sect3>

      <sect3>
	<title>Preparing a Boot Program with
	  <application>Etherboot</application></title>

	<indexterm>
	  <primary>Etherboot</primary>
	</indexterm>

	<para><ulink url="http://etherboot.sourceforge.net">Etherboot's Web
	  site</ulink> contains
	  <ulink url="http://etherboot.sourceforge.net/doc/html/userman.html">
	  extensive documentation</ulink> mainly intended for Linux
	  systems, but nonetheless containing useful information.  The
	  following will just outline how you would use
	  <application>etherboot</application> on a FreeBSD
	  system.</para>

	<para>You must first install the <filename
	  role="package">net/etherboot</filename> package or port.
	  The <application>etherboot</application> port can normally
	  be found in <filename>/usr/ports/net/etherboot</filename>.
	  If the ports tree is installed on your system, just typing
	  <literal>make</literal> in this directory should take care
	  of everything.  Else refer to <xref linkend="ports"> for
	  information about ports and packages.</para>

	<para>For our setup, we shall use a boot floppy.  For other methods
	  (PROM, or dos program), please refer to the
	  <application>etherboot</application> documentation.</para>

	<para>To make a boot floppy, insert a floppy in the drive on the
	  machine where you installed <application>etherboot</application>,
	  then change your current directory to the <filename>src</filename>
	  directory in the <application>etherboot</application> tree and
	  type:</para>

	<screen>
	  &prompt.root; <userinput>gmake bin32/<replaceable>devicetype</replaceable>.fd0</userinput>
	</screen>

	<para><replaceable>devicetype</replaceable> depends on the type of
	  the Ethernet card in the diskless workstation.  Refer to the
	  <filename>NIC</filename> file in the same directory to determine the
	  right <replaceable>devicetype</replaceable>.</para>

      </sect3>


      <sect3>
	<title>Configuring the TFTP and NFS Servers</title>

	<indexterm>
	  <primary>TFTP</primary>
	  <secondary>diskless operation</secondary>
	</indexterm>
	<indexterm>
	  <primary>NFS</primary>
	  <secondary>diskless operation</secondary>
	</indexterm>

	<para>You need to enable <command>tftpd</command> on the TFTP
	  server:</para>
	<procedure>
	  <step>
	    <para>Create a directory from which <command>tftpd</command>
	    will serve the files, e.g. <filename>/tftpboot</filename>.</para>
	  </step>

	  <step>
	    <para>Add this line to your
	      <filename>/etc/inetd.conf</filename>:</para>

	    <programlisting>tftp    dgram   udp     wait    root  /usr/libexec/tftpd    tftpd -s /tftpboot</programlisting>

	    <note><para>It appears that at least some PXE versions want
		the TCP version of TFTP.  In this case, add a second line,
		replacing <literal>dgram udp</literal> with <literal>stream
		tcp</literal>.</para>
	    </note>
	  </step>
	  <step>
	    <para>Tell <command>inetd</command> to reread its configuration
	      file:</para>
	    <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/inetd.pid`</userinput></screen>
	  </step>
	</procedure>

	<para>You can place the <filename>tftpboot</filename>
	  directory anywhere on the server.  Make sure that the
	  location is set in both <filename>inetd.conf</filename> and
	  <filename>dhcpd.conf</filename>.</para>

	<para>You also need to enable NFS and export the
	  appropriate filesystem on the NFS server.</para>

	<procedure>
	  <step>
	    <para>Add this to <filename>/etc/rc.conf</filename>:</para>
	    <programlisting>nfs_server_enable="YES"</programlisting>
	  </step>

	  <step>
	    <para>Export the filesystem where the diskless root directory
	      is located by adding the following to
	      <filename>/etc/exports</filename> (adjust the volume mount
	      point and replace <replaceable>margaux</replaceable>
	      with the name of the diskless workstation):</para>

	    <programlisting><replaceable>/data/misc</replaceable> -alldirs -ro <replaceable>margaux</replaceable></programlisting>
	  </step>
	  <step>
	    <para>Tell <command>mountd</command> to reread its configuration
	      file.  If you actually needed to enable NFS in
	      <filename>/etc/rc.conf</filename>
	      at the first step, you probably want to reboot instead.</para>
	    <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/mountd.pid`</userinput></screen>
	  </step>
	</procedure>

      </sect3>

      <sect3>
	<title>Building a Diskless Kernel</title>

	<indexterm>
	  <primary>diskless operation</primary>
	  <secondary>kernel configuration</secondary>
	</indexterm>

	<para>Create a kernel configuration file for the diskless client
	  with the following options (in addition to the usual
	  ones):</para>

	<programlisting>
	  options     BOOTP	  # Use BOOTP to obtain IP address/hostname
	  options     BOOTP_NFSROOT  # NFS mount root filesystem using BOOTP info
	  options     BOOTP_COMPAT   # Workaround for broken bootp daemons.
	</programlisting>

	<para>You may also want to use <literal>BOOTP_NFSV3</literal> and
	  <literal>BOOTP_WIRED_TO</literal> (refer to <filename>LINT</filename>).</para>

	<para>Build the kernel (See <xref linkend="kernelconfig">),
	  and copy it to the tftp directory, under the name listed
	  in <filename>dhcpd.conf</filename>.</para>


      </sect3>

      <sect3>
	  <title>Preparing the Root Filesystem</title>

	<indexterm>
	  <primary>root file system</primary>
	  <secondary>diskless operation</secondary>
	</indexterm>

	<para>You need to create a root filesystem for the diskless
	  workstations, in the location listed as
	  <literal>root-path</literal> in
	  <filename>dhcpd.conf</filename>.</para>

	<para>The easiest way to do this is to use the
	  <filename>/usr/share/examples/diskless/clone_root</filename>
	  shell script.  This script needs customization, at least to adjust
	  the place where the filesystem will be created (the
	  <literal>DEST</literal> variable).</para>

	<para>Refer to the comments at the top of the script for
	    instructions.  They explain how the base filesystem is built,
	    and how files may be selectively overridden by versions specific
	    to diskless operation, to a subnetwork, or to an individual
	    workstation.  They also give examples for the diskless
	    <filename>/etc/fstab</filename> and <filename>
	    /etc/rc.conf</filename> files.</para>

	  <para>The <filename>README</filename> files in
	    <filename>/usr/share/examples/diskless</filename> contain a lot
	    of interesting background information, but, together with the
	    other examples in the <filename>diskless</filename> directory,
	    they actually document a configuration method which is distinct
	    from the one used by <filename>clone_root</filename> and
	    <filename>/etc/rc.diskless[12]</filename>, which is a little
	    confusing.  Use them for reference only, except if you prefer
	    the method that they describe, in which case you will need
	    customized <filename>rc</filename> scripts.</para>
      </sect3>

      <sect3>
	<title>Configuring Swap</title>

	<para>If needed, a swap file located on the server can be
	  accessed via NFS.  The exact <filename>bootptab</filename>
	  or <filename>dhcpd.conf</filename> options are not clearly
	  documented at this time.  The following configuration
	  suggestions have been reported to work in some installations
	  using isc-dhcp 3.0rc11.</para>
	<procedure>
	  <step><para>Add the following lines to
	  <filename>dhcpd.conf</filename>:</para>
	    <programlisting>
	      # Global section
	      option swap-path code 128 = string;
	      option swap-size code 129 = integer 32;

	      host margaux {
		... # Standard lines, see above
		option swap-path <replaceable>"192.168.4.4:/netswapvolume/netswap"</replaceable>;
		option swap-size <replaceable>64000</replaceable>;
	      }
	    </programlisting>
	    <para>The idea is that, at least for a FreeBSD client,
	      DHCP/BOOTP option code 128 is the path to the NFS swap file,
	      and option code 129 is the swap size in kilobytes.  Older
	      versions of <command>dhcpd</command> allowed a syntax of
	      <literal>option option-128 "...</literal>, which does not
	      seem to work any more.</para>
	    <para><filename>/etc/bootptab</filename> would use the
	      following syntax instead:</para>

	    <para><literal>T128="192.168.4.4:/netswapvolume/netswap":T129=64000
	      </literal></para>
	  </step>

	  <step>
	    <para>On the NFS swap file server, create the swap
	    file(s)</para>
	    <screen>
	      &prompt.root; <userinput>mkdir <replaceable>/netswapvolume/netswap</replaceable></userinput>
	      &prompt.root; <userinput>cd <replaceable>/netswapvolume/netswap</replaceable></userinput>
	      &prompt.root; <userinput>dd if=/dev/zero bs=1024 count=<replaceable>64000</replaceable> of=swap.<replaceable>192.168.4.6</replaceable></userinput>
	      &prompt.root; <userinput>chmod 0600 swap.<replaceable>192.168.4.6</replaceable></userinput>
	    </screen>
	    <para><replaceable>192.168.4.6</replaceable> is the IP address
	      for the diskless client.</para>
	  </step>

	  <step>
	    <para>On the NFS swap file server, add the following line to
	    <filename>/etc/exports</filename>:</para>
	    <programlisting>
	      <replaceable>/netswapvolume</replaceable>  -maproot=0:10 -alldirs <replaceable>margaux</replaceable>
	    </programlisting>
	    <para>Then tell <application>mountd</application> to reread the
		exports file, as above.</para>
	  </step>
	</procedure>

      </sect3>

      <sect3>
	<title>Miscellaneous Issues</title>


	<sect4>
	  <title>Running with a Read-only <filename>/usr</filename></title>

	  <indexterm>
	    <primary>diskless operation</primary>
	    <secondary>/usr read-only</secondary>
	  </indexterm>

	    <para>If the diskless workstation is configured to run X, you
	    will have to adjust the xdm configuration file, which puts
	    the error log on <filename>/usr</filename> by default.</para>
	</sect4>
	<sect4>
	  <title>Using a Non-FreeBSD Server</title>

	  <para>When the server for the root filesystem is not running FreeBSD,
	    you will have to create the root filesystem on a
	    FreeBSD machine, then copy it to its destination, using
	    <command>tar</command> or <command>cpio</command>.</para>
	  <para>In this situation, there are sometimes
	    problems with the special files in <filename>/dev</filename>,
	    due to differing major/minor integer sizes.  A solution to this
	    problem is to export a directory from the non-FreeBSD server,
	    mount this directory onto a FreeBSD machine, and run
	    <command>MAKEDEV</command> on the FreeBSD machine
	    to create the correct device entries (FreeBSD 5.0 and later
	    use &man.devfs.5; to allocate device nodes transparently for
	    the user, running <command>MAKEDEV</command> on these
	    versions is useless).</para>

	</sect4>

      </sect3>

    </sect2>
  </sect1>

  <sect1 id="network-isdn">
    <title>Rede Digital de Servi&ccedil;os Integrados - RDSI (ISDN)</title>

    <indexterm>
      <primary>ISDN</primary>
    </indexterm>

    <para>Uma boa fonte de informa&ccedil;&otilde;es sobre a tecnologia e o
    hardware ISDN &eacute; a <ulink url="http://alumni.caltech.edu/~dank/isdn/">
    p&aacute;gina sobre ISDN de Dan Kegel</ulink>.</para>

    <para>Um simples e r&aacute;pido mapa para o ISDN est&aacute; a seguir:</para>

    <itemizedlist>
      <listitem>
	<para>Se voc&ecirc; vive na Europa, pode querer investigar a se&ccedil;&atilde;o
	de placas ISDN.</para>
      </listitem>

      <listitem>
	<para>Se voc&ecirc; estiver planejando usar ISDN primariamente para
	se conectar &agrave; Internet atrav&eacute;s de um Provedor de forma discada
	n&atilde;o permanente, voc&ecirc; pode pode olhar os Adaptadores de
	Terminais.  Assim voc&ecirc; ter&aacute; maior flexibilidade e menos
	problemas se voc&ecirc; trocar de provedores.</para>
      </listitem>

      <listitem>
	<para>Se voc&ecirc; estiver conectando duas Redes Locais ou &agrave;
	Internet com uma conex&atilde;o ISDN dedicada, voc&ecirc; pode considerar a
	op&ccedil;&atilde;o de um roteador/ponte dedicado.</para>
      </listitem>
    </itemizedlist>

    <para>O custo &eacute; um fator significativo na determina&ccedil;&atilde;o de qual
    solu&ccedil;&atilde;o voc&ecirc; vai escolher.  As seguintes op&ccedil;&otilde;es s&atilde;o listadas da
    menos para a mais cara.</para>

    <sect2 id="network-isdn-cards">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Hellmuth</firstname>
	    <surname>Michaelis</surname>
	    <contrib>Contribu&iacute;do por </contrib>
	  </author>
	</authorgroup>
      </sect2info>
      <title>Placas ISDN</title>

      <indexterm>
	<primary>ISDN</primary>
	<secondary>cards</secondary>
      </indexterm>

      <para>A implementa&ccedil;&atilde;o ISDN do FreeBSD suporta somente o padr&atilde;o
      DSS1/Q.931 (ou Euro-ISDN) usando placas passivas.  A partir do
      FreeBSD&nbsp;4.4, algumas placas ativas s&atilde;o suportadas nas quais
      o firmware tamb&eacute;m suporta outros protocolos de sinaliza&ccedil;&atilde;o;
      isto tamb&eacute;m inclui a primeira placa ISDN de Acesso Prim&aacute;rio (Primary
      Rate - PRI) suportada.</para>

      <para>O <application>Isdn4bsd</application> lhe permite conectar
      a outros roteadores ISDN usando IP sobre HDLC ou PPP s&iacute;ncrono:
      tanto usando um kernel contendo PPP com isppp - um driver
      modificado a partir do sppp - ou usando o comando de usu&aacute;rio
      &man.ppp.8;.  Usando o comando &man.ppp.8;, &eacute; poss&iacute;vel agregar
      dois ou mais canais B ISDN.  Uma aplica&ccedil;&atilde;o de secret&aacute;ria 
      eletr&ocirc;nica telef&ocirc;nica tamb&eacute;m est&aacute; dispon&iacute;vel, bem como muitos
      utilit&aacute;rios, como um modem de 300 Baud em software.</para>

      <para>Um crescente n&uacute;mero de placas ISDN para PC s&atilde;o suportadas 
      pelo FreeBSD e os relatos mostram que ele &eacute; usado com sucesso por 
      toda a Europa e em muitas outras partes do mundo.</para>

      <para>As placas ISDN passivas suportadas s&atilde;o na maioria as que
      possuem os chipsets Infineon (anteriormente Siemens) ISAC/HSCX/IPAC, 
      mas tamb&eacute;m placas ISDN com chips da Cologne Chip (somente
      barramento ISA), placas PCI com chips Winbond W6692, algumas
      placas com combina&ccedil;&otilde;es do chipset Tiger300/320/ISAC e algumas
      placas com chipsets de fabricantes espec&iacute;ficos como as placas 
      AVM Fritz!Card PCI V.1.0 e a AVM Fritz!Card PnP.</para>

      <para>Atualmente as placas ISDN ativas suportadas s&atilde;o as 
      AVM B1 (ISA e PCI) e as AVM T1 PCI PRI.</para>

      <para>Para documenta&ccedil;&atilde;o sobre 
      <application>isdn4bsd</application>, veja o diret&oacute;rio
      <filename>/usr/share/examples/isdn/</filename> em seu sistema
      FreeBSD ou em <ulink url="http://www.freebsd-support.de/i4b/">
      homepage of isdn4bsd</ulink> que tamb&eacute;m tem ponteiros para
      dicas, erratas e muito mais documenta&ccedil;&atilde;o como o <ulink
      url="http://people.FreeBSD.org/~hm/">isdn4bsd handbook</ulink>.
      </para>

      <para>No caso de voc&ecirc; estar interessado em adicionar suporte
      para um protocolo ISDN diferente, uma placa PC ISDN atualmente
      n&atilde;o suportada ou de alguma forma melhorar o
      <application>isdn4bsd</application>, por favor, entre em contato
      com &a.hm;.</para>

      <para>Para quest&otilde;es referentes &agrave; instala&ccedil;&atilde;o, configura&ccedil;&atilde;o e
      resolu&ccedil;&atilde;o de problemas com <application>isdn4bsd</application>, 
      est&aacute; dispon&iacute;vel uma lista de discuss&atilde;o &a.isdn.name;.</para>
    </sect2>

    <sect2>
      <title>Adaptadores de Terminal ISDN</title>
      <title>ISDN Terminal Adapters</title>

      <para>Adaptadores de Terminal (AT), s&atilde;o para o ISDN o que os
      modems s&atilde;o para as linhas telef&ocirc;nicas normais.</para>
      <indexterm><primary>modem</primary></indexterm>
      <para>A maioria dos ATs usam o conjunto de comandos padr&atilde;o dos
      modems hayes, e podem ser usados como substitutos de modems.</para>

      <para>Um AT vai operar basicamente da mesma forma que um modem
      exceto pelas velocidades de conex&atilde;o e vaz&atilde;o ser&atilde;o muito mais
      r&aacute;pidas que seu antigo modem.  Voc&ecirc; vai precisar configurar o
      <link linkend="ppp">PPP</link> extamente da mesma forma que 
      configura um modem.  Certifique-se de configurar a velocidade
      serial para a maior poss&iacute;vel.</para>
      <indexterm><primary>PPP</primary></indexterm>
      <para>A principal vantagem de usar um AT para conectar a um
      Provedor Internet &eacute; que voc&ecirc; pode usar PPP Din&acirc;mico.  Enquanto o
      espa&ccedil;o de endere&ccedil;amento IP se torna cada vez mais escasso, a
      maioria dos provedores n&atilde;o desejam mais te fornecer um endere&ccedil;o
      IP est&aacute;tico.  A maioria dos roteadores dedicados n&atilde;o s&atilde;o capazes
      de suportar aloca&ccedil;&atilde;o din&acirc;mica de IP.</para>

      <para>ATs contam completamente com o daemon PPP que voc&ecirc; est&aacute;
      executando para suas caracter&iacute;sticas e estabilidade de conex&atilde;o.
      Isto permite a voc&ecirc; facilmente fazer atualiza&ccedil;&atilde;o de usar um modem
      para ISDN em uma m&aacute;quina FreeBSD, se voc&ecirc; j&aacute; possui o PPP
      configurado.  Entretanto, quaisquer problemas que voc&ecirc; j&aacute;
      experimentou com o programa PPP ir&atilde;o persistir.</para>

      <para>Se voc&ecirc; quer estabilidade m&aacute;xima, use a opc&atilde;o de kernel
      <link linkend="ppp">PPP</link>, n&atilde;o o 
      <link linkend="userppp">iijPPP</link> de contexto de usu&aacute;rio.
      </para>

      <para>&Eacute; sabido que os seguintes ATs funcionam com o FreeBSD.</para>

      <itemizedlist>
	<listitem>
	  <para>Motorola BitSurfer e Bitsurfer Pro</para>
	</listitem>

	<listitem>
	  <para>Adtran</para>
	</listitem>
      </itemizedlist>

      <para>A maioria dos outros ATs provavelmente tamb&eacute;m v&atilde;o
      funcionar, uma vez que os fornecedores de ATs tentam garantir
      que seu produto pode aceitar a maior parte do conjunto de
      comandos padr&atilde;o AT dos modems.</para>

      <para>O verdadeiro problema com os ATs externos &eacute; que, como os
      modems, voc&ecirc; vai precisar de uma boa placa serial em seu
      computador.</para>

      <para>Voc&ecirc; deve ler o tutorial <ulink
      url="../../articles/serial-uart/index.html">FreeBSD Serial
      Hardware</ulink> para uma compreens&atilde;o detalhada dos dispositivos
      seriais e as diferen&ccedil;as entre portas seriais ass&iacute;ncronas e
      s&iacute;ncronas.</para>

      <para>Um AT executando em uma porta serial de um PC padr&atilde;o
      (ass&iacute;ncrona) limita voc&ecirc; a 115.2&nbsp;Kbs, mesmo que voc&ecirc; tenha
      uma conex&atilde;o de 128&nbsp;Kbs. Para utilizar completamente os
      128&nbsp;Kbs que o ISDN &eacute; capaz, voc&ecirc; precisa mover os AT para
      uma placa serial s&iacute;ncrona.</para>

      <para>N&atilde;o fa&ccedil;a a tolice de comprar um AT interno pensando que
      voc&ecirc; evitou o assunto s&iacute;ncrono/ass&iacute;ncrono.  Os ATs internos
      simplesmente possuem um chip de porta serial padr&atilde;o PC
      embutidos.  Tudo que isto far&aacute; &eacute; poup&aacute;-lo de comprar outro cabo
      serial e encontrar outra tomada el&eacute;trica dispon&iacute;vel.</para>

      <para>Uma placa s&iacute;ncrona com um AT &eacute; pelo menos t&atilde;o r&aacute;pida
      quanto um roteador dedicado, e com uma simples caixa 386 com
      FreeBSD gerenciando-a, provavelmente mais flex&iacute;vel.</para>

      <para>A escolha de AT/s&iacute;ncrono ou roteador dedicado &eacute; um amplo
      assunto religioso.  Houve algumas debates sobre isto nas listas
      de discuss&atilde;o.  Eu sugiro que voc&ecirc; busque os <ulink
      url="../../../../search/index.html">arquivos</ulink> para a
      discuss&atilde;o completa.</para>
    </sect2>

    <sect2>
      <title>Roteadores/Pontes Dedicados</title>
      <indexterm>
	<primary>ISDN</primary>
	<secondary>stand-alone bridges/routers</secondary>
      </indexterm>
      <para>Pontes ou roteadores ISDN n&atilde;o s&atilde;o nada espec&iacute;ficos ao
      FreeBSD ou quanlquer outro sistema operacional.  Para uma
      descri&ccedil;&atilde;o mais completa da tecnologia de roteamento e liga&ccedil;&atilde;o,
      por favor consulte um livro de refer&ecirc;ncia em Redes de
      Comunica&ccedil;&atilde;o de Dados.</para>

      <para>No contexto desta p&aacute;gina, os termos roteador e ponte ser&atilde;o
      usados de forma intercambi&aacute;vel.</para>

      <para>Enquanto o custo de roteadores/pontes ISDN de poucos
      recursos diminui, tornam-se cada vez mais escolhas populares.
      Um roteador ISDN &eacute; uma pequena caixa que se conecta diretamente
      em sua rede local Ethernet e gerencia sua pr&oacute;pria conex&atilde;o a
      outro roteador/ponte.  Possui embutido software para comunica&ccedil;&atilde;o
      via PPP e outros protocolos populares.</para>

      <para>Um roteador vai lhe permitir vaz&atilde;o muito mais r&aacute;pida que
      um AT padr&atilde;o, uma vez que estar&aacute; usando uma conex&atilde;o ISDN
      totalmente s&iacute;ncrona.</para>

      <para>O principal problema com roteadores e pontes ISDN &eacute; que a
      interoperabilidade entre fabricantes ainda pode ser um problema.
      Se voc&ecirc; estiver planejando se conectar a um provedor Internet,
      voc&ecirc; deve conversar suas necessidades com eles.</para>

      <para>Se voc&ecirc; est&aacute; planejando conectar dois segmentos de Redes
      Locais, como sua Rede Local dom&eacute;stica e a do escrit&oacute;rio, esta &eacute;
      a solu&ccedil;&atilde;o mais simples e de mais baixo custo de manuten&ccedil;&atilde;o.  Uma
      vez que voc&ecirc; est&aacute; adquirindo o equipamento para as duas pontas
      da conex&atilde;o, voc&ecirc; pode estar seguro de que o enlace ir&aacute;
      funcionar.</para>

      <para>Por exemplo, para conectar um computador dom&eacute;stico ou
      rede de escrit&oacute;rio filial &agrave; rede do escrit&oacute;rio principal, a
      seguinte configura&ccedil;&atilde;o pode ser usada.</para>

      <example>
	<title>Escrit&oacute;rio Filial ou Rede Dom&eacute;stica</title>

	<indexterm><primary>10 base 2</primary></indexterm>
	<para>A rede usa uma topologia em barra com Ethernet 10 base 2
	(<quote>thinnet</quote>). Conecte o roteador ao cabo de rede
	com transceptor AUI/10BT, se necess&aacute;rio.</para>

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="advanced-networking/isdn-bus">
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">---Sun workstation
|
---FreeBSD box
|
---Windows 95 (Do not admit to owning it)
|
Stand-alone router
   |
ISDN BRI line</literallayout>
	  </textobject>

	  <textobject>
	    <phrase>Ethernet 10 Base 2</phrase>
	  </textobject>
	</mediaobject>

	<para>Se seu escrit&oacute;rio dom&eacute;stico/filial &eacute; somente um
	computador, voc&ecirc; pode usar um cabo de par tran&ccedil;ado crossover
	para conect&aacute;-lo diretamente ao roteador dedicado.</para>
      </example>

      <example>
	<title>Escrit&oacute;rio Principal ou Outra Rede Local</title>

	<indexterm><primary>10 base T</primary></indexterm>
	<para>A rede usa uma topologia em estrela, com Ethernet 10
	base T (<quote>Par Tran&ccedil;ado</quote>).</para>

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="advanced-networking/isdn-twisted-pair">
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">    -------Servidor Novell
    | H |
    |   ---Sun
    |   |
    | U ---FreeBSD
    |   |
    |   ---Windows 95
    | B |
    |___---roteador dedicado
		|
	Linha ISDN BRI</literallayout>
	  </textobject>

	  <textobject>
	    <phrase>Diagrama de Rede ISDN</phrase>
	  </textobject>
	</mediaobject>
      </example>

      <para>Uma grande vantagem da maioria dos roteadores/pontes &eacute; que
      eles lhe permitem ter 2 conex&otilde;es PPP <emphasis>separadas e 
      independentes</emphasis> a 2 s&iacute;tios separados ao 
      <emphasis>mesmo</emphasis> tempo.  Isto n&atilde;o &eacute; suportado na
      maioria dos ATs, exceto em modelos espec&iacute;ficos (geralmente
      caros) que possuem duas portas seriais.  N&atilde;o confundir isto com
      agrega&ccedil;&atilde;o de canais, MPP etc.</para>

      <para>Isto pode ser uma caracter&iacute;stica muito &uacute;til se, por
      exemplo, voc&ecirc; possuir uma conex&atilde;o ISDN dedicada em seu
      escrit&oacute;rio e desejar se conectar atrav&eacute;s dela, mas n&atilde;o quer ter
      mais uma linha ISDN no trabalho.  Um roteador no local do
      escrit&oacute;rio pode gerenciar uma conex&atilde;o dedicada de canal B 
      (64&nbsp;Kbps) para a Internet e usar o outro canal B para uma
      conex&atilde;o de dados separada.  O segundo canal B pode ser usado
      para receber ou realizar acesso discado ou agrega&ccedil;&atilde;o din&acirc;mica
      (MPP etc.) com o primeiro canal B para obter mais largura de
      banda.</para>

      <indexterm><primary>IPX/SPX</primary></indexterm>
      <para>Uma ponte Ethernet tamb&eacute;m vai lhe permitir transmitir mais
      do que tr&aacute;fego IP.  Voc&ecirc; tamb&eacute;m pode transmitir IPX/SPX ou
      quaisquer outros protocolos que voc&ecirc; usa.</para>
    </sect2>
  </sect1>

  <sect1 id="network-nis">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Bill</firstname>
      	  <surname>Swingle</surname>
	  <contrib>Written by </contrib>
	 </author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Eric</firstname>
	  <surname>Ogren</surname>
	  <contrib>Enhanced by </contrib>
	</author>
	<author>
	  <firstname>Udo</firstname>
	  <surname>Erdelhoff</surname>
	</author>
      </authorgroup>
    </sect1info>
    <title>NIS/YP</title>

    <sect2>
      <title>What Is It?</title>
      <indexterm><primary>NIS</primary></indexterm>
      <indexterm><primary>Solaris</primary></indexterm>
      <indexterm><primary>HP-UX</primary></indexterm>
      <indexterm><primary>AIX</primary></indexterm>
      <indexterm><primary>Linux</primary></indexterm>
      <indexterm><primary>NetBSD</primary></indexterm>
      <indexterm><primary>OpenBSD</primary></indexterm>
      <para>NIS, which stands for Network Information Services, was
	developed by Sun Microsystems to centralize administration of &unix;
	(originally &sunos;) systems.  It has now essentially become an
	industry standard; all major &unix; like systems (&solaris;, HP-UX, &aix;, Linux,
	NetBSD, OpenBSD, FreeBSD, etc) support NIS.</para>

      <indexterm><primary>yellow pages</primary><see>NIS</see></indexterm>
      <para>NIS was formerly known as Yellow Pages, but because of
	trademark issues, Sun changed the name.  The old term (and yp) is
	still often seen and used.</para>

      <indexterm>
	<primary>NIS</primary>
	<secondary>domains</secondary>
      </indexterm>
      <para>It is a RPC-based client/server system that allows a group
	of machines within an NIS domain to share a common set of
	configuration files.  This permits a system administrator to set
	up NIS client systems with only minimal configuration data and
	add, remove or modify configuration data from a single
	location.</para>

      <indexterm><primary>Windows NT</primary></indexterm>
      <para>It is similar to the &windowsnt; domain system; although the
	internal implementation of the two are not at all similar,
	the basic functionality can be compared.</para>
    </sect2>

    <sect2>
      <title>Terms/Processes You Should Know</title>

      <para>There are several terms and several important user processes
	that you will come across when
	attempting to implement NIS on FreeBSD, whether you are trying to
	create an NIS server or act as an NIS client:</para>

      <indexterm>
	<primary><application>portmap</application></primary>
      </indexterm>

      <informaltable>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Term</entry>
	      <entry>Description</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>NIS domainname</entry>
	      <entry>An NIS master server and all of its clients
		(including its slave servers) have a NIS
		domainname.  Similar to an &windowsnt; domain name, the NIS
		domainname does not have anything to do with DNS.</entry>
	    </row>
	    <row>
	      <entry>portmap</entry>
	      <entry>Must be running in order to enable RPC (Remote
		Procedure Call, a network protocol used by NIS).  If
		<command>portmap</command> is not running, it will be
		impossible to run an NIS server, or to act as an NIS
		client.</entry>
	    </row>
	    <row>
	      <entry>ypbind</entry>

	      <entry><quote>Binds</quote> an NIS client to its NIS
		server.  It will take the NIS domainname from the
		system, and using RPC, connect to the
		server.  <command>ypbind</command> is the core of
		client-server communication in an NIS environment; if
		<command>ypbind</command> dies on a client machine, it
		will not be able to access the NIS server.</entry>
	    </row>
	    <row>
	      <entry>ypserv</entry>
	      <entry>Should only be running on NIS servers; this is the NIS
		server process itself.  If &man.ypserv.8; dies, then the
		server will no longer be able to respond to NIS requests
		(hopefully, there is a slave server to take over for
		it).  There are some implementations of NIS (but not the
		FreeBSD one), that do not try to reconnect to another
		server if the server it used before dies.  Often, the
		only thing that helps in this case is to restart the
		server process (or even the whole server) or the
		<command>ypbind</command> process on the client.
	      </entry>
	    </row>
	    <row>
	      <entry>rpc.yppasswdd</entry>
	      <entry>Another process that should only be running on
		NIS master servers; this is a daemon that will allow NIS
		clients to change their NIS passwords.  If this daemon
		is not running, users will have to login to the NIS
		master server and change their passwords there.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
      <!-- XXX Missing: rpc.ypxfrd (not important, though) May only run
      on the master -->

    </sect2>

    <sect2>
      <title>How Does It Work?</title>

      <para>There are three types of hosts in an NIS environment: master
	servers, slave servers, and clients.  Servers act as a central
	repository for host configuration information.  Master servers
	hold the authoritative copy of this information, while slave
	servers mirror this information for redundancy.  Clients rely on
	the servers to provide this information to them.</para>

      <para>Information in many files can be shared in this manner.  The
	<filename>master.passwd</filename>, <filename>group</filename>,
	and <filename>hosts</filename> files are commonly shared via NIS.
	Whenever a process on a client needs information that would
	normally be found in these files locally, it makes a query to the
	NIS server that it is bound to instead.</para>

      <sect3>
	<title>Machine Types</title>

	<itemizedlist>
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>master server</secondary>
	  </indexterm>
	  <listitem>
	    <para>A <emphasis>NIS master server</emphasis>.
	      This server, analogous to a &windowsnt;
	      primary domain controller, maintains the files used by all
	      of the NIS clients.  The <filename>passwd</filename>,
	      <filename>group</filename>, and other various files used by the
	      NIS clients live on the master server.</para>

	    <note><para>It is possible for one machine to be an NIS
	      master server for more than one NIS domain.  However, this will
	      not be covered in this introduction, which assumes a relatively
	      small-scale NIS environment.</para></note>
	  </listitem>
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>slave server</secondary>
	  </indexterm>
	  <listitem>
	    <para><emphasis>NIS slave servers</emphasis>.
	      Similar to the &windowsnt; backup domain
	      controllers, NIS slave servers maintain copies of the NIS
	      master's data files.  NIS slave servers provide the redundancy,
	      which is needed in important environments.  They also help
	      to balance the load of the master server:  NIS Clients always
	      attach to the NIS server whose response they get first, and
	      this includes slave-server-replies.</para>
	  </listitem>
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>client</secondary>
	  </indexterm>
	  <listitem>
	    <para><emphasis>NIS clients</emphasis>.  NIS clients, like most
	      &windowsnt; workstations, authenticate against the NIS server (or the &windowsnt;
	      domain controller in the &windowsnt; Workstation case) to log on.</para>
	  </listitem>
	</itemizedlist>
      </sect3>
    </sect2>

    <sect2>
      <title>Using NIS/YP</title>

      <para>This section will deal with setting up a sample NIS
	environment.</para>

      <note><para>This section assumes that you are running FreeBSD&nbsp;3.3
	or later.  The instructions given here will
	<emphasis>probably</emphasis> work for any version of FreeBSD greater
	than 3.0, but there are no guarantees that this is
	true.</para></note>


      <sect3>
	<title>Planning</title>

	<para>Let us assume that you are the administrator of a small
	  university lab.  This lab, which consists of 15 FreeBSD machines,
	  currently has no centralized point of administration;  each machine
	  has its own <filename>/etc/passwd</filename> and
	  <filename>/etc/master.passwd</filename>.  These files are kept in
	  sync with each other only through manual intervention;
	  currently, when you add a user to the lab, you must run
	  <command>adduser</command> on all 15 machines.
	  Clearly, this has to change, so you have decided to convert the
	  lab to use NIS, using two of the machines as servers.</para>

	<para>Therefore, the configuration of the lab now looks something
	  like:</para>

	<informaltable>
	  <tgroup cols="3">
	    <thead>
	      <row>
		<entry>Machine name</entry>
		<entry>IP address</entry>
		<entry>Machine role</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry><hostid>ellington</hostid></entry>
		<entry><hostid role="ipaddr">10.0.0.2</hostid></entry>
		<entry>NIS master</entry>
	      </row>
	      <row>
		<entry><hostid>coltrane</hostid></entry>
		<entry><hostid role="ipaddr">10.0.0.3</hostid></entry>
		<entry>NIS slave</entry>
	      </row>
	      <row>
		<entry><hostid>basie</hostid></entry>
		<entry><hostid role="ipaddr">10.0.0.4</hostid></entry>
		<entry>Faculty workstation</entry>
	      </row>
	      <row>
		<entry><hostid>bird</hostid></entry>
		<entry><hostid role="ipaddr">10.0.0.5</hostid></entry>
		<entry>Client machine</entry>
	      </row>
	      <row>
		<entry><hostid>cli[1-11]</hostid></entry>
		<entry><hostid role="ipaddr">10.0.0.[6-17]</hostid></entry>
		<entry>Other client machines</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>If you are setting up a NIS scheme for the first time, it
	  is a good idea to think through how you want to go about it.  No
	  matter what the size of your network, there are a few decisions
	  that need to be made.</para>

	<sect4>
	  <title>Choosing a NIS Domain Name</title>

	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>domainname</secondary>
	  </indexterm>
	  <para>This might not be the <quote>domainname</quote> that you
	    are used to.  It is more accurately called the
	    <quote>NIS domainname</quote>.  When a client broadcasts its
	    requests for info, it includes the name of the NIS domain
	    that it is part of.  This is how multiple servers on one
	    network can tell which server should answer which request.
	    Think of the NIS domainname as the name for a group of hosts
	    that are related in some way.</para>

	  <para>Some organizations choose to use their Internet
	    domainname for their NIS domainname.  This is not
	    recommended as it can cause confusion when trying to debug
	    network problems.  The NIS domainname should be unique
	    within your network and it is helpful if it describes the
	    group of machines it represents.  For example, the Art
	    department at Acme Inc.  might be in the
	    <quote>acme-art</quote> NIS domain.  For this example,
	    assume you have chosen the name
	    <emphasis>test-domain</emphasis>.</para>

	  <indexterm><primary>SunOS</primary></indexterm>
	  <para>However, some operating systems (notably &sunos;) use their
	    NIS domain name as their Internet domain name.
	    If one or more machines on your network have this restriction,
	    you <emphasis>must</emphasis> use the Internet domain name as
	    your NIS domain name.</para>
	</sect4>

	<sect4>
	  <title>Physical Server Requirements</title>

	  <para>There are several things to keep in mind when choosing a
	    machine to use as a NIS server.  One of the unfortunate things
	    about NIS is the level of dependency the clients have on the
	    server.  If a client cannot contact the server for its NIS
	    domain, very often the machine becomes unusable.  The lack of
	    user and group information causes most systems to temporarily
	    freeze up.  With this in mind you should make sure to choose a
	    machine that will not be prone to being rebooted regularly, or
	    one that might be used for development.  The NIS server should
	    ideally be a stand alone machine whose sole purpose in life is
	    to be an NIS server.  If you have a network that is not very
	    heavily used, it is acceptable to put the NIS server on a
	    machine running other services, just keep in mind that if the
	    NIS server becomes unavailable, it will affect
	    <emphasis>all</emphasis> of your NIS clients adversely.</para>
	</sect4>
      </sect3>

      <sect3>
	<title>NIS Servers</title>

	<para>The canonical copies of all NIS information are stored on
	  a single machine called the NIS master server.  The databases
	  used to store the information are called NIS maps.  In FreeBSD,
	  these maps are stored in
	  <filename>/var/yp/[domainname]</filename> where
	  <filename>[domainname]</filename> is the name of the NIS domain
	  being served.  A single NIS server can support several domains
	  at once, therefore it is possible to have several such
	  directories, one for each supported domain.  Each domain will
	  have its own independent set of maps.</para>

	<para>NIS master and slave servers handle all NIS requests with
	  the <command>ypserv</command> daemon.  <command>ypserv</command>
	  is responsible for receiving incoming requests from NIS clients,
	  translating the requested domain and map name to a path to the
	  corresponding database file and transmitting data from the
	  database back to the client.</para>

	<sect4>
	  <title>Setting Up a NIS Master Server</title>
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>server configuration</secondary>
	  </indexterm>
	  <para>Setting up a master NIS server can be relatively straight
	    forward, depending on your needs.  FreeBSD comes with support
	    for NIS out-of-the-box.  All you need is to add the following
	    lines to <filename>/etc/rc.conf</filename>, and FreeBSD will
	    do the rest for you.</para>

	  <procedure>
	    <step>
	      <para><programlisting>nisdomainname="test-domain"</programlisting>
		This line will set the NIS domainname to
		<emphasis>test-domain</emphasis>
		upon network setup (e.g.  after reboot).</para>
	    </step>
	    <step>
	      <para><programlisting>nis_server_enable="YES"</programlisting>
		This will tell FreeBSD to start up the NIS server processes
		when the networking is next brought up.</para>
	    </step>
	    <step>
	      <para><programlisting>nis_yppasswdd_enable="YES"</programlisting>
		This will enable the <command>rpc.yppasswdd</command>
		daemon which, as mentioned above, will allow users to
		change their NIS password from a client machine.</para>
	    </step>
	  </procedure>

	  <note>
	    <para>Depending on your NIS setup, you may need to add
	      further entries.  See the <link
	      linkend="network-nis-server-is-client">section about NIS servers
	      that are also NIS clients</link>, below, for
	      details.</para>
	  </note>

	  <para>Now, all you have to do is to run the command
	    <command>/etc/netstart</command> as superuser.  It will
	    set up everything for you, using the values you defined in
	    <filename>/etc/rc.conf</filename>.</para>
	</sect4>

	<sect4>
	  <title>Initializing the NIS Maps</title>
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>maps</secondary>
	  </indexterm>
	  <para>The <emphasis>NIS maps</emphasis> are database files,
	    that are kept in the <filename>/var/yp</filename> directory.
	    They are generated from configuration files in the
	    <filename>/etc</filename> directory of the NIS master, with one
	    exception: the <filename>/etc/master.passwd</filename> file.
	    This is for a good reason; you do not want to propagate
	    passwords to your <username>root</username> and other
	    administrative accounts to all the servers in the NIS domain.
	    Therefore, before we initialize the NIS maps, you should:</para>

	  <screen>&prompt.root; <userinput>cp /etc/master.passwd /var/yp/master.passwd</userinput>
&prompt.root; <userinput>cd /var/yp</userinput>
&prompt.root; <userinput>vi master.passwd</userinput></screen>

	  <para>You should remove all entries regarding system accounts
	    (<username>bin</username>, <username>tty</username>,
	    <username>kmem</username>, <username>games</username>, etc), as
	    well as any accounts that you do not want to be propagated to the
	    NIS clients (for example <username>root</username> and any other
	    UID 0 (superuser) accounts).</para>

	  <note><para>Make sure the
	    <filename>/var/yp/master.passwd</filename> is neither group
	    nor world readable (mode 600)!  Use the
	    <command>chmod</command> command, if appropriate.</para></note>

	  <indexterm><primary>Tru64 UNIX</primary></indexterm>
	  <para>When you have finished, it is time to initialize the NIS
	    maps!  FreeBSD includes a script named
	    <command>ypinit</command> to do this for you
	    (see its manual page for more information).  Note that this
	    script is available on most &unix; Operating Systems, but not on all.
	    On Digital UNIX/Compaq Tru64 UNIX it is called
	    <command>ypsetup</command>.
	    Because we are generating maps for an NIS master, we are
	    going to pass the <option>-m</option> option to
	    <command>ypinit</command>.
	    To generate the NIS maps, assuming you already performed
	    the steps above, run:</para>

	  <screen>ellington&prompt.root; <userinput>ypinit -m test-domain</userinput>
Server Type: MASTER Domain: test-domain
Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.
Do you want this procedure to quit on non-fatal errors? [y/n: n] <userinput>n</userinput>
Ok, please remember to go back and redo manually whatever fails.
If you don't, something might not work.
At this point, we have to construct a list of this domains YP servers.
rod.darktech.org is already known as master server.
Please continue to add any slave servers, one per line.  When you are
done with the list, type a &lt;control D&gt;.
master server   :  ellington
next host to add:  <userinput>coltrane</userinput>
next host to add:  <userinput>^D</userinput>
The current list of NIS servers looks like this:
ellington
coltrane
Is this correct?  [y/n: y] <userinput>y</userinput>

[..output from map generation..]

NIS Map update completed.
ellington has been setup as an YP master server without any errors.</screen>

	  <para><command>ypinit</command> should have created
	    <filename>/var/yp/Makefile</filename> from
	    <filename>/var/yp/Makefile.dist</filename>.
	    When created, this file assumes that you are operating
	    in a single server NIS environment with only FreeBSD
	    machines.  Since <emphasis>test-domain</emphasis> has
	    a slave server as well, you must edit
	    <filename>/var/yp/Makefile</filename>:</para>

	  <screen>ellington&prompt.root; <userinput>vi /var/yp/Makefile</userinput></screen>

	  <para>You should comment out the line that says</para>

	  <programlisting>NOPUSH = "True"</programlisting>

	  <para>(if it is not commented out already).</para>
	</sect4>

	<sect4>
	  <title>Setting up a NIS Slave Server</title>
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>slave server</secondary>
	  </indexterm>
	  <para>Setting up an NIS slave server is even more simple than
	    setting up the master.  Log on to the slave server and edit the
	    file <filename>/etc/rc.conf</filename> as you did before.
	    The only difference is that we now must use the
	    <option>-s</option> option when running <command>ypinit</command>.
	    The <option>-s</option> option requires the name of the NIS
	    master be passed to it as well, so our command line looks
	    like:</para>

  <screen>coltrane&prompt.root; <userinput>ypinit -s ellington test-domain</userinput>

Server Type: SLAVE Domain: test-domain Master: ellington

Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.

Do you want this procedure to quit on non-fatal errors? [y/n: n]  <userinput>n</userinput>

Ok, please remember to go back and redo manually whatever fails.
If you don't, something might not work.
There will be no further questions.  The remainder of the procedure
should take a few minutes, to copy the databases from ellington.
Transferring netgroup...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byuser...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byhost...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring group.bygid...
ypxfr: Exiting: Map successfully transferred
Transferring group.byname...
ypxfr: Exiting: Map successfully transferred
Transferring services.byname...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.byname...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.byname...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring netid.byname...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring ypservers...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byname...
ypxfr: Exiting: Map successfully transferred

coltrane has been setup as an YP slave server without any errors.
Don't forget to update map ypservers on ellington.</screen>

	  <para>You should now have a directory called
	    <filename>/var/yp/test-domain</filename>.  Copies of the NIS
	    master server's maps should be in this directory.  You will
	    need to make sure that these stay updated.  The following
	    <filename>/etc/crontab</filename> entries on your slave
	    servers should do the job:</para>

	  <programlisting>20      *       *       *       *       root   /usr/libexec/ypxfr passwd.byname
21      *       *       *       *       root   /usr/libexec/ypxfr passwd.byuid</programlisting>

	  <para>These two lines force the slave to sync its maps with
	    the maps on the master server.  Although these entries are
	    not mandatory, since the master server attempts to ensure
	    any changes to its NIS maps are communicated to its slaves
	    and because password information is vital to systems
	    depending on the server, it is a good idea to force the
	    updates.  This is more important on busy networks where map
	    updates might not always complete.</para>

	  <para>Now, run the command <command>/etc/netstart</command> on the
	    slave server as well, which again starts the NIS server.</para>
	</sect4>
      </sect3>

      <sect3>
	<title>NIS Clients</title>

	<para>An NIS client establishes what is called a binding to a
	  particular NIS server using the
	  <command>ypbind</command> daemon.
	  <command>ypbind</command> checks the system's default
	  domain (as set by the <command>domainname</command> command),
	  and begins broadcasting RPC requests on the local network.
	  These requests specify the name of the domain for which
	  <command>ypbind</command> is attempting to establish a binding.
	  If a server that has been configured to serve the requested
	  domain receives one of the broadcasts, it will respond to
	  <command>ypbind</command>,  which will record the server's
	  address.  If there are several servers available (a master and
	  several slaves, for example), <command>ypbind</command> will
	  use the address of the first one to respond.  From that point
	  on, the client system will direct all of its NIS requests to
	  that server.  <command>ypbind</command> will
	  occasionally <quote>ping</quote> the server to make sure it is
	  still up and running.  If it fails to receive a reply to one of
	  its pings within a reasonable amount of time,
	  <command>ypbind</command> will mark the domain as unbound and
	  begin broadcasting again in the hopes of locating another
	  server.</para>

	<sect4>
	  <title>Setting Up a NIS Client</title>
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>client configuration</secondary>
	  </indexterm>
	  <para>Setting up a FreeBSD machine to be a NIS client is fairly
	    straightforward.</para>

	  <procedure>
	    <step>
	      <para>Edit the file <filename>/etc/rc.conf</filename> and
		add the following lines in order to set the NIS domainname
		and start <command>ypbind</command> upon network
		startup:</para>

	      <programlisting>nisdomainname="test-domain"
nis_client_enable="YES"</programlisting>
	    </step>

	    <step>
	      <para>To import all possible password entries from the NIS
		server, remove all user accounts from your
		<filename>/etc/master.passwd</filename> file and use
		<command>vipw</command> to add the following line to
		the end of the file:</para>

	      <programlisting>+:::::::::</programlisting>

	      <note>
		<para>This line will afford anyone with a valid account in
		  the NIS server's password maps an account.  There are
		  many ways to configure your NIS client by changing this
		  line.  See the <link linkend="network-netgroups">netgroups
		  section</link> below for more information.
		  For more detailed reading see O'Reilly's book on
		  <literal>Managing NFS and NIS</literal>.</para>
	      </note>

	      <note>
		<para>You should keep at least one local account (i.e.
		  not imported via NIS) in your
		  <filename>/etc/master.passwd</filename> and this
		  account should also be a member of the group
		  <groupname>wheel</groupname>.  If there is something
		  wrong with NIS, this account can be used to log in
		  remotely, become root, and fix things.</para>
	      </note>
	    </step>

	    <step>
	      <para>To import all possible group entries from the NIS
		server, add this line to your
		<filename>/etc/group</filename> file:</para>

	      <programlisting>+:*::</programlisting>
	    </step>
	  </procedure>

	  <para>After completing these steps, you should be able to run
	    <command>ypcat passwd</command> and see the NIS server's
	    passwd map.</para>
	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>NIS Security</title>

      <para>In general, any remote user can issue an RPC to
	&man.ypserv.8; and retrieve the contents of your NIS maps,
	provided the remote user knows your domainname.  To prevent
	such unauthorized transactions, &man.ypserv.8; supports a
	feature called securenets which can be used to restrict access
	to a given set of hosts.  At startup, &man.ypserv.8; will
	attempt to load the securenets information from a file called
	<filename>/var/yp/securenets</filename>.</para>

      <note>
	<para>This path varies depending on the path specified with the
	  <option>-p</option> option.  This file contains entries that
	  consist of a network specification and a network mask separated
	  by white space.  Lines starting with <quote>#</quote> are
	  considered to be comments.  A sample securenets file might look
	  like this:</para>
      </note>

      <programlisting># allow connections from local host -- mandatory
127.0.0.1     255.255.255.255
# allow connections from any host
# on the 192.168.128.0 network
192.168.128.0 255.255.255.0
# allow connections from any host
# between 10.0.0.0 to 10.0.15.255
# this includes the machines in the testlab
10.0.0.0      255.255.240.0</programlisting>

      <para>If &man.ypserv.8; receives a request from an address that
	matches one of these rules, it will process the request
	normally.  If the address fails to match a rule, the request
	will be ignored and a warning message will be logged.  If the
	<filename>/var/yp/securenets</filename> file does not exist,
	<command>ypserv</command> will allow connections from any
	host.</para>

      <para>The <command>ypserv</command> program also has support for Wietse
	Venema's
	<application>tcpwrapper</application> package.  This allows the
	administrator to use the <application>tcpwrapper</application> configuration
	files for access control instead of
	<filename>/var/yp/securenets</filename>.</para>

      <note>
	<para>While both of these access control mechanisms provide some
	  security, they, like the privileged port test, are
	  vulnerable to <quote>IP spoofing</quote> attacks.  All
	  NIS-related traffic should be blocked at your firewall.</para>

	<para>Servers using <filename>/var/yp/securenets</filename>
	  may fail to serve legitimate NIS clients with archaic TCP/IP
	  implementations.  Some of these implementations set all
	  host bits to zero when doing broadcasts and/or fail to
	  observe the subnet mask when calculating the broadcast
	  address.  While some of these problems can be fixed by
	  changing the client configuration, other problems may force
	  the retirement of the client systems in question or the
	  abandonment of <filename>/var/yp/securenets</filename>.</para>

	<para>Using <filename>/var/yp/securenets</filename> on a
	  server with such an archaic implementation of TCP/IP is a
	  really bad idea and will lead to loss of NIS functionality
	  for large parts of your network.</para>

	<indexterm><primary>tcpwrapper</primary></indexterm>
	<para>The use of the <application>tcpwrapper</application>
	  package increases the latency of your NIS server.  The
	  additional delay may be long enough to cause timeouts in
	  client programs, especially in busy networks or with slow
	  NIS servers.  If one or more of your client systems
	  suffers from these symptoms, you should convert the client
	  systems in question into NIS slave servers and force them
	  to bind to themselves.</para>
      </note>
    </sect2>

    <sect2>
      <title>Barring Some Users from Logging On</title>

      <para>In our lab, there is a machine <hostid>basie</hostid> that is
	supposed to be a faculty only workstation.  We do not want to take this
	 machine out of the NIS domain, yet the <filename>passwd</filename>
       file on the master NIS server contains accounts for both faculty and
	students.  What can we do?</para>

      <para>There is a way to bar specific users from logging on to a
	machine, even if they are present in the NIS database.  To do this,
	all you must do is add
	<emphasis>-<replaceable>username</replaceable></emphasis> to the end of
	the <filename>/etc/master.passwd</filename> file on the client
	machine, where <replaceable>username</replaceable> is the username of
	the user you wish to bar from logging in.  This should preferably be
	done using <command>vipw</command>, since <command>vipw</command>
	will sanity check your changes to
	<filename>/etc/master.passwd</filename>, as well as
	automatically rebuild the password database when you
	finish editing.  For example, if we wanted to bar user
	<emphasis>bill</emphasis> from logging on to <hostid>basie</hostid>
	we would:</para>

	<screen>basie&prompt.root; <userinput>vipw</userinput>
<userinput>[add -bill to the end, exit]</userinput>
vipw: rebuilding the database...
vipw: done

basie&prompt.root; <userinput>cat /etc/master.passwd</userinput>

root:[password]:0:0::0:0:The super-user:/root:/bin/csh
toor:[password]:0:0::0:0:The other super-user:/root:/bin/sh
daemon:*:1:1::0:0:Owner of many system processes:/root:/sbin/nologin
operator:*:2:5::0:0:System &:/:/sbin/nologin
bin:*:3:7::0:0:Binaries Commands and Source,,,:/:/sbin/nologin
tty:*:4:65533::0:0:Tty Sandbox:/:/sbin/nologin
kmem:*:5:65533::0:0:KMem Sandbox:/:/sbin/nologin
games:*:7:13::0:0:Games pseudo-user:/usr/games:/sbin/nologin
news:*:8:8::0:0:News Subsystem:/:/sbin/nologin
man:*:9:9::0:0:Mister Man Pages:/usr/share/man:/sbin/nologin
bind:*:53:53::0:0:Bind Sandbox:/:/sbin/nologin
uucp:*:66:66::0:0:UUCP pseudo-user:/var/spool/uucppublic:/usr/libexec/uucp/uucico
xten:*:67:67::0:0:X-10 daemon:/usr/local/xten:/sbin/nologin
pop:*:68:6::0:0:Post Office Owner:/nonexistent:/sbin/nologin
nobody:*:65534:65534::0:0:Unprivileged user:/nonexistent:/sbin/nologin
+:::::::::
-bill

basie&prompt.root;</screen>
    </sect2>

    <sect2 id="network-netgroups">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Udo</firstname>
	    <surname>Erdelhoff</surname>
	    <contrib>Contributed by </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Using Netgroups</title>
      <indexterm><primary>netgroups</primary></indexterm>

      <para>The method shown in the previous section works reasonably
	well if you need special rules for a very small number of
	users and/or machines.  On larger networks, you
	<emphasis>will</emphasis> forget to bar some users from logging
	onto sensitive machines, or you may even have to modify each
	machine separately, thus losing the main benefit of NIS,
	<emphasis>centralized</emphasis> administration.</para>

      <para>The NIS developers' solution for this problem is called
	<emphasis>netgroups</emphasis>.  Their purpose and semantics
	can be compared to the normal groups used by &unix; file
	systems.  The main differences are the lack of a numeric id
	and the ability to define a netgroup by including both user
	accounts and other netgroups.</para>

      <para>Netgroups were developed to handle large, complex networks
	with hundreds of users and machines.  On one hand, this is
	a Good Thing if you are forced to deal with such a situation.
	On the other hand, this complexity makes it almost impossible to
	explain netgroups with really simple examples.  The example
	used in the remainder of this section demonstrates this
	problem.</para>

      <para>Let us assume that your successful introduction of NIS in
	your laboratory caught your superiors' interest.  Your next
	job is to extend your NIS domain to cover some of the other
	machines on campus.  The two tables contain the names of the
	new users and new machines as well as brief descriptions of
	them.</para>

      <informaltable>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>User Name(s)</entry>
	      <entry>Description</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>alpha, beta</entry>
	      <entry>Normal employees of the IT department</entry>
	    </row>

	    <row>
	      <entry>charlie, delta</entry>
	      <entry>The new apprentices of the IT department</entry>
	    </row>

	    <row>
	      <entry>echo, foxtrott, golf, ...</entry>
	      <entry>Ordinary employees</entry>
	    </row>

	    <row>
	      <entry>able, baker, ...</entry>
	      <entry>The current interns</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <informaltable>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Machine Name(s)</entry>
	      <entry>Description</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <!--  Names taken from "Good Omens" by Neil Gaiman and Terry
		    Pratchett.  Many thanks for a brilliant book.  -->
	      <entry>war, death, famine, pollution</entry>
	      <entry>Your most important servers.  Only the IT
		employees are allowed to log onto these
		machines.</entry>
	    </row>
	    <row>
	      <!-- gluttony was omitted because it was too fat -->
	      <entry>pride, greed, envy, wrath, lust, sloth</entry>
	      <entry>Less important servers.  All members of the IT
		department are allowed to login onto these machines.</entry>
	    </row>

	    <row>
	      <entry>one, two, three, four, ...</entry>
	      <entry>Ordinary workstations.  Only the
		<emphasis>real</emphasis> employees are allowed to use
		these machines.</entry>
	    </row>

	    <row>
	      <entry>trashcan</entry>
	      <entry>A very old machine without any critical data.
		Even the intern is allowed to use this box.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>If you tried to implement these restrictions by separately
	blocking each user, you would have to add one
	-<replaceable>user</replaceable> line to each system's
	<filename>passwd</filename>
	for each user who is not allowed to login onto that system.
	If you forget just one entry, you could be in trouble.  It may
	be feasible to do this correctly during the initial setup,
	however you <emphasis>will</emphasis> eventually forget to add
	the lines for new users during day-to-day operations.  After
	all, Murphy was an optimist.</para>

      <para>Handling this situation with netgroups offers several
	advantages.  Each user need not be handled separately;
	you assign a user to one or more netgroups and allow or forbid
	logins for all members of the netgroup.  If you add a new
	machine, you will only have to define login restrictions for
	netgroups.  If a new user is added, you will only have to add
	the user to one or more netgroups.  Those changes are
	independent of each other; no more <quote>for each combination
	of user and machine do...</quote> If your NIS setup is planned
	carefully, you will only have to modify exactly one central
	configuration file to grant or deny access to machines.</para>

      <para>The first step is the initialization of the NIS map
	netgroup.  FreeBSD's &man.ypinit.8; does not create this map by
	default, but its NIS implementation will support it once it has
	been created.  To create an empty map, simply type</para>

      <screen>ellington&prompt.root; <userinput>vi /var/yp/netgroup</userinput></screen>

      <para>and start adding content.  For our example, we need at
	 least four netgroups: IT employees, IT apprentices, normal
	 employees and interns.</para>

      <programlisting>IT_EMP  (,alpha,test-domain)    (,beta,test-domain)
IT_APP  (,charlie,test-domain)  (,delta,test-domain)
USERS   (,echo,test-domain)     (,foxtrott,test-domain) \
	(,golf,test-domain)
INTERNS (,able,test-domain)     (,baker,test-domain)</programlisting>

      <para><literal>IT_EMP</literal>, <literal>IT_APP</literal> etc.
	are the names of the netgroups.  Each bracketed group adds
	one or more user accounts to it.  The three fields inside a
	group are:</para>

      <orderedlist>
	<listitem>
	  <para>The name of the host(s) where the following items are
	    valid.  If you do not specify a hostname, the entry is
	    valid on all hosts.  If you do specify a hostname, you
	    will enter a realm of darkness, horror and utter confusion.</para>
	</listitem>

	<listitem>
	  <para>The name of the account that belongs to this
	    netgroup.</para>
	</listitem>

	<listitem>
	  <para>The NIS domain for the account.  You can import
	    accounts from other NIS domains into your netgroup if you
	    are one of the unlucky fellows with more than one NIS
	    domain.</para>
	</listitem>
      </orderedlist>

      <para>Each of these fields can contain wildcards.  See
	&man.netgroup.5; for details.</para>

      <note>
	<indexterm><primary>netgroups</primary></indexterm>
	<para>Netgroup names longer than 8 characters should not be
	  used, especially if you have machines running other
	  operating systems within your NIS domain.  The names are
	  case sensitive; using capital letters for your netgroup
	  names is an easy way to distinguish between user, machine
	  and netgroup names.</para>

	<para>Some NIS clients (other than FreeBSD) cannot handle
	  netgroups with a large number of entries.  For example, some
	  older versions of &sunos; start to cause trouble if a netgroup
	  contains more than 15 <emphasis>entries</emphasis>.  You can
	  circumvent this limit by creating several sub-netgroups with
	  15 users or less and a real netgroup that consists of the
	  sub-netgroups:</para>

	<programlisting>BIGGRP1  (,joe1,domain)  (,joe2,domain)  (,joe3,domain) [...]
BIGGRP2  (,joe16,domain)  (,joe17,domain) [...]
BIGGRP3  (,joe31,domain)  (,joe32,domain)
BIGGROUP BIGGRP1 BIGGRP2 BIGGRP3</programlisting>

	<para>You can repeat this process if you need more than 225
	  users within a single netgroup.</para>
      </note>

      <para>Activating and distributing your new NIS map is
	easy:</para>

      <screen>ellington&prompt.root; <userinput>cd /var/yp</userinput>
ellington&prompt.root; <userinput>make</userinput></screen>

      <para>This will generate the three NIS maps
	<filename>netgroup</filename>,
	<filename>netgroup.byhost</filename> and
	<filename>netgroup.byuser</filename>.  Use &man.ypcat.1; to
	check if your new NIS maps are available:</para>

      <screen>ellington&prompt.user; <userinput>ypcat -k netgroup</userinput>
ellington&prompt.user; <userinput>ypcat -k netgroup.byhost</userinput>
ellington&prompt.user; <userinput>ypcat -k netgroup.byuser</userinput></screen>

      <para>The output of the first command should resemble the
	contents of <filename>/var/yp/netgroup</filename>.  The second
	command will not produce output if you have not specified
	host-specific netgroups.  The third command can be used to
	get the list of netgroups for a user.</para>

      <para>The client setup is quite simple.  To configure the server
	<replaceable>war</replaceable>, you only have to start
	&man.vipw.8; and replace the line</para>

      <programlisting>+:::::::::</programlisting>

      <para>with</para>

      <programlisting>+@IT_EMP:::::::::</programlisting>

      <para>Now, only the data for the users defined in the netgroup
	<replaceable>IT_EMP</replaceable> is imported into
	<replaceable>war</replaceable>'s password database and only
	these users are allowed to login.</para>

      <para>Unfortunately, this limitation also applies to the ~
	function of the shell and all routines converting between user
	names and numerical user IDs.  In other words,
	<command>cd ~<replaceable>user</replaceable></command> will not work,
	<command>ls -l</command> will show the numerical id instead of
	the username and <command>find . -user joe -print</command> will
	fail with <errorname>No such user</errorname>.  To fix this, you will
	have to import all user entries <emphasis>without allowing them
	to login onto your servers</emphasis>.</para>

      <para>This can be achieved by adding another line to
	<filename>/etc/master.passwd</filename>.  This line should
	contain:</para>

      <para><literal>+:::::::::/sbin/nologin</literal>, meaning
	<quote>Import all entries but replace the shell with
	<filename>/sbin/nologin</filename> in the imported
	entries</quote>.  You can replace any field
	in the passwd entry by placing a default value in your
	<filename>/etc/master.passwd</filename>.</para>

      <!-- Been there, done that, got the scars to prove it - ue -->
      <warning>
	<para>Make sure that the line
	<literal>+:::::::::/sbin/nologin</literal> is placed after
	<literal>+@IT_EMP:::::::::</literal>.  Otherwise, all user
	accounts imported from NIS will have /sbin/nologin as their
	login shell.</para>
      </warning>

      <para>After this change, you will only have to change one NIS
	map if a new employee joins the IT department.  You could use
	a similar approach for the less important servers by replacing
	the old <literal>+:::::::::</literal> in their local version
	of <filename>/etc/master.passwd</filename> with something like
	this:</para>

      <programlisting>+@IT_EMP:::::::::
+@IT_APP:::::::::
+:::::::::/sbin/nologin</programlisting>

      <para>The corresponding lines for the normal workstations
	could be:</para>

      <programlisting>+@IT_EMP:::::::::
+@USERS:::::::::
+:::::::::/sbin/nologin</programlisting>

      <para>And everything would be fine until there is a policy
	change a few weeks later:  The IT department starts hiring
	interns.  The IT interns are allowed to use the normal
	workstations and the less important servers; and the IT
	apprentices are allowed to login onto the main servers.  You
	add a new netgroup IT_INTERN, add the new IT interns to this
	netgroup and start to change the config on each and every
	machine...  As the old saying goes:  <quote>Errors in
	centralized planning lead to global mess</quote>.</para>

      <para>NIS' ability to create netgroups from other netgroups can
	be used to prevent situations like these.  One possibility
	is the creation of role-based netgroups.  For example, you
	could create a netgroup called
	<replaceable>BIGSRV</replaceable> to define the login
	restrictions for the important servers, another netgroup
	called <replaceable>SMALLSRV</replaceable> for the less
	important servers and a third netgroup called
	<replaceable>USERBOX</replaceable> for the normal
	workstations.  Each of these netgroups contains the netgroups
	that are allowed to login onto these machines.  The new
	entries for your NIS map netgroup should look like this:</para>

      <programlisting>BIGSRV    IT_EMP IT_APP
SMALLSRV IT_EMP IT_APP ITINTERN
USERBOX   IT_EMP ITINTERN USERS</programlisting>

      <para>This method of defining login restrictions works
	reasonably well if you can define groups of machines with
	identical restrictions.  Unfortunately, this is the exception
	and not the rule.  Most of the time, you will need the ability
	to define login restrictions on a per-machine basis.</para>

      <para>Machine-specific netgroup definitions are the other
	possibility to deal with the policy change outlined above.  In
	this scenario, the <filename>/etc/master.passwd</filename> of
	each box contains two lines starting with <quote>+</quote>.
	The first of them adds a netgroup with the accounts allowed to
	login onto this machine, the second one adds all other
	accounts with <filename>/sbin/nologin</filename> as shell.  It
	is a good idea to use the ALL-CAPS version of the machine name
	as the name of the netgroup.  In other words, the lines should
	look like this:</para>

      <programlisting>+@<replaceable>BOXNAME</replaceable>:::::::::
+:::::::::/sbin/nologin</programlisting>

      <para>Once you have completed this task for all your machines,
	you will not have to modify the local versions of
	<filename>/etc/master.passwd</filename> ever again.  All
	further changes can be handled by modifying the NIS map.  Here
	is an example of a possible netgroup map for this
	scenario with some additional goodies.</para>

      <programlisting># Define groups of users first
IT_EMP    (,alpha,test-domain)    (,beta,test-domain)
IT_APP    (,charlie,test-domain)  (,delta,test-domain)
DEPT1     (,echo,test-domain)     (,foxtrott,test-domain)
DEPT2     (,golf,test-domain)     (,hotel,test-domain)
DEPT3     (,india,test-domain)    (,juliet,test-domain)
ITINTERN  (,kilo,test-domain)     (,lima,test-domain)
D_INTERNS (,able,test-domain)     (,baker,test-domain)
#
# Now, define some groups based on roles
USERS     DEPT1   DEPT2     DEPT3
BIGSRV    IT_EMP IT_APP
SMALLSRV IT_EMP IT_APP    ITINTERN
USERBOX   IT_EMP ITINTERN USERS
#
# And a groups for a special tasks
# Allow echo and golf to access our anti-virus-machine
SECURITY IT_EMP  (,echo,test-domain)  (,golf,test-domain)
#
# machine-based netgroups
# Our main servers
WAR       BIGSRV
FAMINE    BIGSRV
# User india needs access to this server
POLLUTION BIGSRV  (,india,test-domain)
#
# This one is really important and needs more access restrictions
DEATH     IT_EMP
#
# The anti-virus-machine mentioned above
ONE       SECURITY
#
# Restrict a machine to a single user
TWO       (,hotel,test-domain)
# [...more groups to follow]</programlisting>

      <para>If you are using some kind of database to manage your user
	accounts, you should be able to create the first part of the
	map with your database's report tools.  This way, new users
	will automatically have access to the boxes.</para>

      <para>One last word of caution: It may not always be advisable
	to use machine-based netgroups.  If you are deploying a couple of
	dozen or even hundreds of identical machines for student labs,
	you should use role-based netgroups instead of machine-based
	netgroups to keep the size of the NIS map within reasonable
	limits.</para>
    </sect2>

    <sect2>
      <title>Important Things to Remember</title>

      <para>There are still a couple of things that you will need to do
	differently now that you are in an NIS environment.</para>

      <itemizedlist>
	<listitem>
	  <para>Every time you wish to add a user to the lab, you
	    must add it to the master NIS server <emphasis>only</emphasis>,
	    and <emphasis>you must remember to rebuild the NIS
	    maps</emphasis>.  If you forget to do this, the new user will
	    not be able to login anywhere except on the NIS master.
	    For example, if we needed to add a new user
	    <quote>jsmith</quote> to the lab, we would:</para>

	  <screen>&prompt.root; <userinput>pw useradd jsmith</userinput>
&prompt.root; <userinput>cd /var/yp</userinput>
&prompt.root; <userinput>make test-domain</userinput></screen>

	  <para>You could also run <command>adduser jsmith</command> instead
	    of <command>pw useradd jsmith</command>.</para>
	</listitem>
	<listitem>
	  <para><emphasis>Keep the administration accounts out of the NIS
	    maps</emphasis>.  You do not want to be propagating administrative
	    accounts and passwords to machines that will have users that
	    should not have access to those accounts.</para>
	</listitem>
	<listitem>
	  <para><emphasis>Keep the NIS master and slave
	    secure, and minimize their downtime</emphasis>.
	    If somebody either hacks or simply turns off
	    these machines, they have effectively rendered many people without
	    the ability to login to the lab.</para>

	  <para>This is the chief weakness of any centralized administration
	    system.  If you do
	    not protect your NIS servers, you will have a lot of angry
	    users!</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>NIS v1 Compatibility</title>

      <para>FreeBSD's <application>ypserv</application> has some support
	for serving NIS v1 clients.  FreeBSD's NIS implementation only
	uses the NIS v2 protocol, however other implementations include
	support for the v1 protocol for backwards compatibility with older
	systems.  The <application>ypbind</application> daemons supplied
	with these systems will try to establish a binding to an NIS v1
	server even though they may never actually need it (and they may
	persist in broadcasting in search of one even after they receive a
	response from a v2 server).  Note that while support for normal
	client calls is provided, this version of ypserv does not handle
	v1 map transfer requests; consequently, it cannot be used as a
	master or slave in conjunction with older NIS servers that only
	support the v1 protocol.  Fortunately, there probably are not any
	such servers still in use today.</para>
    </sect2>

    <sect2 id="network-nis-server-is-client">
      <title>NIS Servers That Are Also NIS Clients</title>

      <para>Care must be taken when running ypserv in a multi-server
	domain where the server machines are also NIS clients.  It is
	generally a good idea to force the servers to bind to themselves
	rather than allowing them to broadcast bind requests and possibly
	become bound to each other.  Strange failure modes can result if
	one server goes down and others are dependent upon it.
	Eventually all the clients will time out and attempt to bind to
	other servers, but the delay involved can be considerable and the
	failure mode is still present since the servers might bind to each
	other all over again.</para>

      <para>You can force a host to bind to a particular server by running
	<command>ypbind</command> with the <option>-S</option>
	flag.  If you do not want to do this manually each time you
	reboot your NIS server, you can add the following lines to
	your <filename>/etc/rc.conf</filename>:</para>

      <programlisting>nis_client_enable="YES"	# run client stuff as well
nis_client_flags="-S <replaceable>NIS domain</replaceable>,<replaceable>server</replaceable>"</programlisting>

      <para>See &man.ypbind.8; for further information.</para>
    </sect2>

    <sect2>
      <title>Password Formats</title>
      <indexterm>
	<primary>NIS</primary>
	<secondary>password formats</secondary>
      </indexterm>
      <para>One of the most common issues that people run into when trying
	to implement NIS is password format compatibility.  If your NIS
	server is using DES encrypted passwords, it will only support
	clients that are also using DES.  For example, if you have
	&solaris; NIS clients in your network, then you will almost certainly
	need to use DES encrypted passwords.</para>

      <para>To check which format your servers
	and clients are using, look at <filename>/etc/login.conf</filename>.
	If the host is configured to use DES encrypted passwords, then the
	<literal>default</literal> class will contain an entry like this:</para>

      <programlisting>default:\
	:passwd_format=des:\
	:copyright=/etc/COPYRIGHT:\
	[Further entries elided]</programlisting>

      <para>Other possible values for the <literal>passwd_format</literal>
	capability include <literal>blf</literal> and <literal>md5</literal>
	(for Blowfish and MD5 encrypted passwords, respectively).</para>

      <para>If you have made changes to <filename>/etc/login.conf</filename>,
	you will also need to rebuild the login capability database, which is
	achieved by running the following command as <username>root</username>:</para>

      <screen>&prompt.root; <userinput>cap_mkdb /etc/login.conf</userinput></screen>

      <note><para>The format of passwords already in
	<filename>/etc/master.passwd</filename> will not be updated until
	a user changes their password for the first time <emphasis>after</emphasis>
	the login capability database is rebuilt.</para></note>

      <para>Next, in order to ensure that passwords are encrypted with the
	format that you have chosen, you should also check that the
	<literal>crypt_default</literal> in <filename>/etc/auth.conf</filename>
	gives precedence to your chosen password format.  To do this, place
	the format that you have chosen first in the list.  For example, when
	using DES encrypted passwords, the entry would be:</para>

      <programlisting>crypt_default	=	des blf md5</programlisting>

      <para>Having followed the above steps on each of the &os; based NIS
	servers and clients, you can be sure that they all agree on which
	password format is used within your network.
	If you have trouble authenticating on an NIS client, this
	is a pretty good place to start looking for possible problems.
	Remember: if you want to deploy an NIS server for a heterogenous
	network, you will probably have to use DES on all systems
	because it is the lowest common standard.</para>
    </sect2>
  </sect1>

  <sect1 id="network-dhcp">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Greg</firstname>
      	  <surname>Sutter</surname>
	  <contrib>Written by </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>DHCP</title>

    <sect2>
      <title>What Is DHCP?</title>
      <indexterm>
	<primary>Dynamic Host Configuration Protocol</primary>
	<see>DHCP</see>
      </indexterm>
      <indexterm>
	<primary>Internet Software Consortium (ISC)</primary>
      </indexterm>

      <para>DHCP, the Dynamic Host Configuration Protocol, describes
	the means by which a system can connect to a network and obtain the
	necessary information for communication upon that network.  FreeBSD
	uses the ISC (Internet Software Consortium) DHCP implementation, so
	all implementation-specific information here is for use with the ISC
	distribution.</para>
    </sect2>

    <sect2>
      <title>What This Section Covers</title>

      <para>This section describes both the client-side and server-side
	components of the ISC DHCP system.  The client-side program,
	<command>dhclient</command>, comes integrated within FreeBSD, and
	the server-side portion is available from the
	<filename role="package">net/isc-dhcp3</filename> port.  The
	&man.dhclient.8;, &man.dhcp-options.5;, and &man.dhclient.conf.5;
	manual pages, in addition to the references below, are useful
	resources.</para>
    </sect2>

    <sect2>
      <title>How It Works</title>
      <indexterm><primary>UDP</primary></indexterm>
      <para>When <command>dhclient</command>, the DHCP client, is
	executed on the client machine, it begins broadcasting
	requests for configuration information.  By default, these
	requests are on UDP port 68.  The server replies on UDP 67,
	giving the client an IP address and other relevant network
	information such as netmask, router, and DNS servers.  All of
	this information comes in the form of a DHCP
	<quote>lease</quote> and is only valid for a certain time
	(configured by the DHCP server maintainer).  In this manner,
	stale IP addresses for clients no longer connected to the
	network can be automatically reclaimed.</para>

      <para>DHCP clients can obtain a great deal of information from
	the server.  An exhaustive list may be found in
	&man.dhcp-options.5;.</para>
    </sect2>

    <sect2>
      <title>FreeBSD Integration</title>

      <para>FreeBSD fully integrates the ISC DHCP client,
	<command>dhclient</command>.  DHCP client support is provided
	within both the installer and the base system, obviating the need
	for detailed knowledge of network configurations on any network
	that runs a DHCP server.  <command>dhclient</command> has been
	included in all FreeBSD distributions since 3.2.</para>
	<indexterm>
	  <primary><application>sysinstall</application></primary>
	</indexterm>

	<para>DHCP is supported by
	  <application>sysinstall</application>.  When configuring a
	  network interface within sysinstall, the first question
	  asked is, <quote>Do you want to try DHCP configuration of
	  this interface?</quote> Answering affirmatively will execute
	  <command>dhclient</command>, and if successful, will fill in
	  the network configuration information automatically.</para>

	<para>There are two things you must do to have your system use
	  DHCP upon startup:</para>
	<indexterm>
	  <primary>DHCP</primary>
	  <secondary>requirements</secondary>
	</indexterm>
	<itemizedlist>
	  <listitem>
	    <para>Make sure that the <devicename>bpf</devicename>
	      device is compiled into your kernel.  To do this, add
	      <literal>pseudo-device bpf</literal> to your kernel
	      configuration file, and rebuild the kernel.  For more
	      information about building kernels, see <xref
	      linkend="kernelconfig">.</para>
	    <para>The <devicename>bpf</devicename> device is already
	      part of the <filename>GENERIC</filename> kernel that is
	      supplied with FreeBSD, so if you do not have a custom
	      kernel, you should not need to create one in order to get
	      DHCP working.</para>
	    <note>
	      <para>For those who are particularly security conscious,
		you should be warned that <devicename>bpf</devicename>
		is also the device that allows packet sniffers to work
		correctly (although they still have to be run as
		<username>root</username>).  <devicename>bpf</devicename>
		<emphasis>is</emphasis> required to use DHCP, but if
		you are very sensitive about security, you probably
		should not add <devicename>bpf</devicename> to your
		kernel in the expectation that at some point in the
		future you will be using DHCP.</para>
	    </note>
	  </listitem>
	  <listitem>
	    <para>Edit your <filename>/etc/rc.conf</filename> to
	      include the following:</para>

	    <programlisting>ifconfig_fxp0="DHCP"</programlisting>

	    <note>
	      <para>Be sure to replace <literal>fxp0</literal> with the
		designation for the interface that you wish to dynamically
		 configure, as described in
		 <xref linkend="config-network-setup">.</para>
	    </note>

	    <para>If you are using a different location for
	      <command>dhclient</command>, or if you wish to pass additional
	      flags to <command>dhclient</command>, also include the
	      following (editing as necessary):</para>

	    <programlisting>dhcp_program="/sbin/dhclient"
dhcp_flags=""</programlisting>
	  </listitem>
	</itemizedlist>

	<indexterm>
	  <primary>DHCP</primary>
	  <secondary>server</secondary>
	</indexterm>
	<para>The DHCP server, <command>dhcpd</command>, is included
	  as part of the <filename
	  role="package">net/isc-dhcp3</filename> port in the ports
	  collection.  This port contains the full ISC DHCP
	  distribution, consisting of client, server, relay agent and
	  documentation.
</para>
    </sect2>

    <sect2>
      <title>Files</title>
      <indexterm>
	<primary>DHCP</primary>
	<secondary>configuration files</secondary>
      </indexterm>
      <itemizedlist>
	<listitem><para><filename>/etc/dhclient.conf</filename></para>
	  <para><command>dhclient</command> requires a configuration file,
	    <filename>/etc/dhclient.conf</filename>.  Typically the file
	    contains only comments, the defaults being reasonably sane.  This
	    configuration file is described by the &man.dhclient.conf.5;
	    manual page.</para>
	</listitem>

	<listitem><para><filename>/sbin/dhclient</filename></para>
	  <para><command>dhclient</command> is statically linked and
	    resides in <filename>/sbin</filename>.  The &man.dhclient.8;
	    manual page gives more information about
	    <command>dhclient</command>.</para>
	</listitem>

	<listitem><para><filename>/sbin/dhclient-script</filename></para>
	  <para><command>dhclient-script</command> is the FreeBSD-specific
	    DHCP client configuration script.  It is described in
	    &man.dhclient-script.8;, but should not need any user
	    modification to function properly.</para>
	</listitem>

	<listitem><para><filename>/var/db/dhclient.leases</filename></para>
	  <para>The DHCP client keeps a database of valid leases in this
	    file, which is written as a log.  &man.dhclient.leases.5;
	    gives a slightly longer description.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Further Reading</title>

      <para>The DHCP protocol is fully described in
	<ulink url="http://www.freesoft.org/CIE/RFC/2131/">RFC 2131</ulink>.
	An informational resource has also been set up at
	<ulink url="http://www.dhcp.org/">dhcp.org</ulink>.</para>
    </sect2>

    <sect2 id="network-dhcp-server">
	<title>Installing and Configuring a DHCP Server</title>

	<sect3>
	  <title>What This Section Covers</title>

	  <para>This section provides information on how to configure
	    a FreeBSD system to act as a DHCP server using the ISC
	    (Internet Software Consortium) implementation of the DHCP
	    suite.</para>

	  <para>The server portion of the suite is not provided as part of
	    FreeBSD, and so you will need to install the
	    <filename role="package">net/isc-dhcp3</filename>
	    port to provide this service.  See <xref linkend="ports"> for
	    more information on using the ports collection.</para>
	</sect3>

	<sect3>
	  <title>DHCP Server Installation</title>
	  <indexterm>
	    <primary>DHCP</primary>
	    <secondary>installation</secondary>
	  </indexterm>
	  <para>In order to configure your FreeBSD system as a DHCP server,
	    you will need to ensure that the &man.bpf.4;
	    device is compiled into your kernel.  To do this, add
	    <literal>pseudo-device bpf</literal> to your kernel
	    configuration file, and rebuild the kernel.  For more
	    information about building kernels, see <xref
	    linkend="kernelconfig">.</para>

	  <para>The <devicename>bpf</devicename> device is already
	    part of the <filename>GENERIC</filename> kernel that is
	    supplied with FreeBSD, so you do not need to create a custom
	    kernel in order to get DHCP working.</para>

	    <note>
	      <para>Those who are particularly security conscious
		should note that <devicename>bpf</devicename>
		is also the device that allows packet sniffers to work
		correctly (although such programs still need privileged
		access).  <devicename>bpf</devicename>
		<emphasis>is</emphasis> required to use DHCP, but if
		you are very sensitive about security, you probably
		should not include <devicename>bpf</devicename> in your
		kernel purely because you expect to use DHCP at some
		point in the future.</para>
	    </note>

	  <para>The next thing that you will need to do is edit the sample
	    <filename>dhcpd.conf</filename> which was installed by the
	    <filename role="package">net/isc-dhcp3</filename> port.
	    By default, this will be
	    <filename>/usr/local/etc/dhcpd.conf.sample</filename>, and you
	    should copy this to
	    <filename>/usr/local/etc/dhcpd.conf</filename> before proceeding
	    to make changes.</para>
	</sect3>

	<sect3>
	  <title>Configuring the DHCP Server</title>
	  <indexterm>
	    <primary>DHCP</primary>
	    <secondary>dhcpd.conf</secondary>
	  </indexterm>
	  <para><filename>dhcpd.conf</filename> is
	    comprised of declarations regarding subnets and hosts, and is
	    perhaps most easily explained using an example :</para>

	  <programlisting>option domain-name "example.com";<co id="domain-name">
option domain-name-servers 192.168.4.100;<co id="domain-name-servers">
option subnet-mask 255.255.255.0;<co id="subnet-mask">

default-lease-time 3600;<co id="default-lease-time">
max-lease-time 86400;<co id="max-lease-time">
ddns-update-style none;<co id="ddns-update-style">

subnet 192.168.4.0 netmask 255.255.255.0 {
  range 192.168.4.129 192.168.4.254;<co id="range">
  option routers 192.168.4.1;<co id="routers">
}

host mailhost {
  hardware ethernet 02:03:04:05:06:07;<co id="hardware">
  fixed-address mailhost.example.com;<co id="fixed-address">
}</programlisting>

	  <calloutlist>
	    <callout arearefs="domain-name">
	      <para>This option specifies the domain that will be provided
		to clients as the default search domain.  See
		&man.resolv.conf.5; for more information on what this
		means.</para>
	    </callout>

	    <callout arearefs="domain-name-servers">
	      <para>This option specifies a comma separated list of DNS
		servers that the client should use.</para>
	    </callout>

	    <callout arearefs="subnet-mask">
	      <para>The netmask that will be provided to clients.</para>
	    </callout>

	    <callout arearefs="default-lease-time">
	      <para>A client may request a specific length of time that a
		lease will be valid.  Otherwise the server will assign
		a lease with this expiry value (in seconds).</para>
	    </callout>

	    <callout arearefs="max-lease-time">
	      <para>This is the maximum length of time that the server will
		lease for.  Should a client request a longer lease, a lease
		will be issued, although it will only be valid for
		<literal>max-lease-time</literal> seconds.</para>
	    </callout>

	    <callout arearefs="ddns-update-style">
	      <para>This option specifies whether the DHCP server should
		attempt to update DNS when a lease is accepted or released.
		In the ISC implementation, this option is
		<emphasis>required</emphasis>.</para>
	    </callout>

	    <callout arearefs="range">
	      <para>This denotes which IP addresses should be used in
		the pool reserved for allocating to clients.  IP
		addresses between, and including, the ones stated are
		handed out to clients.</para>
	    </callout>

	    <callout arearefs="routers">
	      <para>Declares the default gateway that will be provided to
		clients.</para>
	    </callout>

	    <callout arearefs="hardware">
	      <para>The hardware MAC address of a host (so that the DHCP server
		can recognize a host when it makes a request).</para>
	    </callout>

	    <callout arearefs="fixed-address">
	      <para>Specifies that the host should always be given the same
		IP address.  Note that a hostname is OK here, since the DHCP
		server will resolve the hostname itself before returning the
		lease information.</para>
	    </callout>
	  </calloutlist>

	  <para>Once you have finished writing your
	    <filename>dhcpd.conf</filename>, you can proceed to start the
	    server by issuing the following command:</para>

	  <screen>&prompt.root; <userinput>/usr/local/etc/rc.d/isc-dhcpd.sh start</userinput></screen>

	  <para>Should you need to make changes to the configuration of your
	    server in the future, it is important to note that sending a
	    <literal>SIGHUP</literal> signal to
	    <application>dhcpd</application> does <emphasis>not</emphasis>
	    result in the configuration being reloaded, as it does with most
	    daemons.  You will need to send a <literal>SIGTERM</literal>
	    signal to stop the process, and then restart it using the command
	    above.</para>
	</sect3>

	<sect3>
	  <title>Files</title>
	  <indexterm>
	    <primary>DHCP</primary>
	    <secondary>configuration files</secondary>
	  </indexterm>
	  <itemizedlist>
	    <listitem><para><filename>/usr/local/sbin/dhcpd</filename></para>
	      <para><application>dhcpd</application> is statically linked and
		resides in <filename>/usr/local/sbin</filename>.  The
		&man.dhcpd.8; manual page installed with the
		port gives more information about
		<application>dhcpd</application>.</para>
	    </listitem>

	    <listitem><para><filename>/usr/local/etc/dhcpd.conf</filename></para>
	      <para><application>dhcpd</application> requires a configuration
		file, <filename>/usr/local/etc/dhcpd.conf</filename> before it
		will start providing service to clients.  This file needs to
		contain all the information that should be provided to clients
		that are being serviced, along with information regarding the
		operation of the server.  This configuration file is described
		by the &man.dhcpd.conf.5; manual page installed
		by the port.</para>
	    </listitem>

	    <listitem><para><filename>/var/db/dhcpd.leases</filename></para>
	      <para>The DHCP server keeps a database of leases it has issued
		in this file, which is written as a log.  The manual page
		&man.dhcpd.leases.5;, installed by the port
		gives a slightly longer description.</para>
	    </listitem>

	    <listitem><para><filename>/usr/local/sbin/dhcrelay</filename></para>
	      <para><application>dhcrelay</application> is used in advanced
		environments where one DHCP server forwards a request from a
		client to another DHCP server on a separate network.  The
		&man.dhcrelay.8; manual page provided with the
		port contains more detail.</para>
	    </listitem>
	  </itemizedlist>
	</sect3>

      </sect2>

  </sect1>

  <sect1 id="network-dns">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Chern</firstname>
	  <surname>Lee</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>DNS</title>

    <sect2>
      <title>Overview</title>
      <indexterm><primary>BIND</primary></indexterm>

      <para>FreeBSD utilizes, by default, a version of BIND (Berkeley
	Internet Name Domain), which is the most common implementation of the
	DNS protocol.  DNS is the protocol through which names are mapped to
	IP addresses, and vice versa.  For example, a query for
	<hostid>www.FreeBSD.org</hostid>
	will receive a reply with the IP address of The FreeBSD Project's
	web server, whereas, a query for <hostid>ftp.FreeBSD.org</hostid>
	will return the IP
	address of the corresponding FTP machine.  Likewise, the opposite can
	happen.  A query for an IP address can resolve its hostname.  It is
	not necessary to run a name server to perform DNS lookups on a system.
</para>

      <indexterm><primary>DNS</primary></indexterm>
      <para>DNS is coordinated across the Internet through a somewhat
	complex system of authoritative root name servers, and other
	smaller-scale name servers who host and cache individual domain
	information.
</para>

      <para>
	This document refers to BIND 8.x, as it is the stable version
	used in FreeBSD.  BIND 9.x in FreeBSD can be installed through
	the <filename role="package">net/bind9</filename> port.
</para>

      <para>
	RFC1034 and RFC1035 dictate the DNS protocol.
</para>

      <para>
	Currently, BIND is maintained by the <ulink
	url="http://www.isc.org/">
	Internet Software Consortium (www.isc.org)</ulink>.
</para>
    </sect2>

    <sect2>
      <title>Terminology</title>

      <para>To understand this document, some terms related to DNS must be
	understood.</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Term</entry>
	      <entry>Definition</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>Forward DNS</entry>
	      <entry>Mapping of hostnames to IP addresses</entry>
	    </row>

	    <row>
	      <entry>Origin</entry>
	      <entry>Refers to the domain covered in a particular zone
		file</entry>
	    </row>

	    <row>
	      <entry><application>named</application>, BIND, name server</entry>
	      <entry>Common names for the BIND name server package within
		FreeBSD</entry>
	    </row>

	    <indexterm><primary>resolver</primary></indexterm>
	    <row>
	      <entry>Resolver</entry>
	      <entry>A system process through which a
		machine queries a name server for zone information</entry>
	    </row>

	    <indexterm><primary>reverse DNS</primary></indexterm>
	    <row>
	      <entry>Reverse DNS</entry>
	      <entry>The opposite of forward DNS; mapping of IP addresses to
		hostnames</entry>
	    </row>

	    <indexterm><primary>root zone</primary></indexterm>
	    <row>
	      <entry>Root zone</entry>

	      <entry>The beginning of the Internet zone hierarchy.
		All zones fall under the root zone, similar to how
		all files in a file system fall under the root directory.</entry>
	    </row>

	    <row>
	      <entry>Zone</entry>
	      <entry>An individual domain, subdomain, or portion of the DNS administered by
		the same authority</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <indexterm>
	<primary>zones</primary>
	<secondary>examples</secondary>
      </indexterm>

      <para>Examples of zones:
</para>
      <itemizedlist>
	<listitem>
	  <para><hostid>.</hostid> is the root zone</para>
	</listitem>
	<listitem>
	  <para><hostid>org.</hostid> is a zone under the root zone</para>
	</listitem>
	<listitem>
	  <para><hostid>example.org</hostid> is a zone under the
	  <hostid>org.</hostid> zone</para>
	</listitem>
	<listitem>
	  <para><hostid>foo.example.org.</hostid> is a subdomain, a
	    zone under the <hostid>example.org.</hostid> zone</para>
	</listitem>
	<listitem>
	  <para>
	    <hostid>1.2.3.in-addr.arpa</hostid> is a zone referencing
	    all IP addresses which fall under the 3.2.1.* IP space.
</para>
	</listitem>
      </itemizedlist>

      <para>As one can see, the more specific part of a hostname appears to
	its left.  For example, <hostid>example.org.</hostid> is more
	specific than <hostid>org.</hostid>, as <hostid>org.</hostid> is
	more specific than the root zone.  The layout of each part of
	a hostname is much like a filesystem: the <filename>/dev</filename>
	directory falls within the root, and so on.</para>


    </sect2>

    <sect2>
      <title>Reasons to Run a Name Server</title>

      <para>Name servers usually come in two forms: an authoritative
	name server, and a caching name server.</para>

      <para>An authoritative name server is needed when:</para>

      <itemizedlist>
	<listitem>
	  <para>one wants to serve DNS information to the
	    world, replying authoritatively to queries.</para>
	</listitem>
	<listitem>
	  <para>a domain, such as <hostid>example.org</hostid>, is
	    registered and IP addresses need to be assigned to hostnames
	    under it.</para>
	</listitem>
	<listitem>
	  <para>an IP address block requires reverse DNS entries (IP to
	    hostname).</para>
	</listitem>
	<listitem>
	  <para>a backup name server, called a slave, must reply to queries
	    when the primary is down or inaccessible.</para>
	  </listitem>
      </itemizedlist>

      <para>A caching name server is needed when:</para>

      <itemizedlist>
	<listitem>
	  <para>a local DNS server may cache and respond more quickly
	    than querying an outside name server.</para>
	</listitem>
	<listitem>
	  <para>a reduction in overall network traffic is desired (DNS
	    traffic has been measured to account for 5% or more of total
	    Internet traffic).</para>
	</listitem>
      </itemizedlist>

      <para>When one queries for <hostid>www.FreeBSD.org</hostid>, the
	resolver usually queries the uplink ISP's name server, and retrieves
	the reply.  With a local, caching DNS server, the query only has to
	be made once to the outside world by the caching DNS server.  Every
	additional query will not have to look to the outside of the local
	network, since the information is cached locally.</para>

    </sect2>

    <sect2>
      <title>How It Works</title>
      <para>In FreeBSD, the BIND daemon is called
	<application>named</application> for obvious reasons.</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>File</entry>
	      <entry>Description</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><application>named</application></entry>
	      <entry>the BIND daemon</entry>
	    </row>

	    <row>
	      <entry><command>ndc</command></entry>
	      <entry>name daemon control program</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/namedb</filename></entry>
	      <entry>directory where BIND zone information resides</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/namedb/named.conf</filename></entry>
	      <entry>daemon configuration file</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>
	Zone files are usually contained within the
	<filename>/etc/namedb</filename>
	directory, and contain the DNS zone information
	served by the name server.
</para>
    </sect2>

    <sect2>
      <title>Starting BIND</title>
      <indexterm>
	<primary>BIND</primary>
	<secondary>starting</secondary>
      </indexterm>
      <para>
	Since BIND is installed by default, configuring it all is
	relatively simple.
</para>
      <para>
	To ensure the named daemon is started at boot, put the following
	 modifications in <filename>/etc/rc.conf</filename>:
</para>
      <programlisting>named_enable="YES"</programlisting>
      <para>To start the daemon manually (after configuring it)</para>
      <screen>&prompt.root; <userinput>ndc start</userinput></screen>
    </sect2>

    <sect2>
      <title>Configuration Files</title>
      <indexterm>
	<primary>BIND</primary>
	<secondary>configuration files</secondary>
      </indexterm>
      <sect3>
	<title>Using <command>make-localhost</command></title>
	<para>Be sure to:
</para>
	<screen>&prompt.root; <userinput>cd /etc/namedb</userinput>
&prompt.root; <userinput>sh make-localhost</userinput></screen>
	<para>to properly create the local reverse DNS zone file in
	  <filename>/etc/namedb/localhost.rev</filename>.
</para>
      </sect3>

      <sect3>
	<title><filename>/etc/namedb/named.conf</filename></title>

	<programlisting>// &dollar;FreeBSD$
//
// Refer to the named(8) manual page for details.  If you are ever going
// to setup a primary server, make sure you've understood the hairy
// details of how DNS is working.  Even with simple mistakes, you can
// break connectivity for affected parties, or cause huge amount of
// useless Internet traffic.

options {
	directory "/etc/namedb";

// In addition to the "forwarders" clause, you can force your name
// server to never initiate queries of its own, but always ask its
// forwarders only, by enabling the following line:
//
//      forward only;

// If you've got a DNS server around at your upstream provider, enter
// its IP address here, and enable the line below.  This will make you
// benefit from its cache, thus reduce overall DNS traffic in the
Internet.
/*
	forwarders {
		127.0.0.1;
	};
*/</programlisting>

	<para>
	  Just as the comment says, to benefit from an uplink's cache,
	  <literal>forwarders</literal> can be enabled here.  Under normal
	  circumstances, a name server will recursively query the Internet
	  looking at certain name servers until it finds the answer it is
	  looking for.  Having this enabled will have it query the uplink's
	  name server (or name server provided) first, taking advantage of
	  its cache.  If the uplink name server in question is a heavily
	  trafficked, fast name server, enabling this may be worthwhile.
</para>

	<warning><para><hostid role="ipaddr">127.0.0.1</hostid>
	    will <emphasis>not</emphasis> work here.
	    Change this IP address to a name server at your uplink.</para>
	</warning>

	<programlisting>	/*
	 * If there is a firewall between you and name servers you want
	 * to talk to, you might need to uncomment the query-source
	 * directive below.  Previous versions of BIND always asked
	 * questions using port 53, but BIND 8.1 uses an unprivileged
	 * port by default.
	 */
	// query-source address * port 53;

	/*
	 * If running in a sandbox, you may have to specify a different
	 * location for the dumpfile.
	 */
	// dump-file "s/named_dump.db";
};

// Note: the following will be supported in a future release.
/*
host { any; } {
	topology {
		127.0.0.0/8;
	};
};
*/

// Setting up secondaries is way easier and the rough picture for this
// is explained below.
//
// If you enable a local name server, don't forget to enter 127.0.0.1
// into your /etc/resolv.conf so this server will be queried first.
// Also, make sure to enable it in /etc/rc.conf.

zone "." {
	type hint;
	file "named.root";
};

zone "0.0.127.IN-ADDR.ARPA" {
	type master;
	file "localhost.rev";
};

zone
"0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.IP6.INT" {
	type master;
	file "localhost.rev";
};

// NB: Do not use the IP addresses below, they are faked, and only
// serve demonstration/documentation purposes!
//
// Example secondary config entries.  It can be convenient to become
// a secondary at least for the zone where your own domain is in.  Ask
// your network administrator for the IP address of the responsible
// primary.
//
// Never forget to include the reverse lookup (IN-ADDR.ARPA) zone!
// (This is the first bytes of the respective IP address, in reverse
// order, with ".IN-ADDR.ARPA" appended.)
//
// Before starting to setup a primary zone, better make sure you fully
// understand how DNS and BIND works, however.  There are sometimes
// unobvious pitfalls.  Setting up a secondary is comparably simpler.
//
// NB: Don't blindly enable the examples below. :-)  Use actual names
// and addresses instead.
//
// NOTE!!!  FreeBSD runs bind in a sandbox (see named_flags in rc.conf).
// The directory containing the secondary zones must be write accessible
// to bind.  The following sequence is suggested:
//
//      mkdir /etc/namedb/s
//      chown bind:bind /etc/namedb/s
//      chmod 750 /etc/namedb/s</programlisting>

	<para>For more information on running BIND in a sandbox, see
	  <link linkend="network-named-sandbox">Running named in a sandbox</link>.
	</para>

	<programlisting>/*
zone "example.com" {
	type slave;
	file "s/example.com.bak";
	masters {
		192.168.1.1;
	};
};

zone "0.168.192.in-addr.arpa" {
	type slave;
	file "s/0.168.192.in-addr.arpa.bak";
	masters {
		192.168.1.1;
	};
};
*/</programlisting>
	<para>In <filename>named.conf</filename>, these are examples of slave
	  entries for a forward and reverse zone.</para>

	<para>For each new zone served, a new zone entry must be added to
	  <filename>named.conf</filename></para>

	<para>For example, the simplest zone entry for
	  <hostid role="domainname">example.org</hostid> can look like:</para>

	<programlisting>zone "example.org" {
	type master;
	file "example.org";
};</programlisting>

	<para>The zone is a master, as indicated by the <option>type</option>
	  statement, holding its zone information in
	  <filename>/etc/namedb/example.org</filename> indicated by
	  the <option>file</option> statement.</para>

	<programlisting>zone "example.org" {
	type slave;
	file "example.org";
};</programlisting>

	<para>In the slave case, the zone information is transferred from
	  the master name server for the particular zone, and saved in the
	  file specified.  If and when the master server dies or is
	  unreachable, the slave name server will have the transferred
	  zone information and will be able to serve it.</para>
      </sect3>

      <sect3>
	<title>Zone Files</title>
	<para>
	  An example master zone file for <hostid>example.org</hostid>
	  (existing within <filename>/etc/namedb/example.org</filename>)
	  is as follows:
</para>

	<programlisting>$TTL 3600

example.org.  IN SOA ns1.example.org.  admin.example.org. (
			5	       ; Serial
			10800	   ; Refresh
			3600	    ; Retry
			604800	  ; Expire
			86400 )	 ; Minimum TTL

; DNS Servers
@       IN NS	   ns1.example.org.
@       IN NS	   ns2.example.org.

; Machine Names
localhost       IN A    127.0.0.1
ns1	     IN A    3.2.1.2
ns2	     IN A    3.2.1.3
mail	    IN A    3.2.1.10
@	       IN A    3.2.1.30

; Aliases
www	     IN CNAME	@

; MX Record
@	       IN MX   10      mail.example.org.</programlisting>

	<para>
	  Note that every hostname ending in a <quote>.</quote> is an
	  exact hostname, whereas everything without a trailing
	  <quote>.</quote> is referenced to the origin.  For example,
	  <literal>www</literal> is translated into <literal>www +
	    origin</literal>.  In our fictitious zone file, our origin
	  is <hostid>example.org.</hostid>, so
	  <literal>www</literal> would translate to
	  <hostid>www.example.org.</hostid>
</para>

	<para>
	  The format of a zone file follows:
</para>
	<programlisting>recordname      IN recordtype   value</programlisting>

	<indexterm>
	  <primary>DNS</primary>
	  <secondary>records</secondary>
	</indexterm>
	<para>
	  The most commonly used DNS records:
</para>

	<variablelist>
	  <varlistentry>
	    <term>SOA</term>

	    <listitem><para>start of zone authority</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>NS</term>

	    <listitem><para>an authoritative name server</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>A</term>

	    <listitem><para>A host address</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>CNAME</term>

	    <listitem><para>the canonical name for an alias</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>MX</term>

	    <listitem><para>mail exchanger</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>PTR</term>

	    <listitem><para>a domain name pointer (used in reverse DNS)
	</para></listitem>
	  </varlistentry>
	</variablelist>

	<programlisting>
example.org.  IN SOA ns1.example.org.  admin.example.org. (
			5	       ; Serial
			10800	   ; Refresh after 3 hours
			3600	    ; Retry after 1 hour
			604800	  ; Expire after 1 week
			86400 )	 ; Minimum TTL of 1 day</programlisting>



	<variablelist>
	  <varlistentry>
	    <term><hostid>example.org.</hostid></term>

	    <listitem><para>the domain name, also the origin for this
		zone file.</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><hostid>ns1.example.org.</hostid></term>

	    <listitem><para>the primary/authoritative name server for this
		zone</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><literal>admin.example.org.</literal></term>

	    <listitem><para>the responsible person for this zone,
		email address with @
	  replaced.  (<email>admin@example.org</email> becomes
		<literal>admin.example.org</literal>)</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><literal>5</literal></term>

	      <listitem><para>the serial number of the file.  this
		  must be incremented each time the zone file is modified.
		  Nowadays, many admins prefer a
		  <literal>yyyymmddrr</literal> format for the serial
		  number.  2001041002 would mean last modified 04/10/2001,
		  the latter 02 being the second time the zone file has
		  been modified this day.  The serial number is important
		  as it alerts slave name servers for a zone when it is
		  updated.</para>
	      </listitem>
	  </varlistentry>
	</variablelist>

	<programlisting>
@       IN NS	   ns1.example.org.</programlisting>

	<para>
	  This is an <varname>NS</varname> entry.  Every name server that is going to reply
	  authoritatively for the zone must have one of these entries.
	  The <literal>@</literal> as seen here could have been
	  <hostid role="domainname">example.org.</hostid>
	  The <literal>@</literal> translates to the origin.
</para>

	<programlisting>
localhost       IN A    127.0.0.1
ns1	     IN A    3.2.1.2
ns2	     IN A    3.2.1.3
mail	    IN A    3.2.1.10
@	       IN A    3.2.1.30</programlisting>

	<para>
	  The A record indicates machine names.  As seen above,
	  <hostid>ns1.example.org</hostid> would resolve to
	  <hostid role="ipaddr">3.2.1.2</hostid>.  Again,
	  the origin symbol, <literal>@</literal>, is
	  used here, thus meaning <hostid>example.org</hostid>
	  would resolve to <hostid role="ipaddr">3.2.1.30</hostid>.
</para>

	<programlisting>
www	     IN CNAME	@</programlisting>

	<para>
	  The canonical name record is usually used for giving aliases
	  to a machine.  In the example, <hostid>www</hostid> is
	  aliased to the machine addressed to the origin, or
	  <hostid>example.org</hostid>
	  (<hostid role="ipaddr">3.2.1.30</hostid>).
	  <varname>CNAME</varname>s can be used to provide alias
	  hostnames, or round robin one hostname among multiple
	  machines.
</para>

	<programlisting>
@	       IN MX   10      mail.example.org.</programlisting>

	<para>
	  The <varname>MX</varname> record indicates which mail
	  servers are responsible for handling incoming mail for the
	  zone.  <hostid role="fqdn">mail.example.org</hostid> is the
	  hostname of the mail server, and 10 being the priority of
	  that mail server.
</para>

	<para>
	  One can have several mail servers, with priorities of 3, 2,
	  1.  A mail server attempting to deliver to <hostid
	  role="domainname">example.org</hostid> would first try the
	  highest priority MX, then the second highest, etc, until the
	  mail can be properly delivered.
</para>

	<para>
	  For in-addr.arpa zone files (reverse DNS), the same format is
	  used, except with <varname>PTR</varname> entries instead of
	  <varname>A</varname> or <varname>CNAME</varname>.
</para>

	<programlisting>$TTL 3600

1.2.3.in-addr.arpa.  IN SOA ns1.example.org.  admin.example.org. (
			5	       ; Serial
			10800	   ; Refresh
			3600	    ; Retry
			604800	  ; Expire
			3600 )	  ; Minimum

@       IN NS   ns1.example.org.
@       IN NS   ns2.example.org.

2       IN PTR ns1.example.org.
3       IN PTR ns2.example.org.
10      IN PTR mail.example.org.
30      IN PTR example.org.</programlisting>
	<para>
	 This file gives the proper IP address to hostname mappings of our above
	 fictitious domain.
</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Caching Name Server</title>
      <indexterm>
	<primary>BIND</primary>
	<secondary>caching name server</secondary>
      </indexterm>
      <para>
	A caching name server is a name server that is not
	authoritative for any zones.  It simply asks queries of its own,
	and remembers them for later use.  To set one up, just configure
	the name server as usual, omitting any inclusions of zones.
</para>
    </sect2>

    <sect2 id="network-named-sandbox">
      <title>Running <application>named</application> in a Sandbox</title>
      <indexterm>
	<primary>BIND</primary>
	<secondary>running in a sandbox</secondary>
      </indexterm>

      <indexterm>
	<primary><command>chroot</command></primary>
      </indexterm>
      <para>For added security you may want to run &man.named.8; as an
	unprivileged user, and configure it to &man.chroot.8; into a
	sandbox directory.  This makes everything outside of the sandbox
	inaccessible to the <application>named</application> daemon.  Should
	<application>named</application> be compromised, this will help to
	reduce the damage that can be caused.  By default, FreeBSD has a user
	and a group called <groupname>bind</groupname>, intended for this
	use.</para>

      <note><para>Various people would recommend that instead of configuring
	<application>named</application> to <command>chroot</command>, you
	should run <application>named</application> inside a &man.jail.8;.
	This section does not attempt to cover this situation.</para>
      </note>

      <para>Since <application>named</application> will not be able to
	access anything outside of the sandbox (such as shared
	libraries, log sockets, and so on), there are a number of steps
	that need to be followed in order to allow
	<application>named</application> to function correctly.  In the
	following checklist, it is assumed that the path to the sandbox
	is <filename>/etc/namedb</filename> and that you have made no
	prior modifications to the contents of this directory.  Perform
	the following steps as <username>root</username>.</para>

      <itemizedlist>
	<listitem>
	  <para>Create all directories that <application>named</application>
	    expects to see:</para>

	  <screen>&prompt.root; <userinput>cd /etc/namedb</userinput>
&prompt.root; <userinput>mkdir -p bin dev etc var/tmp var/run master slave</userinput>
&prompt.root; <userinput>chown bind:bind slave var/*</userinput><co id="chown-slave"></screen>



	  <calloutlist>
	    <callout arearefs="chown-slave">
	      <para><application>named</application> only needs write access to
		these directories, so that is all we give it.</para>
	    </callout>
	  </calloutlist>
	</listitem>

	<listitem>
	  <para>Rearrange and create basic zone and configuration files:</para>
	  <screen>&prompt.root; <userinput>cp /etc/localtime etc</userinput><co id="localtime">
&prompt.root; <userinput>mv named.conf etc && ln -sf etc/named.conf</userinput>
&prompt.root; <userinput>mv named.root master</userinput>
<!-- I don't like this next bit -->
&prompt.root; <userinput>sh make-localhost && mv localhost.rev localhost-v6.rev master</userinput>
&prompt.root; <userinput>cat > master/named.localhost
$ORIGIN localhost.
$TTL 6h
@	IN	SOA	localhost.  postmaster.localhost. (
			1	; serial
			3600	; refresh
			1800	; retry
			604800	; expiration
			3600 )	; minimum
	IN	NS	localhost.
	IN	A		127.0.0.1
^D</userinput></screen>

	  <calloutlist>
	    <callout arearefs="localtime">
	      <para>This allows <application>named</application> to log the
		correct time to &man.syslogd.8;</para>
	    </callout>
	  </calloutlist>
	</listitem>

	<listitem>
	  <para>If you are running a version of &os; prior to 4.9-RELEASE, build a statically linked copy of
	    <application>named-xfer</application>, and copy it into the sandbox:</para>

	      <screen>&prompt.root; <userinput>cd /usr/src/lib/libisc</userinput>
&prompt.root; <userinput>make cleandir && make cleandir && make depend && make all</userinput>
&prompt.root; <userinput>cd /usr/src/lib/libbind</userinput>
&prompt.root; <userinput>make cleandir && make cleandir && make depend && make all</userinput>
&prompt.root; <userinput>cd /usr/src/libexec/named-xfer</userinput>
&prompt.root; <userinput>make cleandir && make cleandir && make depend && make NOSHARED=yes all</userinput>
&prompt.root; <userinput>cp named-xfer /etc/namedb/bin && chmod 555 /etc/namedb/bin/named-xfer</userinput><co id="clean-cruft"></screen>

	  <para>After your statically linked
	    <command>named-xfer</command> is installed some cleaning up
	    is required, to avoid leaving stale copies of libraries or
	    programs in your source tree:</para>

	  <screen>&prompt.root; <userinput>cd /usr/src/lib/libisc</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>cd /usr/src/lib/libbind</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>cd /usr/src/libexec/named-xfer</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

	  <calloutlist>
	    <callout arearefs="clean-cruft">
	      <para>This step has been reported to fail occasionally.  If this
		happens to you, then issue the command:</para>

	      <screen>&prompt.root; <userinput>cd /usr/src && make cleandir && make cleandir</userinput></screen>

	      <para>and delete your <filename>/usr/obj</filename> tree:</para>

	      <screen>&prompt.root; <userinput>rm -fr /usr/obj && mkdir /usr/obj</userinput></screen>

		<para>This will clean out any <quote>cruft</quote> from your
		  source tree, and retrying the steps above should then work.</para>
	    </callout>
	  </calloutlist>

	  <para>If you are running &os; version 4.9-RELEASE or later, then
	    the copy of <command>named-xfer</command> in
	    <filename>/usr/libexec</filename> is statically linked by default,
	    and you can simply use &man.cp.1; to copy it into your sandbox.</para>
	</listitem>

	<listitem>
	  <para>Make a <devicename>dev/null</devicename> that
	    <application>named</application> can see and write to:</para>

	  <screen>&prompt.root; <userinput>cd /etc/namedb/dev && mknod null c 2 2</userinput>
&prompt.root; <userinput>chmod 666 null</userinput></screen>
	</listitem>

	<listitem>
	  <para>Symlink <filename> /var/run/ndc</filename> to
	    <filename>/etc/namedb/var/run/ndc</filename>:</para>

	  <screen>&prompt.root; <userinput>ln -sf /etc/namedb/var/run/ndc /var/run/ndc</userinput></screen>

	  <note>
	    <para>This simply avoids having to specify the
	      <option>-c</option> option to &man.ndc.8; every time you
	      run it.  Since the contents of /var/run are deleted on boot,
	      if this is something that you find useful you
	      may wish to add this command to root's crontab, making use
	      of the <option>@reboot</option> option.  See
	      &man.crontab.5; for more information regarding
	      this.</para>
	  </note>

	</listitem>

	<listitem>
	  <para>Configure &man.syslogd.8; to create an extra
	    <devicename>log</devicename> socket that
	    <application>named</application> can write to.  To do this,
	    add <literal>-l /etc/namedb/dev/log</literal> to the
	    <varname>syslogd_flags</varname> variable in
	    <filename>/etc/rc.conf</filename>.</para>
	</listitem>

	<listitem>
	  <para>Arrange to have <application>named</application> start
	    and <command>chroot</command> itself to the sandbox by
	    adding the following to
	    <filename>/etc/rc.conf</filename>:</para>

	  <programlisting>named_enable="YES"
named_flags="-u bind -g bind -t /etc/namedb /etc/named.conf"</programlisting>

	  <note>
	    <para>Note that the configuration file
	    <replaceable>/etc/named.conf</replaceable> is denoted by a full
	    pathname <emphasis>relative to the sandbox</emphasis>, i.e.  in
	    the line above, the file referred to is actually
	    <filename>/etc/namedb/etc/named.conf</filename>.</para>
	  </note>
	</listitem>
      </itemizedlist>

      <para>The next step is to edit
	<filename>/etc/namedb/etc/named.conf</filename> so that
	<application>named</application> knows which zones to load and
	where to find them on the disk.  There follows a commented
	example (anything not specifically commented here is no
	different from the setup for a DNS server not running in a
	sandbox):</para>

	<programlisting>options {
	directory "/";<co id="directory">
	named-xfer "/bin/named-xfer";<co id="named-xfer">
	version "";		// Don't reveal BIND version
	query-source address * port 53;
};
// ndc control socket
controls {
	unix "/var/run/ndc" perm 0600 owner 0 group 0;
};
// Zones follow:
zone "localhost" IN {
	type master;
	file "master/named.localhost";<co id="master">
	allow-transfer { localhost; };
	notify no;
};
zone "0.0.127.in-addr.arpa" IN {
	type master;
	file "master/localhost.rev";
	allow-transfer { localhost; };
	notify no;
};
zone "0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.int" {
	type master;
	file "master/localhost-v6.rev";
	allow-transfer { localhost; };
	notify no;
};
zone "." IN {
	type hint;
	file "master/named.root";
};
zone "private.example.net" in {
	type master;
	file "master/private.example.net.db";
	allow-transfer { 192.168.10.0/24; };
};
zone "10.168.192.in-addr.arpa" in {
	type slave;
	masters { 192.168.10.2; };
	file "slave/192.168.10.db";<co id="slave">
};</programlisting>

      <calloutlist>
	<callout arearefs="directory">
	  <para>The
	    <literal>directory</literal> statement is specified as
	    <filename>/</filename>, since all files that
	    <application>named</application> needs are within this
	    directory (recall that this is equivalent to a
	    <quote>normal</quote> user's
	    <filename>/etc/namedb</filename>.</para>
	</callout>

	<callout arearefs="named-xfer">
	  <para>Specifies the full path
	    to the <command>named-xfer</command> binary (from
	    <application>named</application>'s frame of reference).  This
	    is necessary since <application>named</application> is
	    compiled to look for <command>named-xfer</command> in
	    <filename>/usr/libexec</filename> by default.</para>
	</callout>
	<callout arearefs="master"><para>Specifies the filename (relative
	  to the <literal>directory</literal> statement above) where
	  <application>named</application> can find the zonefile for this
	  zone.</para>
	</callout>
	<callout arearefs="slave"><para>Specifies the filename
	    (relative to the <literal>directory</literal> statement above)
	    where <application>named</application> should write a copy of
	    the zonefile for this zone after successfully transferring it
	    from the master server.  This is why we needed to change the
	    ownership of the directory <filename>slave</filename> to
	    <groupname>bind</groupname> in the setup stages above.</para>
	</callout>
      </calloutlist>

      <para>After completing the steps above, either reboot your
	server or restart &man.syslogd.8; and start &man.named.8;, making
	sure to use the new options specified in
	<varname>syslogd_flags</varname> and
	<varname>named_flags</varname>.  You should now be running a
	sandboxed copy of <application>named</application>!</para>

    </sect2>

    <sect2>
      <title>Security</title>

      <para>Although BIND is the most common implementation of DNS,
	there is always the issue of security.  Possible and
	exploitable security holes are sometimes found.
</para>

      <para>
	It is a good idea to subscribe to <ulink
	url="http://www.cert.org/">CERT</ulink> and
	<ulink url="../handbook/eresources.html#ERESOURCES-MAIL">freebsd-security-notifications</ulink>
	to stay up to date with the current Internet and FreeBSD security
	issues.
</para>

      <tip><para>If a problem arises, keeping sources up to date and having a
	fresh build of named would not hurt.</para></tip>
    </sect2>

    <sect2>
      <title>Further Reading</title>
      <para>
	BIND/named manual pages: &man.ndc.8; &man.named.8; &man.named.conf.5;
</para>

      <itemizedlist>
	<listitem>
	  <para><ulink
	      url="http://www.isc.org/products/BIND/">Official ISC Bind
	      Page</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink
	  url="http://www.nominum.com/getOpenSourceResource.php?id=6">
	  BIND FAQ</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink url="http://www.oreilly.com/catalog/dns4/">O'Reilly
	 DNS and BIND 4th Edition</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink
	      url="ftp://ftp.isi.edu/in-notes/rfc1034.txt">RFC1034
	      - Domain Names - Concepts and Facilities</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink
	      url="ftp://ftp.isi.edu/in-notes/rfc1035.txt">RFC1035
	      - Domain Names - Implementation and Specification</ulink></para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="network-ntp">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Hukins</surname>
	  <contrib>Contribu&iacute;do por </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>NTP</title>

    <indexterm><primary>NTP</primary></indexterm>

    <sect2>
      <title>Vis&atilde;o Geral</title>

      <para>Ao longo do tempo, o rel&oacute;gio de um computador tende 
      a variar.  Enquanto o tempo passa, o rel&oacute;gio do computador se
      torna menos preciso.  O NTP (Network Time Protocol) &eacute; uma forma
      de assegurar que o seu rel&oacute;gio est&aacute; correto.</para>
      
      <para>Muitos servi&ccedil;os Internet dependem, ou muito se beneficiam,
      da precis&atilde;o do rel&oacute;gio do computador estar correto.  Por
      exemplo, um servidor Web pode receber solicita&ccedil;&otilde;es para enviar
      um arquivo se ele foi modificado desde uma certa hora.  Servi&ccedil;os
      como o &man.cron.8; executam comandos em uma hora espec&iacute;fica.
      Se o rel&oacute;gio est&aacute; errado, estes comandos podem n&atilde;o ser
      executados no momento esperado.</para>

      <indexterm>
	<primary>NTP</primary>
	<secondary>ntpd</secondary>
      </indexterm>
      <para>O FreeBSD &eacute; disponibilizado com o servidor &man.ntpd.8;
      que pode ser usado para consultar outros servidores NTP para
      ajustar o rel&oacute;gio em sua m&aacute;quina ou fornecer servi&ccedil;os de hora
      para outros.</para>
    </sect2>

    <sect2>
      <title>Escolhendo os Servidores NTP Adequados</title>

      <indexterm>
	<primary>NTP</primary>
	<secondary>choosing servers</secondary>
      </indexterm>

      <para>Para sincronizar seu rel&oacute;gio, voc&ecirc; vai precisar encontrar
      um ou mais servidores NTP para usar.  Seu administrador de rede
      ou Provedor de Servi&ccedil;os Internet podem ter configurado um
      servidor NTP para este prop&oacute;sito&mdash;verifique sua
      documenta&ccedil;&atilde;o para confirmar se este &eacute; o caso.  Existe uma 
      <ulink 
      url="http://www.eecis.udel.edu/~mills/ntp/servers.html">lista 
      de servidores NTP publicamente acess&iacute;veis</ulink> os quais
      podem ser usados para encontrar um servidor NTP pr&oacute;ximo a voc&ecirc;.
      Certifique-se de estar ciente da pol&iacute;tica de qualquer
      servidor escolhido e, se necess&aacute;rio, solicite permiss&atilde;o para
      uso.</para>

      <para>Escolher alguns servidores NTP n&atilde;o conectados &eacute; uma boa
      id&eacute;ia no caso de algum dos servidores que voc&ecirc; estiver usando 
      se tornar inalcan&ccedil;avel ou seu rel&oacute;gio n&atilde;o for confi&aacute;vel.  
      &man.ntpd.8; usa as respostas recebidas de outros servidores de
      forma inteligente&mdash;ele vai favorecer os servidores mais
      confi&aacute;veis em detrimento dos menos confi&aacute;veis.</para>
    </sect2>

    <sect2>
      <title>Configurando Sua M&aacute;quina</title>

      <indexterm>
	<primary>NTP</primary>
	<secondary>configuration</secondary>
      </indexterm>

      <sect3>
	<title>Configura&ccedil;&atilde;o B&aacute;sica</title>
	<indexterm><primary>ntpdate</primary></indexterm>

	<para>Se voc&ecirc; somente deseja sicronizar seu rel&oacute;gio quando a
	m&aacute;quina for inicializada, voc&ecirc; pode usar &man.ntpdate.8;.
	Isto pode ser adequado para algumas m&aacute;quinas desktop as quais
	s&atilde;o freq&uuml;entemente reinicializadas e necessitam somente de
	sincroniza&ccedil;&otilde;es esparsas, mas a maioria das m&aacute;quinas deveria
	executar &man.ntpd.8;.<para>

	<para>Usando &man.ntpdate.8; na inicializa&ccedil;&atilde;o tamb&eacute;m &eacute; uma boa
	id&eacute;ia para m&aacute;quinas que rodam &man.ntpd.8;.  O programa
	&man.ntpd.8; altera o rel&oacute;gio gradualmente, ao passo que o
	&man.ntpdate.8; ajusta o rel&oacute;gio, qualquer que seja a
	diferen&ccedil;a entre a hora atual do rel&oacute;gio e a hora correta.</para>

	<para>Para ativar o &man.ntpdate.8; durante a inicializa&ccedil;&atilde;o,
	adicione <literal>ntpdate_enable="YES"</literal> ao 
	<filename>/etc/rc.conf</filename>.  Voc&ecirc; tamb&eacute;m vai precisar
	especificar todos os servidores com os quais deseja
	sincronizar e quaisquer par&acirc;metros a serem passados ao
	&man.ntpdate.8; em <varname>ntpdate_flags</varname>.</para>
      </sect3>

      <sect3>
	<indexterm>
	  <primary>NTP</primary>
	  <secondary>ntp.conf</secondary>
	</indexterm>

	<title>Configura&ccedil;&atilde;o Geral</title>

	<para>O NTP &eacute; configurado pelo arquivo 
	<filename>/etc/ntp.conf</filename> no formato descrito em
	&man.ntp.conf.5;.  Aqui est&aacute; um exemplo simples:</para>

	<programlisting>server ntplocal.example.com prefer
server timeserver.example.org
server ntp2a.example.net

driftfile /var/db/ntp.drift</programlisting>

	<para>A op&ccedil;&atilde;o <literal>server</literal> especifica quais
	servidores devem ser usados, com um servidor por linha.  Se um
	servidor &eacute; especificado com o argumento 
	<literal>prefer</literal>, como em <hostid
	role="fqdn">ntplocal.example.com</hostid>, este servidor &eacute;
	preferido sobre os demais servidores.  Uma resposta de um servidor
	preferido ser&aacute; descartada se ela diferir muito das respostas
	dos demais servidores, caso contr&aacute;rio ser&aacute; usada
	desconsiderando as outras respostas.  O argumento 
	<literal>prefer</literal> normalmente &eacute; usado para servidores
	NTP que s&atilde;o reconhecidamente de alta precis&atilde;o, como os que
	possuem hardware especial para monitoramento da hora.</para>

	<para>A op&ccedil;&atilde;o <literal>driftfile</literal> especifica qual
	arquivo &eacute; usado para armazenar a compensa&ccedil;&atilde;o de freq&uuml;&ecirc;ncia do
	rel&oacute;gio do sistema.  O programa &man.ntpd.8; usa isto para
	compensar automaticamente as varia&ccedil;&otilde;es naturais do 
	rel&oacute;gio, permitindo que seja mantida uma configura&ccedil;&atilde;o correta 
	mesmo que seja cortada a conex&atilde;o de todas as fontes externas
	de hora durante um per&iacute;odo de tempo.</para>

	<para>A op&ccedil;&atilde;o <literal>driftfile</literal> especifica qual
	arquivo &eacute; usado para armazenar informa&ccedil;&otilde;es sobre as respostas
	recebidas anteriormente dos servidores NTP que voc&ecirc; estiver
	usando.  Este arquivo cont&eacute;m informa&ccedil;&otilde;es internas para o NTP.
	Ele n&atilde;o deve ser alterado por nenhum outro processo.</para>

      </sect3>

      <sect3>
	<title>Controlando acesso ao Seu Servidor</title>

	<para>Por padr&atilde;o, seu servidor NTP ser&aacute; acess&iacute;vel a todos os
	sistemas na Internet.  A op&ccedil;&atilde;o <literal>restrict</literal> em 
	<filename>/etc/ntp.conf</filename> permite que voc&ecirc; controle 
	quais m&aacute;quinas podem acessar seu servidor.</para>

	<para>Se voc&ecirc; quer negar acesso a todas as m&aacute;quinas ao seu
	servidor NTP, adicione a seguinte linha ao
	<filename>/etc/ntp.conf</filename>:</para>

	<programlisting>restrict default ignore</programlisting>

	<para>Se voc&ecirc; quer permitir que somente m&aacute;quinas em sua 
	rede sincronizem seus rel&oacute;gios com seu servidor, mas
	assegurar que n&atilde;o lhes seja permitido configurar o servidor ou
	usada como pares (peers) de sincronismo, adicione</para>

	<programlisting>restrict 192.168.1.0 mask 255.255.255.0 notrust nomodify notrap</programlisting>

	<para>onde <hostid role="ipaddr">192.168.1.0</hostid> 
	&eacute; um endere&ccedil;o IP em sua rede e <hostid
	role="netmask">255.255.255.0</hostid> &eacute; a m&aacute;scara de subrede
	de sua rede.</para>

	<para><filename>/etc/ntp.conf</filename> pode conter
	m&uacute;ltiplas op&ccedil;&otilde;es <literal>restrict</literal>.  Para mais
	detalhes, veja a subse&ccedil;&atilde;o <literal>Access Control Support</literal>
	de &man.ntp.conf.5;.</para>

      </sect3>
    </sect2>

    <sect2>
      <title>Executando o Servidor NTP</title>

      <para>Para assegurar que o servidor NTP &eacute; iniciado durante a
      inicializa&ccedil;&atilde;o, adicione a linha 
      <literal>xntpd_enable="YES"</literal>.  Se voc&ecirc; deseja passar
      par&acirc;metros adicionais ao &man.ntpd.8;, edite o par&acirc;metro
      <varname>xntpd_flags</varname> no 
      <filename>/etc/rc.conf</filename>.</para>

      <para>Para iniciar o servidor sem reinicializar a m&aacute;quina, rode
      <command>ntpd</command> certificando de especificar quaisquer
      par&acirc;metros adicionais de <varname>xntpd_flags</varname> em 
      <filename>/etc/rc.conf</filename>.  Por exemplo:</para>
      <screen>&prompt.root; 
      <userinput>ntpd -p /var/run/ntpd.pid</userinput></screen>

      <note>
	<para>No &os;&nbsp;5.X, v&aacute;rias op&ccedil;&otilde;es foram renomeadas no
	<filename>/etc/rc.conf</filename>.  Assim, voc&ecirc; vai ter que
	trocar cada ocorr&ecirc;ncia de <literal>xntpd</literal> por
	<literal>ntpd</literal> nas op&ccedil;&otilde;es acima.</para></note>
    </sect2>

    <sect2>
      <title>Usando o ntpd com uma Conex&atilde;o Internet Tempor&aacute;ria</title>

      <para>O programa &man.ntpd.8; n&atilde;o precisa de uma conex&atilde;o
      permanente &agrave; Internet para funcionar corretamente.  
      Entretanto, se voc&ecirc; tem uma conex&atilde;o tempor&aacute;ria que est&aacute;
      configurada para discar por demanda, &eacute; uma boa id&eacute;ia evitar que
      o tr&aacute;fego NTP de disparar uma conex&atilde;o discada ou de manter a
      conex&atilde;o ativa.  Se voc&ecirc; estiver usando o usu&aacute;rio PPP, voc&ecirc; pode
      usar diretrizes <literal>filter</literal> em
      <filename>/etc/ppp/ppp.conf</filename>.  Por exemplo:</para>

      <programlisting> set filter dial 0 deny udp src eq 123
 # Prevent NTP traffic from initiating dial out
 set filter dial 1 permit 0 0
 set filter alive 0 deny udp src eq 123
 # Prevent incoming NTP traffic from keeping the connection open
 set filter alive 1 deny udp dst eq 123
 # Prevent outgoing NTP traffic from keeping the connection open
 set filter alive 2 permit 0/0 0/0</programlisting>

      <para>Para maiores detalhes, veja a se&ccedil;&atilde;o <literal>FILTRAGEM DE
      PACOTES</literal> em &man.ppp.8; e os exemplos em
      <filename>/usr/share/examples/ppp/</filename>.</para>

      <note>
	<para>Alguns provedores de acesso Internet bloqueiam portas de
	n&uacute;meros baixos impedindo o NTP de funcionar, uma vez que as
	respostas nunca alcan&ccedil;am sua m&aacute;quina.</para>
      </note>
    </sect2>

    <sect2>
      <title>Mais Informa&ccedil;&otilde;es</title>

      <para>Documenta&ccedil;&atilde;o para o servidor NTP podem ser encontradas em
      <filename>/usr/share/doc/ntp/</filename> em formato HTML.</para>
    </sect2>
  </sect1>

  <sect1 id="network-natd">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Chern</firstname>
	  <surname>Lee</surname>
	  <contrib>Contribu&iacute;do por</contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Tradu&ccedil;&atilde;o de Endere&ccedil;o de Rede (NAT)</title>

    <sect2 id="network-natoverview">
      <title>Vis&atilde;o Geral</title>
      <indexterm>
	<primary><application>natd</application></primary>
      </indexterm>
      <para>O daemon de Tradu&ccedil;&atilde;o de Endere&ccedil;o de Rede do FreeBSD,
      geralmente conhecido como &man.natd.8; &eacute; o daemon que aceita
      pacotes IP entrantes n&atilde;o modificados, altera a origem para a
      m&aacute;quina local e re-injeta estes pacotes de volta ao fluxo de
      pacotes IP saintes.  &man.natd.8; faz isso mudando o endere&ccedil;o IP
      de origem e a porta, de forma que, quando o dado &eacute; recebido de
      volta, &eacute; capaz de determinar sua localiza&ccedil;&atilde;o original e 
      repass&aacute;-lo ao seu solicitante original.</para>

      <indexterm><primary>Internet connection sharing</primary></indexterm>
      <indexterm><primary>IP masquerading</primary></indexterm>
      <para>O uso mais comum do NAT &eacute; executar o que &eacute; mais geralmente
      conhecido como Compartilhamento de Conex&atilde;o Internet.</para>
    </sect2>

    <sect2 id="network-natsetup">
      <title>Estrutura</title>
      <para>Dada a redu&ccedil;&atilde;o do espa&ccedil;o de endere&ccedil;amento IP no IPv4, e o
      elevado n&uacute;mero de usu&aacute;rios em linhas de alta velocidade para
      consumidores, como cabo ou DSL, as pessoas est&atilde;o
      progressivamente precisando de uma solu&ccedil;&atilde;o de Compartilhamento
      de Conex&atilde;o Internet.  A capacidade de conectar v&aacute;rios
      computadores online atrav&eacute;s de uma conex&atilde;o e endere&ccedil;o IP torna o
      &man.natd.8; uma escolha razo&aacute;vel.</para>


      <para>Freq&uuml;entemente, um usu&aacute;rio tem uma m&aacute;quina conectada a uma
      linha DSL ou cabo com um endere&ccedil;o IP e deseja usar este
      computador conectado para oferecer acesso Internet a diversos
      mais atrav&eacute;s de uma rede local.</para>

      <para>Para isto, a m&aacute;quina FreeBSD na Internet precisa atuar
      como um gateway.  Esta m&aacute;quina precisa ter duas placas de rede
      &mdash;uma para conectar ao roteador Internet, a outra para
      conectar a uma rede local.  Todas as m&aacute;quinas na rede local s&atilde;o
      conectadas atrav&eacute;s de um concentrador ou comutador.</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="advanced-networking/natd">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced">  _______       __________       ________
 |       |     |	  |     |	|
 |  Hub  |-----| Client B |-----| Router |----- Internet
 |_______|     |__________|     |________|
     |
 ____|_____
|	  |
| Client A |
|__________|</literallayout>
	</textobject>

	<textobject>
	  <phrase>Diagrama da Rede</phrase>
	</textobject>
      </mediaobject>

      <para>Uma configura&ccedil;&atilde;o como esta &eacute; geralmente usada para
      compartilhar uma conex&atilde;o Internet.  Uma das m&aacute;quinas da
      <acronym>LAN</acronym> est&aacute; conectada &agrave; Internet.  As demais
      m&aacute;quinas acessam a Internet atrav&eacute;s daquela m&aacute;quina 
      <quote>gateway</quote>.</para>
    </sect2>

    <sect2 id="network-natdkernconfiguration">
      <indexterm>
	<primary>kernel</primary>
	<secondary>configuration</secondary>
      </indexterm>
      <title>Configura&ccedil;&atilde;o</title>
      <para>As seguintes op&ccedil;&otilde;es precisam estar no arquivo de 
      configura&ccedil;&atilde;o do kernel:</para>
      <programlisting>options IPFIREWALL
options IPDIVERT</programlisting>

      <para>Adicionalmente, por escolha, o seguinte tamb&eacute;m pode ser
      apropriado:</para>
      <programlisting>options IPFIREWALL_DEFAULT_TO_ACCEPT
options IPFIREWALL_VERBOSE</programlisting>

      <para>O seguinte precisaa estar no 
      <filename>/etc/rc.conf</filename>:</para>

      <programlisting>gateway_enable="YES"
firewall_enable="YES"
firewall_type="OPEN"
natd_enable="YES"
natd_interface="<replaceable>fxp0</replaceable>"
natd_flags=""</programlisting>

      <informaltable frame="none">
	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry>gateway_enable="YES"</entry>
	      <entry>Configura a m&aacute;quina parar atuar como um gateway.
	      Executando 
	      <command>sysctl net.inet.ip.forwarding=1</command> 
	      causaria o mesmo efeito.</entry>
	    </row>
	    <row><entry>firewall_enable="YES"</entry>
	     <entry>Ativa as regras do firewall em
	     <filename>/etc/rc.firewall</filename> durante a
	     inicializa&ccedil;&atilde;o.</entry>
	    </row>
	    <row><entry>firewall_type="OPEN"</entry>
	      <entry>Isto especifica um conjunto predefinido de
	      regras do firewall, permitindo a entrada de qualquer
	      coisa.  Veja <filename>/etc/rc.firewall</filename> 
	      para tipos adicinais.</entry>
	    </row>
	    <row>
	      <entry>natd_interface="fxp0"</entry>
	      <entry>Indica a qual interface repassar pacotes (a
	      interface conectada &agrave; Internet).</entry>
	    </row>
	    <row>
	      <entry>natd_flags=""</entry>
	      <entry>Qualquer das op&ccedil;&otilde;es de configura&ccedil;&atilde;o passadas ao
	      &man.natd.8; durante a inicializa&ccedil;&atilde;o.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Tendo as op&ccedil;&otilde;es anteriores definidas em
      <filename>/etc/rc.conf</filename> seria executado 
      <command>natd -interface fxp0</command> durante a inicializa&ccedil;&atilde;o.
      Ele tamb&eacute;m pode ser executado manualmente.</para>

      <para>Cada m&aacute;quina e interface na rede local deveria ter
      n&uacute;meros de endere&ccedil;os IP atribu&iacute;dos no espa&ccedil;o de rede privado
      como definido por <ulink
      url="ftp://ftp.isi.edu/in-notes/rfc1918.txt">RFC 1918</ulink> 
      e ter como o gateway padr&atilde;o, o endere&ccedil;o IP interno da 
      m&aacute;quina <application>natd</application>.</para>

      <para>Por exemplo, o cliente <hostid>A</hostid> e 
      <hostid>B</hostid> na rede local possuem endere&ccedil;os IP
      <hostid role="ipaddr">192.168.0.2</hostid> e 
      <hostid role="ipaddr">192.168.0.3</hostid>, enquanto a 
      interface de rede local da m&aacute;quina executando o natd possui o
      endere&ccedil;o IP <hostid role="ipaddr">192.168.0.1</hostid>.  O 
      gateway padr&atilde;o dos clientes <hostid>A</hostid> e
      <hostid>B</hostid> precisa ser o da m&aacute;quina com natd, <hostid
      role="ipaddr">192.168.0.1</hostid>.  A interface externa, ou
      Internet, da m&aacute;quina com natd n&atilde;o requer nenhuma modifica&ccedil;&atilde;o
      especial para o funcionamento do &man.natd.8;.</para>
    </sect2>

    <sect2 id="network-natdport-redirection">
      <title>Redirecionamento de Porta</title>

      <para>A desvantagem do &man.natd.8; &eacute; que os clientes da rede
      local n&atilde;o s&atilde;o diretamente acess&iacute;veis a partir da Internet.  Os
      clientes dentro da rede local podem fazer conex&otilde;es saindo para o
      mundo, mas n&atilde;o podem receber conex&otilde;es vindas de fora.  Isto
      apresenta um problema ao se tentar executar servi&ccedil;os Internet em
      uma das m&aacute;quinas cliente da rede local.  Uma forma simples de
      contornar isto &eacute; redirecionando certas portas Internet na
      m&aacute;quina com <application>natd</application> para um cliente da
      rede local.</para>

      <para>Por exemplo, um servidor IRC roda em um cliente 
      <hostid>A</hostid>, e um servidor web em um cliente 
      <hostid>B</hostid>.  Para que isto funcione corretamente, as conex&otilde;es
      recebidas nas portas 6667 (IRC) e 80 (web) precisam ser
      redirecionadas para as respectivas m&aacute;quinas.</para>

      <para>Um <option>-redirect_port</option> precisa ser passado ao
      &man.natd.8; com as op&ccedil;&otilde;es adequadas.  A sintaxe &eacute; a seguinte:</para>
      <programlisting>     -redirect_port proto targetIP:targetPORT[-targetPORT]
		 [aliasIP:]aliasPORT[-aliasPORT]
		 [remoteIP[:remotePORT[-remotePORT]]]</programlisting>

      <para>No exemplo acima, o argumento deve ser:</para>

	<programlisting>    -redirect_port tcp 192.168.0.2:6667 6667
    -redirect_port tcp 192.168.0.3:80 80</programlisting>

      <para>Isto ir&aacute; direcionar as portas <emphasis>tcp</emphasis> 
      corretas para as m&aacute;quinas clientes da rede local.</para>

      <para>Um argumento <option>-redirect_port</option> pode ser
      usado para indicar faixas de portas al&eacute;m de portas individuais.
      Por exemplo, <replaceable>tcp 192.168.0.2:2000-3000 
      2000-3000</replaceable> redirecionaria todas as conex&otilde;es
      recebidas nas portas 2000 a 3000 para portas 2000 a 3000 no
      cliente <hostid>A</hostid>.</para>

      <para>Estas op&ccedil;&otilde;es podem ser usadas executando diretamente o 
      &man.natd.8;, ou inseridas na op&ccedil;&atilde;o 
      <literal>natd_flags=""</literal> em 
      <filename>/etc/rc.conf</filename>.</para>

      <para>Para mais op&ccedil;&otilde;es de configura&ccedil;&atilde;o, consulte &man.natd.8;.</para>
    </sect2>

    <sect2 id="network-natdaddress-redirection">
      <title>Redirecionamento de Endere&ccedil;o</title>
      <indexterm><primary>address redirection</primary></indexterm>
      <para>Redirecionamento de endere&ccedil;o &eacute; &uacute;til se v&aacute;rios endere&ccedil;os IP
      est&atilde;o dispon&iacute;veis, mesmo que eles precisem estar em uma m&aacute;quina.
      Com isto, o &man.natd.8; pode designar cada cliente da rede local
      com seu pr&oacute;prio endere&ccedil;o externo.  O &man.natd.8; ent&atilde;o
      reescreve os pacotes de sa&iacute;da dos clientes da rede local com o
      endere&ccedil;o IP externo apropriado e redireciona todo o tr&aacute;fego de
      entrada para aquele endere&ccedil;o IP de volta ao cliente da rede
      local espec&iacute;fico.  Isto tamb&eacute;m &eacute; conhecido como NAT est&aacute;tico.
      Por exemplo, os endere&ccedil;os IP 
      <hostid role="ipaddr">128.1.1.1</hostid>,
      <hostid role="ipaddr">128.1.1.2</hostid> e
      <hostid role="ipaddr">128.1.1.3</hostid> pertencem &agrave; maquina
      gateway com <application>natd</application>.  O <hostid
      role="ipaddr">128.1.1.1</hostid> pode ser usado como o o
      endere&ccedil;o IP externo da m&aacute;quina gateway, enquanto 
      <hostid role="ipaddr">128.1.1.2</hostid> e 
      <hostid role="ipaddr">128.1.1.3</hostid> s&atilde;o repassados de volta
      aos clientes <hostid>A</hostid> e <hostid>B</hostid> da rede 
      local.</para>

      <para>A sintaxe de <option>-redirect_address</option> &eacute; a
      seguinte:</para>

      <programlisting>-redirect_address IPlocal IPp&uacute;blico</programlisting>


      <informaltable frame="none">
	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry>IPlocal</entry>
	      <entry>O endere&ccedil;o IP interno do cliente da rede local.</entry>
	    </row>
	    <row>
	      <entry>IPp&uacute;blico</entry>
	      <entry>O endere&ccedil;o IP externo correspondente ao cliente 
	      da rede local.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>No exemplo, este argumento seria escrito:</para>

      <programlisting>-redirect_address 192.168.0.2 128.1.1.2
-redirect_address 192.168.0.3 128.1.1.3</programlisting>

      <para>Como <option>-redirect_port</option>, estes argumentos
      tamb&eacute;m s&atilde;o inseridos na op&ccedil;&atilde;o <literal>natd_flags=""</literal> do
      <filename>/etc/rc.conf</filename>.  Com redirecionamento de
      endere&ccedil;o, n&atilde;o h&aacute; necessidade de redirecionamento de porta, uma
      vez que todos os dados recebidos em um endere&ccedil;o IP em particular
      s&atilde;o redirecionados.</para>

      <para>Os endere&ccedil;os IP externos na m&aacute;quina com 
      <application>natd</application> precisam ser ativos como
      secund&aacute;rios na interface externa.  Veja como fazer em
      &man.rc.conf.5;.</para>
    </sect2>
  </sect1>

  <sect1 id="network-inetd">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Chern</firstname>
	  <surname>Lee</surname>
	  <contrib>Contribu&iacute;do por </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>O <quote>Super-Servidor</quote> <application>inetd</application></title>

    <sect2 id="network-inetd-overview">
      <title>Vis&atilde;o Geral</title>

      <para>&man.inetd.8; is referred to as the <quote>Internet
	  Super-Server</quote> because it manages connections for several
	daemons.  Programs that provide network service are commonly
	known as daemons.  <application>inetd</application> serves as a
	managing server for other daemons.  When a connection is
	received by <application>inetd</application>, it determines
	which daemon the connection is destined for, spawns the
	particular daemon and delegates the socket to it.  Running one
	instance of <application>inetd</application> reduces the overall
	system load as compared to running each daemon individually in
	stand-alone mode.</para>

      <para>Primarily, <application>inetd</application> is used to
	spawn other daemons, but several trivial protocols are handled
	directly, such as <application>chargen</application>,
	<application>auth</application>, and
	<application>daytime</application>.</para>

      <para>This section will cover the basics in configuring
	<application>inetd</application> through its command-line
	options and its configuration file,
	<filename>/etc/inetd.conf</filename>.</para>
    </sect2>

    <sect2 id="network-inetd-settings">
      <title>Settings</title>

      <para><application>inetd</application> is initialized through
	the <filename>/etc/rc.conf</filename> system.  The
	<literal>inetd_enable</literal> option is set to
	<quote>NO</quote> by default, but is often times turned on by
	<application>sysinstall</application> with the medium security
	profile.  Placing:
	<programlisting>inetd_enable="YES"</programlisting> or
	<programlisting>inetd_enable="NO"</programlisting> into
	<filename>/etc/rc.conf</filename> can enable or disable
	<application>inetd</application> starting at boot time.</para>

      <para>Additionally, different command-line options can be passed
	to <application>inetd</application> via the
	<literal>inetd_flags</literal> option.</para>
    </sect2>

    <sect2 id="network-inetd-cmdline">
      <title>Command-Line Options</title>

      <para><application>inetd</application> synopsis:</para>

      <para><option>     inetd [-d] [-l] [-w] [-W] [-c maximum] [-C rate] [-a address | hostname]
	   [-p filename] [-R rate] [configuration file]</option></para>

      <variablelist>
	<varlistentry>
	  <term>-d</term>

	  <listitem>
	    <para>Turn on debugging.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-l</term>

	  <listitem>
	    <para>Turn on logging of successful connections.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-w</term>

	  <listitem>
	    <para>Turn on TCP Wrapping for external services (on by
	      default).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-W</term>

	  <listitem>
	    <para>Turn on TCP Wrapping for internal services which are
	      built into <application>inetd</application> (on by
	      default).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-c maximum</term>

	  <listitem>
	    <para>Specify the default maximum number of simultaneous
	      invocations of each service; the default is unlimited.
	      May be overridden on a per-service basis with the
	      <option>max-child</option> parameter.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-C rate</term>

	  <listitem>
	    <para>Specify the default maximum number of times a
	      service can be invoked from a single IP address in one
	      minute; the default is unlimited.  May be overridden on a
	      per-service basis with the
	      <option>max-connections-per-ip-per-minute</option>
	      parameter.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-R rate</term>

	  <listitem>
	    <para>Specify the maximum number of times a service can be
	      invoked in one minute; the default is 256.  A rate of 0
	      allows an unlimited number of invocations.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-a</term>

	  <listitem>
	    <para>Specify one specific IP address to bind to.
	      Alternatively, a hostname can be specified, in which case
	      the IPv4 or IPv6 address which corresponds to that
	      hostname is used.  Usually a hostname is specified when
	      <application>inetd</application> is run inside a
	      &man.jail.8;, in which case the hostname corresponds to
	      the &man.jail.8; environment.</para>

	    <para>When hostname specification is used and both IPv4
	      and IPv6 bindings are desired, one entry with the
	      appropriate protocol type for each binding is required for
	      each service in <filename>/etc/inetd.conf</filename>.  For
	      example, a TCP-based service would need two entries, one
	      using <quote>tcp4</quote> for the protocol and the other using
	      <quote>tcp6</quote>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-p</term>

	  <listitem>
	    <para>Specify an alternate file in which to store the
	      process ID.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>These options can be passed to
	<application>inetd</application> using the
	<literal>inetd_flags</literal> option in
	<filename>/etc/rc.conf</filename>.  By default,
	<literal>inetd_flags</literal> is set to <quote>-wW</quote>,
	which turns on TCP wrapping for
	<application>inetd</application>'s internal and external
	services.  For novice users, these parameters usually do not need
	to be modified or even entered in
	<filename>/etc/rc.conf</filename>.</para>

      <note>
	<para>An external service is a daemon outside of
	  <application>inetd</application>, which is invoked when a
	  connection is received for it.  On the other hand, an internal
	  service is one that <application>inetd</application> has the
	  facility of offering within itself.</para>
      </note>

    </sect2>

    <sect2 id="network-inetd-conf">
      <title><filename>inetd.conf</filename></title>

      <para>Configuration of <application>inetd</application> is
	controlled through the <filename>/etc/inetd.conf</filename>
	file.</para>

      <para>When a modification is made to
	<filename>/etc/inetd.conf</filename>,
	<application>inetd</application> can be forced to re-read its
	configuration file by sending a HangUP signal to the
	<application>inetd</application> process as shown:</para>

      <example id="network-inetd-hangup">
	<title>Sending <application>inetd</application> a HangUP Signal</title>

	<screen>&prompt.root; <userinput>kill -HUP `cat /var/run/inetd.pid`</userinput></screen>
      </example>

      <para>Each line of the configuration file specifies an
	individual daemon.  Comments in the file are preceded by a
	<quote>#</quote>.  The format of
	<filename>/etc/inetd.conf</filename> is as follows:</para>

      <programlisting>service-name
socket-type
protocol
{wait|nowait}[/max-child[/max-connections-per-ip-per-minute]]
user[:group][/login-class]
server-program
server-program-arguments</programlisting>

      <para>An example entry for the <application>ftpd</application> daemon
	using IPv4:</para>

      <programlisting>ftp     stream tcp     nowait root    /usr/libexec/ftpd       ftpd -l</programlisting>

      <variablelist>
	<varlistentry>
	  <term>service-name</term>

	  <listitem>
	    <para>This is the service name of the particular daemon.
	      It must correspond to a service listed in
	      <filename>/etc/services</filename>.  This determines which
	      port <application>inetd</application> must listen to.  If
	      a new service is being created, it must be placed in
	      <filename>/etc/services</filename>
	      first.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>socket-type</term>

	  <listitem>
	    <para>Either <literal>stream</literal>,
	      <literal>dgram</literal>, <literal>raw</literal>, or
	      <literal>seqpacket</literal>.  <literal>stream</literal>
	      must be used for connection-based, TCP daemons, while
	      <literal>dgram</literal> is used for daemons utilizing the
	      UDP transport protocol.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>protocol</term>

	  <listitem>
	    <para>One of the following:</para>

	    <informaltable>
	      <tgroup cols="2">
		<thead>
		  <row>
		    <entry>Protocol</entry>
		    <entry>Explanation</entry>
		  </row>
		</thead>
		<tbody>
		  <row>
		    <entry>tcp, tcp4</entry>
		    <entry>TCP IPv4</entry>
		  </row>
		  <row>
		    <entry>udp, udp4</entry>
		    <entry>UDP IPv4</entry>
		  </row>
		  <row>
		    <entry>tcp6</entry>
		    <entry>TCP IPv6</entry>
		  </row>
		  <row>
		    <entry>udp6</entry>
		    <entry>UDP IPv6</entry>
		  </row>
		  <row>
		    <entry>tcp46</entry>
		    <entry>Both TCP IPv4 and v6</entry>
		  </row>
		  <row>
		    <entry>udp46</entry>
		    <entry>Both UDP IPv4 and v6</entry>
		  </row>
		</tbody>
	      </tgroup>
	    </informaltable>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>{wait|nowait}[/max-child[/max-connections-per-ip-per-minute]]</term>

	  <listitem>
	    <para><option>wait|nowait</option> indicates whether the
	      daemon invoked from <application>inetd</application> is
	      able to handle its own socket or not.
	      <option>dgram</option> socket types must use the wait
	      option, while stream socket daemons, which are usually
	      multi-threaded, should use <option>nowait</option>.
	      <option>wait</option> usually hands off multiple sockets
	      to a single daemon, while <option>nowait</option> spawns a
	      child daemon for each new socket.</para>

	    <para>The maximum number of child daemons
	      <application>inetd</application> may spawn can be set using
	      the <option>max-child</option> option.  If a limit of ten
	      instances of a particular daemon is needed, a
	      <literal>/10</literal> would be placed after
	      <option>nowait</option>.</para>

	    <para>In addition to <option>max-child</option>, another
	      option limiting the maximum connections from a single
	      place to a particular daemon can be enabled.
	      <option>max-connections-per-ip-per-minute</option> does
	      just this.  A value of ten here would limit any particular
	      IP address connecting to a particular service to ten
	      attempts per minute.  This is useful to prevent
	      intentional or unintentional resource consumption and
	      Denial of Service (DoS) attacks to a machine.</para>

	    <para>In this field, <option>wait</option> or
	      <option>nowait</option> is mandatory.
	      <option>max-child</option> and
	      <option>max-connections-per-ip-per-minute</option> are
	      optional.</para>

	    <para>A stream-type multi-threaded daemon without any
	      <option>max-child</option> or
	      <option>max-connections-per-ip-per-minute</option> limits
	      would simply be: <literal>nowait</literal></para>

	    <para>The same daemon with a maximum limit of ten daemons
	      would read: <literal>nowait/10</literal></para>

	    <para>Additionally, the same setup with a limit of twenty
	      connections per IP address per minute and a maximum
	      total limit of ten child daemons would read:
	      <literal>nowait/10/20</literal></para>

	    <para>These options are all utilized by the default
	      settings of the <application>fingerd</application> daemon,
	      as seen here:</para>

	    <programlisting>finger stream tcp     nowait/3/10 nobody /usr/libexec/fingerd fingerd -s</programlisting>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>user</term>

	  <listitem>
	    <para>The user is the username that the particular daemon
	      should run as.  Most commonly, daemons run as the
	      <username>root</username> user.  For security purposes, it is
	      common to find some servers running as the
	      <username>daemon</username> user, or the least privileged
	      <username>nobody</username> user.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>server-program</term>

	  <listitem>
	    <para>The full path of the daemon to be executed when a
	      connection is received.  If the daemon is a service
	      provided by <application>inetd</application> internally,
	      then <option>internal</option> should be
	      used.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>server-program-arguments</term>

	  <listitem>
	    <para>This works in conjunction with
	      <option>server-program</option> by specifying the
	      arguments, starting with argv[0], passed to the daemon on
	      invocation.  If <application>mydaemon -d</application> is
	      the command line, <literal>mydaemon -d</literal> would be
	      the value of <option>server program arguments</option>.
	      Again, if the daemon is an internal service, use
	      <option>internal</option> here.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="network-inetd-security">
      <title>Security</title>

      <para>Depending on the security profile chosen at install, many
	of <application>inetd</application>'s daemons may be enabled by
	default.  If there is no apparent need for a particular daemon,
	disable it!  Place a <quote>#</quote> in front of the daemon in
	question, and send a <link linkend="network-inetd-hangup">hangup signal
	  to inetd</link>.
	Some daemons, such as <application>fingerd</application>, may
	not be desired at all because they provide an attacker with too
	much information.</para>

      <para>Some daemons are not security-conscious and have long, or
	non-existent timeouts for connection attempts.  This allows an
	attacker to slowly send connections to a particular daemon, thus
	saturating available resources.  It may be a good idea to place
	<option>ip-per-minute</option> and <option>max-child</option>
	limitations on certain daemons.</para>

      <para>By default, TCP wrapping is turned on.  Consult the
	&man.hosts.access.5; manual page for more information on placing
	TCP restrictions on various <application>inetd</application>
	invoked daemons.</para>
    </sect2>

    <sect2 id="network-inetd-misc">
      <title>Miscellaneous</title>

      <para><application>daytime</application>,
	<application>time</application>,
	<application>echo</application>,
	<application>discard</application>,
	<application>chargen</application>, and
	<application>auth</application> are all internally provided
	services of <application>inetd</application>.</para>

      <para>The <application>auth</application> service provides identity
	(ident, identd) network services, and is configurable to a certain
	degree.</para>

      <para>Consult the &man.inetd.8; manual page for more in-depth
	information.</para>
    </sect2>
  </sect1>

  <sect1 id="network-plip">
    <title>IP em Linha Paralela (PLIP)</title>

    <indexterm><primary>PLIP</primary></indexterm>
    <indexterm><primary>Parallel Line IP</primary></indexterm>

    <para>PLIP nos permite usar TCP/IP entre portas paralelas.  &Eacute; &uacute;til
    em m&aacute;quinas sem placas de rede, ou para instalar em laptops.
    Nesta se&ccedil;&atilde;o vamos examinar:</para>

    <itemizedlist>
      <listitem>
	<para>Criando um cabo paralelo (laplink).</para>
      </listitem>

      <listitem>
	<para>Conectando dois computadores com PLIP.</para>
      </listitem>
    </itemizedlist>

    <sect2 id="network-create-parallel-cable">
      <title>Criando um Cabo Paralelo</title>

      <para>Voc&ecirc; pode comprar um cabo paralelo na maioria das lojas de
      suprimentos de inform&aacute;tica.  Se voc&ecirc; n&atilde;o puder fazer isso, ou
      voc&ecirc; apenas quer saber como um cabo &eacute; feito, a tabela a seguir
      mostra como fazer um a partir de um cabo paralelo para
      impressora.</para>

      <table>
	<title>Conectando um Cabo Paralelo para Conex&atilde;o em Rede</title>

	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry>A-name</entry>

	      <entry>A-End</entry>

	      <entry>B-End</entry>

	      <entry>Descr.</entry>

	      <entry>Post/Bit</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><literallayout>DATA0
-ERROR</literallayout></entry>

	      <entry><literallayout>2
15</literallayout></entry>

	      <entry><literallayout>15
2</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x01
1/0x08</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA1
+SLCT</literallayout></entry>

	      <entry><literallayout>3
13</literallayout></entry>

	      <entry><literallayout>13
3</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x02
1/0x10</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA2
+PE</literallayout></entry>

	      <entry><literallayout>4
12</literallayout></entry>

	      <entry><literallayout>12
4</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x04
1/0x20</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA3
-ACK</literallayout></entry>

	      <entry><literallayout>5
10</literallayout></entry>

	      <entry><literallayout>10
5</literallayout></entry>

	      <entry>Strobe</entry>

	      <entry><literallayout>0/0x08
1/0x40</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA4
BUSY</literallayout></entry>

	      <entry><literallayout>6
11</literallayout></entry>

	      <entry><literallayout>11
6</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x10
1/0x80</literallayout></entry>
	    </row>

	    <row>
	      <entry>GND</entry>

	      <entry>18-25</entry>

	      <entry>18-25</entry>

	      <entry>GND</entry>

	      <entry>-</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>

    <sect2 id="network-plip-setup">
      <title>Configurando o PLIP</title>

      <para>Primeiro, voc&ecirc; precisa obter um cabo laplink.  Depois,
      certifique-se de que ambos os computadores possuem um kernel com
      suporte do gerenciador de dispositivos &man.lpt.4;:</para>

      <screen>&prompt.root; <userinput>grep lp /var/run/dmesg.boot</userinput>
lpt0: &lt;Printer&gt; on ppbus0
lpt0: Interrupt-driven port</screen>

      <para>A porta paralela precisa ser uma porta gerenciada por
      interrup&ccedil;&otilde;es.  No &os;&nbsp;4.X, voc&ecirc; deve ter uma linha similar
      &agrave; seguinte em seu arquivo de configura&ccedil;&atilde;o do kernel:</para>

      <programlisting>device ppc0 at isa?  irq 7</programlisting>

      <para>No &os;&nbsp;5.X, o arquivo
      <filename>/boot/device.hints</filename> deve conter as seguintes
      linhas:</para>

      <programlisting>hint.ppc.0.at="isa" 
      hint.ppc.0.irq="7"</programlisting>

      <para>Ent&atilde;o verifique se o arquivo de configura&ccedil;&atilde;o do kernel tem
      uma linha <literal>device plip</literal> ou se o m&oacute;dulo de
      kernel <filename>plip.ko</filename> est&aacute; carregado.  Em ambos os
      casos, a interface de rede paralela deve aparecer quando voc&ecirc;
      usar diretamente o comando &man.ifconfig.8;.  No &os;&nbsp;4.X
      assim:</para>

      <screen>&prompt.root; <userinput>ifconfig lp0</userinput>
lp0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500</screen>

      <para>e no &os;&nbsp;5.X:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0</userinput>
plip0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500</screen>

      <note><para>O nome do dispositivo usado para a interface
      paralela &eacute; diferente entre o &os;&nbsp;4.X 
      (<devicename>lp<replaceable>X</replaceable></devicename>) 
      e o &os;&nbsp;5.X 
      (<devicename>plip<replaceable>X</replaceable></devicename>).</para></note>

      <para>Conecte o cabo laplink na interface paralela em ambos os
      computadores.</para>

      <para>Configure os par&acirc;metros da interface de rede nos dois
      s&iacute;tios como <username>root</username>.  Por exemplo, se voc&ecirc;
      quer conectar o sistema <hostid>host1</hostid> executando
      &os;&nbsp;4.X com <hostid>host2</hostid> executando &os;&nbsp;5.X:</para>

      <programlisting>		 host1 &lt;-----&gt; host2
IP Address    10.0.0.1      10.0.0.2</programlisting>

      <para>Configure a interface em <hostid>host1</hostid> fazendo:</para>

      <screen>&prompt.root; <userinput>ifconfig lp0 10.0.0.1 10.0.0.2</userinput></screen>

      <para>Configure a interface no <hostid>host2</hostid> fazendo:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0 10.0.0.2 10.0.0.1</userinput></screen>


      <para>Voc&ecirc; agora deve ter uma conex&atilde;o funcionando.  Por favor
      leia as p&aacute;ginas de manual &man.lp.4; e &man.lpt.4; para mais
      detalhes.</para>

      <para>Voc&ecirc; deve tamb&eacute;m adicionar ambas os sistemas ao 
      <filename>/etc/hosts</filename>:</para>

      <programlisting>127.0.0.1	       localhost.my.domain localhost
10.0.0.1		host1.my.domain host1
10.0.0.2		host2.my.domain</programlisting>

      <para>Para confirmar que a conex&atilde;o funciona, v&aacute; a cada sistema e
      fa&ccedil;a um ping para o outro.  Por exemplo, em 
      <hostid>host1</hostid>:</para>

	  <screen>&prompt.root; <userinput>ifconfig lp0</userinput>
lp0: flags=8851&lt;UP,POINTOPOINT,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
	inet 10.0.0.1 --&gt; 10.0.0.2 netmask 0xff000000
&prompt.root; <userinput>netstat -r</userinput>
Routing tables

Internet:
Destination	Gateway	  Flags     Refs     Use      Netif Expire
host2	      host1	      UH	  0       0       lp0
&prompt.root; <userinput>ping -c 4 host2</userinput>
PING host2 (10.0.0.2): 56 data bytes
64 bytes from 10.0.0.2: icmp_seq=0 ttl=255 time=2.774 ms
64 bytes from 10.0.0.2: icmp_seq=1 ttl=255 time=2.530 ms
64 bytes from 10.0.0.2: icmp_seq=2 ttl=255 time=2.556 ms
64 bytes from 10.0.0.2: icmp_seq=3 ttl=255 time=2.714 ms

--- host2 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 2.530/2.643/2.774/0.103 ms</screen>

    </sect2>
  </sect1>

  <sect1 id="network-ipv6">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Aaron</firstname>
	  <surname>Kaplan</surname>
	  <contrib>Originalmente Escrito por </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Reestruturado e Adicionado por </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>IPv6</title>
    <para>IPv6 (tamb&eacute;m conhecido como IPng <quote>IP next 
    generation</quote>) &eacute; a nova vers&atilde;o do bem conhecido protocolo 
    IP (tamb&eacute;m conhecido como <acronym>IPv4</acronym>).  Como outros 
    sistemas *BSD atuais, o FreeBSD inclui a implementa&ccedil;&atilde;o de 
    refer&ecirc;ncia <acronym>KAME</acronym>.  Ent&atilde;o o seu sistema FreeBSD
    vem com tudo o que voc&ecirc; via precisar para experi&ecirc;ncias com IPv6.  
    Esta se&ccedil;&atilde;o enfoca na configura&ccedil;&atilde;o e ativa&ccedil;&atilde;o do IPv6.</para>

    <para>No in&iacute;cio dos anos 90, as pessoas tomaram conhecimento do
    r&aacute;pido esgotamento do espa&ccedil;o de endere&ccedil;amento do IPv4.  Dada a
    taxa de expans&atilde;o da Internet, haviam duas preocupa&ccedil;&otilde;es principais: </para>

    <itemizedlist>
      <listitem>
	<para>Esgotamento de endere&ccedil;os.  Hoje isto n&atilde;o &eacute; uma
	preocupa&ccedil;&atilde;o t&atilde;o grande, uma vez que espa&ccedil;os de endere&ccedil;os
	privados (<hostid role="ipaddr">10.0.0.0/8</hostid>,
	  <hostid role="ipaddr">192.168.0.0/24</hostid>,
	  etc.) e a Tradu&ccedil;&atilde;o de Endere&ccedil;os de Rede (Network Address 
	  Translation - <acronym>NAT</acronym>) est&atilde;o sendo empregados.</para>
      </listitem>

      <listitem>
	<para>Entrada nas tabelas de roteadores estavam ficando
	grandes demais.  Hoje isto ainda &eacute; uma preocupa&ccedil;&atilde;o.</para>
      </listitem>
    </itemizedlist>

    <para>IPv6 trata destas e muitas outras quest&otilde;es:</para>

    <itemizedlist>
      <listitem>
	<para>Espa&ccedil;o de endere&ccedil;amento de 128 bits.  Em outras
	palavras, existem te&oacute;ricos 
	  340,282,366,920,938,463,463,374,607,431,768,211,456
	  endere&ccedil;os dispon&iacute;veis.  Isto significa que s&atilde;o
	  aproximadamente 6.67 * 10^27 endere&ccedil;os IPv6 por metro
	  quadrado em nosso planeta.</para>
      </listitem>

      <listitem>
	<para>Roteadores armazenar&atilde;o somente endere&ccedil;os agregados de
	redes em suas tabelas de roteamento, reduzindo assim, o espa&ccedil;o
	m&eacute;dio de uma tabela de roteamento para 8192 entradas.</para>
      </listitem>
    </itemizedlist>

    <para>Tamb&eacute;m existem muitas outras caracter&iacute;sticas &uacute;teis do IPv6
    como:</para>

    <itemizedlist>
      <listitem>
	<para>Autoconfigura&ccedil;&atilde;o de endere&ccedil;o (RFC2462)</para>
      </listitem>

      <listitem>
	<para>Endere&ccedil;os anycast (<quote>um dentre muitos</quote>)</para>
      </listitem>

      <listitem>
	<para>Endere&ccedil;os multicast obrigat&oacute;rios</para>
      </listitem>

      <listitem>
	<para>IPsec (IP security)</para>
      </listitem>

      <listitem>
	<para>Estrutura simplificada de cabe&ccedil;alho</para>
      </listitem>

      <listitem>
	<para><acronym>IP</acronym> M&oacute;vel</para>
      </listitem>

      <listitem>
	<para>Mecanismos de transi&ccedil;&atilde;o IPv4-para-IPv6</para>
      </listitem>
    </itemizedlist>


    <para>Para maiores informa&ccedil;&otilde;es veja:</para>

    <itemizedlist>
      <listitem>
	<para>IPv6 overview at <ulink url="http://www.sun.com">Sun.com</ulink></para>
      </listitem>

      <listitem>
	<para><ulink url="http://www.ipv6.org">IPv6.org</ulink></para>
      </listitem>

      <listitem>
	<para><ulink url="http://www.kame.net">KAME.net</ulink></para>
      </listitem>

      <listitem>
	<para><ulink url="http://www.6bone.net">6bone.net</ulink></para>
      </listitem>
    </itemizedlist>

    <sect2>
      <title>Fundamentos em Endere&ccedil;os IPv6</title>
      <para>Existem diferentes tipos de endere&ccedil;os IPv6: Unicast,
      Anycast e Multicast.</para>

      <para>Endere&ccedil;os Unicast s&atilde;o os endere&ccedil;os conhecidos.  Um pacote
      enviado a um endere&ccedil;o unicast chega exatamente &agrave; interface
      pertencente ao endere&ccedil;o.</para>

      <para>Endere&ccedil;os anycast s&atilde;o sintaticamente indistingu&iacute;veis de
      endere&ccedil;os unicast, mas eles endere&ccedil;am um grupo de interfaces.
      Um pacote destinado para um endere&ccedil;o anycast vai chegar na
      interface mais pr&oacute;xima (em m&eacute;trica de roteador).  Endere&ccedil;os
      anycast somente podem ser usados por roteadores.</para>

      <para>Endere&ccedil;os multicast identificam um grupo de interfaces.
      Um pacote destinado a um endere&ccedil;o multicast vai chegar em todas
      as interfaces pertencentes ao grupo multicast.</para>

	<note><para>O endere&ccedil;o de difus&atilde;o (broadcast) IPv4
	(normalmente <hostid role="ipaddr">xxx.xxx.xxx.255</hostid>) 
	&eacute; expresso por endere&ccedil;os multicast em IPv6.</para></note>

      <para>Endere&ccedil;os IPv6 Reservados:</para>

<screen>ipv6-address 	prefixlength(Bits)	description	Notes

	::			128 Bits			n&atilde;o especificado cf.  0.0.0.0 em endere&ccedil;o IPv4
	::1			128 Bits			endere&ccedil;o loopback cf.  127.0.0.1 em IPv4
	::00:xx:xx:xx:xx	96 Bits				IPv4 embutido	Os 32 bits mais baixos s&atilde;o os
								endere&ccedil;os	IPv4.  Tamb&eacute;m chamado 
								<quote>Endere&ccedil;o IPv4 compat&iacute;vel com IPv6
								</quote>
	::ff:xx:xx:xx:xx	96 Bits		IPv4 mapeado    Os 32 bits mais baixos s&atilde;o os
						IPv6 address	endere&ccedil;os IPv4.  Para sistemas
								que n&atilde;o suportam IPv6
	fe80:: - feb::		10 Bits		link-local	cf.  endere&ccedil;o loopback em
						IPv4
	fec0:: - fef::		10 Bits		locais ao s&iacute;tio
	ff::			8 Bits		multicast
	001 (base 2)		3 Bits		unicast globais	Todos os endere&ccedil;os unicast globais
								s&atilde;o atribu&iacute;dos deste
								conjunto.  Os 3 primeiros Bits
								s&atilde;o <quote>001</quote>.</screen>

    </sect2>

    <sect2>
      <title>Lendo Endere&ccedil;os IPv6</title>
      <para>A forma can&ocirc;nica &eacute; representada como: <hostid
      role="ip6addr">x:x:x:x:x:x:x:x</hostid>, cada 
      <quote>x</quote> sendo um valor hexadecimal de 16 
      Bits.  Por exemplo <hostid
      role="ip6addr">FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</hostid></para>

      <para>Freq&uuml;entemente um endere&ccedil;o ter&aacute; longas subs&eacute;ries 
      compostas por zerosr, ent&atilde;o cada subs&eacute;rie pode ser abreviada por
      <quote>::</quote>. Por exemplo <hostid 
      role="ip6addr">fe80::1</hostid> corresponde &agrave; forma can&ocirc;nica 
      <hostid 
      role="ip6addr">fe80:0000:0000:0000:0000:0000:0000:0001</hostid></para>

      <para>Uma terceira forma &eacute; escrever a &uacute;ltima parte de 32 Bits na
      forma conhecida (decimal), estilo IPv4, com pontos 
      <quote>.</quote> como separadores.  Por exemplo, 
      <hostid role="ip6addr">2002::10.0.0.1</hostid> corresponde &agrave;
      representa&ccedil;&atilde;o can&ocirc;nica (hexadecimal)
      <hostid role="ip6addr">2002:0000:0000:0000:0000:0000:0a00:0001</hostid>
       que por sua vez equivale a escrever 
       <hostid role="ip6addr">2002::a00:1</hostid></para>


      <para>Agora, os leitores devem ser capazes de compreender o
      seguinte:</para>

      <screen>&prompt.root; <userinput>ifconfig</userinput></screen>

      <programlisting>rl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
	 inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
	 inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
	 ether 00:00:21:03:08:e1
	 media: Ethernet autoselect (100baseTX )
	 status: active</programlisting>

      <para><hostid role="ip6addr">fe80::200:21ff:fe03:8e1%rl0</hostid>
      &eacute; um endere&ccedil;o auto-configurado tipo enlace-local.  Ele inclui o
      MAC Ethernet misturado como parte da auto-configura&ccedil;&atilde;o.</para>

      <para>Para maiores informa&ccedil;&otilde;es sobre a estrutura dos endere&ccedil;os
      IPv6, veja a RFC2373.</para>
    </sect2>

    <sect2>
      <title>Conectando-se</title>

      <para>Atualmente existem quatro formas de se conectar a outros
      sistemas e redes IPv6:</para>

      <itemizedlist>
	<listitem>
	  <para>Associar-se ao 6bone experimental</para>
	</listitem>

	<listitem>
	  <para>Obtendo uma rede IPv6 de seu provedor de
	  conectividade.  Procure seu provedor Internet para
	  instru&ccedil;&otilde;es.</para>
	</listitem>

	<listitem>
	  <para>Tunelamento via 6-para-4</para>
	</listitem>

	<listitem>
	  <para>Usar o port freenet6 se estiver em uma conex&atilde;o
	  discada.</para>
	</listitem>
      </itemizedlist>

      <para>Aqui vamos falar sobre como se conectar ao 6bone uma vez
      que atualmente parece ser a forma mais popular.</para>

      <para>Primeiro, veja a p&aacute;gina do 6bone e encontre a conex&atilde;o para
      o 6bone mais pr&oacute;xima de voc&ecirc;.  Escreva para a pessoa respons&aacute;vel
      e com um pouco de sorte voc&ecirc; receber&aacute; instru&ccedil;&otilde;es sobre como
      configurar sua conex&atilde;o.  Geralmente isto envolve preparar um
      t&uacute;nel GRE (gif).</para>

      <para>Aqui est&aacute; um exemplo t&iacute;pico de como preparar um t&uacute;nel
      &man.gif.4;:</para>

      <screen>&prompt.root; <userinput>ifconfig gif0 create</userinput>
&prompt.root; <userinput>ifconfig gif0</userinput>
gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
&prompt.root; <userinput>ifconfig gif0 tunnel <replaceable>MEU_END_IPv4</replaceable>  <replaceable>END_IPv4_DELE</replaceable></userinput>
&prompt.root; <userinput>ifconfig gif0 inet6 alias <replaceable>MEU_END_IPv6_ATRIBUIDO_COMO_PONTO_FINAL_DO_T&Uacute;NEL</replaceable></userinput></screen>

      <para>Substitua as palavras em mai&uacute;sculas pela informa&ccedil;&atilde;o
      recebida do n&oacute; 6bone de n&iacute;vel superior.</para>

      <para>Isto estabelece o t&uacute;nel.  Verifique se o t&uacute;nel est&aacute;
      funcionando usando &man.ping6.8; <hostid
      role="ip6addr">ff02::1%gif0</hostid>.  Voc&ecirc; deve receber duas
      respostas do ping.</para>

	<note><para>Em caso de voc&ecirc; estar intrigado pelo endere&ccedil;o
	<hostid role="ip6addr">ff02:1%gif0</hostid>, isto &eacute; um
	endere&ccedil;o multicast.  <literal>%gif0</literal> indica que o 
	endere&ccedil;o multicast na interface de rede 
	<devicename>gif0</devicename> deve ser usado.  Uma vez que 
	n&oacute;s usamos <command>ping</command> para um endere&ccedil;o multicast, 
	o outro ponto final do t&uacute;nel deve responder tamb&eacute;m).</para></note>

      <para>Agora, configurar a rota para sua conex&atilde;o ao 6bone deve
      ser bem clara:</para>

      <screen>&prompt.root; <userinput>route add -inet6 default -interface gif0</userinput>
&prompt.root; <userinput>ping6 -n <replaceable>MINHA_CONEX&Atilde;O</replaceable></userinput></screen>

      <screen>&prompt.root; <userinput>traceroute6 www.jp.FreeBSD.org</userinput>
(3ffe:505:2008:1:2a0:24ff:fe57:e561) from 3ffe:8060:100::40:2, 30 hops max, 12 byte packets
     1 atnet-meta6 14.147 ms 15.499 ms 24.319 ms
     2 6bone-gw2-ATNET-NT.ipv6.tilab.com 103.408 ms 95.072 ms *
     3 3ffe:1831:0:ffff::4 138.645 ms 134.437 ms 144.257 ms
     4 3ffe:1810:0:6:290:27ff:fe79:7677 282.975 ms 278.666 ms 292.811 ms
     5 3ffe:1800:0:ff00::4 400.131 ms 396.324 ms 394.769 ms
     6 3ffe:1800:0:3:290:27ff:fe14:cdee 394.712 ms 397.19 ms 394.102 ms</screen>

      <para>Esta sa&iacute;da vai ser diferente de m&aacute;quina para m&aacute;quina.
      Agora voc&ecirc; deve ser capaz de alcan&ccedil;ar o s&iacute;tio IPv6 <ulink
      url="http://www.kame.net">www.kame.net</ulink> e ver a tartaruga
      dan&ccedil;ante &mdash; se voc&ecirc; tiver um navegador pronto para IPv6,
      como o <filename role="package">www/mozilla</filename>.</para>

    </sect2>

    <sect2>
      <title>DNS no Mundo IPv6</title>
      <para>Existem duas novas formas de registros DNS para IPv6:</para>

      <itemizedlist>
	<listitem>
	  <para>Registros AAAA,</para>
	</listitem>

	<listitem>
	  <para>Registros A6</para>
	</listitem>
      </itemizedlist>

      <para>Usar registros AAAA &eacute; bem direto.  Atribua seu nome de
      sistema ao novo endere&ccedil;o IPv6 que voc&ecirc; rec&eacute;m obteve
      adicionando:</para>

      <programlisting>MEUNOMEDESISTEMA	   AAAA    MEUENDIPv6</programlisting>

      <para>ao seu arquivo DNS de zona prim&aacute;ria.  No caso de voc&ecirc; n&atilde;o
      servir suas pr&oacute;prias zonas <acronym>DNS</acronym> pe&ccedil;a ao seu
      provedor <acronym>DNS</acronym>.  Vers&otilde;es atuais do
      <application>bind</application> (vers&otilde;es 8.3 e 9) suportam
      registros AAAA.</para>
    </sect2>
  </sect1>

</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
<!--  LocalWords:  config mnt www -->
