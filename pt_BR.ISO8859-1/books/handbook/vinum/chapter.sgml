<!--
	The Vinum Volume Manager
	By Greg Lehey (grog at lemis dot com)

	Added to the Handbook by Hiten Pandya <hiten@uk.FreeBSD.org>
	and Tom Rhodes <trhodes@FreeBSD.org>

	For the FreeBSD Documentation Project
	$FreeBSD: doc/en_US.ISO8859-1/books/handbook/vinum/chapter.sgml,v 1.25 2003/11/05 10:36:56 ceri Exp $
-->

<chapter id="vinum-vinum">
  <title>O Gerenciador de Volumes Vinum</title>
  
  <sect1 id="vinum-synopsis">
    <title>Sinópse</title>

    <para>Não importa quais discos você tem, eles sempre terão
     limitações
    
      <itemizedlist>
	<listitem>
	  <para>Eles podem ser pequenos demais.</para>
	</listitem>

	<listitem>
	  <para>Eles podem ser lentos demais.</para>
	</listitem>

	<listitem>
	  <para>Eles podem ser pouco seguro.</para>
	</listitem>
      </itemizedlist>
  </sect1>

  <sect1 id="vinum-intro">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Greg</firstname>
	  <surname>Lehey</surname>
	  <contrib>Originally written by </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>Discos são muito pequenos</title>

    <indexterm><primary>Vinum</primary></indexterm>
    <indexterm><primary>RAID</primary>
    <secondary>Software</secondary></indexterm>
   
    <para><emphasis>Vinum</emphasis> o chamado <emphasis>Gerenciador
	de Volumes</emphasis> é o disco virtual que trata destes
	três problemas, vamos analiza-los com mais detalhes.  Soluções
	para estes problemas tem sido propostas e 
	implementadas:</para>

    <para>os discos estão ficando maiores, mas os requisitos para
    armazenamento de dados também.  frequentemente você vai querer um
    sistema de arquivos maior do que o disco que você tem disponível.
    Reconhecidamente, este problema já não é tão agudo com era a dez
    anos atrás, mas ele ainda existe.  alguns sistemas resolveram isso
    criando um dispositivo abstrato onde armazena seus dados em um
    número de discos.</para>
  </sect1>

  <sect1 id="vinum-access-bottlenecks">
    <title>Gargalo de acesso</title>

    <para>Sistemas modernos frequentemente precisam acessar dados de uma
    maneira incrívelmente rápida.  Por exemplo, grandes servidores de
    FTP e HTTP podem manter milhares de sessões ao mesmo tempo e podem
    ter multiplas conexões de 100&nbsp;Mbit/s com o mundo externo, bem
    além das taxas de transmisão da maioria dos discos.</para>
    
    <para>Os discos atuais podem transferir dados sequêncialmente em até
    70&nbsp;MB/s, mas esse valor este valor é de pouca importância em um
    ambiente onde muitos processos independentes acessam  um disco, onde
    eles talvez atinjam apenas uma fração desse valor.  Nesses casos é
    mais importante observar o problema do ponto de vista do subsystem:
    o parametro importante é a carga que uma transferência coloca no
    subsystem, em outras palavras, o tempo em que a transferência ocupa
    os discos envolvidos.</para>
       
    <para>Em qualquer disco de transferência, o disco deve primeiramente
    posicionar as cabeças de leitura e esperar até que o primeiro setor
    passe em baixo delas e depois sim executar a transferência.  Esses
    atos podem ser considerados com se fossem atômicos: não faz o menor
    sentido interromper eles.</para>
    
    <para><anchor id="vinum-latency"> considere uma transferência
    típica de aproximadamente 10&nbsp;kB: a geração atual de discos de
    alta performance podem posicionar as cabeças em uma média de
    3.5&nbsp;ms.  Os discos mais rápidos giram em 15,000&nbsp;rpm,
    então, a rotação latente média (metade de uma revolução) é de
    2&nbsp;ms.  Em 70&nbsp;MB/s, a transferência propriamente dita, leva
    em torno de 150&nbsp;&mu;s, o que é quase nada comprado com o
    tempo de posicionamento.  Em tal caso, a taxa efetiva de
    transferência fica um pouco maior que 1&nbsp;MB/s e é altamente
    dependente no tamanho do que vai ser transferido, é claro.</para>

    <para>A solução óbvia e tradicional para esse gargalo é <quote>more
    spindles</quote>: ele usa vários discos pequenos  com a mesma
    capacidade de armazenamento em vez de usar um outro disco grande.
    Cada disco é capaz de se posicionar e transferir dados de maneira
    independente, então o ritmo de transferência efetivo, cresce a uma
    taxa próxima ao número de discos usados.</para>

    <para>O ritmo de transferência exato é, claramente, menor que o
    número de discos envolvidos: apesar de cada disco é capaz de relizar
    transferencias em paralelo, não existe nenhuma forma de se assegurar
    que as solicitações estão distribuidas de maneira uniforme entre os
    discos.  Inevitavelmente a carga no disco será maior do que no
    outro.</para> 
    
    <indexterm>
      <primary>concatenação de dicos</primary>
    </indexterm>
    <indexterm>
      <primary>Vinum</primary>
      <secondary>concatenação</secondary>
    </indexterm>

    <para>A igualdade da carga nos discos é fortemente dependente do
    modo em que os dados são compartilhados entre eles.  No
    próximo debate, seria conveniente visualizar um disco como se fosse
    um grande número de setores de dados mapeados numericamente, como as
    páginas de um livro.  o método mais simples seria dividir o disco
    virtual em pequenos grupos de setores consecutivos do tamanho do
    disco fisico individual e depois armzena-los desse jeito, semelhante
    a pegar um livro grande e dividi-lo em pequenas sessões.  Esse étodo
    é chamado de <emphasis>concatenação</emphasis> e tem a vantagem que
    os discos não precisam ter nenhum tipo de relacionamento quanto a
    tamanho.  Funciona bem quando o acesso ao disco virtual é dividido
    de maneira igual entre os seus espaços mapeados.  quando o acesso é
    concentrado um uma área menor, o aumento no desempenho é menos
    acentuado. <xref linkend="vinum-concat"> Ilustra a sequência na qual
    as unidades de armazenamento são alocadas em uma organização
    concatenada.</para>
    
    <para>
      <figure id="vinum-concat">
	<title>Organização concatenada</title>
	<graphic fileref="vinum/vinum-concat">
      </figure>
    </para>

    <indexterm>
      <primary>particionamento de discos</primary>
    </indexterm>
    <indexterm>
      <primary>Vinum</primary>
      <secondary>particionamento</secondary>
    </indexterm>

    <para>Um mapeamento alternativo é dividir o address space em
    componentes menores, de tamanhos iguais e armazena-los
    sequencialmente em discos diferentes.  Por exemplo, os primeiros 256
    setores poderiam ser armazenados no primeiro disco, os 256 setores
    seguintes no próximo disco e assim por diante.  Depois de preencher
    o último disco processo se repete até que os discos estejam cheios.
    Esse mapemento é chamado de <emphasis>striping</emphasis> ou
    <acronym>RAID-0</acronym>.

    
    <footnote>
      <indexterm><primary>RAID</primary></indexterm>
    
      <para><acronym>RAID</acronym> significa <emphasis>Array redundante
      de discos baratos</emphasis> e oferece várias formas de tolerancia
      de erros, apesar de que um termo um pouco equivocado, pois não
      fornece redundância.</para> </footnote>.
      

    O striping exige um esforço grande para localizar os dados e
    isso causa carga adicional de I/O onde a tranferência é distribuida
    para diversos discos, mas pode também fornecer uma carga constante
    entre os discos.  <xref linkend="vinum-striped"> ilustra  sequência
    em que as unidades de armazenamento são alocadas em uma organização
    striped.</para>
    
    <para>
      <figure id="vinum-striped">
        <title>Striped Organization</title>
	<graphic fileref="vinum/vinum-striped">
      </figure>
    </para>
  </sect1>

  <sect1 id="vinum-data-integrity">
    <title>Integridade de dados</title>

      <para>O outro problema com os discos atuais é que eles não são
      confiáveis.  Apesar que a confiança nos discos cresceu
      tremendamente nos últimos anos, esses ainda são um dos componentes
      do núcleo de em servidor com a maior possibilidade de falhar.  E
      quando eles falham, os resultados podem ser catastróficos:
      substituir um disco e recuperar seus dados pode levar dias.</para>
      
      <indexterm>
	<primary>espelhamento de disco</primary>
      </indexterm>
      <indexterm>
	<primary>Vinum</primary>
	<secondary>mirroring</secondary>
      </indexterm>
      <indexterm>
	<primary>RAID-1</primary>
      </indexterm>
      
      <para>O método tradicional de acessar esse problema tem sido o
      <emphasis>espelhamento</emphasis>, mantendo duas cópias dos dados
      em dois lugares fisicos distintos.  desde da aparição dos níveis
      de <acronym>RAID</acronym>, essa técnica de espelhamento também é
      chamada de <acronym>RAID nível 1</acronym> ou
      <acronym>RAID-1</acronym>.  qualquer escrita feita no volume
      é escrita nas duas localidades; a leitura pode ser feita a partir
      de uma delas, então se o disco falhar, os dados ainda estarão
      disponíveis no outro.</para>
      
      <para>Espelhamento tem dois problemas:</para>
    
	<itemizedlist>
	  <listitem>
	    <para>O preço.  Exige duas vezes mais armazenamento de disco
	    do que uma solução sem redundância.</para>
	  </listitem>

	  <listitem>
	    <para>O impácto de mémoria.  A escrita deve ser feita para
	    os dois discos, devido a isso eles usam duas vezes mais
	    largura de banda do que um volume não espelhado.  Na leitura
	    não há queda de performance: chega até a parecer que está
	    mais rápido.</para>
	  </listitem>
	</itemizedlist>

      <para><indexterm><primary>RAID-5</primary></indexterm>Uma solução
      alternativa é <emphasis>parity</emphasis>, implementada nos níveis
      2, 3, 4 e 5 do <acronym>RAID</acronym>.  Entre esses,
      <acronym>RAID-5</acronym> é o mais interessante.  Como
      implementado no vinum, é uma variante na organização strip onde
      dedica um bloco de cada strip à parity dos outros blocos.  Um
      <acronym>RAID-5</acronym> plex é parecido com um vinum striped
      plex, exceto que ele implementa o <acronym>RAID-5</acronym> pois
      ele inclui um parity bloco em cada stripe.  Como exigido pelo
      <acronym>RAID-5</acronym>, o local do bloco parity muda de um
      stripe para o outro.  Os números nos blocos de dados indica o
      número relativo do bloco.</para>

      <para>
	<figure id="vinum-raid5-org">
	  <title> Organização RAID-5</title>
	  <graphic fileref="vinum/vinum-raid5-org">
	</figure>
      </para>

      <para>Comparado com espelhamento, <acronym>RAID-5</acronym> tem a
      vantagem de requer significativamente menos espaço de
      armazenameto.  O acesso à leitura é parecida com a utilizada nas
      organizações striped, mas o acesso à escrita é bem reduzida, chega
      a até 25% da performance de leitura aproximadamente.  Se uma
      partição falha, o array pode continuar a operar em um modo de 
      despreza: a leitura das partições acessiveis restantes continua
      normalmente, mas a leitura da partição danificada é recalculada
      pelo bloco correspondente de todos as partições restantes.</para>
  </sect1>

  <sect1 id="vinum-objects">
    <title>Objetos do Vinum</title>
      <para>Para que o Vinum possa solucionar esse problema, ele
      implementa um quarto nível em hierarquia de objetos:</para>
      

      <itemizedlist>
	<listitem>
	  <para>O objeto mais visivel é o disco vitual, chamado de
	  <emphasis>volume</emphasis>.  Volumes tem essencialmente as
	  mesmas propriedades de uma partição &unix;, mas tem umas
	  pequenas diferenças.  Eles não tem nenhuma limitação de
	  tamanho.</para>
	</listitem>

	<listitem>
	  <para>Volumes são compostos de <emphasis>plexes</emphasis>, no
	  qual representa o espaço total de adressamento de um volume.
	  Dessa forma, esse nível na hierarquia fornece redundância.
	  Pense em plexes como uma partição individual em um array
	  clonado, cada um ontendo os mesmos dados.</para>
	</listitem>

	<listitem>
	  <para>Desde que o Vinum existe no sistema de armazenamento de
	  discos &unix;, seria possível usar partições &unix; como um
	  bloco de construção para plexes de multiplos discos, mas no
	  final isso acaba sendo muito inflexível: o número de partições
	  de um disco &unix; é limitado.  Ao contrário, Vinum subdivide
	  uma única partição &unix; (os <emphasis>discos de
	  vinum</emphasis>) em contínuas areas chamadas
	  <emphasis>subdiscos</emphasis>, no qual é usado como blocas de
	  construção para plexes.</para>
	</listitem>
      
	<listitem>
	  <para>Subdiscos residem em discos de Vinum.  atualmente
	  partições &unix;.  com a exceção de uma pequea área no começo
	  do disco, no qual é usado para armazenamento de configurações
	  e informações sobre o estado, o disco todo fica disponível
	  para armazenamento de dados.</para>
	</listitem>
      </itemizedlist>

      <para>As sessões seguintes descrevem o jeito com que esses objetos
      fornecem a funcionalidade requerida pelo Vinum.</para>

    <sect2>
      <title>Conciderações de um tamanho de volume</title>

      <para>Plexes podem ter muitos subdiscos espalhados por todas as 
      partições nas configurações de vinum.  Como resultado, o tamanho
      de uma prtição original não limta o tamanho nem de um plex e nem
      de um volume.</para>
    </sect2>
    
    <sect2>
      <title>Redundância de armazenamento de dados</title>
      <para>Vinum implementa espelhamento anexando multiplos plexes a um
      volume.  Cada plex é a representação dos dados de um volume.  Um
      volume pode conter entre um e oito plexes.</para>
      
      <para>Apesar de um plex repesentar os dados completos de um
      volume, é possivel que partes da representação esteja fisicamente
      faltando, ou por planejamento (por não definir um subdisco como
      parte de um plex), ou por acidente (como resultado de uma falha no
      disco).  Se que pelo menos um plex possa fornecer dados para a
      extenção completa de endereço do volume, o sistema é completamente
      funcional.</para>
    </sect2>
    
    <sect2>
      <title>Assuntos de performance</title>
      
      <para>Vinum implementa no nível de plexes tanto concatenação
      quanto striping:</para>
      
      <itemizedlist>
	<listitem>
	  <para>Um <emphasis>plex concatenado</emphasis> usa um espaço de
	  adressamento de cada subdisco por vez.</para>
	</listitem>

	<listitem>
	  <para>Um <emphasis>plex striped</emphasis> stripes os dados
	  entre cada subdisco.  Todos os subdiscos tem que ter o mesmo
	  tamanho, e é preciso que existam pelo menos dois subdiscos
	  para que eles possam ser distinguidos a partir de um plex
	  concatenado.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Qual organização plex?</title>
     
     <para>A versão do Vinum suprida com o FreeBSD &rel.current;
     implementa dois tipos de plexes:</para> 
     
      <itemizedlist>
	<listitem>
	  <para>Plexes concatenados são os mais flexiveis: eles podem
	  conter infinitos números de subdiscos e os subdiscos podem ser
	  de tamanhos diferentes.  Os plexes podem ser extendendidos
	  adicionando subdiscos.  Eles requerem menos tempo de 
	  <acronym>CPU</acronym> do que striped plexes, mas a diferença
	  em <acronym>CPU</acronym> overhead não da para ser medida.
	  On the other hand, they are most susceptible to hot spots, 
	  where one disk is very active and others are idle.</para>
        </listitem>

	<listitem>
	  <para>A grande vantágme de plexes striped
	  (<acronym>RAID-0</acronym>) é que eles reduzem os pontos
	  quentes: escolhendo o melhor tamanho de stripe (mais ou menos
	  256&nbsp;kB), você pode igualar a carga nos discos
	  componentes.  As disventagens dessa escolha são cóigos
	  (fracionalmente) mais complexos e restrições em subdiscos:
	  eles tem que ser todos do mesmo tamanho, e extender um plex
	  através da adição de um novo subdisco é tão complicado que
	  vinum atualmente nem o implementa.  Vinum impõe uma restrição
	  adicional, trivial: Um plex striped precisa ter pelo menos
	  dois subdiscos, pois caso contrário seria indistinguivel de um
	  plex concatenado.</para>
	 </listitem>
      </itemizedlist>
    
      <para><xref linkend="vinum-comparison">sumariza as vantágens e
      desvantágens de cada organização plex.</para>
    
      <table id="vinum-comparison">
	<title>Organizações Plex do Vinum</title>
	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry>Tipo de Plex</entry>
	  	<entry>Minimum subdisks</entry>
	  	<entry>Pode adicionar subdiscos</entry>
	  	<entry>Deve ser de igual tamanho</entry>
	  	<entry>Application</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>concatenated</entry>
	      <entry>1</entry>
	      <entry>sim</entry>
	      <entry>não</entry>
	      <entry>Grande armazenamento de dados com máxima
	      flexibilidade de placement e performance moderada</entry>
	    </row>
	    
	    <row>
	      <entry>striped</entry>
	      <entry>2</entry>
	      <entry>não</entry>
	      <entry>sim</entry>
	      <entry>Alta performance em combinação com um acesso
	      altamente concorrido</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>
  </sect1>
  
  <sect1 id="vinum-examples">
    <title>Alguns exemplos</title>
    

    <para>Vinum mantám uma <emphasis>base de dados de
    configuração</emphasis> onde descreve os objetos conhecidos por um
    sistema individua.  Inicialmente, o usuário cria o banco de dados de
    configuração a partir de um ou mais arquivos de configuração com a
    ajuda do utilitário &man.vinum.8;.  Vinum guarda uma cópia das
    configurações de seu banco de dados em cada "fatia" de disco (onde o
    Vinum chama de <emphasis>dispositivo</emphasis>) sobre seu controle.
    Essa base de dados é atualizada em cada mudança de estado, então,
    precisamente recupera o estado de cada objeo do Vinum</para>
    
  
    <sect2>
      <title>O arquivo de configuração</title>
      <para>O arquivo de configuração descreve os objetos individuais do
      Vinum.  A definção de um simples volume poderia ser:</para>
      

      <programlisting>
    drive a device /dev/da3h
    volume myvol
      plex org concat
        sd length 512m drive a</programlisting>

      <para>Esse arquivo descreve quatro objetos do Vinum:</para>
      

      <itemizedlist>
	<listitem>
	  <para>A linha <emphasis>drive</emphasis> descreve uma partição
	  de disco (<emphasis>drive</emphasis>) e sua localidade
	  relativa ao fundamento do 
	  <foreignphrase>hardware</foreignphrase>.  É dado um nome
	  simbólico <emphasis>a</emphasis>.  Essa separação entre nomes
	  simbólicos e nomes de dispositivos permite que os discos sejam
	  movidos de um lado a outro sem confusão.</para>
	</listitem>

	<listitem>
	  <para>A linha <emphasis>volume</emphasis> descreve um volume.
	  O unico atributo requerido é o nome, nesse caso
	  <emphasis>myvol</emphasis>.</para 
	</listitem>

	<listitem>
	  <para>A linha <emphasis>plex</emphasis> define um plex.  O
	  único parâmetro requerido é a organização, nesse caso
	  <emphasis>concat</emphasis>.  nenhum nome é necessário: o
	  sistema irá automaticamente gerar um nome a partir do volume
	  adicionando o sufixo  <emphasis>.p</emphasis>
	  <emphasis>x</emphasis>, onde <emphasis>x</emphasis> é o número
	  de plexes no volume.  Então, esse plex terá o nome
	  <emphasis>myvol.p0</emphasis>.</para>
	</listitem>

	<listitem>
	  <para>A linha <emphasis>sd</emphasis> descreve um subdisco.
	  As mínimas especificações são os nomes dos discos no qual será
	  armazenado, e o tamanho do subdisco.  Como nos plexes, nenhum
	  nome é necessário: o sistema delega automaticamente nomes
	  provenientes dos plexes adicionando o sufixo
	  <emphasis>.s</emphasis><emphasis>x</emphasis>, onde
	  <emphasis>x</emphasis> é o número de subdiscos do plex.  Então
	  Vinum delega a esse subdisco o nome de
	  <emphasis>myvol.p0.s0</emphasis>.</para>
	</listitem>
      </itemizedlist>

      <para>Depois de processar esse arquivo, &man.vinum.8; gera a
      seguinte saida:</para>
      
      <programlisting>
      &prompt.root; vinum -&gt; <command>create config1</command>
      Configuration summary
      Drives:         1 (4 configured)
      Volumes:        1 (4 configured)
      Plexes:         1 (8 configured)
      Subdisks:       1 (16 configured)
     
	D a                     State: up       Device /dev/da3h        Avail: 2061/2573 MB (80%)
	
	V myvol                 State: up       Plexes:       1 Size:        512 MB
	
	P myvol.p0            C State: up       Subdisks:     1 Size:        512 MB
	
	S myvol.p0.s0           State: up       PO:        0  B Size:        512 MB</programlisting>

      <para>
      
      This output shows the brief listing format of &man.vinum.8;.  It
	is represented graphically in <xref linkend="vinum-simple-vol">.</para>

      <para>
	<figure id="vinum-simple-vol">
	  <title>A Simple Vinum Volume</title>
	  <graphic fileref="vinum/vinum-simple-vol">
	</figure>
      </para>

      <para>This figure, and the ones which follow, represent a
	volume, which contains the plexes, which in turn contain the
	subdisks.  In this trivial example, the volume contains one
	plex, and the plex contains one subdisk.</para>

      <para>This particular volume has no specific advantage over a
	conventional disk partition.  It contains a single plex, so it
	is not redundant.  The plex contains a single subdisk, so
	there is no difference in storage allocation from a
	conventional disk partition.  The following sections
	illustrate various more interesting configuration
	methods.</para>
    </sect2>

    <sect2>
      <title>Increased Resilience: Mirroring</title>

      <para>The resilience of a volume can be increased by mirroring.
	When laying out a mirrored volume, it is important to ensure
	that the subdisks of each plex are on different drives, so
	that a drive failure will not take down both plexes.  The
	following configuration mirrors a volume:</para>

      <programlisting>
	drive b device /dev/da4h
	volume mirror
      plex org concat
        sd length 512m drive a
	  plex org concat
	    sd length 512m drive b</programlisting>

      <para>In this example, it was not necessary to specify a
	definition of drive <emphasis>a</emphasis> again, since Vinum
	keeps track of all objects in its configuration database.
	After processing this definition, the configuration looks
	like:</para>


      <programlisting>
	Drives:         2 (4 configured)
	Volumes:        2 (4 configured)
	Plexes:         3 (8 configured)
	Subdisks:       3 (16 configured)
	
	D a                     State: up       Device /dev/da3h        Avail: 1549/2573 MB (60%)
	D b                     State: up       Device /dev/da4h        Avail: 2061/2573 MB (80%)

    V myvol                 State: up       Plexes:       1 Size:        512 MB
    V mirror                State: up       Plexes:       2 Size:        512 MB
  
    P myvol.p0            C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p0           C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p1           C State: initializing     Subdisks:     1 Size:        512 MB
  
    S myvol.p0.s0           State: up       PO:        0  B Size:        512 MB
	S mirror.p0.s0          State: up       PO:        0  B Size:        512 MB
	S mirror.p1.s0          State: empty    PO:        0  B Size:        512 MB</programlisting>
	
      <para><xref linkend="vinum-mirrored-vol"> shows the structure
	graphically.</para>

      <para>
	<figure id="vinum-mirrored-vol">
	  <title>A Mirrored Vinum Volume</title>
	  <graphic fileref="vinum/vinum-mirrored-vol">
	</figure>
      </para>

      <para>In this example, each plex contains the full 512&nbsp;MB
	of address space.  As in the previous example, each plex
	contains only a single subdisk.</para>
    </sect2>

    <sect2>
      <title>Optimizing Performance</title>

      <para>The mirrored volume in the previous example is more
	resistant to failure than an unmirrored volume, but its
	performance is less: each write to the volume requires a write
	to both drives, using up a greater proportion of the total
	disk bandwidth.  Performance considerations demand a different
	approach: instead of mirroring, the data is striped across as
	many disk drives as possible.  The following configuration
	shows a volume with a plex striped across four disk
	drives:</para>

	<programlisting>
	drive c device /dev/da5h
	drive d device /dev/da6h
	volume stripe
	plex org striped 512k
	  sd length 128m drive a
	  sd length 128m drive b
	  sd length 128m drive c
	  sd length 128m drive d</programlisting>

      <para>As before, it is not necessary to define the drives which are
	already known to Vinum.  After processing this definition, the
	configuration looks like:</para>

      <programlisting>
	Drives:         4 (4 configured)
	Volumes:        3 (4 configured)
	Plexes:         4 (8 configured)
	Subdisks:       7 (16 configured)
  
    D a                     State: up       Device /dev/da3h        Avail: 1421/2573 MB (55%)
    D b                     State: up       Device /dev/da4h        Avail: 1933/2573 MB (75%)
    D c                     State: up       Device /dev/da5h        Avail: 2445/2573 MB (95%)
    D d                     State: up       Device /dev/da6h        Avail: 2445/2573 MB (95%)
  
    V myvol                 State: up       Plexes:       1 Size:        512 MB
    V mirror                State: up       Plexes:       2 Size:        512 MB
    V striped               State: up       Plexes:       1 Size:        512 MB
  
    P myvol.p0            C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p0           C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p1           C State: initializing     Subdisks:     1 Size:        512 MB
    P striped.p1            State: up       Subdisks:     1 Size:        512 MB
  
    S myvol.p0.s0           State: up       PO:        0  B Size:        512 MB
    S mirror.p0.s0          State: up       PO:        0  B Size:        512 MB
    S mirror.p1.s0          State: empty    PO:        0  B Size:        512 MB
    S striped.p0.s0         State: up       PO:        0  B Size:        128 MB
    S striped.p0.s1         State: up       PO:      512 kB Size:        128 MB
    S striped.p0.s2         State: up       PO:     1024 kB Size:        128 MB
    S striped.p0.s3         State: up       PO:     1536 kB Size:        128 MB</programlisting>

      <para>
	<figure id="vinum-striped-vol">
	  <title>A Striped Vinum Volume</title>
	  <graphic fileref="vinum/vinum-striped-vol">
	</figure>
      </para>

      <para>This volume is represented in
	<xref linkend="vinum-striped-vol">.  The darkness of the stripes
	indicates the position within the plex address space: the lightest stripes
	come first, the darkest last.</para>
    </sect2>

    <sect2>
      <title>Resilience and Performance</title>

      <para><anchor id="vinum-resilience">With sufficient hardware, it
	is possible to build volumes which show both increased
	resilience and increased performance compared to standard
	&unix; partitions.  A typical configuration file might
	be:</para>

      <programlisting>
	volume raid10
      plex org striped 512k
        sd length 102480k drive a
        sd length 102480k drive b
        sd length 102480k drive c
        sd length 102480k drive d
        sd length 102480k drive e
      plex org striped 512k
        sd length 102480k drive c
        sd length 102480k drive d
        sd length 102480k drive e
        sd length 102480k drive a
        sd length 102480k drive b</programlisting>

      <para>The subdisks of the second plex are offset by two drives from those
	of the first plex: this helps ensure that writes do not go to the same
	subdisks even if a transfer goes over two drives.</para>

      <para><xref linkend="vinum-raid10-vol"> represents the structure
	of this volume.</para>

      <para>
	<figure id="vinum-raid10-vol">
	  <title>A Mirrored, Striped Vinum Volume</title>
	  <graphic fileref="vinum/vinum-raid10-vol">
        </figure>
      </para>
    </sect2>
  </sect1>
  
  <sect1 id="vinum-object-naming">
    <title>Nomenclatura de objetos</title>

    <para>Como descrito assima, Vinum desigina nomes padrões
    para plexes e subdisks, embora você possa sobrescreve-los.
    Sobrescrever os nomes padrões, não é recomenado: experiências com o
    com o gerenciador de volumes VERITAS, que permite nomes arbitrários
    para objetos, tem mostrado que essa flexibilidade não tras uma
    vantágem significativa e pode causar confusão.</para>

    <para>Nomes podem conter qualquer caracter não nulo, mas é
    recomendado que estes sejam restritos a letras, digitos e caracteres
    underscore.  Os nomes dos volumes, plexes e subdiscos podem ser
    formados por até 64 caracteres, e o nome dos drives por até
    32.</para>
    
    <para>Objetos do Vinum são dispositivos designados na
    hierarquia <filename>/dev/vinum</filename>.  a configuração descrita
    abaixo causaria o Vinum a criar o seguinte node de
    despositivo:</para>
    

    <itemizedlist>
      <listitem>
	<para>Os dispositivos de controle
	<devicename>/dev/vinum/control</devicename> e
	<devicename>/dev/vinum/controld</devicename>, no qual são usados
	por &man.vinum.8; e pelo daemon de Vinum respectivamente.</para> 
      </listitem> 
	      

      <listitem>
	<para>Entrada de dispositivo de caracter e bloco para cada
	volume.  Esses são os principais dispositivos usados pelo Vinum.
	Os nomes dos dispoitivos bloco é o nome do volume, enquanto os
	do caracter seguem as tradições BSD de prepending (preceder) a
	letra <emphasis>r</emphasis> ao nome.  Por isso a configurção
	abaixo incluiria os dispositivos bloco
	<devicename>/dev/vinum/myvol</devicename>,
	<devicename>/dev/vinum/mirror</devicename>,
	<devicename>/dev/vinum/striped</devicename>,
	<devicename>/dev/vinum/raid5</devicename> e
	<devicename>/dev/vinum/raid10</devicename>, e o dispositivos
	caracter <devicename>/dev/vinum/rmyvol</devicename>,
	<devicename>/dev/vinum/rmirror</devicename>,
	<devicename>/dev/vinum/rstriped</devicename>,
	<devicename>/dev/vinum/rraid5</devicename> e
	<devicename>/dev/vinum/rraid10</devicename>.  obviament existe m
	problema aqui: é possível ter dois olumes chamados
	<emphasis>r</emphasis> e <emphasis>rr</emphasis>, mas ocorreria um
	conflito criando o node do  dispositivo
	<devicename>/dev/vinum/rr</devicename>: seria um dispositivo de
	caracter para o volume <emphasis>r</emphasis> ou um dispositivo
	bloco para o volume <emphasis>rr</emphasis>?  Atualmente Vinum
	não endereça o conflito: o primeiro volume definido levará o
	nome.</para> 
      </listitem>

      <listitem>
	<para>Um diretório <devicename>/dev/vinum/drive</devicename> com
	entradas para cada disco.  Essas entradas são na verdade links
	simbólicos para os disco nodes correspondentes.<.para>
      </listitem>

      <listitem>
	<para>Um diretório <filename>/dev/vinum/volume</filename> com
	entradas para cada volume, que contém um subdiretório para cada
	plex, que por sua vez contém subdiretórios para seus
	subdiscos.</para>
      </listitem>

      <listitem>
	<para>The directories
	  <devicename>/dev/vinum/plex</devicename>,
	  <devicename>/dev/vinum/sd</devicename>, and
	  <devicename>/dev/vinum/rsd</devicename>, onde contém um
	  node de dispositivo bloco para cada plex e um node de
	  dispositivo bloco e caracter para cada subdisco,
	  respectivamente.</para>
      </listitem>
    </itemizedlist>

    <para>Por exemplo, considere o seguinte arquivo de
    configuração:</para>
	<programlisting>
	drive drive1 device /dev/sd1h
	drive drive2 device /dev/sd2h
	drive drive3 device /dev/sd3h
	drive drive4 device /dev/sd4h
    volume s64 setupstate
      plex org striped 64k
        sd length 100m drive drive1
        sd length 100m drive drive2
        sd length 100m drive drive3
        sd length 100m drive drive4
	</programlisting>

    <para>Depois de processar esse arquivo, &man.vinum.8; cria a
    seguinte estrutura em <filename>/dev/vinum</filename>:</para>

    <programlisting>
	brwx------  1 root  wheel   25, 0x40000001 Apr 13 16:46 Control
	brwx------  1 root  wheel   25, 0x40000002 Apr 13 16:46 control
	brwx------  1 root  wheel   25, 0x40000000 Apr 13 16:46 controld
	drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 drive
	drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 plex
	crwxr-xr--  1 root  wheel   91,   2 Apr 13 16:46 rs64
	drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 rsd
	drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 rvol
	brwxr-xr--  1 root  wheel   25,   2 Apr 13 16:46 s64
	drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 sd
	drwxr-xr-x  3 root  wheel       512 Apr 13 16:46 vol

	/dev/vinum/drive:
    total 0
    lrwxr-xr-x  1 root  wheel  9 Apr 13 16:46 drive1 -&gt; /dev/sd1h
    lrwxr-xr-x  1 root  wheel  9 Apr 13 16:46 drive2 -&gt; /dev/sd2h
    lrwxr-xr-x  1 root  wheel  9 Apr 13 16:46 drive3 -&gt; /dev/sd3h
    lrwxr-xr-x  1 root  wheel  9 Apr 13 16:46 drive4 -&gt; /dev/sd4h
  
    /dev/vinum/plex:
    total 0
    brwxr-xr--  1 root  wheel   25, 0x10000002 Apr 13 16:46 s64.p0
    
    /dev/vinum/rsd:
    total 0
    crwxr-xr--  1 root  wheel   91, 0x20000002 Apr 13 16:46 s64.p0.s0
    crwxr-xr--  1 root  wheel   91, 0x20100002 Apr 13 16:46 s64.p0.s1
    crwxr-xr--  1 root  wheel   91, 0x20200002 Apr 13 16:46 s64.p0.s2
    crwxr-xr--  1 root  wheel   91, 0x20300002 Apr 13 16:46 s64.p0.s3
  
    /dev/vinum/rvol:
    total 0
    crwxr-xr--  1 root  wheel   91,   2 Apr 13 16:46 s64
  
    /dev/vinum/sd:
    total 0
    brwxr-xr--  1 root  wheel   25, 0x20000002 Apr 13 16:46 s64.p0.s0
    brwxr-xr--  1 root  wheel   25, 0x20100002 Apr 13 16:46 s64.p0.s1
    brwxr-xr--  1 root  wheel   25, 0x20200002 Apr 13 16:46 s64.p0.s2
    brwxr-xr--  1 root  wheel   25, 0x20300002 Apr 13 16:46 s64.p0.s3
  
    /dev/vinum/vol:
    total 1
    brwxr-xr--  1 root  wheel   25,   2 Apr 13 16:46 s64
    drwxr-xr-x  3 root  wheel       512 Apr 13 16:46 s64.plex
  
    /dev/vinum/vol/s64.plex:
    total 1
    brwxr-xr--  1 root  wheel   25, 0x10000002 Apr 13 16:46 s64.p0
    drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 s64.p0.sd
  
    /dev/vinum/vol/s64.plex/s64.p0.sd:
    total 0
    brwxr-xr--  1 root  wheel   25, 0x20000002 Apr 13 16:46 s64.p0.s0
    brwxr-xr--  1 root  wheel   25, 0x20100002 Apr 13 16:46 s64.p0.s1
    brwxr-xr--  1 root  wheel   25, 0x20200002 Apr 13 16:46 s64.p0.s2
    brwxr-xr--  1 root  wheel   25, 0x20300002 Apr 13 16:46 s64.p0.s3</programlisting>

    <para>Apesar de não ser recomendado alocalçao de nomes específicos
    para plexes e subdiscos, os discos do Vinum devem ser nomeados.
    Isso torna possível mover um disco para uma outra localidade e ainda
    sim reconhace-lo automaticamente.  Os nomes dos discos podem conter
    até 32 caracteres.</para>
    
    <sect2>
      <title>Criando sistema de arquivos </title>

	<para>Volumes e discos parecem idênticos para um sistema, com
	uma exessão.  Ao contrário de discos &unix;, Vinum não particiona
	volumes, no qual então, não possui uma tabela de partições.
	Isso exigiu uma mudança em alguns utilitários de discos como
	&man.newfs.8;, onde previamente interpretou a última letra de um 
	nome de volume de Vinum como um	identificador de partições.  Por
	exemplo, uma partição de disco pode ter um nome como
	<devicename>/dev/ad0a</devicename> ou
	<devicename>/dev/da2h</devicename>.  Esses nomes representam a
	primeira partição (<devicename>a</devicename>) no primeiro (0)
	disco IDE (<devicename>ad</devicename>) e a oitava partição
	(<devicename>h</devicename>) no terceiro disco SCSI (2)
	(<devicename>da</devicename>), respectivamente.  Em contraste,
	um volume Vinum pode ser chamado de
	<devicename>/dev/vinum/concat</devicename>, um nome que não tem
	nenhum relacionamento com o nome da partição.</para>
	
	  
	<para>Normalmente, &man.newfs.8; interpreta o nome do disco e
	reclama se não entender.  Por exemplo:</para>
	
	<screen>&prompt.root; <userinput>newfs /dev/vinum/concat</userinput>
newfs: /dev/vinum/concat: can't figure out file system partition</screen>

	<note><para>O que segue só é valido para as versões de freeBSD
	anteriores a 5.0:</para></note>

	<para>Para criar um sistema de arquivos nesse volume, use a
	opção <option>-v</option> para &man.newfs.8;:</para>

	<screen>&prompt.root; <userinput>newfs -v /dev/vinum/concat</userinput></screen>

    </sect2>
  </sect1>
  
  <sect1 id="vinum-config">
    <title>Configurando Vinum</title>

    <para>O kernel <filename>GENERIC</filename> não contém Vinum.  É
    possível construir um kernel especial para incluir o Vinum, mas não
    é recomendado.  A maneira simples de iniciar o Vinum é com o módulo
    de kernel (<acronym>kld</acronym>).  Você nem precisa usar
    &man.kldload.8; para Vinum: quando você inicia &man.vinum.8;, ele
    verifica se o modulo foi carregado ou não, e o carrega
    automaticamente.</para>
    
    

    <sect2>
      <title>Inicialização</title>

      <para>Vinum armazena as informações de configuração das fatias de
      disco essencialmente da mesma forma que os arquivos de
      configuração.  Quando lendo do banco de dados de configuração,
      Vinum reconhece algumas palavras chave que não são permitidas nos
      arquivos de configuração.  Por exemplo, uma configuração de disco
      talves contenha o seguinte texto:</para>
      
      
	<programlisting>volume myvol state up
volume bigraid state down
plex name myvol.p0 state up org concat vol myvol
plex name myvol.p1 state up org concat vol myvol
plex name myvol.p2 state init org striped 512b vol myvol
plex name bigraid.p0 state initializing org raid5 512b vol bigraid
sd name myvol.p0.s0 drive a plex myvol.p0 state up len 1048576b driveoffset 265b plexoffset 0b
sd name myvol.p0.s1 drive b plex myvol.p0 state up len 1048576b driveoffset 265b plexoffset 1048576b
sd name myvol.p1.s0 drive c plex myvol.p1 state up len 1048576b driveoffset 265b plexoffset 0b
sd name myvol.p1.s1 drive d plex myvol.p1 state up len 1048576b driveoffset 265b plexoffset 1048576b
sd name myvol.p2.s0 drive a plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 0b
sd name myvol.p2.s1 drive b plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 524288b
sd name myvol.p2.s2 drive c plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 1048576b
sd name myvol.p2.s3 drive d plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 1572864b
sd name bigraid.p0.s0 drive a plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 0b
sd name bigraid.p0.s1 drive b plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 4194304b
sd name bigraid.p0.s2 drive c plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 8388608b
sd name bigraid.p0.s3 drive d plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 12582912b
sd name bigraid.p0.s4 drive e plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 16777216b</programlisting>
  
	<para>A diferença clara aqui é a presença explicita de
	informações sobre localidade e nomenclatura (Sendo as duas no
	caso permitidas, mas desencorajadas) e também informações sobre
	os estados (mas não são disponíveis para o usuário).  Vinum não
	armazena informações sobre os disco nas informações de
	configuração: ele acha os drives by scanning the configured
	disk drives for partitions with a Vinum label.  Isso abilita o
	Vinum a identificar discos corretamente, mesmo que eles tenham
	sido rotulados com uma diferente nomeação de drives
	&unix;.</para>
	
	
      <sect3 id="vinum-rc-startup">
	<title>Inicialização Automática</title>

        <para>Para iniciar o Vinum automaticamente quando você boota o
	sistema, afirme-se de que você tem a seguinte linha no seu
	<filename>/etc/rc.conf</filename>:</para>
	

	<programlisting>start_vinum="YES"		# set to YES to start vinum</programlisting>

	<para>Se o seu sistema não possuir o arquivo
	<filename>/etc/rc.conf</filename>, crie um com esse conteúdo.
	Isso fará com que o sistema carregue o Vinum
	<acronym>kld</acronym> na inicialização, e inicie qualquer
	objeto citado na configuração.  Isso é feito antes de montar os
	sistemas de arquivos, então, é possível fazer automaticamente um 
	&man.fsck.8; e montar os sistemas de arquivo nos volumes de
	Vinum.</para>
	

	<para>Quando você inicia Vinum com o comando <command>vinum
	start</command>, Vinum lê a base de dados de configuração de um
	dos discos do Vinum.  Sobre circunstâncias normais, cada um dos
	discos contém uma cópia idêntica da base de dados de
	configuração, então não importa que disco é lido.  Embora, após
	uma pane, Vinum tem que determinar qual o disco foi atualizado
	mais recentemente e ler as configurações desse disco.  E então
	as atualiza, se necessário, progressivamente do	disco mais
	velho.</para>
	
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="vinum-root">
    <title>Usando Vinum para o sistemas de arquivos raiz</title>
    

    <para>Para uma máquina que esta espelhada por inteiro usando Vinum,
    é desejável espelhar também o sistema de arquivos raiz.  Setar
    tal configuração é menos trivial do que espelhar um disco
    arbitrário:</para>

    <itemizedlist>
      <listitem>
	<para>O sistema de arquivos raiz deve estar disponível bem
	cedo durante o processo de inicialização, então a infraestrutura
	do Vinum deveria estar disponível também nessa hora.</para> 
      </listitem>
      <listitem><para>O volume contendo os arquivos de sistema raiz também
      contém o bootstap de sistema e o kernel, no qual tem que ser lido
      pela utilidade nativa de sistema (ex. A BIOS no caso dos PC's)
      onde frequentemente não pode ser ensinada sobre os detalhes do
      Vinum.</para>
      </listitem>
    </itemizedlist>

    <para>Nas sessões que seguem, o termo <quote>root volume</quote> é
    usado para descrevero volume de Vinum que contém os sistemas de
    arquivo raiz.  É provávelmente uma boa idéia usar o nome
    <literal>"root"</literal> para esse volume, mas isso não é de
    maneira nenhuma obrigatório.  Apesar de que todos os exemplos
    de comandos nas sessões seguintes assumem esse nome.</para>



    <sect2>
      <title>Iniciando o Vinum a tempo para o sistema de arquivos raiz
      </title>

      <para>Existem algumas medidas a se tomar para que isso aconteça:
      </para>

      <itemizedlist>
	<listitem>
	  <para>Vinum precisa estar disponível no kernel na hora do
	  boot.  Então, o método para iniciar automaticamente o Vinum
	  descrito em <xref linkend="vinum-rc-startup"> não é aplicável
	  nesse caso, e o parâmetro <literal>start_vinum</literal> não
	  pode estar ativado quando a seguinte configuração estiver
	  sendo arrumada.  A primeira opção seria compilar o Vinum
	  staticamente no kernel, então estara disponível o tempo todo,
	  mas isso também não e sempre desejável.  Existe outra opção no
	  entanto, que seria fazer com que o
	  <filename>/boot/loader</filename> (<xref
	  linkend="boot-loader">) carregue o módulo de kenel do vinum
	  cedo, antes de iniciar o kernel.  Isso pode ser feito
	  adicionando a seguinte linha</para>
	  

	  <para><literal>vinum_load="YES"</literal></para>

	  <para>no arquivo
	    <filename>/boot/loader.conf</filename>.</para>
	</listitem>

	<listitem>
	  <para>Vinum deve ser iniciado cedo pois ele precisa suprir o
	  volume para os arquivos de sistemas raiz.  Por padrão, a parte
	  do kernel do vinum não esta procurando por discos que possam
	  conter informações de volume de vinum até que o administrador
	  (ou um dos scripts de inicialização) lance o comando
	  <command>vinum start</command>.</para>
	  

	  <note><para>Os parágrafos seguintes descrevem os passos
	  necessários para o FreeBSD 5.x e superiores.  os passos
	  obrigatórios para o 4.x, são diferentes e estão descritos a
	  baixo em <xref linkend="vinum-root-4x">.</para></note>
	  

	  <para>colocando a linha:</para>
	  

	  <para><literal>vinum.autostart="YES"</literal></para>

	  <para>em <filename>/boot/loader.conf</filename>, Vinum é
	    instruido para procurar automaticamente em todos os discos
	    por informações úteis a ele como parte da inicialização do
	    kernel.</para> 

	  <para>Note que não é necesário ensinar ao kernel aonde
	  procurar pelos arquivos de sistema raiz.
	  <filename>/boot/loader</filename> procura o nome do
	  dispositivo raiz em <filename>/etc/fstab</filename>, e passa
	  essa informação para o kernel.  Quando chega a hora de montar
	  os arquivos de sistema raiz, o kernel descobre a partir do nome
	  do dispositivo fornecido qual é o disco que se deve pedir para
	  passar o nome do dispositivo raiz para um numero de
	  identificação interna de dispostivo.</para>
	  
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Tornando um volume raiz baseado em vinum accessível para o
      <literal>Bootstrap</literal>
      

      <para>Visto que o atual <literal>Bootstrap</literal> do FreeBSD
      contém apenas 7.5 KB de código, e já tem o trabalho de ler
      arquivos de UFS (como <filename>/boot/loader</filename>), é
      completamente impossível ensiná-lo também sobre as estruturas
      internas do vinum para que ele possa analizar os dados de
      configuração do vinum, e descobrir sozinho os elementos de um
      volume de inicialização.  Dessa forma, alguns truques são
      necessários para fornecer ao código do
      <literal>bootstrap</literal> a ilusão de que ele é uma partição
      <literal>"a"</literal> padrão que contém o arquivo de sistem
      raiz.</para>
     
      
      <para>Para que isso se torne possível, os seguintes requisitos
      para o volume rzia devem ser compridos:</para>
      

      <itemizedlist>
	<listitem>
	  <para>o volume raiz não pode estar partido ou em RAID-5.</para>
	</listitem>

	<listitem>
	  <para>Um volume raiz não pode conter mais de um sublink
	  concatenado por plex.
	</listitem>
      </itemizedlist>

      <para>Note que é desejado e possivel que existam multiplos plexes,
      cada um contendo uma réplica do sistema de arquivos raiz.  O
      processo de bootstrap ira, entretanto, usar somente uma delas para
      achar o bootstrap e todos os arquivos, até que o próprio kernel
      monte os sistemas de arquivos.  cada subdisco dentro desse plex
      ira então precisar da sua própria partição imaginária
      <literal>"a"</literal>, para que o dispositivo correspondente se
      torne bootável.  Não é strictly necessário que cada uma dessa falsa
      partição <literal>"a"</literal> se encontre no mesmo offset junto
      ao seu dispositivo, comparado com outros plexes do volume raiz.
      Entretanto, seria provavelmente uma boa ideia criar os volumes do
      vinum desse jeito para que os dispositivos espelhados sejam
      simetricos evitando assim confusão</para>
      
	
      <para>Para setar essas partições <literal>"a"</literal>, para cada
      dispositivo contendo parte do volume raiz, as etapas segintes
      precisam ser realizadas:</para>
      
      <procedure>
	<step>
	  <para>A localização (offset do início do dispositivo) e tamanho
	  dos subdiscos dos dispositivos que fazem parte do volume raiz
	  precisam ser avaliados usando o comando</para>
	  
	  <para><command>vinum l -rv root</command></para>

	  <para>note que em Vinum, os offsets e tamanhos são medidos em
	  bytes.  Eles precisam ser divididos por 512 para obter o
	  número de blocos que irão, por sua vez, ser usados no comando
	  <command>disklabel</command>.</para> 
	</step>

	<step>
	  <para>Execute o comando</para>

	  <para><command>disklabel -e
	    </command><replaceable>devname</replaceable></para>

	  <para>Para cada dispositivo que participa no volume raiz.
	  <replaceable>devname</replaceable> deve ser ou o nome do disco
	  (exemplo <devicename>da0</devicename>) para discos sem tabela
	  de partições (ex. fdisk), ou o nome da partição (exemplo
	  <devicename>ad0s1</devicename>).</para>
	 
	  <para>Se já existir uma partição <literal>"a"</literal> no
	  dispositivo (presumidamente, contendo um sistema de arquivos 
	  raiz pré-vinum), essa deve ser renomeada, permanecendo
	  acessível (por segurança), mas não será mais usado para
	  bootstrap como padrão.  Note que partições ativas (como um
	  sistema de arquivo raiz atualmente montado) não podem ser
	  renomeadas, então isso deve ser feito quando a máquina é
	  inicializada por um modo de <quote>Reparo</quote>, ou em um
	  processo de duas etapas, onde (em uma situação de
	  espelhamento) o disco que não foi usado no boot será
	  manipulado primeiro.</para>
	 

	  <para>Então, o offset da partição de Vinum nesse dispositivo
	  (se existente) deve ser adicionado ao offset do subdisco de
	  volume raiz respectivo desse mesmo dispositivo.  O valor
	  resultante passara a ser o valor <literal>"offset"</literal> 
	  para a nova partição <literal>"a"</literal>.  O valor do 
	  <literal>"tamanho"</literal> dessa partição pode ser tirado
	  literalmente do cálculo acima.  O <literal>"fstype"</literal>
	  deve ser <literal>4.2BSD</literal>.  Os valores de
	  <literal>"fsize"</literal>, <literal>"bsize"</literal>, e
	  <literal>"cpg"</literal> devem ser escolhidos para melhor
	  se adaptar ao atual sistema, apesar de que, eles não são muito
	  importantes dentro desse contexto.</para>
	 

	  <para>Dessa forma, uma nova partição <literal>"a"</literal>
	  será formada e irá envolver as partições de vinum nesse
	  dipositivo.  Note que o <command>disklabel</command> só vai
	  permitir isso se as partições de vinum tiverem sido
	  propriamente marcadas usando o <literal>"vinum"</literal>
	  fstype.</para>
	</step>

	<step>
	  <para>Isso é tudo!  Uma falsa partção <literal>"a"</literal>
	  agora existe em cada dispositivo que tenha uma réplica do
	  volume raiz.  É altamente recomendável verificar o resuldado
	  novamente, usando um comando como</para>
	  
	  <para><command>fsck -n
	    </command><devicename>/dev/<replaceable>devname</replaceable>a</devicename></para>
	</step>
      </procedure>

      <para>deve ser lembrado que todos os arquivos que contém
      informações de controle, devem ser relacionadas com o sistema de
      arquivos raiz no volume de vinum onde, quando setando um novo
      volume raiz do vinum, talves não seja igual ao que esta em uso.
      Então, em particular, os arquivos <filename>/etc/fstab</filename>
      e <filename>/boot/loader.conf</filename> irão precisar de
      cuidados.<para>
      
      <para>Na próxima reinicialização, o bootstrap deve descobrir a
      informação de controle apropriada a partir do novo aruivo de
      sistemas raiz do vinum, e agir de acordo.  No final do processo de
      inicialização do kernel, depois que todos os dispositivos forem
      anunciados, a notícia importante que mostra o sucesso dessa
      configuração é uma mensagem como:</para>
      
      <para><screen>Mounting root from ufs:/dev/vinum/root</screen></para>
    </sect2>

    <sect2>
      <title>Example of a Vinum-based Root setup</title>

      <para>Depois que o volume raiz do Vinum estiver ativado, a saida
      de <command>vinum l -rv root</command> poderia parecer com:</para>

      <para>
	<screen>
...
Subdisk root.p0.s0:
		Size:        125829120 bytes (120 MB)
		State: up
		Plex root.p0 at offset 0 (0  B)
		Drive disk0 (/dev/da0h) at offset 135680 (132 kB)

Subdisk root.p1.s0:
		Size:        125829120 bytes (120 MB)
		State: up
		Plex root.p1 at offset 0 (0  B)
		Drive disk1 (/dev/da1h) at offset 135680 (132 kB)
	</screen>
      </para>

      <para>Os valores a serem notados são <literal>135680</literal>
      para o offset (relativo à partição
      <devicename>/dev/da0h</devicename>).  Isso traduz a 265 blocos de
      disco de 512-byte em termos de <command>disklabel</command>.  Da
      mesma forma, o tamanho desse volume raiz é de 245760 blocos de
      512-byte.  <devicename>/dev/da1h</devicename>, contendo a segunda
      réplica desse volume raiz, tem uma configuração simérica.</para>
      

      <para>O disklabel para esses dispositivos devem se parecer
      com:</para>
      
      <para>
	<screen>
...
8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  a:   245760      281    4.2BSD     2048 16384     0   # (Cyl.    0*- 15*)
  c: 71771688        0    unused        0     0         # (Cyl.    0 - 4467*)
  h: 71771672       16     vinum                        # (Cyl.    0*- 4467*)
	</screen>
      </para>

      <para>Pode ser observado que o parâmetro <literal>"size"</literal>
      para a partição <literal>"a"</literal> falsa bate com o valor
      esboçado acima, enquanto o parâmetro <literal>"offset"</literal> é
      a soma do offset dentro da partição de vinum
      <literal>"h"</literal>, e o offset dessa partição dentro do
      dispositivo (ou fatia).  Essa é a configuração típica necessária
      para evitar os problemas descitos em <xref
      linkend="vinum-root-panic">.  Pode também ser visto que toda
      partição <literal>"a"</literal> etsá completamente dentro da
      partição <literal>"h"</literal> contendo todos os dados do vinum
      para esse dispositivo.</para> 
     
    
      <para>Note que no exemplo acima, o dispositivo inteiro esta
      dedicado ao vinum, e não há nenhum resto de partição raiz
      pre-vinum, partindo de que esse foi um disco com configurações
      novas e foi apenas pretendido a ser parte de uma configuração de
      vinum, sempre.</para>
    </sect2>

    <sect2>
      <title>Troubleshooting</title>

      <para>If something goes wrong, a way is needed to recover from
	the situation.	The following list contains few known pitfalls
	and solutions.</para>

      <sect3>
	<title>System Bootstrap Loads, but System Does Not Boot</title>

	<para>If for any reason the system does not continue to boot,
	  the bootstrap can be interrupted with by pressing the
	  <keycap>space</keycap> key at the 10-seconds warning.	 The
	  loader variables (like <literal>vinum.autostart</literal>)
	  can be examined using the <command>show</command>, and
	  manipulated using <command>set</command> or
	  <command>unset</command> commands.</para>

	<para>If the only problem was that the Vinum kernel module was
	  not yet in the list of modules to load automatically, a
	  simple <command>load vinum</command> will help.</para>

	<para>When ready, the boot process can be continued with a
	  <command>boot -as</command>.	The options
	  <option>-as</option> will request the kernel to ask for the
	  root filesystem to mount (<option>-a</option>), and make the
	  boot process stop in single-user mode (<option>-s</option>),
	  where the root filesystem is mounted read-only.  That way,
	  even if only one plex of a multi-plex volume has been
	  mounted, no data inconsistency between plexes is being
	  risked.</para>

	<para>At the prompt asking for a root filesystem to mount, any
	  device that contains a valid root filesystem can be entered.
	  If <filename>/etc/fstab</filename> had been set up
	  correctly, the default should be something like
	  <literal>ufs:/dev/vinum/root</literal>.  A typical alternate
	  choice would be something like
	  <userinput>ufs:da0d</userinput> which could be a
	  hypothetical partition that contains the pre-Vinum root
	  filesystem.  Care should be taken if one of the alias
	  <literal>"a"</literal> partitions are entered here that are
	  actually reference to the subdisks of the Vinum root device,
	  because in a mirrored setup, this would only mount one piece
	  of a mirrored root device.  If this filesystem is to be
	  mounted read-write later on, it is necessary to remove the
	  other plex(es) of the Vinum root volume since these plexes
	  would otherwise carry inconsistent data.</para>
      </sect3>

      <sect3>
	<title>Only Primary Bootstrap Loads</title>

	<para>If <filename>/boot/loader</filename> fails to load, but
	  the primary bootstrap still loads (visible by a single dash
	  in the left column of the screen right after the boot
	  process starts), an attempt can be made to interrupt the
	  primary bootstrap at this point, using the
	  <keycap>space</keycap> key.  This will make the bootstrap
	  stop in stage two, see <xref linkend="boot-boot1">.  An
	  attempt can be made here to boot off an alternate partition,
	  like the partition containing the previous root filesystem
	  that has been moved away from <literal>"a"</literal>
	  above.</para>
      </sect3>

      <sect3 id="vinum-root-panic">
	<title>Nothing Boots, the Bootstrap
	  Panics</title>

	<para>This situation will happen if the bootstrap had been
	  destroyed by the Vinum installation.	Unfortunately, Vinum
	  accidentally currently leaves only 4 KB at the beginning of
	  its partition free before starting to write its Vinum header
	  information.	However, the stage one and two bootstraps plus
	  the disklabel embedded between them currently require 8 KB.
	  So if a Vinum partition was started at offset 0 within a
	  slice or disk that was meant to be bootable, the Vinum setup
	  will trash the bootstrap.</para>

	<para>Similarly, if the above situation has been recovered,
	  for example by booting from a <quote>Fixit</quote> medium,
	  and the bootstrap has been re-installed using
	  <command>disklabel -B</command> as described in <xref
	  linkend="boot-boot1">, the bootstrap will trash the Vinum
	  header, and Vinum will no longer find its disk(s).  Though
	  no actual Vinum configuration data or data in Vinum volumes
	  will be trashed by this, and it would be possible to recover
	  all the data by entering exact the same Vinum configuration
	  data again, the situation is hard to fix at all.  It would
	  be necessary to move the entire Vinum partition by at least
	  4 KB off, in order to have the Vinum header and the system
	  bootstrap no longer collide.</para>
      </sect3>
    </sect2>

    <sect2 id="vinum-root-4x">
      <title>Diferença para o freeBSD 4.x</title>

      <para>Com o freeBSD 4.x, algumas funções internas são obrigatórias
      para fazer com que o vinum procure por todos os discos, e o código
      que desobre o número de identidade interno do dispositivo raiz não
      é inteligênte suficiente para suportar nomes como
      <devicename>/dev/vinum/root</devicename> automaticamente.  Então,
      as coisas são um pouco diferentes aqui.</para>
     
      <para>Vinum precisa ser informado dos discos exatos que ele tem
      que procurar, use uma linha parecida com a seguinte em
      <filename>/boot/loader.conf</filename>:</para>
      
      <para><literal>vinum.drives="/dev/<replaceable>da0</replaceable>
	/dev/<replaceable>da1</replaceable>"</literal></para>

      <para>É importante que todos os discos que contém dados do vinum
      sejam mencionados.  Não será prejudicial se discos a
      <emphasis>mais</emphasis> forem listados, e nem é necessário
      adicionar cada fatia ou cada partição explicitamente, porque o
      vinum irá procurar  por cabeçalhos válidos para ele em todos as
      partições dos discos citados.</para>
      

      <para>a partir do momento em que as rotinas usadas para passar o
      nome do arquivo de sistema raiz e para produzir o device ID
      (major/minor number) estão preparadas apenas para suportar nomes
      de dispositivos <quote>clássicos</quote> como
      <devicename>/dev/ad0s1a</devicename>, eles não podem fazer o menor
      sentido em um nome de volume raiz do tipo
      <devicename>/dev/vinum/root</devicename>.  Por esta razão, o
      próprio vinum precisa setar antecipadamente o parâmero interno de
      kernel que armazena o número de identidade do dispositivo raiz
      durante a sua inicialização.  Isso é feito setando a variável
      <literal>vinum.root</literal> com o valor do nome do volume
      raiz.  A entrada em <filename>/boot/loader.conf</filename> para
      efetuar essa tarefa se parece com:</para>
      
      <para><literal>vinum.root="root"</literal></para>

      <para>Agora, quando a inicialização do kernel tenta descobrir o
      dispositivo raiz a ser montado, vê se algum modulo de kernel 
      
      Now, when the kernel initialization tries to find out the
	root device to mount, it sees whether some kernel module has
	already pre-initialized the kernel parameter for it.  If that
	is the case, <emphasis>and</emphasis> the device claiming the
	root device matches the major number of the driver as figured
	out from the name of the root device string being passed (that
	is, <literal>"vinum"</literal> in our case), it will use the
	pre-allocated device ID, instead of trying to figure out one
	itself.	 That way, during the usual automatic startup, it can
	continue to mount the Vinum root volume for the root
	filesystem.</para>

      <para>However, when <command>boot -a</command> has been
	requesting to ask for entering the name of the root device
	manually, it must be noted that this routine still cannot
	actually parse a name entered there that refers to a Vinum
	volume.  If any device name is entered that does not refer to
	a Vinum device, the mismatch between the major numbers of the
	pre-allocated root parameter and the driver as figured out
	from the given name will make this routine enter its normal
	parser, so entering a string like
	<userinput>ufs:da0d</userinput> will work as expected. Note
	that if this fails, it is however no longer possible to
	re-enter a string like <userinput>ufs:vinum/root</userinput>
	again, since it cannot be parsed.  The only way out is to
	reboot again, and start over then.  (At the
	<quote>askroot</quote> prompt, the initial
	<devicename>/dev/</devicename> can always be omitted.)</para>
    </sect2>
  </sect1>
</chapter>
