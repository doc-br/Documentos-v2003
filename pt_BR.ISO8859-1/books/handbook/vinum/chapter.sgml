<!--
	The Vinum Volume Manager
	By Greg Lehey (grog at lemis dot com)

	Added to the Handbook by Hiten Pandya <hiten@uk.FreeBSD.org>
	and Tom Rhodes <trhodes@FreeBSD.org>

	For the FreeBSD Documentation Project
	$FreeBSD: doc/en_US.ISO8859-1/books/handbook/vinum/chapter.sgml,v 1.25 2003/11/05 10:36:56 ceri Exp $
-->

<chapter id="vinum-vinum">
  <title>O Gerenciador de Volumes Vinum</title>
  
  <sect1 id="vinum-synopsis">
    <title>Sinópse</title>

    <para>Não importa quais discos você tem, eles sempre terão
     limitações
    
      <itemizedlist>
	<listitem>
	  <para>Eles podem ser pequenos demais.</para>
	</listitem>

	<listitem>
	  <para>Eles podem ser lentos demais.</para>
	</listitem>

	<listitem>
	  <para>Eles podem ser pouco seguros.</para>
	</listitem>
      </itemizedlist>
  </sect1>

  <sect1 id="vinum-intro">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Greg</firstname>
	  <surname>Lehey</surname>
	  <contrib>Originally written by </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>Discos são muito pequenos</title>

    <indexterm><primary>Vinum</primary></indexterm>
    <indexterm><primary>RAID</primary>
    <secondary>Software</secondary></indexterm>
   
    <para><emphasis>Vinum</emphasis> o chamado <emphasis>Gerenciador de
    Volumes</emphasis> é o disco virtual que trata destes três
    problemas, vamos analiza-los com mais detalhes.  Soluções para estes
    problemas tem sido propostas e implementadas:</para>

    <para>os discos estão ficando maiores, mas os requisitos para
    armazenamento de dados também.  Frequentemente você vai querer um
    sistema de arquivos maior do que o disco que você tem disponível.
    Reconhecidamente, este problema já não é tão agudo com era a dez
    anos atrás, mas ele ainda existe.  Alguns sistemas resolveram isso
    criando um dispositivo abstrato onde armazenam seus dados em um
    número de discos.</para>
  </sect1>

  <sect1 id="vinum-access-bottlenecks">
    <title>Gargalo de acesso</title>

    <para>Sistemas modernos frequentemente precisam acessar dados de uma
    maneira incrívelmente rápida.  Por exemplo, grandes servidores de
    FTP e HTTP podem manter milhares de sessões ao mesmo tempo e podem
    ter multiplas conexões de 100&nbsp;Mbit/s com o mundo externo, bem
    além das taxas de transmisão da maioria dos discos.</para>
    
    <para>Os discos atuais podem transferir dados sequencialmente em até
    70&nbsp;MB/s, mas este valor é de pouca importância em um ambiente
    onde muitos processos independentes acessam  um disco, onde eles
    talvez atinjam apenas uma fração desse valor.  Nesses casos é mais
    importante observar o problema do ponto de vista do subsystem: o
    parametro importante é a carga que uma transferência coloca no
    subsystem, em outras palavras, o tempo em que a transferência ocupa
    os discos envolvidos.</para>
       
    <para>Em qualquer operação de transferência, o disco
    deve primeiramente posicionar as cabeças de leitura e esperar até
    que o primeiro setor passe em baixo delas e depois sim executar a
    transferência.  Esses atos podem ser considerados com se fossem
    atômicos: não faz o menor sentido interromper eles.</para>
    
    <para><anchor id="vinum-latency">Considere uma transferência
    típica de aproximadamente 10&nbsp;kB: a geração atual de discos de
    alta performance podem posicionar as cabeças em uma média de
    3.5&nbsp;ms.  Os discos mais rápidos giram em 15.000&nbsp;rpm,
    então, a rotação latente média (metade de uma revolução) é de
    2&nbsp;ms.  Em 70&nbsp;MB/s, a transferência propriamente dita, leva
    em torno de 150&nbsp;&mu;s, o que é quase nada comprado com o
    tempo de posicionamento.  Em tal caso, a taxa efetiva de
    transferência fica um pouco maior que 1&nbsp;MB/s e é altamente
    dependente no tamanho do que vai ser transferido, é claro.</para>

    <para>A solução óbvia e tradicional para esse gargalo é <quote>more
    spindles</quote>: ele usa vários discos pequenos  com a mesma
    capacidade de armazenamento em vez de usar um outro disco grande.
    Cada disco é capaz de se posicionar e transferir dados de maneira
    independente, então o ritmo de transferência efetivo, cresce a uma
    taxa próxima ao número de discos usados.</para>

    <para>O ritmo de transferência exato é, claramente, menor que o
    número de discos envolvidos: apesar de cada disco ser capaz de relizar
    transferencias em paralelo, não existe nenhuma forma de se assegurar
    que as solicitações estão distribuidas de maneira uniforme entre os
    discos.  Inevitavelmente a carga no disco será maior do que no
    outro.</para> 
    
    <indexterm>
      <primary>concatenação de dicos</primary>
    </indexterm>
    <indexterm>
      <primary>Vinum</primary>
      <secondary>concatenação</secondary>
    </indexterm>

    <para>A distribuição equilibrada da carga nos discos é fortemente
    dependente do modo em que os dados são compartilhados entre eles.
    No próximo debate, seria conveniente visualizar um disco como se
    fosse um grande número de setores de dados mapeados por números,
    como as páginas de um livro.  O método mais simples seria dividir o
    disco virtual em pequenos grupos de setores consecutivos do tamanho
    do disco físico individual e depois armzená-los desse jeito,
    semelhante a pegar um livro grande e dividí-lo em pequenas sessões.
    Esse étodo é chamado de <emphasis>concatenação</emphasis> e tem a
    vantagem que os discos não precisam ter nenhum tipo de
    relacionamento quanto a tamanho.  Funciona bem quando o acesso ao
    disco virtual é dividido de maneira igual entre os seus espaços
    mapeados.  Quando o acesso é concentrado uma área menor, o
    aumento no desempenho é menos acentuado.  A <xref linkend="vinum-concat"> 
    ilustra a seqüência na qual as unidades de armazenamento são
    alocadas em uma organização concatenada.
    </para> 
    <para>
      <figure id="vinum-concat">
	<title>Organização Concatenada</title>
	<graphic fileref="vinum/vinum-concat">
      </figure>
    </para>

    <indexterm>
      <primary>striping de discos</primary>
    </indexterm>
    <indexterm>
      <primary>Vinum</primary>
      <secondary>striping</secondary>
    </indexterm>

    <para>Um mapeamento alternativo é dividir o espaço de endereçamento em
    componentes menores, de tamanhos iguais e armazená-los
    seqüencialmente em discos diferentes.  Por exemplo, os primeiros 256
    setores poderiam ser armazenados no primeiro disco, os 256 setores
    seguintes no próximo disco e assim por diante.  Depois de preencher
    o último disco o processo se repete até que os discos estejam cheios.
    Esse mapemento é chamado de <emphasis>striping</emphasis> ou
    <acronym>RAID-0</acronym>.
    
    <footnote>
      <indexterm><primary>RAID</primary></indexterm>
    
      <para><acronym>RAID</acronym> (Redundant Array of Inexpensive
      Disks) significa <emphasis>Vetor redundante de discos
      baratos</emphasis> e oferece várias formas de tolerância de erros,
      apesar de que um termo um pouco equivocado, pois não fornece
      redundância.</para> </footnote>.

    O <foreignphrase>striping</foreignphrase> exige um esforço grande
    para localizar os dados e isso causa carga adicional de I/O onde a
    tranferência é distribuida para diversos discos, mas pode também
    fornecer uma carga constante entre os discos.  <xref linkend="vinum-striped"> 
    ilustra uma seqüência em que as unidades de armazenamento são
    alocadas em uma organização <foreignphrase>striped</foreignphrase>.</para>
    
    <para>
      <figure id="vinum-striped">
        <title>Organização Striped</title>
	<graphic fileref="vinum/vinum-striped">
      </figure>
    </para>
  </sect1>

  <sect1 id="vinum-data-integrity">
    <title>Integridade de dados</title>

      <para>O outro problema com os discos atuais é que eles não são
      confiáveis.  Apesar do crescimento significativo na credibilidade
      dos discos nos últimos anos, esses ainda são um dos componentes
      do núcleo de servidor com a maior possibilidade de falhar.  E
      quando eles falham, os resultados podem ser catastróficos:
      substituir um disco e recuperar seus dados pode levar dias.</para>
      
      <indexterm>
	<primary>espelhamento de disco</primary>
      </indexterm>
      <indexterm>
	<primary>Vinum</primary>
	<secondary>espelhamento</secondary>
      </indexterm>
      <indexterm>
	<primary>RAID-1</primary>
      </indexterm>
      
      <para>O método tradicional de abordar esse problema tem sido o
      <emphasis>espelhamento</emphasis>, mantendo duas cópias dos dados
      em dois lugares físicos distintos.  Desde da aparição dos níveis
      de <acronym>RAID</acronym>, essa técnica de espelhamento também é
      chamada de <acronym>RAID nível 1</acronym> ou
      <acronym>RAID-1</acronym>.  Qualquer escrita feita no volume
      é realizada nas duas localidades, a leitura pode ser feita a partir
      de uma delas, então se o disco falhar, os dados ainda estarão
      disponíveis no outro.</para>
      
      <para>O espelhamento tem dois problemas:</para>
    
	<itemizedlist>
	  <listitem>
	    <para>O preço.  Exige duas vezes mais armazenamento de disco
	    do que uma solução sem redundância.</para>
	  </listitem>

	  <listitem>
	    <para>O impacto de performance.  A escrita deve ser feita para
	    os dois discos, devido a isso eles usam duas vezes mais
	    largura de banda do que um volume não espelhado.  Na leitura
	    não há queda de performance: chega até a parecer que está
	    mais rápido.</para>
	  </listitem>
	</itemizedlist>

      <para><indexterm><primary>RAID-5</primary></indexterm>Uma solução
      alternativa é a <emphasis>paridade</emphasis>, implementada nos níveis
      2, 3, 4 e 5 do <acronym>RAID</acronym>.  Dentre esses,
      <acronym>RAID-5</acronym> é o mais interessante.  Como
      implementado no Vinum, é uma variante na organização
      <foreignphrase>striped</foreignphrase> onde dedica um bloco de
      cada fatia à paridade dos outros blocos.  Conforme implementado no
      Vinum, um plex <acronym>RAID-5</acronym> é parecido com um plex
      <foreignphrase>striped</foreignphrase>, exceto que ele implementa
      o <acronym>RAID-5</acronym> incluindo um bloco de paridade em
      cada fatia.  Como exigido pelo <acronym>RAID-5</acronym>, o local
      do bloco de paridade muda de uma fatia para a outra.  Os números nos
      blocos de dados indicam o número relativo do bloco.</para>

      <para>
	<figure id="vinum-raid5-org">
	  <title>Organização RAID-5</title>
	  <graphic fileref="vinum/vinum-raid5-org">
	</figure>
      </para>

      <para>Comparado com espelhamento, <acronym>RAID-5</acronym> tem a
      vantagem de requerer significativamente menos espaço de
      armazenameto.  O acesso de leitura é parecido com o utilizado nas
      organizações <foreignphrase>striped</foreignphrase>, mas o acesso
      à escrita é bem reduzido, chega a até 25% da performance de
      leitura aproximadamente.  Se uma partição falha, o vetor pode
      continuar a operar em modo degradado: a leitura das partições
      acessíveis restantes continua normalmente, mas a leitura da
      partição danificada é recalculada pelo bloco correspondente de
      todos os discos restantes.</para>
  </sect1>

  <sect1 id="vinum-objects">
    <title>Objetos do Vinum</title>
      <para>Para que o Vinum possa solucionar esse problema, ele
      implementa uma hierarquia de objetos em quatro níveis:</para>

      <itemizedlist>
	<listitem>
	  <para>O objeto mais visível é o disco virtual, chamado de
	  <emphasis>volume</emphasis>.  Volumes tem essencialmente as
	  mesmas propriedades de uma partição &unix;, contudo tem
	  algumas pequenas diferenças.  Eles não tem nenhuma limitação
	  de tamanho.</para>
	</listitem>

	<listitem>
	  <para>Volumes são compostos de <emphasis>plexes</emphasis>, no
	  qual representa o espaço total de adressamento de um volume.
	  Dessa forma, esse nível na hierarquia fornece redundância.
	  Pense em plexes como uma partição individual em um vetor
	  clonado, cada um contendo os mesmos dados.</para>
	</listitem>

	<listitem>
	  <para>Desde que o Vinum exista no sistema de armazenamento de
	  discos &unix;, seria possível usar partições &unix; como um
	  bloco de construção para plexes de múltiplos discos, mas no
	  final isso acaba sendo muito inflexível: o número de partições
	  de um disco &unix; é limitado.  Ao contrário, Vinum subdivide
	  uma única partição &unix; (os <emphasis>discos do
	  vinum</emphasis>) em área contínuas chamadas
	  <emphasis>subdiscos</emphasis>, os quais são usados como
	  blocos de construção para plexes.</para>
	</listitem>
      
	<listitem>
	  <para>Subdiscos residem em discos do Vinum.  Atualmente
	  partições &unix;.  Com a exceção de uma pequea área no começo
	  do disco, a qual é usada para armazenamento de informações de
	  configuração e estado, o disco todo fica disponível para
	  armazenamento de dados.</para>
	</listitem>
      </itemizedlist>

      <para>As sessões seguintes descrevem o modo com que esses objetos
      fornecem a funcionalidade requerida pelo Vinum.</para>

    <sect2>
      <title>Considerações de um tamanho de volume</title>

      <para>Plexes podem ter muitos subdiscos espalhados por todas as 
      partições nas configurações do vinum.  Como resultado, o tamanho
      de uma prtição original não limta o tamanho nem de um plex e nem
      de um volume.</para>
    </sect2>
    
    <sect2>
      <title>Armazenamento de Dados Redundante</title>
      <para>Vinum implementa espelhamento anexando múltiplos plexes a um
      volume.  Cada plex é a representação dos dados de um volume.  Um
      volume pode conter de um a oito plexes.</para>
      
      <para>Apesar de um plex repesentar os dados completos de um
      volume, é possivel que partes da representação estejam fisicamente
      ausentes, seja por planejamento (por não definir um subdisco como
      parte de um plex), ou por acidente (como resultado de uma falha no
      disco).  Contanto que, pelo menos um plex possa fornecer dados para a
      extenção completa de endereço do volume, o sistema é completamente
      funcional.</para>
    </sect2>
    
    <sect2>
      <title>Questões de performance</title>
      
      <para>Vinum implementa no nível do plex tanto concatenação
      quanto striping:</para>
      
      <itemizedlist>
	<listitem>
	  <para>Um <emphasis>plex concatenado</emphasis> usa um espaço de
	  endereçamento de cada subdisco por vez.</para>
	</listitem>

	<listitem>
	  <para>Um <emphasis>plex striped</emphasis> distribui os dados
	  entre cada subdisco.  Todos os subdiscos têm que ter o mesmo
	  tamanho, e é preciso que existam pelo menos dois subdiscos
	  para que eles possam ser distinguidos a partir de um plex
	  concatenado.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Qual organização plex?</title>
     
     <para>A versão do Vinum suprida com o FreeBSD &rel.current;
     implementa dois tipos de plexes:</para>
     
      <itemizedlist>
	<listitem>
	  <para>Plexes concatenados são os mais flexíveis: eles podem
	  conter infinitos números de subdiscos e os subdiscos podem ser
	  de tamanhos diferentes.  Os plexes podem ser extendendidos
	  adicionando subdiscos.  Eles requerem menos tempo de 
	  <acronym>CPU</acronym> do que plexes
	  <foreignphrase>striped</foreignphrase>, mas a diferença
	  em sobrecarga de <acronym>CPU</acronym> não da para ser medida.
	  Por outro lado, eles são mais sucetíveis a <literal>hot
	  spots</literal>, onde um disco é muito ativo e outros estão
	  ociosos.</para>
        </listitem>

	<listitem>
	  <para>A grande vantágem de plexes <foreignphrase>striped</foreignphrase>
	  (<acronym>RAID-0</acronym>) é que eles reduzem os <literal>hot
	  spots</literal>: escolhendo o melhor tamanho de
	  <foreignphrase>stripe</foreignphrase> (mais ou menos
	  256&nbsp;kB), você pode igualar a carga nos discos
	  componentes.  As desvantagens dessa escolha são códigos
	  (fracionalmente) mais complexos e restrições em subdiscos:
	  eles tem que ser todos do mesmo tamanho, e extender um plex
	  através da adição de um novo subdisco é tão complicado que
	  Vinum atualmente nem o implementa.  Vinum impõe uma restrição
	  trivial adicional: Um plex
	  <foreignphrase>striped</foreignphrase> precisa ter pelo menos
	  dois subdiscos, pois caso contrário seria indistinguivel de um
	  plex concatenado.</para>
	 </listitem>
      </itemizedlist>
    
      <para><xref linkend="vinum-comparison"> sumariza as vantagens e
      desvantagens de cada organização plex.</para>
    
      <table id="vinum-comparison">
	<title>Organizações do Plex no Vinum</title>
	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry>Tipo de Plex</entry>
	  	<entry>Mínimo de subdiscos</entry>
	  	<entry>Pode adicionar subdiscos</entry>
	  	<entry>Deve ser de igual tamanho</entry>
	  	<entry>Aplicação</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>concatenado</entry>
	      <entry>1</entry>
	      <entry>sim</entry>
	      <entry>não</entry>
	      <entry>Grande armazenamento de dados com máxima
	      flexibilidade de posicionamento e performance moderada</entry>
	    </row>
	    
	    <row>
	      <entry><foreignphrase>striped</foreignphrase></entry>
	      <entry>2</entry>
	      <entry>não</entry>
	      <entry>sim</entry>
	      <entry>Alta performance em combinação com um acesso
	      altamente concorrido</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>
  </sect1>
  
  <sect1 id="vinum-examples">
    <title>Alguns exemplos</title>
    

    <para>Vinum mantém uma <emphasis>base de dados de
    configuração</emphasis> onde descreve os objetos conhecidos por um
    sistema individual.  Inicialmente, o usuário cria o banco de dados de
    configuração a partir de um ou mais arquivos de configuração com a
    ajuda do utilitário &man.vinum.8;.  Vinum guarda uma cópia das
    configurações de seu banco de dados em cada fatia de disco (a qual
    Vinum chama de <emphasis>dispositivo</emphasis>) sobre seu controle.
    Essa base de dados é atualizada em cada mudança de estado, então,
    precisamente recupera o estado de cada objeto do Vinum.</para>
    
  
    <sect2>
      <title>O Arquivo de Configuração</title>
      <para>O arquivo de configuração descreve os objetos individuais do
      Vinum.  A definção de um simples volume poderia ser:</para>
      

      <programlisting>
        drive a device /dev/da3h
        volume myvol
          plex org concat
            sd length 512m drive a</programlisting>

      <para>Esse arquivo descreve quatro objetos do Vinum:</para>
      

      <itemizedlist>
	<listitem>
	  <para>A linha <emphasis>drive</emphasis> descreve uma partição
	  de disco (<emphasis>drive</emphasis>) e sua localidade
	  relativa ao <foreignphrase>hardware</foreignphrase>
	  subjacente.  É dado um nome simbólico <emphasis>a</emphasis>.
	  Essa separação entre nomes simbólicos e nomes de dispositivos
	  permite que os discos sejam movidos de um lado a outro sem
	  confusão.</para>
	</listitem>

	<listitem>
	  <para>A linha <emphasis>volume</emphasis> descreve um volume.
	  O único atributo requerido é o nome, nesse caso
	  <emphasis>myvol</emphasis>.</para>
	</listitem>

	<listitem>
	  <para>A linha <emphasis>plex</emphasis> define um plex.  O
	  único parâmetro requerido é a organização, nesse caso
	  <emphasis>concat</emphasis>.  Nenhum nome é necessário: o
	  sistema irá automaticamente gerar um nome a partir do volume
	  adicionando o sufixo
	  <emphasis>.p</emphasis><emphasis>x</emphasis>, onde
	  <emphasis>x</emphasis> é o número de plexes no volume.  Então,
	  esse plex terá o nome <emphasis>myvol.p0</emphasis>.</para>
	</listitem>

	<listitem>
	  <para>A linha <emphasis>sd</emphasis> descreve um subdisco.
	  As especificações mínimas são o nome do disco no qual será
	  armazenado, e o tamanho do subdisco.  Como nos plexes, nenhum
	  nome é necessário: o sistema delega automaticamente nomes
	  provenientes dos plexes adicionando o sufixo
	  <emphasis>.s</emphasis><emphasis>x</emphasis>, onde
	  <emphasis>x</emphasis> é o número de subdiscos do plex.  Então
	  Vinum delega a esse subdisco o nome de
	  <emphasis>myvol.p0.s0</emphasis>.</para>
	</listitem>
      </itemizedlist>

      <para>Depois de processar esse arquivo, &man.vinum.8; gera a
      seguinte saida:</para>
      
      <programlisting>
      &prompt.root; vinum -&gt; <command>create config1</command>
      Configuration summary
      Drives:         1 (4 configured)
      Volumes:        1 (4 configured)
      Plexes:         1 (8 configured)
      Subdisks:       1 (16 configured)
     
	D a                     State: up       Device /dev/da3h        Avail: 2061/2573 MB (80%)
	
	V myvol                 State: up       Plexes:       1 Size:        512 MB
	
	P myvol.p0            C State: up       Subdisks:     1 Size:        512 MB
	
	S myvol.p0.s0           State: up       PO:        0  B Size:        512 MB</programlisting>

      <para>Essa saida mostra um pequeno formato de listagem do
      &man.vinum.8;.  É representado graficamente em <xref
      linkend="vinum-simple-vol">.</para>
      
      <para>
	<figure id="vinum-simple-vol">
	  <title>Um Volume Simples de Vinum</title>
	  <graphic fileref="vinum/vinum-simple-vol">
	</figure>
      </para>

      <para>Essa figura, e as outras que seguem, representam um volume,
      que contém plexes, e estes, por sua vez possuem subdiscos.  Nesse
      exemplo trivial, o volume contém um plex, e o plex contém um
      subdisco.</para>
      
      <para>Esse volume em particular não tem nenhuma vantagem
      específica sobre uma partição de um disco convencional.  Contém um
      único plex, então, não é redundante.  O plex contém um único
      subdisco, então a alocação de dados não se difere de uma partição
      de disco convencional.  As sessões seguintes exemplificam diversos
      métodos de configuração mais interessantes.</para>
    </sect2>

    <sect2>
      <title>Crescimento na Confiança: Espelhamento</title>

      <para>A confiança em um volume pode ser aumentada com
      espelhamento.  Quando planejando um espelhamento de volume, é
      importante se assegurar que o subdisco de cada plex esta em
      partições diferentes, para que uma falha de disco não derrube os
      dois plexes.  A seguinte configuração espelha um volume:</para>

      <programlisting>
	drive b device /dev/da4h
	volume mirror
      plex org concat
        sd length 512m drive a
	  plex org concat
	    sd length 512m drive b</programlisting>

      <para>Nesse exemplo, não foi necessário especificar uma definição
      de uma partição <emphasis>a</emphasis> novamente, a partir do
      momento que o vinum armazena todos os objetos em sua base de
      dados de configuração.  Depois de processar essa definição, a
      configuração se parece com:</para>
      

      <programlisting>
	Drives:         2 (4 configured)
	Volumes:        2 (4 configured)
	Plexes:         3 (8 configured)
	Subdisks:       3 (16 configured)
	
	D a                     State: up       Device /dev/da3h        Avail: 1549/2573 MB (60%)
	D b                     State: up       Device /dev/da4h        Avail: 2061/2573 MB (80%)

    V myvol                 State: up       Plexes:       1 Size:        512 MB
    V mirror                State: up       Plexes:       2 Size:        512 MB
  
    P myvol.p0            C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p0           C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p1           C State: initializing     Subdisks:     1 Size:        512 MB
  
    S myvol.p0.s0           State: up       PO:        0  B Size:        512 MB
	S mirror.p0.s0          State: up       PO:        0  B Size:        512 MB
	S mirror.p1.s0          State: empty    PO:        0  B Size:        512 MB</programlisting>
	
      <para><xref linkend="vinum-mirrored-vol"> mostra a estrutura
      graficamente.</para>

      <para>
	<figure id="vinum-mirrored-vol">
	  <title>Um Volume de Vinum Espelhado</title>
	  <graphic fileref="vinum/vinum-mirrored-vol">
	</figure>
      </para>

      <para>Nesse esemplo, cada plex contém os 512&nbsp;MB de espaço de
      endereço.  E como no exemplo anterior, cada plex contém um único
      subdisco.</para>
    </sect2>

    <sect2>
      <title>Otimizando a Performance</title>

      <para>O espelhamento do volume no exemplo anterior é mais
      resistente a falhas do que o volume não espelhado, mas sua
      performance é menor: cada escrita no volume requer a escrita em
      dois discos, usando assim mais largura de banda de disco.  
      Quando se quer considerar a peformance é indicado uma abordagem
      diferente: ao invés de espelhar, os dados são segmentados dentre o
      maior numero de partições possível.  A configuração seguinte
      mostra um volume com um plex
      <foreignphrase>striped</foreignphrase> entre quatro
      partições:</para>
      
	<programlisting>
	drive c device /dev/da5h
	drive d device /dev/da6h
	volume stripe
	plex org striped 512k
	  sd length 128m drive a
	  sd length 128m drive b
	  sd length 128m drive c
	  sd length 128m drive d</programlisting>

      <para>Como antes, não é necessário definir as partições que já são
      conhecidas pelo vinum.  Depois de processar essa definição, a
      configuração se parece com:</para>
      
      <programlisting>
	Drives:         4 (4 configured)
	Volumes:        3 (4 configured)
	Plexes:         4 (8 configured)
	Subdisks:       7 (16 configured)
  
    D a                     State: up       Device /dev/da3h        Avail: 1421/2573 MB (55%)
    D b                     State: up       Device /dev/da4h        Avail: 1933/2573 MB (75%)
    D c                     State: up       Device /dev/da5h        Avail: 2445/2573 MB (95%)
    D d                     State: up       Device /dev/da6h        Avail: 2445/2573 MB (95%)
  
    V myvol                 State: up       Plexes:       1 Size:        512 MB
    V mirror                State: up       Plexes:       2 Size:        512 MB
    V striped               State: up       Plexes:       1 Size:        512 MB
  
    P myvol.p0            C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p0           C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p1           C State: initializing     Subdisks:     1 Size:        512 MB
    P striped.p1            State: up       Subdisks:     1 Size:        512 MB
  
    S myvol.p0.s0           State: up       PO:        0  B Size:        512 MB
    S mirror.p0.s0          State: up       PO:        0  B Size:        512 MB
    S mirror.p1.s0          State: empty    PO:        0  B Size:        512 MB
    S striped.p0.s0         State: up       PO:        0  B Size:        128 MB
    S striped.p0.s1         State: up       PO:      512 kB Size:        128 MB
    S striped.p0.s2         State: up       PO:     1024 kB Size:        128 MB
    S striped.p0.s3         State: up       PO:     1536 kB Size:        128 MB</programlisting>

      <para>
	<figure id="vinum-striped-vol">
	  <title>Um volume Vinum <foreignphrase>Striped</foreignphrase></title>
	  <graphic fileref="vinum/vinum-striped-vol">
	</figure>
      </para>

      <para>Esse volume é representado em
	<xref linkend="vinum-striped-vol">.  O sombreado dos
	<foreignphrase>stripes</foreignphrase> indica a porção junto ao
	espaço endereçado do plex: os stripes mais claros vem primeiro,
	os mais escuros por último.</para>
    </sect2>

    <sect2>
      <title>Estabilidade e Performance</title>

      <para><anchor id="vinum-resilience">Com o hardware necessário, é
      possível construir volumes que apresentam tanto acréscimo de
      performance quanto de estabilidade quando comparados às partições &unix;
      comuns.  Um arquivo de configuração típico pode ser:</para>
      
      <programlisting>
	volume raid10
      plex org striped 512k
        sd length 102480k drive a
        sd length 102480k drive b
        sd length 102480k drive c
        sd length 102480k drive d
        sd length 102480k drive e
      plex org striped 512k
        sd length 102480k drive c
        sd length 102480k drive d
        sd length 102480k drive e
        sd length 102480k drive a
        sd length 102480k drive b</programlisting>

      <para>Os subdiscos do segundo plex estão deslocados por dois
      discos em relação ao primeiro plex: isso ajuda a garantir que não
      acontecerá escrita no mesmo subdisco, mesmo que a transferência
      aconteça sobre dois discos.</para>
      
      <para><xref linkend="vinum-raid10-vol"> representa a estrutura
	desse volume.</para>

      <para>
	<figure id="vinum-raid10-vol">
	  <title>Um Volume Vinum Striped e Espelhado</title>
	  <graphic fileref="vinum/vinum-raid10-vol">
        </figure>
      </para>
    </sect2>
  </sect1>
  
  <sect1 id="vinum-object-naming">
    <title>Nomenclatura de objetos</title>

    <para>Como descrito assima, Vinum designa nomes padrões
    para plexes e subdisks, embora você possa sobrescrevê-los.
    Sobrescrever os nomes padrões, não é recomenado: experiências com o
    gerenciador de volumes VERITAS, que permite nomes arbitrários
    para objetos, têm mostrado que essa flexibilidade não trás 
    vantagem significativa e pode causar confusão.</para>

    <para>Nomes podem conter qualquer caracter não nulo, mas é
    recomendado que estes sejam restritos a letras, digitos e caracteres
    de sublinhado.  Os nomes dos volumes, plexes e subdiscos podem ser
    formados por até 64 caracteres, e o nome dos drives por até
    32.</para>
    
    <para>Objetos do Vinum são dispositivos designados na
    hierarquia <filename>/dev/vinum</filename>.  A configuração descrita
    acima faria o Vinum a criar os seguintes nós de despositivo:</para>

    <itemizedlist>
      <listitem>
	<para>Os dispositivos de controle
	<devicename>/dev/vinum/control</devicename> e
	<devicename>/dev/vinum/controld</devicename>, os quais são usados
	por &man.vinum.8; e pelo daemon do Vinum respectivamente.</para> 
      </listitem> 

      <listitem>
	<para>Entrada de dispositivo de caracter e bloco para cada
	volume.  Esses são os principais dispositivos usados pelo Vinum.
	Os nomes dos dispoitivos de bloco são o nome do volume, enquanto os
	de caracter seguem a tradição BSD de preceder a letra
	<emphasis>r</emphasis> ao nome.  Por isso a configurção abaixo
	incluiria os dispositivos de bloco
	<devicename>/dev/vinum/myvol</devicename>,
	<devicename>/dev/vinum/mirror</devicename>,
	<devicename>/dev/vinum/striped</devicename>,
	<devicename>/dev/vinum/raid5</devicename> e
	<devicename>/dev/vinum/raid10</devicename>, e os dispositivos de
	caracter <devicename>/dev/vinum/rmyvol</devicename>,
	<devicename>/dev/vinum/rmirror</devicename>,
	<devicename>/dev/vinum/rstriped</devicename>,
	<devicename>/dev/vinum/rraid5</devicename> e
	<devicename>/dev/vinum/rraid10</devicename>.  óbviamente existe
	um problema aqui: é possível ter dois volumes chamados
	<emphasis>r</emphasis> e <emphasis>rr</emphasis>, mas ocorreria um
	conflito criando o nó do dispositivo
	<devicename>/dev/vinum/rr</devicename>: seria um dispositivo de
	caracter para o volume <emphasis>r</emphasis> ou um dispositivo
	bloco para o volume <emphasis>rr</emphasis>?  Atualmente Vinum
	não trata este conflito: o primeiro volume definido levará o
	nome.</para> 
      </listitem>

      <listitem>
	<para>Um diretório <devicename>/dev/vinum/drive</devicename> com
	entradas para cada disco.  Essas entradas são na verdade
	<foreignphrase>links</foreignphrase> simbólicos para os discos
	nós correspondentes.</para>
      </listitem>

      <listitem>
	<para>Um diretório <filename>/dev/vinum/volume</filename> com
	entradas para cada volume, que contém um subdiretório para cada
	plex, que por sua vez contém subdiretórios para seus
	subdiscos.</para>
      </listitem>

      <listitem>
	<para>Os diretórios
	  <devicename>/dev/vinum/plex</devicename>,
	  <devicename>/dev/vinum/sd</devicename>, e
	  <devicename>/dev/vinum/rsd</devicename>, onde contém um
	  nó de dispositivo de bloco para cada plex e um nó de
	  dispositivo de bloco e caracter para cada subdisco,
	  respectivamente.</para>
      </listitem>
    </itemizedlist>

    <para>Por exemplo, considere o seguinte arquivo de configuração:</para>
	<programlisting>
	drive drive1 device /dev/sd1h
	drive drive2 device /dev/sd2h
	drive drive3 device /dev/sd3h
	drive drive4 device /dev/sd4h
    volume s64 setupstate
      plex org striped 64k
        sd length 100m drive drive1
        sd length 100m drive drive2
        sd length 100m drive drive3
        sd length 100m drive drive4
	</programlisting>

    <para>Depois de processar esse arquivo, &man.vinum.8; cria a
    seguinte estrutura em <filename>/dev/vinum</filename>:</para>

    <programlisting>
	brwx------  1 root  wheel   25, 0x40000001 Apr 13 16:46 Control
	brwx------  1 root  wheel   25, 0x40000002 Apr 13 16:46 control
	brwx------  1 root  wheel   25, 0x40000000 Apr 13 16:46 controld
	drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 drive
	drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 plex
	crwxr-xr--  1 root  wheel   91,   2 Apr 13 16:46 rs64
	drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 rsd
	drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 rvol
	brwxr-xr--  1 root  wheel   25,   2 Apr 13 16:46 s64
	drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 sd
	drwxr-xr-x  3 root  wheel       512 Apr 13 16:46 vol

	/dev/vinum/drive:
    total 0
    lrwxr-xr-x  1 root  wheel  9 Apr 13 16:46 drive1 -&gt; /dev/sd1h
    lrwxr-xr-x  1 root  wheel  9 Apr 13 16:46 drive2 -&gt; /dev/sd2h
    lrwxr-xr-x  1 root  wheel  9 Apr 13 16:46 drive3 -&gt; /dev/sd3h
    lrwxr-xr-x  1 root  wheel  9 Apr 13 16:46 drive4 -&gt; /dev/sd4h
  
    /dev/vinum/plex:
    total 0
    brwxr-xr--  1 root  wheel   25, 0x10000002 Apr 13 16:46 s64.p0
    
    /dev/vinum/rsd:
    total 0
    crwxr-xr--  1 root  wheel   91, 0x20000002 Apr 13 16:46 s64.p0.s0
    crwxr-xr--  1 root  wheel   91, 0x20100002 Apr 13 16:46 s64.p0.s1
    crwxr-xr--  1 root  wheel   91, 0x20200002 Apr 13 16:46 s64.p0.s2
    crwxr-xr--  1 root  wheel   91, 0x20300002 Apr 13 16:46 s64.p0.s3
  
    /dev/vinum/rvol:
    total 0
    crwxr-xr--  1 root  wheel   91,   2 Apr 13 16:46 s64
  
    /dev/vinum/sd:
    total 0
    brwxr-xr--  1 root  wheel   25, 0x20000002 Apr 13 16:46 s64.p0.s0
    brwxr-xr--  1 root  wheel   25, 0x20100002 Apr 13 16:46 s64.p0.s1
    brwxr-xr--  1 root  wheel   25, 0x20200002 Apr 13 16:46 s64.p0.s2
    brwxr-xr--  1 root  wheel   25, 0x20300002 Apr 13 16:46 s64.p0.s3
  
    /dev/vinum/vol:
    total 1
    brwxr-xr--  1 root  wheel   25,   2 Apr 13 16:46 s64
    drwxr-xr-x  3 root  wheel       512 Apr 13 16:46 s64.plex
  
    /dev/vinum/vol/s64.plex:
    total 1
    brwxr-xr--  1 root  wheel   25, 0x10000002 Apr 13 16:46 s64.p0
    drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 s64.p0.sd
  
    /dev/vinum/vol/s64.plex/s64.p0.sd:
    total 0
    brwxr-xr--  1 root  wheel   25, 0x20000002 Apr 13 16:46 s64.p0.s0
    brwxr-xr--  1 root  wheel   25, 0x20100002 Apr 13 16:46 s64.p0.s1
    brwxr-xr--  1 root  wheel   25, 0x20200002 Apr 13 16:46 s64.p0.s2
    brwxr-xr--  1 root  wheel   25, 0x20300002 Apr 13 16:46 s64.p0.s3</programlisting>

    <para>Apesar de não ser recomendado alocação de nomes específicos
    para plexes e subdiscos, os discos Vinum devem ser nomeados.
    Isso torna possível mover um disco para uma outra localidade e ainda
    sim reconhacê-lo automaticamente.  Os nomes dos discos podem conter
    até 32 caracteres.</para>
    
    <sect2>
      <title>Criando Sistemas de Arquivos</title>

	<para>Volumes e discos parecem idênticos para o sistema, com
	uma excessão.  Ao contrário de discos &unix;, Vinum não particiona
	volumes, assim, não possui uma tabela de partições.
	Isso exigiu uma mudança em alguns utilitários de discos como
	&man.newfs.8;, que previamente tentava interpretar a última
	letra de um nome de volume Vinum como um identificador de
	partições.  Por exemplo, uma partição de disco pode ter um nome
	como <devicename>/dev/ad0a</devicename> ou
	<devicename>/dev/da2h</devicename>.  Esses nomes representam a
	primeira partição (<devicename>a</devicename>) no primeiro (0)
	disco IDE (<devicename>ad</devicename>) e a oitava partição
	(<devicename>h</devicename>) no terceiro disco SCSI (2)
	(<devicename>da</devicename>), respectivamente.  Em contraste,
	um volume Vinum pode ser chamado de
	<devicename>/dev/vinum/concat</devicename>, um nome que não tem
	nenhum relacionamento com o nome da partição.</para>
	
	  
	<para>Normalmente, &man.newfs.8; interpreta o nome do disco e
	reclama se não entendê-lo.  Por exemplo:</para>
	
	<screen>&prompt.root; <userinput>newfs /dev/vinum/concat</userinput>
newfs: /dev/vinum/concat: can't figure out file system partition</screen>

	<note><para>O que segue só é valido para as versões de FreeBSD
	anteriores a 5.0:</para></note>

	<para>Para criar um sistema de arquivos nesse volume, use a
	opção <option>-v</option> para &man.newfs.8;:</para>

	<screen>&prompt.root; <userinput>newfs -v /dev/vinum/concat</userinput></screen>

    </sect2>
  </sect1>
  
  <sect1 id="vinum-config">
    <title>Configurando Vinum</title>

    <para>O <literal>kernel</literal> <filename>GENERIC</filename> não
    contém Vinum.  É possível construir um <literal>kernel</literal>
    especial para incluir o Vinum, mas não é recomendado.  A maneira
    simples de iniciar o Vinum é com o módulo de
    <literal>kernel</literal> (<acronym>kld</acronym>).  Você nem
    precisa usar &man.kldload.8; para Vinum: quando você inicia
    &man.vinum.8;, ele verifica se o modulo foi carregado ou não, e o
    carrega automaticamente.</para>
    
    <sect2>
      <title>Inicialização</title>

      <para>Vinum armazena as informações de configuração das partições de
        disco essencialmente da mesma forma que os arquivos de
	configuração.  Quando lê do banco de dados de configuração,
	Vinum reconhece algumas palavras chave que não são permitidas
	nos arquivos de configuração.  Por exemplo, uma configuração de
	disco talvez contenha o seguinte texto:</para>
      
	<programlisting>volume myvol state up
volume bigraid state down
plex name myvol.p0 state up org concat vol myvol
plex name myvol.p1 state up org concat vol myvol
plex name myvol.p2 state init org striped 512b vol myvol
plex name bigraid.p0 state initializing org raid5 512b vol bigraid
sd name myvol.p0.s0 drive a plex myvol.p0 state up len 1048576b driveoffset 265b plexoffset 0b
sd name myvol.p0.s1 drive b plex myvol.p0 state up len 1048576b driveoffset 265b plexoffset 1048576b
sd name myvol.p1.s0 drive c plex myvol.p1 state up len 1048576b driveoffset 265b plexoffset 0b
sd name myvol.p1.s1 drive d plex myvol.p1 state up len 1048576b driveoffset 265b plexoffset 1048576b
sd name myvol.p2.s0 drive a plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 0b
sd name myvol.p2.s1 drive b plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 524288b
sd name myvol.p2.s2 drive c plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 1048576b
sd name myvol.p2.s3 drive d plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 1572864b
sd name bigraid.p0.s0 drive a plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 0b
sd name bigraid.p0.s1 drive b plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 4194304b
sd name bigraid.p0.s2 drive c plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 8388608b
sd name bigraid.p0.s3 drive d plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 12582912b
sd name bigraid.p0.s4 drive e plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 16777216b</programlisting>
  
	<para>A diferença clara aqui é a presença explicita de
	informações sobre localidade e nomenclatura (Sendo as duas no
	caso permitidas, mas desencorajadas) e também informações sobre
	os estados (mas não são disponíveis para o usuário).  Vinum não
	armazena informações sobre os discos nas informações de
	configuração: ele acha as informações pesquisando nos discos
	configurados por partições identificadas como Vinum.  Isso habilita o
	Vinum a identificar discos corretamente, mesmo que eles tenham
	sido rotulados com uma identificação de drives &unix;
	diferente.</para>
	
      <sect3 id="vinum-rc-startup">
	<title>Inicialização Automática</title>

        <para>Para iniciar o Vinum automaticamente quando você
	inicializa o sistema, certifique-se de que você tem a seguinte linha
	no seu <filename>/etc/rc.conf</filename>:</para>
	

	<programlisting>start_vinum="YES"		# set to YES to start vinum</programlisting>

	<para>Se o seu sistema não possuir o arquivo
	<filename>/etc/rc.conf</filename>, crie um com esse conteúdo.
	Isso fará com que o sistema carregue o Vinum
	<acronym>kld</acronym> na inicialização, e inicie qualquer
	objeto citado na configuração.  Isso é feito antes de montar os
	sistemas de arquivos, então, é possível fazer automaticamente um 
	&man.fsck.8; e montar os sistemas de arquivo nos volumes
	Vinum.</para>
	

	<para>Quando você inicia Vinum com o comando <command>vinum
	start</command>, Vinum lê a base de dados de configuração de um
	dos discos Vinum.  Sobre circunstâncias normais, cada um dos
	discos contém uma cópia idêntica da base de dados de
	configuração, então não importa que disco é lido.  Embora, após
	uma pane, Vinum tenha que determinar qual o disco foi atualizado
	mais recentemente e ler as configurações desse disco.  E então
	as atualiza, se necessário, progressivamente no	disco mais
	velho.</para>
	
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="vinum-root">
    <title>Usando Vinum para o Sistema de Arquivos Raiz</title>
    

    <para>Para uma máquina que esta espelhada por inteiro usando Vinum,
    é desejável espelhar também o sistema de arquivos raiz.  Executar
    tal configuração é menos trivial do que espelhar um disco
    arbitrário:</para>

    <itemizedlist>
      <listitem>
	<para>O sistema de arquivos raiz deve estar disponível bem
	cedo durante o processo de inicialização, então a infra-estrutura
	Vinum deveria estar disponível também nessa hora.</para> 
      </listitem>
      <listitem><para>O volume contendo os arquivos de sistema raiz também
      contém o bootstap de sistema e o <literal>kernel</literal>, no
      qual tem que ser lido pela utilidade nativa de sistema (ex. A BIOS
      no caso dos PC's) onde frequentemente não pode ser ensinada sobre
      os detalhes do Vinum.</para>
      </listitem>
    </itemizedlist>

    <para>Nas sessões que seguem, o termo <quote>root volume</quote> é
    usado para descrever o volume Vinum que contém os sistemas de
    arquivo raiz.  É provavelmente uma boa idéia usar o nome
    <literal>"root"</literal> para esse volume, mas isso não é de
    maneira nenhuma obrigatório.  Apesar de que todos os exemplos
    de comandos nas sessões seguintes assumem esse nome.</para>

    <sect2>
      <title>Iniciando o Vinum a Tempo Para o Sistema de Arquivos Raiz
      </title>

      <para>Existem algumas medidas a se tomar para que isso aconteça:
      </para>

      <itemizedlist>
	<listitem>
	  <para>Vinum precisa estar disponível no
	  <literal>kernel</literal> na hora do boot.  Então, o método
	  para iniciar automaticamente o Vinum descrito em <xref
	  linkend="vinum-rc-startup"> não é aplicável nesse caso, e o
	  parâmetro <literal>start_vinum</literal>
	  <emphasis>não</emphasis> pode estar ativado quando a seguinte
	  configuração estiver sendo arrumada.  A primeira opção seria
	  compilar o Vinum staticamente no <literal>kernel</literal>,
	  então estará disponível o tempo todo, mas isso também não é
	  sempre desejável.  Existe outra opção no entanto, que seria
	  fazer com que o <filename>/boot/loader</filename> (<xref
	  linkend="boot-loader">) carregue o módulo de kenel do vinum
	  cedo, antes de iniciar o <literal>kernel</literal>.  Isso pode
	  ser feito adicionando a seguinte linha</para>

	  <para><literal>vinum_load="YES"</literal></para>

	  <para>no arquivo
	    <filename>/boot/loader.conf</filename>.</para>
	</listitem>

	<listitem>
	  <para>Vinum deve ser iniciado cedo pois ele precisa suprir o
	  volume para os arquivos de sistemas raiz.  Por padrão, a parte
	  do <literal>kernel</literal> do vinum não esta procurando por
	  discos que possam conter informações de volume Vinum até que o
	  administrador (ou um dos scripts de inicialização) lance o
	  comando <command>vinum start</command>.</para>

	  <note><para>Os parágrafos seguintes descrevem os passos
	  necessários para o FreeBSD 5.x e superiores.  Os passos
	  obrigatórios para o 4.x, são diferentes e estão descritos a
	  baixo em <xref linkend="vinum-root-4x">.</para></note>
	  
	  <para>Colocando a linha:</para>

	  <para><literal>vinum.autostart="YES"</literal></para>

	  <para>em <filename>/boot/loader.conf</filename>, Vinum é
	    instruído para procurar automaticamente em todos os discos
	    por informações úteis a ele como parte da inicialização do
	    <literal>kernel</literal>.</para> 

	  <para>Note que não é necesário ensinar ao
	  <literal>kernel</literal> aonde procurar pelos arquivos de
	  sistema raiz.  <filename>/boot/loader</filename> procura o
	  nome do dispositivo raiz em <filename>/etc/fstab</filename>, e
	  passa essa informação para o <literal>kernel</literal>.
	  Quando chega a hora de montar os arquivos de sistema raiz, o
	  <literal>kernel</literal> descobre a partir do nome do
	  dispositivo fornecido qual é o disco que se deve pedir para
	  passar o nome do dispositivo raiz para um ID interno de
	  dispostivo (número maior/menor).</para>
	  
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Tornando um Volume Raiz Baseado em Vinum Accessível Para o
      Bootstrap</title>

      <para>Visto que o atual <literal>Bootstrap</literal> do FreeBSD
      contém apenas 7.5 KB de código, e já tem o trabalho de ler
      arquivos no UFS (como <filename>/boot/loader</filename>), é
      completamente impossível ensiná-lo também sobre as estruturas
      internas do Vinum para que ele possa analizar seus dados de
      configuração, e descobrir sozinho os elementos de um
      volume de inicialização.  Dessa forma, alguns truques são
      necessários para fornecer ao código do
      <literal>bootstrap</literal> a ilusão de que ele é uma partição
      <literal>"a"</literal> padrão que contém o arquivo de sistema
      raiz.</para>
     
      <para>Para que isso se torne possível, os seguintes requisitos
      para o volume razia devem ser compridos:</para>
      
      <itemizedlist>
	<listitem>
	  <para>O volume raiz não pode estar partido ou em RAID-5.</para>
	</listitem>

	<listitem>
	  <para>Um volume raiz não pode conter mais de um subdisco
	  concatenado por plex.
	</listitem>
      </itemizedlist>

      <para>Note que é desejado e possível que existam múltiplos plexes,
      cada um contendo uma réplica do sistema de arquivos raiz.  O
      processo de bootstrap irá, entretanto, usar somente uma delas para
      achar o bootstrap e todos os arquivos, até que o próprio
      <literal>kernel</literal> monte os sistemas de arquivos.  Cada
      subdisco dentro desse plex irá então precisar da sua própria
      partição imaginária <literal>"a"</literal>, para que o dispositivo
      correspondente se torne bootável.  Não é estritamente necessário
      que cada uma dessas falsas partições <literal>"a"</literal> se
      encontrem no mesmo ponto junto ao seu dispositivo, comparado com
      outros plexes do volume raiz.  Entretanto, provavelmente seria uma
      boa idéia criar os volumes do Vinum desse jeito para que os
      dispositivos espelhados sejam simétricos, evitando, assim,
      confusão.</para>
      
      <para>Para definir essas partições <literal>"a"</literal>, para cada
      dispositivo contendo parte do volume raiz, as etapas segintes
      precisam ser realizadas:</para>
      
      <procedure>
	<step>
	  <para>A localização (<foreignphrase>offset</foreignphrase> do
	  início do dispositivo) e tamanho dos subdiscos dos
	  dispositivos que fazem parte do volume raiz precisam ser
	  examinados usando o comando</para>
	  
	  <para><command>vinum l -rv root</command></para>

	  <para>Note que no Vinum, os
	  <foreignphrase>offsets</foreignphrase> e tamanhos são medidos
	  em bytes.  Eles precisam ser divididos por 512 para obter o
	  número de blocos que irão, por sua vez, ser usados no comando
	  <command>disklabel</command>.</para>
	</step>

	<step>
	  <para>Execute o comando</para>

	  <para><command>disklabel -e
	    </command><replaceable>devname</replaceable></para>

	  <para>Para cada dispositivo que participa no volume raiz.
	  <replaceable>devname</replaceable> deve ser ou o nome do disco
	  (exemplo <devicename>da0</devicename>) para discos sem tabela
	  de partições (ex. fdisk), ou o nome da partição (exemplo
	  <devicename>ad0s1</devicename>).</para>
	 
	  <para>Se já existir uma partição <literal>"a"</literal> no
	  dispositivo (provavelmente, contendo um sistema de arquivos 
	  raiz pré-Vinum), essa deve ser renomeada, permanecendo
	  acessível (por segurança), mas não será mais usado para
	  bootstrap como padrão.  Note que partições ativas (como um
	  sistema de arquivo raiz atualmente montado) não podem ser
	  renomeadas, então isso deve ser feito quando a máquina é
	  inicializada através de uma mídia <quote>Fixit</quote>, ou em um
	  processo de duas etapas, onde (em uma situação de
	  espelhamento) o disco que não foi usado no boot será
	  manipulado primeiro.</para>
	 
	  <para>Então, o <foreignphrase>offset</foreignphrase> da
	  partição Vinum nesse dispositivo (se existente) deve ser
	  adicionado ao <foreignphrase>offset</foreignphrase> do
	  subdisco de volume raiz respectivo desse mesmo dispositivo.  O
	  valor resultante passará a ser o valor <literal>"offset"</literal> 
	  para a nova partição <literal>"a"</literal>.  O valor do 
	  <literal>"size"</literal> dessa partição pode ser tirado
	  literalmente do cálculo acima.  O <literal>"fstype"</literal>
	  deve ser <literal>4.2BSD</literal>.  Os valores de
	  <literal>"fsize"</literal>, <literal>"bsize"</literal>, e
	  <literal>"cpg"</literal> devem ser escolhidos para melhor
	  se adaptar aos atuais do sistema, apesar de que, eles não são muito
	  importantes dentro desse contexto.</para>
	 
	  <para>Dessa forma, uma nova partição <literal>"a"</literal>
	  será formada e sobrepõe as partições Vinum nesse dipositivo.
	  Note que o <command>disklabel</command> só vai permitir isso
	  se as partições do vinum tiverem sido propriamente marcadas
	  usando o <literal>"vinum"</literal> fstype.</para>
	</step>

	<step>
	  <para>Isso é tudo!  Uma falsa partição <literal>"a"</literal>
	  agora existe em cada dispositivo que tenha uma réplica do
	  volume raiz.  É altamente recomendável verificar o resuldado
	  novamente, usando um comando como</para>
	  
	  <para><command>fsck -n
	    </command><devicename>/dev/<replaceable>devname</replaceable>a</devicename></para>
	</step>
      </procedure>

      <para>Deve ser lembrado que todos os arquivos que contém
      informações de controle, precisam ser relativos ao sistema de
      arquivos raiz no volume Vinum onde, quando definido um novo
      volume raiz Vinum, não deve conincidir com o sistema raiz
      atualmente ativo.  Então, em particular, os arquivos
      <filename>/etc/fstab</filename> e
      <filename>/boot/loader.conf</filename> irão precisar de
      cuidados específicos.<para>
      
      <para>Na próxima reinicialização, o <literal>bootstrap</literal>
      deve descobrir a informação de controle apropriada a partir do
      novo sistema de arquivos raiz Vinum, e agir adequadamente.  No
      final do processo de inicialização do <literal>kernel</literal>,
      depois que todos os dispositivos forem anunciados, a notícia
      importante que mostra o sucesso dessa configuração é uma mensagem
      como:</para>
      
      <para><screen>Mounting root from ufs:/dev/vinum/root</screen></para>
    </sect2>

    <sect2>
      <title>Exemplo Configuração Vinum Para o Sistemas de Arquivos
      Raiz</title>

      <para>Após o volume raiz do Vinum ser ativado, a saída de
      <command>vinum l -rv root</command> deve parecer com:</para>

      <para>
	<screen>
...
Subdisk root.p0.s0:
		Size:        125829120 bytes (120 MB)
		State: up
		Plex root.p0 at offset 0 (0  B)
		Drive disk0 (/dev/da0h) at offset 135680 (132 kB)

Subdisk root.p1.s0:
		Size:        125829120 bytes (120 MB)
		State: up
		Plex root.p1 at offset 0 (0  B)
		Drive disk1 (/dev/da1h) at offset 135680 (132 kB)
	</screen>
      </para>

      <para>Os valores a serem notados são <literal>135680</literal>
      para o <foreignphrase>offset</foreignphrase> (relativo à partição
      <devicename>/dev/da0h</devicename>).  Isso quer sizer, em termos
      de <command>disklabel</command>, 265 blocos de disco com 512 bytes
      cada.  Da mesma forma, o tamanho desse volume raiz é de 245760
      blocos de 512 bytes.  <devicename>/dev/da1h</devicename>, contendo
      a segunda réplica desse volume raiz, tem uma configuração
      simérica.</para>

      <para>O <foreignphrase>disklabel</foreignphrase> para esses
      dispositivos devem se parecer com:</para>
      
      <para>
	<screen>
...
8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  a:   245760      281    4.2BSD     2048 16384     0   # (Cyl.    0*- 15*)
  c: 71771688        0    unused        0     0         # (Cyl.    0 - 4467*)
  h: 71771672       16     vinum                        # (Cyl.    0*- 4467*)
	</screen>
      </para>

      <para>Pode ser observado que o parâmetro <literal>"size"</literal>
      para a partição <literal>"a"</literal> falsa bate com o valor
      esboçado acima, enquanto o parâmetro <literal>"offset"</literal> é
      a soma do <foreignphrase>offset</foreignphrase> dentro da partição
      Vinum <literal>"h"</literal>, e o
      <foreignphrase>offset</foreignphrase> dessa partição dentro do
      dispositivo (ou fatia).  Essa é a configuração típica necessária
      para evitar os problemas descritos em <xref
      linkend="vinum-root-panic">.  Pode também ser visto que toda
      partição <literal>"a"</literal> está completamente dentro da
      partição <literal>"h"</literal> contendo todos os dados do Vinum
      para esse dispositivo.</para>
    
      <para>Note que no exemplo acima, o dispositivo inteiro está
      dedicado ao Vinum, e não há nenhum resto de partição raiz
      pré-Vinum, partindo de que esse foi um disco com configurações
      novas e foi dedicado exclusivamente a ser parte de uma
      configuração Vinum.</para>
    </sect2>

    <sect2>
      <title>Resolução de Problemas</title>

      <para>Caso algo saia errado, é preciso ter uma saída para
      recuperar a situação. A seguinte lista contém algumas armadilhas e
      suas soluções.</para>

      <sect3>
	<title>O <literal>Bootstrap</literal> do sistema entra, mas o sistena na inicializa</title>

	<para>Caso, por alguma razão, o sistema não continue
	inicializando, o <literal>bootstrap</literal> pode ser
	interrompido pressionando-se a tecla <keycap>espaço</keycap> 
	no alerta de 10 segundos.  As variáveis do <literal>loader</loteral>
	(como <literal>vinum.autostart</literal>) podem ser examindas
	usando o <command>show</command>, e manipuladas com os comandos
	<command>set</command> ou <command>unset</command>.</para>

	<para>Caso o único problema seja que o módulo Vinum do
	<literal>kernel</literal>
	não esteja na lista de módulos para serem carregados
	automaticamente, um simples <command>load vinum</command> irá
	ajudar.</para>

	<para>Quando pronto, o processo de <literal>boot</literal> pode
	ser retomado com o comando <command>boot -as</command>.  As
	opções <option>-as</option> irão requere ao
	<literal>kernel</literal> que consulte qual sistema de arquivos
	raiz deve montar (<option>-a</option>), e faça o processo em
	modo <literal>single-user</literal> (<option>-s</option>), onde
	o sistema raiz é montado apenas para leitura.  Desta forma,
	mesmo que apenas um plex de um volume multi-plex tenha sido
	montado, nenhum dado entre os plexes corre risco de
	inconsistência.</para>

	<para>Quando for solicitado o sistema de arquivos raíz a ser
	montado, qualquer dispositivo que contenha um sistema de
	arquivos raíz válido pode ser informado.  Caso
	<filename>/etc/fstab</filename> tenha sido definido
	corretamente, o esperado é algo como
	<literal>ufs:/dev/vinum/root</literal>. Uma escolha alternativa
	típica pode ser algo como <userinput>ufs:da0d</userinput> que
	pode ser uma hipotética partição contendo o sistema de arquivos
	pré-Vinum.  Deve-se tomar cuidado caso uma das partições apelido
	<literal>"a"</literal> forem informadas onde há na verdade uma
	referência aos subdiscos Vinum para o sistema de arquivos raíz,
	porque em uma configuração de espelhamento, deve-se apenas
	montar uma peça de um dispositivo raíz. Caso o sistema de
	arquivos for montado para leitura e escrita posteriormente, será
	necessário remover o(s) outro(s) plex(es) do volume Vinum raíz,
	uma vez que estes plexes provavelmente trarão dados
	inconsistentes.</para>
      </sect3>

      <sect3>
	<title>Only Primary Bootstrap Loads</title>

	<para>If <filename>/boot/loader</filename> fails to load, but
	  the primary bootstrap still loads (visible by a single dash
	  in the left column of the screen right after the boot
	  process starts), an attempt can be made to interrupt the
	  primary bootstrap at this point, using the
	  <keycap>space</keycap> key.  This will make the bootstrap
	  stop in stage two, see <xref linkend="boot-boot1">.  An
	  attempt can be made here to boot off an alternate partition,
	  like the partition containing the previous root filesystem
	  that has been moved away from <literal>"a"</literal>
	  above.</para>
      </sect3>

      <sect3 id="vinum-root-panic">
	<title>Nothing Boots, the Bootstrap
	  Panics</title>

	<para>This situation will happen if the bootstrap had been
	  destroyed by the Vinum installation.	Unfortunately, Vinum
	  accidentally currently leaves only 4 KB at the beginning of
	  its partition free before starting to write its Vinum header
	  information.	However, the stage one and two bootstraps plus
	  the disklabel embedded between them currently require 8 KB.
	  So if a Vinum partition was started at offset 0 within a
	  slice or disk that was meant to be bootable, the Vinum setup
	  will trash the bootstrap.</para>

	<para>Similarly, if the above situation has been recovered,
	  for example by booting from a <quote>Fixit</quote> medium,
	  and the bootstrap has been re-installed using
	  <command>disklabel -B</command> as described in <xref
	  linkend="boot-boot1">, the bootstrap will trash the Vinum
	  header, and Vinum will no longer find its disk(s).  Though
	  no actual Vinum configuration data or data in Vinum volumes
	  will be trashed by this, and it would be possible to recover
	  all the data by entering exact the same Vinum configuration
	  data again, the situation is hard to fix at all.  It would
	  be necessary to move the entire Vinum partition by at least
	  4 KB off, in order to have the Vinum header and the system
	  bootstrap no longer collide.</para>
      </sect3>
    </sect2>

    <sect2 id="vinum-root-4x">
      <title>Diferença para o freeBSD 4.x</title>

      <para>Com o freeBSD 4.x, algumas funções internas são obrigatórias
      para fazer com que o vinum procure por todos os discos, e o código
      que desobre o número de identidade interno do dispositivo raiz não
      é inteligênte suficiente para suportar nomes como
      <devicename>/dev/vinum/root</devicename> automaticamente.  Então,
      as coisas são um pouco diferentes aqui.</para>
     
      <para>Vinum precisa ser informado dos discos exatos que ele tem
      que procurar, use uma linha parecida com a seguinte em
      <filename>/boot/loader.conf</filename>:</para>
      
      <para><literal>vinum.drives="/dev/<replaceable>da0</replaceable>
	/dev/<replaceable>da1</replaceable>"</literal></para>

      <para>É importante que todos os discos que contém dados do vinum
      sejam mencionados.  Não será prejudicial se discos a
      <emphasis>mais</emphasis> forem listados, e nem é necessário
      adicionar cada fatia ou cada partição explicitamente, porque o
      vinum irá procurar  por cabeçalhos válidos para ele em todos as
      partições dos discos citados.</para>

      <para>a partir do momento em que as rotinas usadas para passar o
      nome do arquivo de sistema raiz e para produzir o device ID
      (major/minor number) estão preparadas apenas para suportar nomes
      de dispositivos <quote>clássicos</quote> como
      <devicename>/dev/ad0s1a</devicename>, eles não podem fazer o menor
      sentido em um nome de volume raiz do tipo
      <devicename>/dev/vinum/root</devicename>.  Por esta razão, o
      próprio vinum precisa setar antecipadamente o parâmero interno de
      <literal>kernel</literal> que armazena o número de identidade do
      dispositivo raiz durante a sua inicialização.  Isso é feito
      setando a variável <literal>vinum.root</literal> com o valor do
      nome do volume raiz.  A entrada em
      <filename>/boot/loader.conf</filename> para efetuar essa tarefa se
      parece com:</para>
      
      <para><literal>vinum.root="root"</literal></para>

      <para>Agora, quando a inicialização do <literal>kernel</literal>
      tenta descobrir o dispositivo raiz a ser montado, vê se algum
      modulo de <literal>kernel</literal>
      
      Now, when the kernel initialization tries to find out the
	root device to mount, it sees whether some kernel module has
	already pre-initialized the kernel parameter for it.  If that
	is the case, <emphasis>and</emphasis> the device claiming the
	root device matches the major number of the driver as figured
	out from the name of the root device string being passed (that
	is, <literal>"vinum"</literal> in our case), it will use the
	pre-allocated device ID, instead of trying to figure out one
	itself.	 That way, during the usual automatic startup, it can
	continue to mount the Vinum root volume for the root
	filesystem.</para>

      <para>However, when <command>boot -a</command> has been
	requesting to ask for entering the name of the root device
	manually, it must be noted that this routine still cannot
	actually parse a name entered there that refers to a Vinum
	volume.  If any device name is entered that does not refer to
	a Vinum device, the mismatch between the major numbers of the
	pre-allocated root parameter and the driver as figured out
	from the given name will make this routine enter its normal
	parser, so entering a string like
	<userinput>ufs:da0d</userinput> will work as expected. Note
	that if this fails, it is however no longer possible to
	re-enter a string like <userinput>ufs:vinum/root</userinput>
	again, since it cannot be parsed.  The only way out is to
	reboot again, and start over then.  (At the
	<quote>askroot</quote> prompt, the initial
	<devicename>/dev/</devicename> can always be omitted.)</para>
    </sect2>
  </sect1>
</chapter>
