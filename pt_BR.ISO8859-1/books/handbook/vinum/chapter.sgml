<!--
	The Vinum Volume Manager
	By Greg Lehey (grog at lemis dot com)

	Added to the Handbook by Hiten Pandya <hiten@uk.FreeBSD.org>
	and Tom Rhodes <trhodes@FreeBSD.org>

	For the FreeBSD Documentation Project
	$FreeBSD: doc/en_US.ISO8859-1/books/handbook/vinum/chapter.sgml,v 1.25 2003/11/05 10:36:56 ceri Exp $
-->

<chapter id="vinum-vinum">
  <title>O Gerenciador de Volumes Vinum</title>
  
  <sect1 id="vinum-synopsis">
    <title>Sinópse</title>

    <para>Não importa quais discos você tem, eles sempre terão
     limitações
    
      <itemizedlist>
	<listitem>
	  <para>Eles podem ser pequenos demais.</para>
	</listitem>

	<listitem>
	  <para>Eles podem ser lentos demais.</para>
	</listitem>

	<listitem>
	  <para>Eles podem ser pouco seguro.</para>
	</listitem>
      </itemizedlist>
  </sect1>

  <sect1 id="vinum-intro">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Greg</firstname>
	  <surname>Lehey</surname>
	  <contrib>Originally written by </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>Discos são muito pequenos</title>

    <indexterm><primary>Vinum</primary></indexterm>
    <indexterm><primary>RAID</primary>
    <secondary>Software</secondary></indexterm>
   
    <para><emphasis>Vinum</emphasis> o chamado <emphasis>Gerenciador
	de Volumes</emphasis> é o disco virtual que trata destes
	três problemas, vamos analiza-los com mais detalhes.  Soluções
	para estes problemas tem sido propostas e 
	implementadas:</para>

    <para>os discos estão ficando maiores, mas os requisitos para
    armazenamento de dados também.  frequentemente você vai querer um
    sistema de arquivos maior do que o disco que você tem disponível.
    Reconhecidamente, este problema já não é tão agudo com era a dez
    anos atrás, mas ele ainda existe.  alguns sistemas resolveram isso
    criando um dispositivo abstrato onde armazena seus dados em um
    número de discos.</para>
  </sect1>

  <sect1 id="vinum-access-bottlenecks">
    <title>Gargalo de acesso</title>

    <para>Sistemas modernos frequentemente precisam acessar dados de uma
    maneira incrívelmente rápida.  Por exemplo, grandes servidores de
    FTP e HTTP podem manter milhares de sessões ao mesmo tempo e podem
    ter multiplas conexões de 100&nbsp;Mbit/s com o mundo externo, bem
    além das taxas de transmisão da maioria dos discos.</para>
    
    <para>Os discos atuais podem transferir dados sequêncialmente em até
    70&nbsp;MB/s, mas esse valor este valor é de pouca importância em um
    ambiente onde muitos processos independentes acessam  um disco, onde
    eles talvez atinjam apenas uma fração desse valor.  Nesses casos é
    mais importante observar o problema do ponto de vista do subsystem:
    o parametro importante é a carga que uma transferência coloca no
    subsystem, em outras palavras, o tempo em que a transferência ocupa
    os discos envolvidos.</para>
       
    <para>Em qualquer disco de transferência, o disco deve primeiramente
    posicionar as cabeças de leitura e esperar até que o primeiro setor
    passe em baixo delas e depois sim executar a transferência.  Esses
    atos podem ser considerados com se fossem atômicos: não faz o menor
    sentido interromper eles.</para>
    
    <para><anchor id="vinum-latency"> considere uma transferência
    típica de aproximadamente 10&nbsp;kB: a geração atual de discos de
    alta performance podem posicionar as cabeças em uma média de
    3.5&nbsp;ms.  Os discos mais rápidos giram em 15,000&nbsp;rpm,
    então, a rotação latente média (metade de uma revolução) é de
    2&nbsp;ms.  Em 70&nbsp;MB/s, a transferência propriamente dita, leva
    em torno de 150&nbsp;&mu;s, o que é quase nada comprado com o
    tempo de posicionamento.  Em tal caso, a taxa efetiva de
    transferência fica um pouco maior que 1&nbsp;MB/s e é altamente
    dependente no tamanho do que vai ser transferido, é claro.</para>

    <para>A solução óbvia e tradicional para esse gargalo é <quote>more
    spindles</quote>: ele usa vários discos pequenos  com a mesma
    capacidade de armazenamento em vez de usar um outro disco grande.
    Cada disco é capaz de se posicionar e transferir dados de maneira
    independente, então o ritmo de transferência efetivo, cresce a uma
    taxa próxima ao número de discos usados.</para>

    <para>O ritmo de transferência exato é, claramente, menor que o
    número de discos envolvidos: apesar de cada disco é capaz de relizar
    transferencias em paralelo, não existe nenhuma forma de se assegurar
    que as solicitações estão distribuidas de maneira uniforme entre os
    discos.  Inevitavelmente a carga no disco será maior do que no
    outro.</para> 
    
    <indexterm>
      <primary>concatenação de dicos</primary>
    </indexterm>
    <indexterm>
      <primary>Vinum</primary>
      <secondary>concatenação</secondary>
    </indexterm>

    <para>A igualdade da carga nos discos é fortemente dependente do
    modo em que os dados são compartilhados entre eles.  No
    próximo debate, seria conveniente visualizar um disco como se fosse
    um grande número de setores de dados mapeados numericamente, como as
    páginas de um livro.  o método mais simples seria dividir o disco
    virtual em pequenos grupos de setores consecutivos do tamanho do
    disco fisico individual e depois armzena-los desse jeito, semelhante
    a pegar um livro grande e dividi-lo em pequenas sessões.  Esse étodo
    é chamado de <emphasis>concatenação</emphasis> e tem a vantagem que
    os discos não precisam ter nenhum tipo de relacionamento quanto a
    tamanho.  Funciona bem quando o acesso ao disco virtual é dividido
    de maneira igual entre os seus espaços mapeados.  quando o acesso é
    concentrado um uma área menor, o aumento no desempenho é menos
    acentuado. <xref linkend="vinum-concat"> Ilustra a sequência na qual
    as unidades de armazenamento são alocadas em uma organização
    concatenada.</para>
    
    <para>
      <figure id="vinum-concat">
	<title>Organização concatenada</title>
	<graphic fileref="vinum/vinum-concat">
      </figure>
    </para>

    <indexterm>
      <primary>particionamento de discos</primary>
    </indexterm>
    <indexterm>
      <primary>Vinum</primary>
      <secondary>particionamento</secondary>
    </indexterm>

    <para>Um mapeamento alternativo é dividir o address space em
    componentes menores, de tamanhos iguais e armazena-los
    sequencialmente em discos diferentes.  Por exemplo, os primeiros 256
    setores poderiam ser armazenados no primeiro disco, os 256 setores
    seguintes no próximo disco e assim por diante.  Depois de preencher
    o último disco processo se repete até que os discos estejam cheios.
    Esse mapemento é chamado de <emphasis>striping</emphasis> ou
    <acronym>RAID-0</acronym>.

    
    <footnote>
      <indexterm><primary>RAID</primary></indexterm>
    
      <para><acronym>RAID</acronym> significa <emphasis>Array redundante
      de discos baratos</emphasis> e oferece várias formas de tolerancia
      de erros, apesar de que um termo um pouco equivocado, pois não
      fornece redundância.</para> </footnote>.
      

    O striping exige um esforço grande para localizar os dados e
    isso causa carga adicional de I/O onde a tranferência é distribuida
    para diversos discos, mas pode também fornecer uma carga constante
    entre os discos.  <xref linkend="vinum-striped"> ilustra  sequência
    em que as unidades de armazenamento são alocadas em uma organização
    striped.</para>
    
    <para>
      <figure id="vinum-striped">
        <title>Striped Organization</title>
	<graphic fileref="vinum/vinum-striped">
      </figure>
    </para>
  </sect1>

  <sect1 id="vinum-data-integrity">
    <title>Integridade de dados</title>

      <para>O outro problema com os discos atuais é que eles não são
      confiáveis.  Apesar que a confiança nos discos cresceu
      tremendamente nos últimos anos, esses ainda são um dos componentes
      do núcleo de em servidor com a maior possibilidade de falhar.  E
      quando eles falham, os resultados podem ser catastróficos:
      substituir um disco e recuperar seus dados pode levar dias.</para>
      
      <indexterm>
	<primary>espelhamento de disco</primary>
      </indexterm>
      <indexterm>
	<primary>Vinum</primary>
	<secondary>mirroring</secondary>
      </indexterm>
      <indexterm>
	<primary>RAID-1</primary>
      </indexterm>
      
      <para>O método tradicional de acessar esse problema tem sido o
      <emphasis>espelhamento</emphasis>, mantendo duas cópias dos dados
      em dois lugares fisicos distintos.  desde da aparição dos níveis
      de <acronym>RAID</acronym>, essa técnica de espelhamento também é
      chamada de <acronym>RAID nível 1</acronym> ou
      <acronym>RAID-1</acronym>.  qualquer escrita feita no volume
      é escrita nas duas localidades; a leitura pode ser feita a partir
      de uma delas, então se o disco falhar, os dados ainda estarão
      disponíveis no outro.</para>
      
      <para>Espelhamento tem dois problemas:</para>
    
	<itemizedlist>
	  <listitem>
	    <para>O preço.  Exige duas vezes mais armazenamento de disco
	    do que uma solução sem redundância.</para>
	  </listitem>

	  <listitem>
	    <para>O impácto de mémoria.  A escrita deve ser feita para
	    os dois discos, devido a isso eles usam duas vezes mais
	    largura de banda do que um volume não espelhado.  Na leitura
	    não há queda de performance: chega até a parecer que está
	    mais rápido.</para>
	  </listitem>
	</itemizedlist>

      <para><indexterm><primary>RAID-5</primary></indexterm>Uma solução
      alternativa é <emphasis>parity</emphasis>, implementada nos níveis
      2, 3, 4 e 5 do <acronym>RAID</acronym>.  Entre esses,
      <acronym>RAID-5</acronym> é o mais interessante.  Como
      implementado no vinum, é uma variante na organização strip onde
      dedica um bloco de cada strip à parity dos outros blocos.  Um
      <acronym>RAID-5</acronym> plex é parecido com um vinum striped
      plex, exceto que ele implementa o <acronym>RAID-5</acronym> pois
      ele inclui um parity bloco em cada stripe.  Como exigido pelo
      <acronym>RAID-5</acronym>, o local do bloco parity muda de um
      stripe para o outro.  Os números nos blocos de dados indica o
      número relativo do bloco.</para>

      <para>
	<figure id="vinum-raid5-org">
	  <title> Organização RAID-5</title>
	  <graphic fileref="vinum/vinum-raid5-org">
	</figure>
      </para>

      <para>Comparado com espelhamento, <acronym>RAID-5</acronym> tem a
      vantagem de requer significativamente menos espaço de
      armazenameto.  O acesso à leitura é parecida com a utilizada nas
      organizações striped, mas o acesso à escrita é bem reduzida, chega
      a ate 25% da performance de leitura aproximadamente.  se um disco
      falha, 
      
      Compared to mirroring, <acronym>RAID-5</acronym> has the
	advantage of requiring significantly less storage space.  Read
	access is similar to that of striped organizations, but write
	access is significantly slower, approximately 25% of the read
	performance.  If one drive fails, the array can continue to
	operate in degraded mode: a read from one of the remaining
	accessible drives continues normally, but a read from the
	failed drive is recalculated from the corresponding block from
	all the remaining drives.
      </para>
  </sect1>

  <sect1 id="vinum-objects">
    <title>Vinum Objects</title>
      <para>In order to address these problems, Vinum implements a four-level
	hierarchy of objects:</para>

      <itemizedlist>
	<listitem>
	  <para>The most visible object is the virtual disk, called a
	    <emphasis>volume</emphasis>.  Volumes have essentially the same
	    properties as a &unix; disk drive, though there are some minor
	    differences.  They have no size limitations.</para>
	</listitem>

	<listitem>
	  <para>Volumes are composed of <emphasis>plexes</emphasis>,
	    each of which represent the total address space of a
	    volume.  This level in the hierarchy thus provides
	    redundancy.  Think of plexes as individual disks in a
	    mirrored array, each containing the same data.</para>
	</listitem>

	<listitem>
	  <para>Since Vinum exists within the &unix; disk storage
	    framework, it would be possible to use &unix;
	    partitions as the building block for multi-disk plexes,
	    but in fact this turns out to be too inflexible:
	    &unix; disks can have only a limited number of
	    partitions.  Instead, Vinum subdivides a single
	    &unix; partition (the <emphasis>drive</emphasis>)
	    into contiguous areas called
	    <emphasis>subdisks</emphasis>, which it uses as building
	    blocks for plexes.</para>
	</listitem>
      
	<listitem>
	  <para>Subdisks reside on Vinum <emphasis>drives</emphasis>,
	    currently &unix; partitions.  Vinum drives can
	    contain any number of subdisks.  With the exception of a
	    small area at the beginning of the drive, which is used
	    for storing configuration and state information, the
	    entire drive is available for data storage.</para>
	</listitem>
      </itemizedlist>

      <para>The following sections describe the way these objects provide the
	functionality required of Vinum.</para>

    <sect2>
      <title>Conciderações de um tamanho de volume</title>

      <para>Plexes podem ter muitos subdiscos espalhados por todas as 
      partições nas configurações de vinum.  Como resultado, o tamanho
      de uma prtição original não limta o tamanho nem de um plex e nem
      de um volume.</para>
    </sect2>
    
    <sect2>
      <title>Redundância de armazenamento de dados</title>
      <para>Vinum implementa espelhamento anexando multiplos plexes a um
      volume.  Cada plex é a representação dos dados de um volume.  Um
      volume pode conter entre um e oito plexes.</para>
      
      <para>Apesar de um plex repesentar os dados completos de um
      volume, é possivel que partes da representação esteja fisicamente
      faltando, ou por planejamento (por não definir um subdisco como
      parte de um plex), ou por acidente (como resultado de uma falha no
      disco).  Se que pelo menos um plex possa fornecer dados para a
      extenção completa de endereço do volume, o sistema é completamente
      funcional.</para>
    </sect2>
    
    <sect2>
      <title>'
      
      Performance Issues</title>

      <para>Vinum implements both concatenation and striping at the
	plex level:</para>

      <itemizedlist>
	<listitem>
	  <para>A <emphasis>concatenated plex</emphasis> uses the
	    address space of each subdisk in turn.</para>
	</listitem>

	<listitem>
	  <para>A <emphasis>striped plex</emphasis> stripes the data
	    across each subdisk.  The subdisks must all have the same
	    size, and there must be at least two subdisks in order to
	    distinguish it from a concatenated plex.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Which Plex Organization?</title>
      <para>The version of Vinum supplied with FreeBSD &rel.current; implements
	two kinds of plex:</para>
    
      <itemizedlist>
	<listitem>
	  <para>Concatenated plexes are the most flexible: they can
	    contain any number of subdisks, and the subdisks may be of
	    different length.  The plex may be extended by adding
	    additional subdisks.  They require less
	    <acronym>CPU</acronym> time than striped plexes, though
	    the difference in <acronym>CPU</acronym> overhead is not
	    measurable.  On the other hand, they are most susceptible
	    to hot spots, where one disk is very active and others are
	    idle.</para>
        </listitem>

	<listitem>
	  <para>The greatest advantage of striped
	    (<acronym>RAID-0</acronym>) plexes is that they reduce hot
	    spots: by choosing an optimum sized stripe (about
	    256&nbsp;kB), you can even out the load on the component
	    drives.  The disadvantages of this approach are
	    (fractionally) more complex code and restrictions on
	    subdisks: they must be all the same size, and extending a
	    plex by adding new subdisks is so complicated that Vinum
	    currently does not implement it.  Vinum imposes an
	    additional, trivial restriction: a striped plex must have
	    at least two subdisks, since otherwise it is
	    indistinguishable from a concatenated plex.</para>
	</listitem>
      </itemizedlist>
    
      <para><xref linkend="vinum-comparison"> summarizes the advantages
	and disadvantages of each plex organization.</para>
    
      <table id="vinum-comparison">
	<title>Vinum Plex Organizations</title>
	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry>Plex type</entry>
	  	<entry>Minimum subdisks</entry>
	  	<entry>Can add subdisks</entry>
	  	<entry>Must be equal size</entry>
	  	<entry>Application</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>concatenated</entry>
	      <entry>1</entry>
	      <entry>yes</entry>
	      <entry>no</entry>
	      <entry>Large data storage with maximum placement flexibility
	        and moderate performance</entry>
	    </row>
	    
	    <row>
	      <entry>striped</entry>
	      <entry>2</entry>
	      <entry>no</entry>
	      <entry>yes</entry>
	      <entry>High performance in combination with highly concurrent
		access</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>
  </sect1>
  
  <sect1 id="vinum-examples">
    <title>Some Examples</title>

    <para>Vinum maintains a <emphasis>configuration
      database</emphasis> which describes the objects known to an
      individual system.  Initially, the user creates the
      configuration database from one or more configuration files with
      the aid of the &man.vinum.8; utility program.  Vinum stores a
      copy of its configuration database on each disk slice (which
      Vinum calls a <emphasis>device</emphasis>) under its control.
      This database is updated on each state change, so that a restart
      accurately restores the state of each Vinum object.</para>
  
    <sect2>
      <title>The Configuration File</title>
      <para>The configuration file describes individual Vinum objects.  The
	definition of a simple volume might be:</para>

      <programlisting>
    drive a device /dev/da3h
    volume myvol
      plex org concat
        sd length 512m drive a</programlisting>

      <para>This file describes four Vinum objects:</para>

      <itemizedlist>
	<listitem>
	  <para>The <emphasis>drive</emphasis> line describes a disk
	    partition (<emphasis>drive</emphasis>) and its location
	    relative to the underlying hardware.  It is given the
	    symbolic name <emphasis>a</emphasis>.  This separation of
	    the symbolic names from the device names allows disks to
	    be moved from one location to another without
	    confusion.</para>
	</listitem>

	<listitem>
	  <para>The <emphasis>volume</emphasis> line describes a volume.
	    The only required attribute is the name, in this case
	    <emphasis>myvol</emphasis>.</para>
	</listitem>

	<listitem>
	  <para>The <emphasis>plex</emphasis> line defines a plex.
	    The only required parameter is the organization, in this
	    case <emphasis>concat</emphasis>.  No name is necessary:
	    the system automatically generates a name from the volume
	    name by adding the suffix
	    <emphasis>.p</emphasis><emphasis>x</emphasis>, where
	    <emphasis>x</emphasis> is the number of the plex in the
	    volume.  Thus this plex will be called
	    <emphasis>myvol.p0</emphasis>.</para>
	</listitem>

	<listitem>
	  <para>The <emphasis>sd</emphasis> line describes a subdisk.
	    The minimum specifications are the name of a drive on
	    which to store it, and the length of the subdisk.  As with
	    plexes, no name is necessary: the system automatically
	    assigns names derived from the plex name by adding the
	    suffix <emphasis>.s</emphasis><emphasis>x</emphasis>,
	    where <emphasis>x</emphasis> is the number of the subdisk
	    in the plex.  Thus Vinum gives this subdisk the name
	    <emphasis>myvol.p0.s0</emphasis>.</para>
	</listitem>
      </itemizedlist>

      <para>After processing this file, &man.vinum.8; produces the following
	output:</para>

      <programlisting>
      &prompt.root; vinum -&gt; <command>create config1</command>
      Configuration summary
      Drives:         1 (4 configured)
      Volumes:        1 (4 configured)
      Plexes:         1 (8 configured)
      Subdisks:       1 (16 configured)
     
	D a                     State: up       Device /dev/da3h        Avail: 2061/2573 MB (80%)
	
	V myvol                 State: up       Plexes:       1 Size:        512 MB
	
	P myvol.p0            C State: up       Subdisks:     1 Size:        512 MB
	
	S myvol.p0.s0           State: up       PO:        0  B Size:        512 MB</programlisting>

      <para>This output shows the brief listing format of &man.vinum.8;.  It
	is represented graphically in <xref linkend="vinum-simple-vol">.</para>

      <para>
	<figure id="vinum-simple-vol">
	  <title>A Simple Vinum Volume</title>
	  <graphic fileref="vinum/vinum-simple-vol">
	</figure>
      </para>

      <para>This figure, and the ones which follow, represent a
	volume, which contains the plexes, which in turn contain the
	subdisks.  In this trivial example, the volume contains one
	plex, and the plex contains one subdisk.</para>

      <para>This particular volume has no specific advantage over a
	conventional disk partition.  It contains a single plex, so it
	is not redundant.  The plex contains a single subdisk, so
	there is no difference in storage allocation from a
	conventional disk partition.  The following sections
	illustrate various more interesting configuration
	methods.</para>
    </sect2>

    <sect2>
      <title>Increased Resilience: Mirroring</title>

      <para>The resilience of a volume can be increased by mirroring.
	When laying out a mirrored volume, it is important to ensure
	that the subdisks of each plex are on different drives, so
	that a drive failure will not take down both plexes.  The
	following configuration mirrors a volume:</para>

      <programlisting>
	drive b device /dev/da4h
	volume mirror
      plex org concat
        sd length 512m drive a
	  plex org concat
	    sd length 512m drive b</programlisting>

      <para>In this example, it was not necessary to specify a
	definition of drive <emphasis>a</emphasis> again, since Vinum
	keeps track of all objects in its configuration database.
	After processing this definition, the configuration looks
	like:</para>


      <programlisting>
	Drives:         2 (4 configured)
	Volumes:        2 (4 configured)
	Plexes:         3 (8 configured)
	Subdisks:       3 (16 configured)
	
	D a                     State: up       Device /dev/da3h        Avail: 1549/2573 MB (60%)
	D b                     State: up       Device /dev/da4h        Avail: 2061/2573 MB (80%)

    V myvol                 State: up       Plexes:       1 Size:        512 MB
    V mirror                State: up       Plexes:       2 Size:        512 MB
  
    P myvol.p0            C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p0           C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p1           C State: initializing     Subdisks:     1 Size:        512 MB
  
    S myvol.p0.s0           State: up       PO:        0  B Size:        512 MB
	S mirror.p0.s0          State: up       PO:        0  B Size:        512 MB
	S mirror.p1.s0          State: empty    PO:        0  B Size:        512 MB</programlisting>
	
      <para><xref linkend="vinum-mirrored-vol"> shows the structure
	graphically.</para>

      <para>
	<figure id="vinum-mirrored-vol">
	  <title>A Mirrored Vinum Volume</title>
	  <graphic fileref="vinum/vinum-mirrored-vol">
	</figure>
      </para>

      <para>In this example, each plex contains the full 512&nbsp;MB
	of address space.  As in the previous example, each plex
	contains only a single subdisk.</para>
    </sect2>

    <sect2>
      <title>Optimizing Performance</title>

      <para>The mirrored volume in the previous example is more
	resistant to failure than an unmirrored volume, but its
	performance is less: each write to the volume requires a write
	to both drives, using up a greater proportion of the total
	disk bandwidth.  Performance considerations demand a different
	approach: instead of mirroring, the data is striped across as
	many disk drives as possible.  The following configuration
	shows a volume with a plex striped across four disk
	drives:</para>

	<programlisting>
	drive c device /dev/da5h
	drive d device /dev/da6h
	volume stripe
	plex org striped 512k
	  sd length 128m drive a
	  sd length 128m drive b
	  sd length 128m drive c
	  sd length 128m drive d</programlisting>

      <para>As before, it is not necessary to define the drives which are
	already known to Vinum.  After processing this definition, the
	configuration looks like:</para>

      <programlisting>
	Drives:         4 (4 configured)
	Volumes:        3 (4 configured)
	Plexes:         4 (8 configured)
	Subdisks:       7 (16 configured)
  
    D a                     State: up       Device /dev/da3h        Avail: 1421/2573 MB (55%)
    D b                     State: up       Device /dev/da4h        Avail: 1933/2573 MB (75%)
    D c                     State: up       Device /dev/da5h        Avail: 2445/2573 MB (95%)
    D d                     State: up       Device /dev/da6h        Avail: 2445/2573 MB (95%)
  
    V myvol                 State: up       Plexes:       1 Size:        512 MB
    V mirror                State: up       Plexes:       2 Size:        512 MB
    V striped               State: up       Plexes:       1 Size:        512 MB
  
    P myvol.p0            C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p0           C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p1           C State: initializing     Subdisks:     1 Size:        512 MB
    P striped.p1            State: up       Subdisks:     1 Size:        512 MB
  
    S myvol.p0.s0           State: up       PO:        0  B Size:        512 MB
    S mirror.p0.s0          State: up       PO:        0  B Size:        512 MB
    S mirror.p1.s0          State: empty    PO:        0  B Size:        512 MB
    S striped.p0.s0         State: up       PO:        0  B Size:        128 MB
    S striped.p0.s1         State: up       PO:      512 kB Size:        128 MB
    S striped.p0.s2         State: up       PO:     1024 kB Size:        128 MB
    S striped.p0.s3         State: up       PO:     1536 kB Size:        128 MB</programlisting>

      <para>
	<figure id="vinum-striped-vol">
	  <title>A Striped Vinum Volume</title>
	  <graphic fileref="vinum/vinum-striped-vol">
	</figure>
      </para>

      <para>This volume is represented in
	<xref linkend="vinum-striped-vol">.  The darkness of the stripes
	indicates the position within the plex address space: the lightest stripes
	come first, the darkest last.</para>
    </sect2>

    <sect2>
      <title>Resilience and Performance</title>

      <para><anchor id="vinum-resilience">With sufficient hardware, it
	is possible to build volumes which show both increased
	resilience and increased performance compared to standard
	&unix; partitions.  A typical configuration file might
	be:</para>

      <programlisting>
	volume raid10
      plex org striped 512k
        sd length 102480k drive a
        sd length 102480k drive b
        sd length 102480k drive c
        sd length 102480k drive d
        sd length 102480k drive e
      plex org striped 512k
        sd length 102480k drive c
        sd length 102480k drive d
        sd length 102480k drive e
        sd length 102480k drive a
        sd length 102480k drive b</programlisting>

      <para>The subdisks of the second plex are offset by two drives from those
	of the first plex: this helps ensure that writes do not go to the same
	subdisks even if a transfer goes over two drives.</para>

      <para><xref linkend="vinum-raid10-vol"> represents the structure
	of this volume.</para>

      <para>
	<figure id="vinum-raid10-vol">
	  <title>A Mirrored, Striped Vinum Volume</title>
	  <graphic fileref="vinum/vinum-raid10-vol">
        </figure>
      </para>
    </sect2>
  </sect1>
  
  <sect1 id="vinum-object-naming">
    <title>Nomenclatura de objetos</title>

    <para>Como descrito assima, Vinum desigina nomes padrões
    para plexes e subdisks, embora você possa sobrescreve-los.
    Sobrescrever os nomes padrões, não é recomenado: experiências com o
    com o gerenciador de volumes VERITAS, que permite nomes arbitrários
    para objetos, tem mostrado que essa flexibilidade não tras uma
    vantágem significativa e pode causar confusão.</para>

    <para>Nomes podem conter qualquer caracter não nulo, mas é
    recomendado que estes sejam restritos a letras, digitos e caracteres
    underscore.  Os nomes dos volumes, plexes e subdiscos podem ser
    formados por até 64 caracteres, e o nome dos drives por até
    32.</para>
    
    <para>Objetos do Vinum são dispositivos designados na
    hierarquia <filename>/dev/vinum</filename>.  a configuração descrita
    abaixo causaria o Vinum a criar o seguinte node de
    despositivo:</para>
    

    <itemizedlist>
      <listitem>
	<para>Os dispositivos de controle
	<devicename>/dev/vinum/control</devicename> e
	<devicename>/dev/vinum/controld</devicename>, no qual são usados
	por &man.vinum.8; e pelo daemon de Vinum respectivamente.</para> 
      </listitem> 
	      

      <listitem>
	<para>Entrada de dispositivo de caracter e bloco para cada
	volume.  Esses são os principais dispositivos usados pelo Vinum.
	Os nomes dos dispoitivos bloco é o nome do volume, enquanto os
	do caracter seguem as tradições BSD de prepending (preceder) a
	letra <emphasis>r</emphasis> ao nome.  Por isso a configurção
	abaixo incluiria os dispositivos bloco
	<devicename>/dev/vinum/myvol</devicename>,
	<devicename>/dev/vinum/mirror</devicename>,
	<devicename>/dev/vinum/striped</devicename>,
	<devicename>/dev/vinum/raid5</devicename> e
	<devicename>/dev/vinum/raid10</devicename>, e o dispositivos
	caracter <devicename>/dev/vinum/rmyvol</devicename>,
	<devicename>/dev/vinum/rmirror</devicename>,
	<devicename>/dev/vinum/rstriped</devicename>,
	<devicename>/dev/vinum/rraid5</devicename> e
	<devicename>/dev/vinum/rraid10</devicename>.  obviament existe m
	problema aqui: é possível ter dois olumes chamados
	<emphasis>r</emphasis> e <emphasis>rr</emphasis>, mas ocorreria um
	conflito criando o node do  dispositivo
	<devicename>/dev/vinum/rr</devicename>: seria um dispositivo de
	caracter para o volume <emphasis>r</emphasis> ou um dispositivo
	bloco para o volume <emphasis>rr</emphasis>?  Atualmente Vinum
	não endereça o conflito: o primeiro volume definido levará o
	nome.</para> 
      </listitem>

      <listitem>
	<para>Um diretório <devicename>/dev/vinum/drive</devicename> com
	entradas para cada disco.  Essas entradas são na verdade links
	simbólicos para os disco nodes correspondentes.<.para>
      </listitem>

      <listitem>
	<para>Um diretório <filename>/dev/vinum/volume</filename> com
	entradas para cada volume, que contém um subdiretório para cada
	plex, que por sua vez contém subdiretórios para seus
	subdiscos.</para>
      </listitem>

      <listitem>
	<para>The directories
	  <devicename>/dev/vinum/plex</devicename>,
	  <devicename>/dev/vinum/sd</devicename>, and
	  <devicename>/dev/vinum/rsd</devicename>, onde contém um
	  node de dispositivo bloco para cada plex e um node de
	  dispositivo bloco e caracter para cada subdisco,
	  respectivamente.</para>
      </listitem>
    </itemizedlist>

    <para>Por exemplo, considere o seguinte arquivo de
    configuração:</para>
	<programlisting>
	drive drive1 device /dev/sd1h
	drive drive2 device /dev/sd2h
	drive drive3 device /dev/sd3h
	drive drive4 device /dev/sd4h
    volume s64 setupstate
      plex org striped 64k
        sd length 100m drive drive1
        sd length 100m drive drive2
        sd length 100m drive drive3
        sd length 100m drive drive4
	</programlisting>

    <para>Depois de processar esse arquivo, &man.vinum.8; cria a
    seguinte estrutura em <filename>/dev/vinum</filename>:</para>

    <programlisting>
	brwx------  1 root  wheel   25, 0x40000001 Apr 13 16:46 Control
	brwx------  1 root  wheel   25, 0x40000002 Apr 13 16:46 control
	brwx------  1 root  wheel   25, 0x40000000 Apr 13 16:46 controld
	drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 drive
	drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 plex
	crwxr-xr--  1 root  wheel   91,   2 Apr 13 16:46 rs64
	drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 rsd
	drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 rvol
	brwxr-xr--  1 root  wheel   25,   2 Apr 13 16:46 s64
	drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 sd
	drwxr-xr-x  3 root  wheel       512 Apr 13 16:46 vol

	/dev/vinum/drive:
    total 0
    lrwxr-xr-x  1 root  wheel  9 Apr 13 16:46 drive1 -&gt; /dev/sd1h
    lrwxr-xr-x  1 root  wheel  9 Apr 13 16:46 drive2 -&gt; /dev/sd2h
    lrwxr-xr-x  1 root  wheel  9 Apr 13 16:46 drive3 -&gt; /dev/sd3h
    lrwxr-xr-x  1 root  wheel  9 Apr 13 16:46 drive4 -&gt; /dev/sd4h
  
    /dev/vinum/plex:
    total 0
    brwxr-xr--  1 root  wheel   25, 0x10000002 Apr 13 16:46 s64.p0
    
    /dev/vinum/rsd:
    total 0
    crwxr-xr--  1 root  wheel   91, 0x20000002 Apr 13 16:46 s64.p0.s0
    crwxr-xr--  1 root  wheel   91, 0x20100002 Apr 13 16:46 s64.p0.s1
    crwxr-xr--  1 root  wheel   91, 0x20200002 Apr 13 16:46 s64.p0.s2
    crwxr-xr--  1 root  wheel   91, 0x20300002 Apr 13 16:46 s64.p0.s3
  
    /dev/vinum/rvol:
    total 0
    crwxr-xr--  1 root  wheel   91,   2 Apr 13 16:46 s64
  
    /dev/vinum/sd:
    total 0
    brwxr-xr--  1 root  wheel   25, 0x20000002 Apr 13 16:46 s64.p0.s0
    brwxr-xr--  1 root  wheel   25, 0x20100002 Apr 13 16:46 s64.p0.s1
    brwxr-xr--  1 root  wheel   25, 0x20200002 Apr 13 16:46 s64.p0.s2
    brwxr-xr--  1 root  wheel   25, 0x20300002 Apr 13 16:46 s64.p0.s3
  
    /dev/vinum/vol:
    total 1
    brwxr-xr--  1 root  wheel   25,   2 Apr 13 16:46 s64
    drwxr-xr-x  3 root  wheel       512 Apr 13 16:46 s64.plex
  
    /dev/vinum/vol/s64.plex:
    total 1
    brwxr-xr--  1 root  wheel   25, 0x10000002 Apr 13 16:46 s64.p0
    drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 s64.p0.sd
  
    /dev/vinum/vol/s64.plex/s64.p0.sd:
    total 0
    brwxr-xr--  1 root  wheel   25, 0x20000002 Apr 13 16:46 s64.p0.s0
    brwxr-xr--  1 root  wheel   25, 0x20100002 Apr 13 16:46 s64.p0.s1
    brwxr-xr--  1 root  wheel   25, 0x20200002 Apr 13 16:46 s64.p0.s2
    brwxr-xr--  1 root  wheel   25, 0x20300002 Apr 13 16:46 s64.p0.s3</programlisting>

    <para>Apesar de não ser recomendado alocalçao de nomes específicos
    para plexes e subdiscos, os discos do Vinum devem ser nomeados.
    Isso torna possível mover um disco para uma outra localidade e ainda
    sim reconhace-lo automaticamente.  Os nomes dos discos podem conter
    até 32 caracteres.</para>
    
    <sect2>
      <title>Criando sistema de arquivos </title>

	<para>Volumes e discos parecem idênticos para um sistema, com
	uma exessão.  Ao contrário de discos &unix;, Vinum não particiona
	volumes, no qual então, não possui uma tabela de partições.
	Isso exigiu uma mudança em alguns utilitários de discos como
	&man.newfs.8;, onde previamente interpretou a última letra de um 
	nome de volume de Vinum como um	identificador de partições.  Por
	exemplo, uma partição de disco pode ter um nome como
	<devicename>/dev/ad0a</devicename> ou
	<devicename>/dev/da2h</devicename>.  Esses nomes representam a
	primeira partição (<devicename>a</devicename>) no primeiro (0)
	disco IDE (<devicename>ad</devicename>) e a oitava partição
	(<devicename>h</devicename>) no terceiro disco SCSI (2)
	(<devicename>da</devicename>), respectivamente.  Em contraste,
	um volume Vinum pode ser chamado de
	<devicename>/dev/vinum/concat</devicename>, um nome que não tem
	nenhum relacionamento com o nome da partição.</para>
	
	  
	<para>Normalmente, &man.newfs.8; interpreta o nome do disco e
	reclama se não entender.  Por exemplo:</para>
	
	<screen>&prompt.root; <userinput>newfs /dev/vinum/concat</userinput>
newfs: /dev/vinum/concat: can't figure out file system partition</screen>

	<note><para>O que segue só é valido para as versões de freeBSD
	anteriores a 5.0:</para></note>

	<para>Para criar um sistema de arquivos nesse volume, use a
	opção <option>-v</option> para &man.newfs.8;:</para>

	<screen>&prompt.root; <userinput>newfs -v /dev/vinum/concat</userinput></screen>

    </sect2>
  </sect1>
  
  <sect1 id="vinum-config">
    <title>Configurando Vinum</title>

    <para>O kernel <filename>GENERIC</filename> não contém Vinum.  É
    possível construir um kernel especial para incluir o Vinum, mas não
    é recomendado.  A maneira simples de iniciar o Vinum é com o módulo
    de kernel (<acronym>kld</acronym>).  Você nem precisa usar
    &man.kldload.8; para Vinum: quando você inicia &man.vinum.8;, ele
    verifica se o modulo foi carregado ou não, e o carrega
    automaticamente.</para>
    
    

    <sect2>
      <title>Inicialização</title>

      <para>Vinum armazena as informações de configuração das fatias de
      disco essencialmente da mesma forma que os arquivos de
      configuração.  Quando lendo do banco de dados de configuração,
      Vinum reconhece algumas palavras chave que não são permitidas nos
      arquivos de configuração.  Por exemplo, uma configuração de disco
      talves contenha o seguinte texto:</para>
      
      
	<programlisting>volume myvol state up
volume bigraid state down
plex name myvol.p0 state up org concat vol myvol
plex name myvol.p1 state up org concat vol myvol
plex name myvol.p2 state init org striped 512b vol myvol
plex name bigraid.p0 state initializing org raid5 512b vol bigraid
sd name myvol.p0.s0 drive a plex myvol.p0 state up len 1048576b driveoffset 265b plexoffset 0b
sd name myvol.p0.s1 drive b plex myvol.p0 state up len 1048576b driveoffset 265b plexoffset 1048576b
sd name myvol.p1.s0 drive c plex myvol.p1 state up len 1048576b driveoffset 265b plexoffset 0b
sd name myvol.p1.s1 drive d plex myvol.p1 state up len 1048576b driveoffset 265b plexoffset 1048576b
sd name myvol.p2.s0 drive a plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 0b
sd name myvol.p2.s1 drive b plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 524288b
sd name myvol.p2.s2 drive c plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 1048576b
sd name myvol.p2.s3 drive d plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 1572864b
sd name bigraid.p0.s0 drive a plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 0b
sd name bigraid.p0.s1 drive b plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 4194304b
sd name bigraid.p0.s2 drive c plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 8388608b
sd name bigraid.p0.s3 drive d plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 12582912b
sd name bigraid.p0.s4 drive e plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 16777216b</programlisting>
  
	<para>A diferença clara aqui é a presença explicita de
	informações sobre localidade e nomenclatura (Sendo as duas no
	caso permitidas, mas desencorajadas) e também informações sobre
	os estados (mas não são disponíveis para o usuário).  Vinum não
	armazena informações sobre os disco nas informações de
	configuração: ele acha os drives by scanning the configured
	disk drives for partitions with a Vinum label.  Isso abilita o
	Vinum a identificar discos corretamente, mesmo que eles tenham
	sido rotulados com uma diferente nomeação de drives
	&unix;.</para>
	
	
      <sect3 id="vinum-rc-startup">
	<title>Inicialização Automática</title>

        <para>Para iniciar o Vinum automaticamente quando você boota o
	sistema, afirme-se de que você tem a seguinte linha no seu
	<filename>/etc/rc.conf</filename>:</para>
	

	<programlisting>start_vinum="YES"		# set to YES to start vinum</programlisting>

	<para>Se o seu sistema não possuir o arquivo
	<filename>/etc/rc.conf</filename>, crie um com esse conteúdo.
	Isso fará com que o sistema carregue o Vinum
	<acronym>kld</acronym> na inicialização, e inicie qualquer
	objeto citado na configuração.  Isso é feito antes de montar os
	sistemas de arquivos, então, é possível fazer automaticamente um 
	&man.fsck.8; e montar os sistemas de arquivo nos volumes de
	Vinum.</para>
	

	<para>Quando você inicia Vinum com o comando <command>vinum
	start</command>, Vinum lê a base de dados de configuração de um
	dos discos do Vinum.  Sobre circunstâncias normais, cada um dos
	discos contém uma cópia idêntica da base de dados de
	configuração, então não importa que disco é lido.  Embora, após
	uma pane, Vinum tem que determinar qual o disco foi atualizado
	mais recentemente e ler as configurações desse disco.  E então
	as atualiza, se necessário, progressivamente do	disco mais
	velho.</para>
	
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="vinum-root">
    <title>Usando Vinum para o sistemas de arquivos raiz</title>
    

    <para>Para uma máquina que esta espelhada por inteiro usando Vinum,
    é desejável espelhar também o sistema de arquivos raiz.  Setar
    tal configuração é menos trivial do que espelhar um disco
    arbitrário:</para>

    <itemizedlist>
      <listitem>
	<para>O sistema de arquivos raiz deve estar disponível bem
	cedo durante o processo de inicialização, então a infraestrutura
	do Vinum deveria estar disponível também nessa hora.</para> 
      </listitem>
      <listitem><para>O volume contendo os arquivos de sistema raiz também
      contém o bootstap de sistema e o kernel, no qual tem que ser lido
      pela utilidade nativa de sistema (ex. A BIOS no caso dos PC's)
      onde frequentemente não pode ser ensinada sobre os detalhes do
      Vinum.</para>
      </listitem>
    </itemizedlist>

    <para>Nas sessões que seguem, o termo <quote>root volume</quote> é
    usado para descrevero volume de Vinum que contém os sistemas de
    arquivo raiz.  É provávelmente uma boa idéia usar o nome
    <literal>"root"</literal> para esse volume, mas isso não é de
    maneira nenhuma obrigatório.  Apesar de que todos os exemplos
    de comandos nas sessões seguintes assumem esse nome.</para>



    <sect2>
      <title>Iniciando o Vinum a tempo para o sistema de arquivos raiz
      </title>

      <para>Existem algumas medidas a se tomar para que isso aconteça:
      </para>

      <itemizedlist>
	<listitem>
	  <para>Vinum precisa estar disponível no kernel na hora do
	  boot.  Então, o método para iniciar automaticamente o Vinum
	  descrito em <xref linkend="vinum-rc-startup"> não é aplicável
	  nesse caso, e o parâmetro <literal>start_vinum</literal> não
	  pode estar ativado quando a seguinte configuração estiver
	  sendo arrumada.  A primeira opção seria compilar o Vinum
	  staticamente no kernel, então estara disponível o tempo todo,
	  mas isso também não e sempre desejável.  Existe outra opção no
	  entanto, que seria fazer com que o
	  <filename>/boot/loader</filename> (<xref
	  linkend="boot-loader">) carregue o módulo de kenel do vinum
	  cedo, antes de iniciar o kernel.  Isso pode ser feito
	  adicionando a seguinte linha</para>
	  

	  <para><literal>vinum_load="YES"</literal></para>

	  <para>no arquivo
	    <filename>/boot/loader.conf</filename>.</para>
	</listitem>

	<listitem>
	  <para>Vinum deve ser iniciado cedo pois ele precisa suprir o
	  volume para os arquivos de sistemas raiz.  Por padrão, a parte
	  do kernel do vinum não esta procurando por discos que possam
	  conter informações de volume de vinum até que o administrador
	  (ou um dos scripts de inicialização) lance o comando
	  <command>vinum start</command>.</para>
	  

	  <note><para>Os parágrafos seguintes descrevem os passos
	  necessários para o FreeBSD 5.x e superiores.  os passos
	  obrigatórios para o 4.x, são diferentes e estão descritos a
	  baixo em <xref linkend="vinum-root-4x">.</para></note>
	  

	  <para>colocando a linha:</para>
	  

	  <para><literal>vinum.autostart="YES"</literal></para>

	  <para>em <filename>/boot/loader.conf</filename>, Vinum é
	    instruido para procurar automaticamente em todos os discos
	    por informações úteis a ele como parte da inicialização do
	    kernel.</para> 

	  <para>Note que não é necesário ensinar ao kernel aonde
	  procurar pelos arquivos de sistema raiz.
	  <filename>/boot/loader</filename> procura o nome do
	  dispositivo raiz em <filename>/etc/fstab</filename>, e passa
	  essa informação para o kernel.  Quando chega a hora de montar
	  os arquivos de sistema raiz, o kernel descobre a partir do nome
	  do dispositivo fornecido qual é o disco que se deve pedir para
	  passar o nome do dispositivo raiz para um numero de
	  identificação interna de dispostivo.</para>
	  
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Tornando um volume raiz baseado em vinum accessível para o
      <literal>Bootstrap</literal>
      

      <para>Visto que o atual <literal>Bootstrap</literal> do FreeBSD
      contém apenas 7.5 KB de código, e já tem o trabalho de ler
      arquivos de UFS (como <filename>/boot/loader</filename>), é
      completamente impossível ensiná-lo também sobre as estruturas
      internas do vinum para que ele possa analizar os dados de
      configuração do vinum, e descobrir sozinho os elementos de um
      volume de inicialização.  Dessa forma, alguns truques são
      necessários para fornecer ao código do
      <literal>bootstrap</literal> a ilusão de que ele é uma partição
      <literal>"a"</literal> padrão que contém o arquivo de sistem
      raiz.</para>
     
      
      <para>Para que isso se torne possível, os seguintes requisitos
      para o volume rzia devem ser compridos:</para>
      

      <itemizedlist>
	<listitem>
	  <para>o volume raiz não pode estar partido ou em RAID-5.</para>
	</listitem>

	<listitem>
	  <para>Um volume raiz não pode conter mais de um sublink
	  concatenado por plex.
	</listitem>
      </itemizedlist>

      <para>
      
      Note that it is desirable and possible that there are
	multiple plexes, each containing one replica of the root
	filesystem.  The bootstrap process will, however, only use one
	of these replica for finding the bootstrap and all the files,
	until the kernel will eventually mount the root filesystem
	itself.	 Each single subdisk within these plexes will then
	need its own <literal>"a"</literal> partition illusion, for
	the respective device to become bootable.  It is not strictly
	needed that each of these faked <literal>"a"</literal>
	partitions is located at the same offset within its device,
	compared with other devices containing plexes of the root
	volume.	 However, it is probably a good idea to create the
	Vinum volumes that way so the resulting mirrored devices are
	symmetric, to avoid confusion.</para>

      <para>In order to set up these <literal>"a"</literal> partitions,
	for each device containing part of the root volume, the
	following needs to be done:</para>

      <procedure>
	<step>
	  <para>The location (offset from the beginning of the device)
	    and size of this device's subdisk that is part of the root
	    volume need to be examined, using the command</para>

	  <para><command>vinum l -rv root</command></para>

	  <para>Note that Vinum offsets and sizes are measured in
	    bytes.  They must be divided by 512 in order to obtain the
	    block numbers that are to be used in the
	    <command>disklabel</command> command.</para>
	</step>

	<step>
	  <para>Run the command</para>

	  <para><command>disklabel -e
	    </command><replaceable>devname</replaceable></para>

	  <para>for each device that participates in the root volume.
	    <replaceable>devname</replaceable> must be either the name
	    of the disk (like <devicename>da0</devicename>) for disks
	    without a slice (aka. fdisk) table, or the name of the
	    slice (like <devicename>ad0s1</devicename>).</para>

	  <para>If there is already an <literal>"a"</literal>
	    partition on the device (presumably, containing a
	    pre-Vinum root filesystem), it should be renamed to
	    something else, so it remains accessible (just in case),
	    but will no longer be used by default to bootstrap the
	    system.  Note that active partitions (like a root
	    filesystem currently mounted) cannot be renamed, so this
	    must be executed either when being booted from a
	    <quote>Fixit</quote> medium, or in a two-step process,
	    where (in a mirrored situation) the disk that has not been
	    currently booted is being manipulated first.</para>

	  <para>Then, the offset the Vinum partition on this
	    device (if any) must be added to the offset of the
	    respective root volume subdisk on this device.  The
	    resulting value will become the
	    <literal>"offset"</literal> value for the new
	    <literal>"a"</literal> partition.  The
	    <literal>"size"</literal> value for this partition can be
	    taken verbatim from the calculation above.	The
	    <literal>"fstype"</literal> should be
	    <literal>4.2BSD</literal>.	The
	    <literal>"fsize"</literal>, <literal>"bsize"</literal>,
	    and <literal>"cpg"</literal> values should best be chosen
	    to match the actual filesystem, though they are fairly
	    unimportant within this context.</para>

	  <para>That way, a new <literal>"a"</literal> partition will
	    be established that overlaps the Vinum partition on this
	    device.  Note that the <command>disklabel</command> will
	    only allow for this overlap if the Vinum partition has
	    properly been marked using the <literal>"vinum"</literal>
	    fstype.</para>
	</step>

	<step>
	  <para>That's all!  A faked <literal>"a"</literal> partition
	    does exist now on each device that has one replica of the
	    root volume.  It is highly recommendable to verify the
	    result again, using a command like</para>

	  <para><command>fsck -n
	    </command><devicename>/dev/<replaceable>devname</replaceable>a</devicename></para>
	</step>
      </procedure>

      <para>It should be remembered that all files containing control
	information must be relative to the root filesystem in the
	Vinum volume which, when setting up a new Vinum root volume,
	might not match the root filesystem that is currently active.
	So in particular, the files <filename>/etc/fstab</filename>
	and <filename>/boot/loader.conf</filename> need to be taken
	care of.</para>

      <para>At next reboot, the bootstrap should figure out the
	appropriate control information from the new Vinum-based root
	filesystem, and act accordingly.  At the end of the kernel
	initialization process, after all devices have been announced,
	the prominent notice that shows the success of this setup is a
	message like:</para>

      <para><screen>Mounting root from ufs:/dev/vinum/root</screen></para>
    </sect2>

    <sect2>
      <title>Example of a Vinum-based Root Setup</title>

      <para>After the Vinum root volume has been set up, the output of
	<command>vinum l -rv root</command> could look like:</para>

      <para>
	<screen>
...
Subdisk root.p0.s0:
		Size:        125829120 bytes (120 MB)
		State: up
		Plex root.p0 at offset 0 (0  B)
		Drive disk0 (/dev/da0h) at offset 135680 (132 kB)

Subdisk root.p1.s0:
		Size:        125829120 bytes (120 MB)
		State: up
		Plex root.p1 at offset 0 (0  B)
		Drive disk1 (/dev/da1h) at offset 135680 (132 kB)
	</screen>
      </para>

      <para>The values to note are <literal>135680</literal> for the
	offset (relative to partition
	<devicename>/dev/da0h</devicename>).  This translates to 265
	512-byte disk blocks in <command>disklabel</command>'s terms.
	Likewise, the size of this root volume is 245760 512-byte
	blocks.	 <devicename>/dev/da1h</devicename>, containing the
	second replica of this root volume, has a symmetric
	setup.</para>

      <para>The disklabel for these devices might look like:</para>

      <para>
	<screen>
...
8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  a:   245760      281    4.2BSD     2048 16384     0   # (Cyl.    0*- 15*)
  c: 71771688        0    unused        0     0         # (Cyl.    0 - 4467*)
  h: 71771672       16     vinum                        # (Cyl.    0*- 4467*)
	</screen>
      </para>

      <para>It can be observed that the <literal>"size"</literal>
	parameter for the faked <literal>"a"</literal> partition
	matches the value outlined above, while the
	<literal>"offset"</literal> parameter is the sum of the offset
	within the Vinum partition <literal>"h"</literal>, and the
	offset of this partition within the device (or slice).	This
	is a typical setup that is necessary to avoid the problem
	described in <xref linkend="vinum-root-panic">.	 It can also
	be seen that the entire <literal>"a"</literal> partition is
	completely within the <literal>"h"</literal> partition
	containing all the Vinum data for this device.</para>

      <para>Note that in the above example, the entire device is
	dedicated to Vinum, and there is no leftover pre-Vinum root
	partition, since this has been a newly set-up disk that was
	only meant to be part of a Vinum configuration, ever.</para>
    </sect2>

    <sect2>
      <title>Troubleshooting</title>

      <para>If something goes wrong, a way is needed to recover from
	the situation.	The following list contains few known pitfalls
	and solutions.</para>

      <sect3>
	<title>System Bootstrap Loads, but System Does Not Boot</title>

	<para>If for any reason the system does not continue to boot,
	  the bootstrap can be interrupted with by pressing the
	  <keycap>space</keycap> key at the 10-seconds warning.	 The
	  loader variables (like <literal>vinum.autostart</literal>)
	  can be examined using the <command>show</command>, and
	  manipulated using <command>set</command> or
	  <command>unset</command> commands.</para>

	<para>If the only problem was that the Vinum kernel module was
	  not yet in the list of modules to load automatically, a
	  simple <command>load vinum</command> will help.</para>

	<para>When ready, the boot process can be continued with a
	  <command>boot -as</command>.	The options
	  <option>-as</option> will request the kernel to ask for the
	  root filesystem to mount (<option>-a</option>), and make the
	  boot process stop in single-user mode (<option>-s</option>),
	  where the root filesystem is mounted read-only.  That way,
	  even if only one plex of a multi-plex volume has been
	  mounted, no data inconsistency between plexes is being
	  risked.</para>

	<para>At the prompt asking for a root filesystem to mount, any
	  device that contains a valid root filesystem can be entered.
	  If <filename>/etc/fstab</filename> had been set up
	  correctly, the default should be something like
	  <literal>ufs:/dev/vinum/root</literal>.  A typical alternate
	  choice would be something like
	  <userinput>ufs:da0d</userinput> which could be a
	  hypothetical partition that contains the pre-Vinum root
	  filesystem.  Care should be taken if one of the alias
	  <literal>"a"</literal> partitions are entered here that are
	  actually reference to the subdisks of the Vinum root device,
	  because in a mirrored setup, this would only mount one piece
	  of a mirrored root device.  If this filesystem is to be
	  mounted read-write later on, it is necessary to remove the
	  other plex(es) of the Vinum root volume since these plexes
	  would otherwise carry inconsistent data.</para>
      </sect3>

      <sect3>
	<title>Only Primary Bootstrap Loads</title>

	<para>If <filename>/boot/loader</filename> fails to load, but
	  the primary bootstrap still loads (visible by a single dash
	  in the left column of the screen right after the boot
	  process starts), an attempt can be made to interrupt the
	  primary bootstrap at this point, using the
	  <keycap>space</keycap> key.  This will make the bootstrap
	  stop in stage two, see <xref linkend="boot-boot1">.  An
	  attempt can be made here to boot off an alternate partition,
	  like the partition containing the previous root filesystem
	  that has been moved away from <literal>"a"</literal>
	  above.</para>
      </sect3>

      <sect3 id="vinum-root-panic">
	<title>Nothing Boots, the Bootstrap
	  Panics</title>

	<para>This situation will happen if the bootstrap had been
	  destroyed by the Vinum installation.	Unfortunately, Vinum
	  accidentally currently leaves only 4 KB at the beginning of
	  its partition free before starting to write its Vinum header
	  information.	However, the stage one and two bootstraps plus
	  the disklabel embedded between them currently require 8 KB.
	  So if a Vinum partition was started at offset 0 within a
	  slice or disk that was meant to be bootable, the Vinum setup
	  will trash the bootstrap.</para>

	<para>Similarly, if the above situation has been recovered,
	  for example by booting from a <quote>Fixit</quote> medium,
	  and the bootstrap has been re-installed using
	  <command>disklabel -B</command> as described in <xref
	  linkend="boot-boot1">, the bootstrap will trash the Vinum
	  header, and Vinum will no longer find its disk(s).  Though
	  no actual Vinum configuration data or data in Vinum volumes
	  will be trashed by this, and it would be possible to recover
	  all the data by entering exact the same Vinum configuration
	  data again, the situation is hard to fix at all.  It would
	  be necessary to move the entire Vinum partition by at least
	  4 KB off, in order to have the Vinum header and the system
	  bootstrap no longer collide.</para>
      </sect3>
    </sect2>

    <sect2 id="vinum-root-4x">
      <title>Diferença para o freeBSD 4.x</title>

      <para>Com o freeBSD 4.x, algumas funções internas são obrigatórias
      para fazer com que o vinum procure por todos os discos, e o código
      que desobre o número de identidade interno do dispositivo raiz não
      é inteligênte suficiente para suportar nomes como
      <devicename>/dev/vinum/root</devicename> automaticamente.  Então,
      as coisas são um pouco diferentes aqui.</para>
     
      <para>Vinum precisa ser informado dos discos exatos que ele tem
      que procurar, use uma linha parecida com a seguinte em
      <filename>/boot/loader.conf</filename>:</para>
      
      <para><literal>vinum.drives="/dev/<replaceable>da0</replaceable>
	/dev/<replaceable>da1</replaceable>"</literal></para>

      <para>É importante que todos os discos que contém dados do vinum
      sejam mencionados.  Não será prejudicial se discos a
      <emphasis>mais</emphasis> forem listados, e nem é necessário
      adicionar cada fatia ou cada partição explicitamente, porque o
      vinum irá procurar  por cabeçalhos válidos para ele em todos as
      partições dos discos citados.</para>
      

      <para>a partir do momento em que as rotinas usadas para passar o
      nome do arquivo de sistema raiz e para produzir o device ID
      (major/minor number) estão preparadas apenas para suportar nomes
      de dispositivos <quote>clássicos</quote> como
      <devicename>/dev/ad0s1a</devicename>, eles não podem fazer o menor
      sentido em um nome de volume raiz do tipo
      <devicename>/dev/vinum/root</devicename>.  Por esta razão, o
      próprio vinum precisa setar antecipadamente o parâmero interno de
      kernel que armazena o número de identidade do dispositivo raiz
      durante a sua inicialização.  Isso é feito setando a variável
      <literal>vinum.root</literal> com o valor do nome do volume
      raiz.  A entrada em <filename>/boot/loader.conf</filename> para
      efetuar essa tarefa se parece com:</para>
      
      <para><literal>vinum.root="root"</literal></para>

      <para>Agora, quando a inicialização do kernel tenta descobrir o
      dispositivo raiz a ser montado, vê se algum modulo de kernel 
      
      Now, when the kernel initialization tries to find out the
	root device to mount, it sees whether some kernel module has
	already pre-initialized the kernel parameter for it.  If that
	is the case, <emphasis>and</emphasis> the device claiming the
	root device matches the major number of the driver as figured
	out from the name of the root device string being passed (that
	is, <literal>"vinum"</literal> in our case), it will use the
	pre-allocated device ID, instead of trying to figure out one
	itself.	 That way, during the usual automatic startup, it can
	continue to mount the Vinum root volume for the root
	filesystem.</para>

      <para>However, when <command>boot -a</command> has been
	requesting to ask for entering the name of the root device
	manually, it must be noted that this routine still cannot
	actually parse a name entered there that refers to a Vinum
	volume.  If any device name is entered that does not refer to
	a Vinum device, the mismatch between the major numbers of the
	pre-allocated root parameter and the driver as figured out
	from the given name will make this routine enter its normal
	parser, so entering a string like
	<userinput>ufs:da0d</userinput> will work as expected. Note
	that if this fails, it is however no longer possible to
	re-enter a string like <userinput>ufs:vinum/root</userinput>
	again, since it cannot be parsed.  The only way out is to
	reboot again, and start over then.  (At the
	<quote>askroot</quote> prompt, the initial
	<devicename>/dev/</devicename> can always be omitted.)</para>
    </sect2>
  </sect1>
</chapter>
