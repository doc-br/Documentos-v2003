<!--
     The FreeBSD Documentation Project

     $FreeBSD: doc/en_US.ISO8859-1/books/handbook/users/chapter.sgml,v 1.39 2003/11/03 20:18:12 blackend Exp $
-->

<chapter id="users">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Neil</firstname>
	<surname>Blakey-Milner</surname>
	<contrib>Contributed by </contrib>
      </author>
    </authorgroup>
    <!-- Feb 2000 -->
  </chapterinfo>

  <title>Usuários e Administração Básica de contas</title>
  
  <sect1 id="users-synopsis">
    <title>Sinópse</title>
    
    <para>O FreeBSD permite várias pessoas usarem o computador ao mesmo tempo.
      Obviamente, somente um daqueles usuários pode sentar-se na frente da tela e 
      do teclado ao mesmo tempo.
      <footnote>
	<para>Bem, ao menos que você enganchar acima dos terminais múltiplos, mas nós iremos
	guardar isso para <xref linkend="serialcomms">.</para>
      </footnote>, mas qualquer número de usuarios podem logar atravéz de uma rede.
      Para usar o sistema qualquer usuário deve ter uma conta.</para>
    
    <para>Depois de ler este cap&iacute;tulo, voce ir&aacute; saber:</para>

    <itemizedlist>
      <listitem>
	<para>A diferença entre várias contas de usuários no sistema FreeBSD.</para>
      </listitem>

      <listitem>
	<para>Como adicionar uma conta de  usuário.</para>
      </listitem>

      <listitem>
	<para>Como remover uma conta de usuário.</para>
      </listitem>

      <listitem>
	<para>Como alterar os detalhes de uma conta de usuário, como o nome 
        completo do usuario, ou a shell preferida.</para>
      </listitem>

      <listitem>
	<para>Como se ajustar os limites básicos por conta, para controlar os 
        recursos tais como memória e tempo de uso do CPU que usuários e grupos 
        de contas podem acessar.</para>
      </listitem>

      <listitem>
	<para>Como usar grupos para facilitar a administração de contas.</para>
      </listitem>
    </itemizedlist>

    <para>Antes de ler este capítulo, você deve::</para>

    <itemizedlist>
      <listitem>
	<para>Entender o básico de &unix, e FreeBSD (<xref
	    linkend="basics">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="users-introduction">
    <title>Introdução</title>

    <para>Todo o acesso ao sistema é conseguido atravéz das contas, e
      todos os processos são executados por usuários, assim usuários e 
      administração de contas são integralmente importantes em sistemas FreeBSD.</para>
    
    <para>Todas as contas em um sistema FreeBSD tem determinadas informações
       associada a ela para indenticiar a conta.</para>

    <variablelist>
      <varlistentry>
	<term>Nome do usuário</term>

        <listitem>
          <para>O nome do usuário será digitado no prompt <prompt>login:</prompt>.
            Os nomes de usuários devem ser unicos em um computador, você não pode
            ter dois usuários com o mesmo nome. Há um número de regras para criar
            nomes válidos de usuários, documentadas em &man.passwd.5;; você usuaria
            tipicamente nomes de usuários que consistem em oito ou poucos caracteres 
            todos minusculos.</para>
	</listitem>
      </varlistentry>         


      <varlistentry>
	<term>Senha</term>

	<listitem>
          <para>Cada conta tem uma senha associada com ela. A Senha pode ser
             vazia, neste caso nenhuma senha será solicitada para acessar o 
             sistema. Isso é normalmente uma idéia muito ruim; todas as contas
             devem ter uma senha.</para>
         </listitem>
      </varlistentry>

      <varlistentry>
	<term>Usuário ID (UID)</term>

	<listitem>
	  <para>O UID é um número de 0 até 65536 usado para identificar de forma 
            única os usuários no sistema. Internamento o FreeBSD usa o UID 
            para identificar usuários&mdash; qualquer comando do FreeBSD será
            liberado para um usuário específico convertendo seu UID depois de 
            utilizar o comando. Isso que dizer que você pode ter contas com 
            diferentes nomes de usuários com o mesmo UID. Tanto quanto para 
            o FreeBSD são um usuário apenas. É improvável que você necessitará 
            sempre fazer isto.</para> 
	</listitem>
      </varlistentry>


      <varlistentry>
	<term>Grupo ID (GID)</term>

	<listitem>
	  <para>O GID é um número de 0 até 65536 usado para identificar de forma
            única o grupo primário que o usuário pertence. Os grupos são um mecanismo
            para controlar o acesso aos recursos baseados em GID ao invéz de UID.
            Isto pode significativamente reduzir o tamanho de arquivos de configurações.
            Um usuário pode também estar em mais de um grupo.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Classe de Login</term>

        <listitem>
	  <para>Classe de login são uma extenção para o mecanismo de grupos que
            fornecem a flexibilidade adicional à adaptar o sistema aos usuários
            diferentes.</para>
	</listitem>
      </varlistentry>


      <varlistentry>
	<term>Tempo de alteração da senha</term>

	<listitem>
	  <para>Por padrão o FreeBSD não força os usuários a trocar as suas senhas
            periodicamente. Você pode fazer isto baseado por usuário, forçando alguns
            ou todos seus usuários para mudar suas senhas depois de um determinado 
            tempo.</para> 
	</listitem>
      </varlistentry>


      <varlistentry>
	<term>Tempo de expiração da conta</term>

	<listitem>
	  <para>Por padrão o FreeBSD não expira as contas. Se você estiver
            criando uma conta que você sabe que tem um tempo limitado de uso,
            por exemplo, em uma escolha onde você tem contas para os estudantes,
            você pode especificar quando a conta expira. Após a expiração do tempo
            o cliente não poderá logar no sistema, embora diretórios e arquivos do 
            cliente permanecerão.</para>
         </listitem>
      </varlistentry>


      <varlistentry>
	<term>Nome completo dos usuários</term>

	<listitem>
	  <para>O nome único do usuário identifica a conta para o FreeBSD, mas
            não reflete necessariamente o nome real do usuário. Esta informação
            pode ser associada com a conta.</para>
	</listitem>
      </varlistentry>
 

      <varlistentry>
	<term>Diretório <foreignphrase>Home</foreignphrase></term>

	<listitem>
	  <para>O Diretório <foreignphrase>Home</foreignphrase> é o caminho completo
            para o diretório do sistema em que o usuário logará no sistema. Uma convenção
            comum deve pôr todos os diretórios home do usuário sob <filename>/home/<replaceable>usuário</replaceable></filename>.
            O usuário armazenaria seus arquivos pessoais em seu diretório home, e 
            todos os diretórios que puderem criar dentro dele.</para>
         </listitem>
      </varlistentry>



      <varlistentry>
	<term><foreignphrase>Shell</foreignphase> do usuário</term>

	<listitem>
	  <para>A shell fornece o ambiente de usuário padrão para interagir com
            o sistema. Existem muitos tipos diferentes de shells, e os usuários
            experientes terão suas próprias preferências, que podem ser refletidas
            para os ajustes de contas.</para>
	</listitem>
      </varlistentry>
    </variablelist>


    <para>Existem tres tipos de contas: o <link
	linkend="users-superuser">super usuário</link>, <link
	linkend="users-system">usuários do sistema</link>, e <link
	linkend="users-user">usuários</link>.  A conta super usuário
      normalmente chamada de <username>root</username>, é usada para 
      administrar o sistema sem limitação de privilegios. Usuários do
      sistema executam serviços.  Finalmente, usuários são usadas por 
      pessoas, que poderão logar, ler e-mail, e assim por diante.</para>
  </sect1>
    
  <sect1 id="users-superuser">
    <title>O super usuário</title>
    
    <indexterm>
      <primary>contas</primary>
      <secondary>super usuário (root)</secondary>
    </indexterm>
    <para>A conta super usuário, normalmente chamada
      <username>root</username>, vem pré configurada para facilitar
      a administração do sistema, e não deve ser usada para tarefas
      cotidianas como envio e recebimento de e-mail, exploração geral
      do sistema, ou para programação.</para>

  
    <para>Isto é porque o super usuário, ao contrário dos usuários normais,
      podem operar sem limites, e o emprego errado do super usuário pode 
      resultar em um espetacular desastre. As contas de usuários são 
      incapazes de destruir o sistema atravéz de um erro, assim que é geralmente
      melhor usar um usuário normal quando possível, a menos que você 
      necessite de um privilégio extra.</para>

   
    <para>Você deve sempre dobrar e triplicar a verificação dos comandos 
      que você emite como o super usuário, desde que um espaço extra ou um
      caracter faltante podem significar a perda irreparável dos dados.</para>
   

    <para>Assim, a primeira coisa que você deve fazer após ter lido este
      capítulo é criar um usuário sem privilégios para você mesmo para 
      uso geral se você não tiver já. Isto aplica-se igualmente se você está 
      rodando em uma máquina multi usuários ou mono usuário.
      Mais tarde neste capítulo, nós discutimos como criar clientes adicionais,
      e como mudar entre o usuário e o super usuário.</para>
  </sect1>
    
  <sect1 id="users-system">
    <title>Contas do sistema</title>

    <indexterm>
      <primary>contas</primary>
      <secondary>sistema</secondary>
    </indexterm>
  
    <para>Usuários do sistema são usados para rodar serviços como DNS,
      correio, servidores web, e assim por diante. A razão para isso é 
      segurança, se todos os serviços rodarem com super usuários, poderiam
      agir sem restrições.</para>

    <indexterm>
      <primary>conta</primary>
      <secondary><username>daemon</username></secondary>
    </indexterm>
    <indexterm>
      <primary>conta</primary>
      <secondary><username>operator</username></secondary>
    </indexterm>
    <para>Exemplos de usuários de sistema são <username>daemon</username>,
      <username>operator</username>, <username>bind</username> (para o Domain
      Name Service), e <username>news</username>. Frequentemente os administradores
      de sistemas criam <username>httpd</username> para rodar um servidor de web.</para> 

    <indexterm>
      <primary>contas</primary>
      <secondary><username>nobody</username></secondary>
    </indexterm>
    <para><username>nobody</username> é o usuário genérico sem privilégios do
      sistema de usuários. Entretanto, é importante manter na sua mente que vários
      serviços usam <username>nobody</username>, e vários arquivos e processos irão
      associar com ele, sendo assim mais privilegiado o usuários torna-se.</para>
  </sect1>

  <sect1 id="users-user">
    <title>Contas de usuários</title>

    <indexterm>
      <primary>contas</primary>
      <secondary>usuários</secondary>
    </indexterm>
    <para>As contas de usuários é o primeiro caminho para pessoas reais  
      acessarem o sistema, e estas contas isolam o usuário e o ambiente,
      impedindo os usuários danifiquem o sistema ou outros usuários, e 
      permitam que usuários customize seu ambiente sem afetar outros.</para>

    <para>Cada pessoa que acessa seu sistema deve ter uma conta de usuário.
      Isto permite que você procure quem está fazendo o que, e previna
      que pessoas alterem outros usuários, configurações ou lerem outros
      e-mails e assim por diante.</para>

    <para>Cada usuário pode ajustar seu próprio ambiente para acomodar
      seu uso no sistema, para usar uma shell alternativa, editor, 
      key bindings e língua.</para>
  </sect1>

  <sect1 id="users-modifying">
    <title>Modificando contas</title>

    <indexterm>
      <primary>contas</primary>
      <secondary>modificando</secondary>
    </indexterm>

    <para>Existem uma variedade de comandos diferentes disponíveis no 
      ambiente &unix; para manipular contas de usuários. Os comandos mais
      comins são sumariados abaixo, seguido por uns exemplos mais detalhados
      de seu uso.</para>
      

    <informaltable>
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Comando</entry>
	    <entry>Sumário</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry>&man.adduser.8;</entry>
	    <entry>O comando recomendado para adicionar novos usuários.</entry>
	  </row>
	  <row>
	    <entry>&man.rmuser.8;</entry>
	    <entry>O comando recomendado para excluir usuários.</entry>
	  </row>
	  <row>
	    <entry>&man.chpass.1;</entry>
            <entry>Uma ferramenta flexivel para alterar informações de usuários.</entry>
	  </row>
	  <row>
	    <entry>&man.passwd.1;</entry>
            <entry>Um simples comando para alterar a senha do usuário</entry>
	  </row>
	  <row>
	    <entry>&man.pw.8;</entry>
            <entry>Uma podereosa e flexível ferramenta para alterar todos os aspectos
             das contas de usuários.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <sect2 id="users-adduser">
      <title><command>adduser</command></title>

      <indexterm>
        <primary>contas</primary>
        <secondary>adicionando</secondary>
      </indexterm>
      <indexterm>
        <primary><command>adduser</command></primary>
      </indexterm>
      <indexterm>
        <primary><filename class=directory>/usr/share/skel</filename></primary>
      </indexterm>
      <indexterm><primary>diretório esqueleto</primary></indexterm>
       <para>&man.adduser.8; é um programa simples para adicionar novos usuários.
         Cria entradas nos arquivos <filename>passwd</filename> e 
         <filename>group</filename>. Criará também um diretório home para o 
         usuário novo, copia os arquivos de configuração padrão 
         (<quote>dotfiles</quote>) de <filename>/usr/share/skel</filename>, e
         pode opcionalmente enviar ao usuário novo uma mensagem de boas vindas.</para>

       <para>In &os;&nbsp;5.0, &man.adduser.8; foi rescrito de Perl script para 
         um shell script que trabalha-se evoluntariamente em torno do &man.pw.8;, 
         assim seu uso é ligeiramente diferente em &os; 4.X e em &os; 5.X.</para>

      <para>Para criar uma configuração inicial, use
       	<command>adduser -s -config_create</command>.
	<footnote>  
          <para>O <option>-s</option> faz &man.adduser.8; por padrão ficar quieto.
            Nós usamos <option>-v</option> mais tarde quando queremos
            mudar padrões.</para>
        </footnote>
        Em seguida, nós configuramos os padrões do &man.adduser.8;, e criamos
        a nossa primeira conta de usuário, desde que estamos usando
        <username>root</username> para uso normal é evil e nasty.</para>
        

      <example>
	<title>Configuring <command>adduser</command> and adding a
	  user on &os;&nbsp;4.X</title>

	<screen>&prompt.root; <userinput>adduser -v</userinput>
Use option ``-silent'' if you don't want to see all warnings and questions.
Check /etc/shells
Check /etc/master.passwd
Check /etc/group
Enter your default shell: csh date no sh tcsh zsh [sh]: <userinput>zsh</userinput>
Your default shell is: zsh -&gt; /usr/local/bin/zsh
Enter your default HOME partition: [/home]:
Copy dotfiles from: /usr/share/skel no [/usr/share/skel]: 
Send message from file: /etc/adduser.message no 
[/etc/adduser.message]: <userinput>no</userinput>
Do not send message
Use passwords (y/n) [y]: <userinput>y</userinput>

Write your changes to /etc/adduser.conf? (y/n) [n]: <userinput>y</userinput>

Ok, let's go.
Don't worry about mistakes. I will give you the chance later to correct any input.
Enter username [a-z0-9_-]: <userinput>jru</userinput>
Enter full name []: <userinput>J. Random User</userinput>
Enter shell csh date no sh tcsh zsh [zsh]: 
Enter home directory (full path) [/home/jru]: 
Uid [1001]: 
Enter login class: default []: 
Login group jru [jru]: 
Login group is ``jru''. Invite jru into other groups: guest no 
[no]: <userinput>wheel</userinput>
Enter password []: 
Enter password again []: 

Name:	  jru
Password: ****
Fullname: J. Random User
Uid:	  1001
Gid:	  1001 (jru)
Class:	  
Groups:	  jru wheel
HOME:     /home/jru
Shell:	  /usr/local/bin/zsh
OK? (y/n) [y]: <userinput>y</userinput>
Added user ``jru''
Copy files from /usr/share/skel to /home/jru
Add another user? (y/n) [y]: <userinput>n</userinput>
Goodbye!
&prompt.root;</screen>
      </example>

      <para>In summary, we changed the default shell to
	<application>zsh</application> (an additional shell found in
	the Ports Collection), and turned off the sending of a welcome mail to
	added users.  We then saved the configuration,
	created an account for <username>jru</username>, and made
	sure <username>jru</username> is in <username>wheel</username>
	group (so that she may assume the role of
	<username>root</username> with the &man.su.1;
	command.)</para>

      <note>
	<para>The password you type in is not echoed, nor are asterisks
	  displayed.  Make sure you do not mistype the password twice.
	  </para>
      </note>

      <note>
	<para>Just use &man.adduser.8; without arguments
	  from now on, and you will not have to go through changing the
	  defaults.  If the program asks you to change the defaults,
	  exit the program, and try the <option>-s</option>
	  option.</para>
      </note>

      <example>
	<title>Adding a user on &os;&nbsp;5.X</title>

	<screen>&prompt.root; <userinput>adduser</userinput>
Username: <userinput>jru</userinput>
Full name: <userinput>J. Random User</userinput>
Uid (Leave empty for default):
Login group [jru]:
Login group is jru. Invite jru into other groups? []: <userinput>wheel</userinput>
Login class [default]:
Shell (sh csh tcsh zsh nologin) [sh]: <userinput>zsh</userinput>
Home directory [/home/jru]:
Use password-based authentication? [yes]:
Use an empty password? (yes/no) [no]:
Use a random password? (yes/no) [no]:
Enter password:
Enter password again:
Lock out the account after creation? [no]:
Username   : jru
Password   : ****
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? (yes/no): <userinput>yes</userinput>
adduser: INFO: Successfully added (jru) to the user database.
Add another user? (yes/no): <userinput>no</userinput>
Goodbye!
&prompt.root;</screen>
      </example>
    </sect2>

    <sect2 id="users-rmuser">
      <title><command>rmuser</command></title>

      <indexterm><primary><command>rmuser</command></primary></indexterm>
      <indexterm>
        <primary>accounts</primary>
        <secondary>removing</secondary>
      </indexterm>

      <para>You can use &man.rmuser.8; to
	completely remove a user from the system.
	&man.rmuser.8; performs the following
	steps:</para>

      <procedure>
	<step>
	  <para>Removes the user's &man.crontab.1; entry (if
	    any).</para>
	</step>
	<step>
	  <para>Removes any &man.at.1; jobs belonging to the
	    user.</para>
	</step>
	<step>
	  <para>Kills all processes owned by the user.</para>
	</step>
	<step>
	  <para>Removes the user from the system's local password
	    file.</para>
	</step>
	<step>
	  <para>Removes the user's home directory (if it is owned by
	    the user).</para>
	</step>
	<step>
	  <para>Removes the incoming mail files belonging to the user
	    from <filename>/var/mail</filename>.</para>
	</step>
	<step>
	  <para>Removes all files owned by the user from temporary
	    file storage areas such as <filename>/tmp</filename>.</para>
	</step>
	<step>
	  <para>Finally, removes the username from all groups to which
	    it belongs in <filename>/etc/group</filename>.
	    
	    <note>
	      <para>If a group becomes empty and the group name is the
		same as the username, the group is removed; this
		complements the per-user unique groups created by
		&man.adduser.8;.</para>
	    </note>
	  </para>
	</step>
      </procedure>

      <para>&man.rmuser.8; cannot be used to remove
	superuser accounts, since that is almost always an indication
	of massive destruction.</para>

      <para>By default, an interactive mode is used, which attempts to
	make sure you know what you are doing.</para>

      <example>
	<title><command>rmuser</command> Interactive Account Removal</title>

	<screen>&prompt.root; <userinput>rmuser jru</userinput>
Matching password entry:
jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? <userinput>y</userinput>
Remove user's home directory (/home/jru)? <userinput>y</userinput>
Updating password file, updating databases, done.
Updating group file: trusted (removing group jru -- personal group is empty) done.
Removing user's incoming mail file /var/mail/jru: done.
Removing files belonging to jru from /tmp: done.
Removing files belonging to jru from /var/tmp: done.
Removing files belonging to jru from /var/tmp/vi.recover: done.
&prompt.root;</screen>
      </example>
    </sect2>

    <sect2 id="users-chpass">
      <title><command>chpass</command></title>

      <indexterm><primary><command>chpass</command></primary></indexterm>
      <para>&man.chpass.1; changes user database
	information such as passwords, shells, and personal
	information.</para>

      <para>Only system administrators, as the superuser, may change
	other users' information and passwords with 
	&man.chpass.1;.</para>

      <para>When passed no options, aside from an optional username,
	&man.chpass.1; displays an editor
	containing user information.  When the user exists from the
	editor, the user database is updated with the new
	information.</para>

      <note>
	<para>In &os;&nbsp;5.X, you will be asked for your password
	 after exiting the editor if you are not the superuser.</para>
      </note>

      <example>
	<title>Interactive <command>chpass</command> by Superuser</title>

	<screen>#Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1001
Gid [# or name]: 1001
Change [month day year]:
Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <para>The normal user can change only a small subset of this
	information, and only for themselves.</para>

      <example>
	<title>Interactive <command>chpass</command> by Normal User</title>

	<screen>#Changing user database information for jru.
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <note>
	<para>&man.chfn.1; and &man.chsh.1; are
	  just links to &man.chpass.1;, as 
	  are &man.ypchpass.1;,
	  &man.ypchfn.1;, and
	  &man.ypchsh.1;.  NIS support is automatic, so
	  specifying the <literal>yp</literal> before the command is
	  not necessary.  If this is confusing to you, do not worry, NIS will
	  be covered in <xref linkend="advanced-networking">.</para>
      </note>
    </sect2>
    <sect2 id="users-passwd">
      <title><command>passwd</command></title>

      <indexterm><primary><command>passwd</command></primary></indexterm>
      <indexterm>
        <primary>accounts</primary>
        <secondary>changing password</secondary>
      </indexterm>
      <para>&man.passwd.1; is the usual way to
	change your own password as a user, or another user's password
	as the superuser.</para>

      <note>
	<para>Users must type in their original password before
	  changing their password, to prevent an unauthorized person
	  from changing their password when the user is away from
	  their console.</para>
      </note>

      <example>
	<title>Changing Your Password</title>

	<screen>&prompt.user; <userinput>passwd</userinput>
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
      </example>

      <example>
	<title>Changing Another User's Password as the Superuser</title>

        <screen>&prompt.root; <userinput>passwd jru</userinput>
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
      </example>

      <note>
	<para>As with &man.chpass.1;,
	  &man.yppasswd.1; is just a link to
	  &man.passwd.1;, so NIS works with either
	  command.</para>
      </note>
    </sect2>


    <sect2 id="users-pw">
      <title><command>pw</command></title>
      <indexterm><primary><command>pw</command></primary></indexterm>

      <para>&man.pw.8; is a command line utility to create, remove,
	modify, and display users and groups.  It functions as a front
	end to the system user and group files.  &man.pw.8;
	has a very powerful set of command line options that make it
	suitable for use in shell scripts, but new users may find it
	more complicated than the other commands presented
	here.</para>
    </sect2>


  </sect1>

  <sect1 id="users-limiting">
    <title>Limiting Users</title>

    <indexterm><primary>limiting users</primary></indexterm>
    <indexterm>
      <primary>accounts</primary>
      <secondary>limiting</secondary>
    </indexterm>
    <para>If you have users, the ability to limit their system use may
      have come to mind.  FreeBSD provides
      several ways an administrator can limit the amount of system
      resources an individual may use.  These limits are
      divided into two sections: disk quotas, and other resource
      limits.</para>

    <indexterm><primary>quotas</primary></indexterm>
    <indexterm>
      <primary>limiting users</primary>
      <secondary>quotas</secondary>
    </indexterm>
    <indexterm><primary>disk quotas</primary></indexterm>
    <para>Disk quotas limit disk usage to users, and
      they
      provide a way to quickly check that usage without
      calculating it every time.  Quotas are discussed in <xref
      linkend="quotas">.</para>

    <para>The other resource limits include ways to limit the amount of
      CPU, memory, and other resources a user may consume.  These are
      defined using login classes and are discussed here.</para>

    <indexterm>
      <primary><filename>/etc/login.conf</filename></primary>
    </indexterm>
    <para>Login classes are defined in
      <filename>/etc/login.conf</filename>.  The precise semantics are
      beyond the scope of this section, but are described in detail in the
      &man.login.conf.5; manual page.  It is sufficient to say that each
      user is assigned to a login class (<literal>default</literal> by
      default), and that each login class has a set of login capabilities
      associated with it.  A login capability is a
      <literal><replaceable>name</replaceable>=<replaceable>value</replaceable></literal>
      pair, where <replaceable>name</replaceable> is a well-known
      identifier and <replaceable>value</replaceable> is an arbitrary
      string processed accordingly depending on the name.  Setting up login
      classes and capabilities is rather straight-forward and is also
      described in &man.login.conf.5;.</para>

    <para>Resource limits are different from plain vanilla login
      capabilities in two ways.  First, for every limit, there is a soft
      (current) and hard limit.  A soft limit may be adjusted by the user
      or application, but may be no higher than the hard limit.  The latter
      may be lowered by the user, but never raised.  Second, most resource
      limits apply per process to a specific user, not the user as a whole.
      Note, however, that these differences are mandated by the specific
      handling of the limits, not by the implementation of the login
      capability framework (i.e., they are not <emphasis>really</emphasis>
      a special case of login capabilities).</para>

    <para>And so, without further ado, below are the most commonly used
      resource limits (the rest, along with all the other login
      capabilities, may be found in &man.login.conf.5;).</para>

    <variablelist>
      <varlistentry>
        <term><literal>coredumpsize</literal></term>

	<listitem>
    <indexterm><primary>coredumpsize</primary></indexterm>
    <indexterm>
      <primary>limiting users</primary>
      <secondary>coredumpsize</secondary>
    </indexterm>
	  <para>The limit on the size of a core file generated by a program
	  is, for obvious reasons, subordinate to other limits on disk
	  usage (e.g., <literal>filesize</literal>, or disk quotas).
	  Nevertheless, it is often used as a less-severe method of
	  controlling disk space consumption: since users do not generate
	  core files themselves, and often do not delete them, setting this
	  may save them from running out of disk space should a large
	  program (e.g., <application>emacs</application>) crash.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>cputime</literal></term>

	<listitem>
    <indexterm><primary>cputime</primary></indexterm>
    <indexterm>
      <primary>limiting users</primary>
      <secondary>cputime</secondary>
    </indexterm>
	  <para>This is the maximum amount of CPU time a user's process may
	    consume.  Offending processes will be killed by the kernel.

	    <note>
	      <para>This is a limit on CPU <emphasis>time</emphasis>
	        consumed, not percentage of the CPU as displayed in some
	        fields by &man.top.1; and &man.ps.1;.  A limit on the
	        latter is, at the time of this writing, not possible, and
	        would be rather useless: a compiler&mdash;probably a
	        legitimate task&mdash;can easily use almost 100% of a CPU
	        for some time.</para>
	    </note>
	  </para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>filesize</literal></term>

	<listitem>
    <indexterm><primary>filesize</primary></indexterm>
    <indexterm>
      <primary>limiting users</primary>
      <secondary>filesize</secondary>
    </indexterm>
	  <para>This is the maximum size of a file the user may possess.
	    Unlike <link linkend="quotas">disk quotas</link>, this limit is
	    enforced on individual files, not the set of all files a user
	    owns.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>maxproc</literal></term>

	<listitem>
    <indexterm><primary>maxproc</primary></indexterm>
        <indexterm>
      <primary>limiting users</primary>
      <secondary>maxproc</secondary>
    </indexterm>
	  <para>This is the maximum number of processes a user may be
	    running.  This includes foreground and background processes
	    alike.  For obvious reasons, this may not be larger than the
	    system limit specified by the <varname>kern.maxproc</varname>
	    &man.sysctl.8;.  Also note that setting this 
	    too small may hinder a
	    user's productivity: it is often useful to be logged in
	    multiple times or execute pipelines.  Some tasks, such as
	    compiling a large program, also spawn multiple processes (e.g.,
	    &man.make.1;, &man.cc.1;, and other intermediate
	    preprocessors).</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>memorylocked</literal></term>

	<listitem>
    <indexterm><primary>memorylocked</primary></indexterm>
    <indexterm>
      <primary>limiting users</primary>
      <secondary>memorylocked</secondary>
    </indexterm>
	  <para>This is the maximum amount a memory a process may have
	    requested to be locked into main memory (e.g., see
	    &man.mlock.2;).  Some system-critical programs, such as
            &man.amd.8;, lock into main memory such that in the event
	    of being swapped out, they do not contribute to
	    a system's trashing in time of trouble.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>memoryuse</literal></term>

	<listitem>
    <indexterm><primary>memoryuse</primary></indexterm>
    <indexterm>
      <primary>limiting users</primary>
      <secondary>memoryuse</secondary>
    </indexterm>
	  <para>This is the maximum amount of memory a process may consume
	    at any given time.  It includes both core memory and swap
	    usage.  This is not a catch-all limit for restricting memory
	    consumption, but it is a good start.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>openfiles</literal></term>

	<listitem>
    <indexterm><primary>openfiles</primary></indexterm>
    <indexterm>
      <primary>limiting users</primary>
      <secondary>openfiles</secondary>
    </indexterm>
	  <para>This is the maximum amount of files a process may have
	    open.  In FreeBSD, files are also used to represent sockets and
	    IPC channels; thus, be careful not to set this too low.  The
	    system-wide limit for this is defined by the
	    <varname>kern.maxfiles</varname> &man.sysctl.8;.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>sbsize</literal></term>

	<listitem>
    <indexterm><primary>sbsize</primary></indexterm>
    <indexterm>
      <primary>limiting users</primary>
      <secondary>sbsize</secondary>
    </indexterm>
	  <para>This is the limit on the amount of network memory, and thus
	    mbufs, a user may consume.  This originated as a response to an
	    old DoS attack by creating a lot of sockets, but can be
	    generally used to limit network communications.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>stacksize</literal></term>

	<listitem>
    <indexterm><primary>stacksize</primary></indexterm>
    <indexterm>
      <primary>limiting users</primary>
      <secondary>stacksize</secondary>
    </indexterm>
	  <para>This is the maximum size a process' stack may grow to.
	    This alone is not sufficient to limit the amount of memory a
	    program may use; consequently, it should be used in conjunction
	    with other limits.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>There are a few other things to remember when setting resource
      limits.  Following are some general tips, suggestions, and
      miscellaneous comments.</para>

    <itemizedlist>
      <listitem>
        <para>Processes started at system startup by
          <filename>/etc/rc</filename> are assigned to the
          <literal>daemon</literal> login class.</para>
      </listitem>

      <listitem>
        <para>Although the <filename>/etc/login.conf</filename> that comes
          with the system is a good source of reasonable values for most
          limits, only you, the administrator, can know what is appropriate
          for your system.  Setting a limit too high may open your system
          up to abuse, while setting it too low may put a strain on
          productivity.</para>
      </listitem>

      <listitem>
        <para>Users of the X Window System (X11) should probably be granted
	  more resources than other users.  X11 by itself takes a lot of
	  resources, but it also encourages users to run more programs
	  simultaneously.</para>
      </listitem>

      <listitem>
        <para>Remember that many limits apply to individual processes, not
          the user as a whole.  For example, setting 
	  <varname>openfiles</varname> to 50 means
          that each process the user runs may open up to 50 files.  Thus,
          the gross amount of files a user may open is the value of
          <literal>openfiles</literal> multiplied by the value of
          <literal>maxproc</literal>.  This also applies to memory
          consumption.</para>
      </listitem>
    </itemizedlist>

    <para>For further information on resource limits and login classes and
      capabilities in general, please consult the relevant manual pages:
      &man.cap.mkdb.1;, &man.getrlimit.2;, &man.login.conf.5;.</para>
  </sect1>

  <sect1 id="users-personalizing">
    <title>Personalizing Users</title>

    <para>Localization is an environment set up by the system
      administrator or user to accommodate different languages,
      character sets, date and time standards, and so on.  This is
      discussed in the <link linkend="l10n">localization</link>
      chapter.</para>
  </sect1>

  <sect1 id="users-groups">
    <title>Groups</title>

    <indexterm><primary>groups</primary></indexterm>
    <indexterm>
      <primary><filename>/etc/groups</filename></primary>
    </indexterm>
    <indexterm>
      <primary>accounts</primary>
      <secondary>groups</secondary>
    </indexterm>
    <para>A group is simply a list of users.  Groups are identified by
      their group name and GID (Group ID).  In FreeBSD (and most other &unix; like
      systems), the two factors the kernel uses to decide whether a process
      is allowed to do something is its user ID and list of groups it
      belongs to.  Unlike a user ID, a process has a list of groups
      associated with it.  You may hear some things refer to the <quote>group ID</quote>
      of a user or process; most of the time, this just means the first
      group in the list.</para>

    <para>The group name to group ID map is in
      <filename>/etc/group</filename>.  This is a plain text file with four
      colon-delimited fields.  The first field is the group name, the
      second is the encrypted password, the third the group ID, and the
      fourth the comma-delimited list of members.  It can safely be edited
      by hand (assuming, of course, that you do not make any syntax
      errors!).  For a more complete description of the syntax, see the
      &man.group.5; manual page.</para>

    <para>If you do not want to edit <filename>/etc/group</filename>
      manually, you can use the &man.pw.8; command to add and edit groups.
      For example, to add a group called <groupname>teamtwo</groupname> and
      then confirm that it exists you can use:</para>

    <example>
      <title>Adding a Group Using &man.pw.8;</title>

      <screen>&prompt.root; <userinput>pw groupadd teamtwo</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:</screen>
    </example>

    <para>The number <literal>1100</literal> above is the group ID of the
      group <groupname>teamtwo</groupname>.  Right now,
      <groupname>teamtwo</groupname> has no members, and is thus rather
      useless.  Let's change that by inviting <username>jru</username> to
      the <groupname>teamtwo</groupname> group.</para>

    <example>
      <title>Adding Somebody to a Group Using &man.pw.8;</title>

      <screen>&prompt.root; <userinput>pw groupmod teamtwo -M jru</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:jru</screen>
    </example>

    <para>The argument to the <option>-M</option> option is a
      comma-delimited list of users who are members of the group.  From the
      preceding sections, we know that the password file also contains a
      group for each user.  The latter (the user) is automatically added to
      the group list by the system; the user will not show up as a member
      when using the <option>groupshow</option> command to &man.pw.8;,
      but will show up when the information is queried via &man.id.1; or
      similar tool.  In other words, &man.pw.8; only manipulates the
      <filename>/etc/group</filename> file; it will never attempt to read
      additionally data from <filename>/etc/passwd</filename>.</para>

    <example>
      <title>Using &man.id.1; to Determine Group Membership</title>

      <screen>&prompt.user; <userinput>id jru</userinput>
uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)</screen>
    </example>

    <para>As you can see, <username>jru</username> is a member of the
      groups <groupname>jru</groupname> and
      <groupname>teamtwo</groupname>.</para>

    <para>For more information about &man.pw.8;, see its manual page, and
      for more information on the format of
      <filename>/etc/group</filename>, consult the &man.group.5; manual
      page.</para>
  </sect1>
</chapter>

<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
