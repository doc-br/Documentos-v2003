<!--
     The FreeBSD Documentation Project

     $FreeBSD: pt_BR.ISO8859-1/books/handbook/users/chapter.sgml,v 1.14 2003/12/10 11:00:37 gamk Exp $
-->

<chapter id="users">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Neil</firstname>
	<surname>Blakey-Milner</surname>
	<contrib>Contributed by </contrib>
      </author>
    </authorgroup>
    <!-- Feb 2000 -->
  </chapterinfo>

  <title>Usuários e Administração Básica de contas</title>
  
  <sect1 id="users-synopsis">
    <title>Sinópse</title>
    
    <para>O FreeBSD permite várias pessoas usarem o computador ao mesmo tempo.
      Obviamente, somente um daqueles usuários pode sentar-se na frente da tela e 
      do teclado ao mesmo tempo.
      <footnote>
	<para>Bem, ao menos que você enganchar acima dos terminais múltiplos, mas nós iremos
	guardar isso para <xref linkend="serialcomms">.</para>
      </footnote>, mas qualquer número de usuarios podem logar atravéz de uma rede.
      Para usar o sistema qualquer usuário deve ter uma conta.</para>
    
    <para>Depois de ler este cap&iacute;tulo, voce ir&aacute; saber:</para>

    <itemizedlist>
      <listitem>
	<para>A diferença entre várias contas de usuários no sistema FreeBSD.</para>
      </listitem>

      <listitem>
	<para>Como adicionar uma conta de  usuário.</para>
      </listitem>

      <listitem>
	<para>Como remover uma conta de usuário.</para>
      </listitem>

      <listitem>
	<para>Como alterar os detalhes de uma conta de usuário, como o nome 
        completo do usuario, ou a shell preferida.</para>
      </listitem>

      <listitem>
	<para>Como se ajustar os limites básicos por conta, para controlar os 
        recursos tais como memória e tempo de uso do CPU que usuários e grupos 
        de contas podem acessar.</para>
      </listitem>

      <listitem>
	<para>Como usar grupos para facilitar a administração de contas.</para>
      </listitem>
    </itemizedlist>

    <para>Antes de ler este capítulo, você deve::</para>

    <itemizedlist>
      <listitem>
	<para>Entender o básico de &unix, e FreeBSD (<xref
	    linkend="basics">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="users-introduction">
    <title>Introdução</title>

    <para>Todo o acesso ao sistema é conseguido atravéz das contas, e
      todos os processos são executados por usuários, assim usuários e 
      administração de contas são integralmente importantes em sistemas FreeBSD.</para>
    
    <para>Todas as contas em um sistema FreeBSD tem determinadas informações
       associada a ela para indenticiar a conta.</para>

    <variablelist>
      <varlistentry>
	<term>Nome do usuário</term>

        <listitem>
          <para>O nome do usuário será digitado no prompt <prompt>login:</prompt>.
            Os nomes de usuários devem ser unicos em um computador, você não pode
            ter dois usuários com o mesmo nome. Há um número de regras para criar
            nomes válidos de usuários, documentadas em &man.passwd.5;; você usuaria
            tipicamente nomes de usuários que consistem em oito ou poucos caracteres 
            todos minusculos.</para>
	</listitem>
      </varlistentry>         


      <varlistentry>
	<term>Senha</term>

	<listitem>
          <para>Cada conta tem uma senha associada com ela. A Senha pode ser
             vazia, neste caso nenhuma senha será solicitada para acessar o 
             sistema. Isso é normalmente uma idéia muito ruim; todas as contas
             devem ter uma senha.</para>
         </listitem>
      </varlistentry>

      <varlistentry>
	<term>Usuário ID (UID)</term>

	<listitem>
	  <para>O UID é um número de 0 até 65536 usado para identificar de forma 
            única os usuários no sistema. Internamento o FreeBSD usa o UID 
            para identificar usuários&mdash; qualquer comando do FreeBSD será
            liberado para um usuário específico convertendo seu UID depois de 
            utilizar o comando. Isso que dizer que você pode ter contas com 
            diferentes nomes de usuários com o mesmo UID. Tanto quanto para 
            o FreeBSD são um usuário apenas. É improvável que você necessitará 
            sempre fazer isto.</para> 
	</listitem>
      </varlistentry>


      <varlistentry>
	<term>Grupo ID (GID)</term>

	<listitem>
	  <para>O GID é um número de 0 até 65536 usado para identificar de forma
            única o grupo primário que o usuário pertence. Os grupos são um mecanismo
            para controlar o acesso aos recursos baseados em GID ao invéz de UID.
            Isto pode significativamente reduzir o tamanho de arquivos de configurações.
            Um usuário pode também estar em mais de um grupo.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Classe de Login</term>

        <listitem>
	  <para>Classe de login são uma extenção para o mecanismo de grupos que
            fornecem a flexibilidade adicional à adaptar o sistema aos usuários
            diferentes.</para>
	</listitem>
      </varlistentry>


      <varlistentry>
	<term>Tempo de alteração da senha</term>

	<listitem>
	  <para>Por padrão o FreeBSD não força os usuários a trocar as suas senhas
            periodicamente. Você pode fazer isto baseado por usuário, forçando alguns
            ou todos seus usuários para mudar suas senhas depois de um determinado 
            tempo.</para> 
	</listitem>
      </varlistentry>


      <varlistentry>
	<term>Tempo de expiração da conta</term>

	<listitem>
	  <para>Por padrão o FreeBSD não expira as contas. Se você estiver
            criando uma conta que você sabe que tem um tempo limitado de uso,
            por exemplo, em uma escolha onde você tem contas para os estudantes,
            você pode especificar quando a conta expira. Após a expiração do tempo
            o cliente não poderá logar no sistema, embora diretórios e arquivos do 
            cliente permanecerão.</para>
         </listitem>
      </varlistentry>


      <varlistentry>
	<term>Nome completo dos usuários</term>

	<listitem>
	  <para>O nome único do usuário identifica a conta para o FreeBSD, mas
            não reflete necessariamente o nome real do usuário. Esta informação
            pode ser associada com a conta.</para>
	</listitem>
      </varlistentry>
 

      <varlistentry>
	<term>Diretório <foreignphrase>Home</foreignphrase></term>

	<listitem>
	  <para>O Diretório <foreignphrase>Home</foreignphrase> é o caminho completo
            para o diretório do sistema em que o usuário logará no sistema. Uma convenção
            comum deve pôr todos os diretórios home do usuário sob <filename>/home/<replaceable>usuário</replaceable></filename>.
            O usuário armazenaria seus arquivos pessoais em seu diretório home, e 
            todos os diretórios que puderem criar dentro dele.</para>
         </listitem>
      </varlistentry>



      <varlistentry>
	<term><foreignphrase>Shell</foreignphrase> do usuário</term>

	<listitem>
	  <para>A shell fornece o ambiente de usuário padrão para interagir com
            o sistema. Existem muitos tipos diferentes de shells, e os usuários
            experientes terão suas próprias preferências, que podem ser refletidas
            para os ajustes de contas.</para>
	</listitem>
      </varlistentry>
    </variablelist>


    <para>Existem tres tipos de contas: o <link
	linkend="users-superuser">super usuário</link>, <link
	linkend="users-system">usuários do sistema</link>, e <link
	linkend="users-user">usuários</link>.  A conta super usuário
      normalmente chamada de <username>root</username>, é usada para 
      administrar o sistema sem limitação de privilegios. Usuários do
      sistema executam serviços.  Finalmente, usuários são usadas por 
      pessoas, que poderão logar, ler e-mail, e assim por diante.</para>
  </sect1>
    
  <sect1 id="users-superuser">
    <title>O super usuário</title>
    
    <indexterm>
      <primary>contas</primary>
      <secondary>super usuário (root)</secondary>
    </indexterm>
    <para>A conta super usuário, normalmente chamada
      <username>root</username>, vem pré configurada para facilitar
      a administração do sistema, e não deve ser usada para tarefas
      cotidianas como envio e recebimento de e-mail, exploração geral
      do sistema, ou para programação.</para>

  
    <para>Isto é porque o super usuário, ao contrário dos usuários normais,
      podem operar sem limites, e o emprego errado do super usuário pode 
      resultar em um espetacular desastre. As contas de usuários são 
      incapazes de destruir o sistema atravéz de um erro, assim que é geralmente
      melhor usar um usuário normal quando possível, a menos que você 
      necessite de um privilégio extra.</para>

   
    <para>Você deve sempre dobrar e triplicar a verificação dos comandos 
      que você emite como o super usuário, desde que um espaço extra ou um
      caracter faltante podem significar a perda irreparável dos dados.</para>
   

    <para>Assim, a primeira coisa que você deve fazer após ter lido este
      capítulo é criar um usuário sem privilégios para você mesmo para 
      uso geral se você não tiver já. Isto aplica-se igualmente se você está 
      rodando em uma máquina multi usuários ou mono usuário.
      Mais tarde neste capítulo, nós discutimos como criar clientes adicionais,
      e como mudar entre o usuário e o super usuário.</para>
  </sect1>
    
  <sect1 id="users-system">
    <title>Contas do sistema</title>

    <indexterm>
      <primary>contas</primary>
      <secondary>sistema</secondary>
    </indexterm>
  
    <para>Usuários do sistema são usados para rodar serviços como DNS,
      correio, servidores web, e assim por diante. A razão para isso é 
      segurança, se todos os serviços rodarem com super usuários, poderiam
      agir sem restrições.</para>

    <indexterm>
      <primary>conta</primary>
      <secondary><username>daemon</username></secondary>
    </indexterm>
    <indexterm>
      <primary>conta</primary>
      <secondary><username>operator</username></secondary>
    </indexterm>
    <para>Exemplos de usuários de sistema são <username>daemon</username>,
      <username>operator</username>, <username>bind</username> (para o Domain
      Name Service), e <username>news</username>. Frequentemente os administradores
      de sistemas criam <username>httpd</username> para rodar um servidor de web.</para> 

    <indexterm>
      <primary>contas</primary>
      <secondary><username>nobody</username></secondary>
    </indexterm>
    <para><username>nobody</username> é o usuário genérico sem privilégios do
      sistema de usuários. Entretanto, é importante manter na sua mente que vários
      serviços usam <username>nobody</username>, e vários arquivos e processos irão
      associar com ele, sendo assim mais privilegiado o usuários torna-se.</para>
  </sect1>

  <sect1 id="users-user">
    <title>Contas de usuários</title>

    <indexterm>
      <primary>contas</primary>
      <secondary>usuários</secondary>
    </indexterm>
    <para>As contas de usuários é o primeiro caminho para pessoas reais  
      acessarem o sistema, e estas contas isolam o usuário e o ambiente,
      impedindo os usuários danifiquem o sistema ou outros usuários, e 
      permitam que usuários customize seu ambiente sem afetar outros.</para>

    <para>Cada pessoa que acessa seu sistema deve ter uma conta de usuário.
      Isto permite que você procure quem está fazendo o que, e previna
      que pessoas alterem outros usuários, configurações ou lerem outros
      e-mails e assim por diante.</para>

    <para>Cada usuário pode ajustar seu próprio ambiente para acomodar
      seu uso no sistema, para usar uma shell alternativa, editor, 
      key bindings e língua.</para>
  </sect1>

  <sect1 id="users-modifying">
    <title>Modificando contas</title>

    <indexterm>
      <primary>contas</primary>
      <secondary>modificando</secondary>
    </indexterm>

    <para>Existem uma variedade de comandos diferentes disponíveis no 
      ambiente &unix; para manipular contas de usuários. Os comandos mais
      comins são sumariados abaixo, seguido por uns exemplos mais detalhados
      de seu uso.</para>
      

    <informaltable>
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Comando</entry>
	    <entry>Sumário</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry>&man.adduser.8;</entry>
	    <entry>O comando recomendado para adicionar novos usuários.</entry>
	  </row>
	  <row>
	    <entry>&man.rmuser.8;</entry>
	    <entry>O comando recomendado para excluir usuários.</entry>
	  </row>
	  <row>
	    <entry>&man.chpass.1;</entry>
            <entry>Uma ferramenta flexivel para alterar informações de usuários.</entry>
	  </row>
	  <row>
	    <entry>&man.passwd.1;</entry>
            <entry>Um simples comando para alterar a senha do usuário</entry>
	  </row>
	  <row>
	    <entry>&man.pw.8;</entry>
            <entry>Uma podereosa e flexível ferramenta para alterar todos os aspectos
             das contas de usuários.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <sect2 id="users-adduser">
      <title><command>adduser</command></title>

      <indexterm>
        <primary>contas</primary>
        <secondary>adicionando</secondary>
      </indexterm>
      <indexterm>
        <primary><command>adduser</command></primary>
      </indexterm>
      <indexterm>
        <primary><filename class=directory>/usr/share/skel</filename></primary>
      </indexterm>
      <indexterm><primary>diretório esqueleto</primary></indexterm>
       <para>&man.adduser.8; é um programa simples para adicionar novos usuários.
         Cria entradas nos arquivos <filename>passwd</filename> e 
         <filename>group</filename>. Criará também um diretório home para o 
         usuário novo, copia os arquivos de configuração padrão 
         (<quote>dotfiles</quote>) de <filename>/usr/share/skel</filename>, e
         pode opcionalmente enviar ao usuário novo uma mensagem de boas vindas.</para>

       <para>Em &os;&nbsp;5.0, &man.adduser.8; foi rescrito de Perl script para 
         um shell script que trabalha-se evoluntariamente em torno do &man.pw.8;, 
         assim seu uso é ligeiramente diferente em &os; 4.X e em &os; 5.X.</para>


      <para>Para criar uma configuração inicial, use
       	<command>adduser -s -config_create</command>.
	<footnote>  
          <para>O <option>-s</option> faz &man.adduser.8; por padrão ficar quieto.
            Nós usamos <option>-v</option> mais tarde quando queremos
            mudar padrões.</para>
        </footnote>
        Em seguida, nós configuramos os padrões do &man.adduser.8;, e criamos
        a nossa primeira conta de usuário, desde que estamos usando
        <username>root</username> para uso normal é evil e nasty.</para>
        

      <example>
	<title>Configurando <command>adduser</command> e adicionando um
	  usuário no &os;&nbsp;4.X</title>

	<screen>&prompt.root; <userinput>adduser -v</userinput>
Use option ``-silent'' if you don't want to see all warnings and questions.
Check /etc/shells
Check /etc/master.passwd
Check /etc/group
Enter your default shell: csh date no sh tcsh zsh [sh]: <userinput>zsh</userinput>
Your default shell is: zsh -&gt; /usr/local/bin/zsh
Enter your default HOME partition: [/home]:
Copy dotfiles from: /usr/share/skel no [/usr/share/skel]: 
Send message from file: /etc/adduser.message no 
[/etc/adduser.message]: <userinput>no</userinput>
Do not send message
Use passwords (y/n) [y]: <userinput>y</userinput>

Write your changes to /etc/adduser.conf? (y/n) [n]: <userinput>y</userinput>

Ok, let's go.
Don't worry about mistakes. I will give you the chance later to correct any input.
Enter username [a-z0-9_-]: <userinput>jru</userinput>
Enter full name []: <userinput>J. Random User</userinput>
Enter shell csh date no sh tcsh zsh [zsh]: 
Enter home directory (full path) [/home/jru]: 
Uid [1001]: 
Enter login class: default []: 
Login group jru [jru]: 
Login group is ``jru''. Invite jru into other groups: guest no 
[no]: <userinput>wheel</userinput>
Enter password []: 
Enter password again []: 

Name:	  jru
Password: ****
Fullname: J. Random User
Uid:	  1001
Gid:	  1001 (jru)
Class:	  
Groups:	  jru wheel
HOME:     /home/jru
Shell:	  /usr/local/bin/zsh
OK? (y/n) [y]: <userinput>y</userinput>
Added user ``jru''
Copy files from /usr/share/skel to /home/jru
Add another user? (y/n) [y]: <userinput>n</userinput>
Goodbye!
&prompt.root;</screen>
      </example>

      <para>Em resumo, nós mudamos a shell padrão para <application>zsh</application>
      (uma shell adicional encontrada na coleção de ports), e desligamos o envio
      de um e-mail de boas vindas para o usuário adicionado. Nós salvamos as configurações,
      criamos uma conta para <username>jru</username>, e certificamos que 
      <username>jry</username> está dentro do grupo <username>wheel</username> (de 
      mode que possa supor o papel de <username>root</username> com o comando &man.su.1;.)</para>
      <note>
        <para>A senha que você digita não é ecoada, nem é mostrado asteriscos.
        Certifique-se que você não digite erradamente a senha duas vezes.
        </para>
      </note>

      <note>
	<para>Use exatamente &man.adduser.8; sem argumentos de agora em diante,
        e você não terá que fazer mudaças padrões. Se o programa pedir que você
        mude os padrões, saida do programa, e tente a opção <option>-s</option>.</para>
      </note>


      <example>
	<title>Adicionando um usuário em um  &os;&nbsp;5.X</title>

	<screen>&prompt.root; <userinput>adduser</userinput>
Username: <userinput>jru</userinput>
Full name: <userinput>J. Random User</userinput>
Uid (Leave empty for default):
Login group [jru]:
Login group is jru. Invite jru into other groups? []: <userinput>wheel</userinput>
Login class [default]:
Shell (sh csh tcsh zsh nologin) [sh]: <userinput>zsh</userinput>
Home directory [/home/jru]:
Use password-based authentication? [yes]:
Use an empty password? (yes/no) [no]:
Use a random password? (yes/no) [no]:
Enter password:
Enter password again:
Lock out the account after creation? [no]:
Username   : jru
Password   : ****
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? (yes/no): <userinput>yes</userinput>
adduser: INFO: Successfully added (jru) to the user database.
Add another user? (yes/no): <userinput>no</userinput>
Goodbye!
&prompt.root;</screen>
      </example>
    </sect2>

    <sect2 id="users-rmuser">
      <title><command>rmuser</command></title>

      <indexterm><primary><command>rmuser</command></primary></indexterm>
      <indexterm>
        <primary>contas</primary>
        <secondary>removendo</secondary>
      </indexterm>

      <para>Você pode usar o &man.rmuser.8; to remover completamente um usuário
        do sistema. &man.rmuser.8; executa as seguintes etapas:</para>

      <procedure>
	<step>
          <para>Remove as entradas &man.crontab.1; do usuário (se tiver algum).</para>
	</step>
	<step>
          <para>Remove todos os trabalhos &man.at.1; que pertence ao usuário.</para>
	</step>
	<step>
          <para>Mata todos os processos controlados pelo usuário.</para>
	</step>
	<step>
          <para>Remove o usuário do arquivo de senha local do sistema</para>
	</step>
	<step>
          <para>Remove o diretório home do usuário (se este for controlado pelo usuário)</para>
	</step>
	<step>
          <para>Remove o arquivo de entrada de e-mail que pertence ao usuário em 
            <filename>/var/mail</filename>.</para>
	</step>
	<step>
          <para>Remove todos os arquivos controlados pelo usuário na area 
            temporária de gravação de arquivos como <filename>/tmp</filename>.</para>
	</step>
	<step>
          <para>Finalmente, remove o nome do usuário de todos os grupos que ele 
            pertence em <filename>/etc/group</filename>.
	    
            <note>
              <para>Se um grupo ficar vazio e o nome do grupo é o mesmo que 
                o nome do usuário, o grupo será removido; isto complementa 
               os grupos originais por usuário que é criado pelo &man.adduser.8;.</para>
            </note>

	  </para>
	</step>
      </procedure>

      <para>&man.rmuser.8; não pode ser usado para remover contas de super usuários,
        desde aquela é quase sempre uma indicação da destruição maciça.</para> 
   
      <para>Por padrão, um modo interatico é usado, que tenta se certificar você 
        para saber o que você está fazendo.</para>

      <example>
	<title><command>rmuser</command> Remoção interativa de contas</title>

	<screen>&prompt.root; <userinput>rmuser jru</userinput>
Matching password entry:
jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? <userinput>y</userinput>
Remove user's home directory (/home/jru)? <userinput>y</userinput>
Updating password file, updating databases, done.
Updating group file: trusted (removing group jru -- personal group is empty) done.
Removing user's incoming mail file /var/mail/jru: done.
Removing files belonging to jru from /tmp: done.
Removing files belonging to jru from /var/tmp: done.
Removing files belonging to jru from /var/tmp/vi.recover: done.
&prompt.root;</screen>
      </example>
    </sect2>

    <sect2 id="users-chpass">
      <title><command>chpass</command></title>

      <indexterm><primary><command>chpass</command></primary></indexterm>
       <para>&man.chpass.1; altera informações da base de dados do usuário tais como 
        senhas, shells e informações pessoais.</para>

       <para>Apenas administradores do sistema, como o super usuário, podem alterar
         informações e senhas de outros usuários com &man.chpass.1;.</para>

      <para>Quando passado sem opções, com exceção de um usuário opcional, 
        &man.chpass.1; abrirá um editor contendo as informações do usuário. 
        Quando o usuário exite do editor, a base de dados do usuário será 
        atualizada com as novas informações.</para>

      <note>
        <para>Em &os;&nbsp;5.X, você irá ser questionado sua senha depois que 
          sair do editor se você não for um super usuário.</para>
      </note>

      <example>
	<title>Interativo <command>chpass</command> pelo super usuário</title>

	<screen>#Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1001
Gid [# or name]: 1001
Change [month day year]:
Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <para>O usuário normal pode alterar somente um subconjunto pequeno
        destas informações, e somente para eles.</para>

      <example>
	<title>Interativo <command>chpass</command> pelo usuário normal</title>

	<screen>#Changing user database information for jru.
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <note>
        <para>&man.chfn.1; e &man.chsh.1; são justamente links para &man.chpass.1;,
          como são &man.ypchpass.1;, &man.ypchfn.1;, e &man.ypchsh.1;. suporte a NIS 
          é automático, assim especificar <literal>yp</literal> antes do comando não
          é necessário. Se isto está confuso para você, não se preocupe, NIS será coberto
          em <xref linkend="advanced-networking">.</para>
       </note>


    </sect2>
    <sect2 id="users-passwd">
      <title><command>passwd</command></title>

      <indexterm><primary><command>passwd</command></primary></indexterm>
      <indexterm>
        <primary>contas</primary>
        <secondary>alterando a senha</secondary>
      </indexterm>
       <para>&man.passwd.1; é a maneira usual para mudar sua própria senha
        como um usuário, ou a senha de um outro usuário como o super usuário.</para>

      <note>
         <para>Os usuários devem digitar dentro sua senha original antes de mudar
           sua senha, para impedir que uma pessoa desautorizada mude sua senha 
           quando o usuário está ausente de seu console.</para>
      </note>

      <example>
	<title>Alterando sua senha</title>

	<screen>&prompt.user; <userinput>passwd</userinput>
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
      </example>

      <example>
        <title>Alterando a senha de outro usuário como o super usuário</title>

        <screen>&prompt.root; <userinput>passwd jru</userinput>
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
      </example>

      <note>
        <para>Como com &man.chpass.1;, &man.yppasswd.1; são justamente um link para
           &man.passwd.1;, assim o NIS trabalha com um ou outro comando.</para>
      </note>
    </sect2>


    <sect2 id="users-pw">
      <title><command>pw</command></title>
      <indexterm><primary><command>pw</command></primary></indexterm>

      <para>&man.pw.8; is a command line utility to create, remove,
	modify, and display users and groups.  It functions as a front
	end to the system user and group files.  &man.pw.8;
	has a very powerful set of command line options that make it
	suitable for use in shell scripts, but new users may find it
	more complicated than the other commands presented
	here.</para>
       
      <para>&man.pw.8; é um comando utilitário para criar, remover, alterar e 
        mostrar usuários e grupos. Isto funciona como um <foreignphrase>front end</foreignphrase>
        para os arquivos do sistema de usuários e grupos. &man.pw.8 tem um
        conjunto muito completo de opções e comandos que faz apropriado para o
        uso em scripts shell, mas os usuários novos podem encontar mais 
        complicações do que os outros comandos apresentados aqui.</para>
    </sect2>


  </sect1>

  <sect1 id="users-limiting">
    <title>Limitando usuários</title>

    <indexterm><primary>limitando usuários</primary></indexterm>
    <indexterm>
      <primary>contas</primary>
      <secondary>limitando</secondary>
    </indexterm>
   
    <para>Se você tiver usuários, a abilidade de limitar seu uso do sistema pode
      ter vindo em sua mente. FreeBSD fornece diversas maneiras que um 
      administrador pode limitar a quantidade de recursos do sistema que um 
      indivíduo pode usar. Estes limites são divididos em duas seções: quotas
      do disco, e outros limites de recursos.</para>

    <indexterm><primary>quotas</primary></indexterm>
    <indexterm>
      <primary>limitando usuários</primary>
      <secondary>quotas</secondary>
    </indexterm>
    <indexterm><primary>quotas de disco</primary></indexterm>
    
    <para>As quotas de disco limitam o uso do disco aos usuários, e 
      fornecem uma maneira de verificar rapidamente esse uso sem calculá-lo
      todas as vezes. As quotas sÀo discutidas em <xref linkend="quotas">.</para>

    <para>Os outros limites de recurso incluem maneiras de limitar a quantidade
      de uso do CPU, memória e outros recursos que um usuário pode consumit. Estes
      são definidos usando classes do início de uma sessão e discutidos aqui.</para>

    <indexterm>
      <primary><filename>/etc/login.conf</filename></primary>
    </indexterm>
    <para>As classes de login são definidas em <filename>/etc/login.conf</filename>. A
      semântica precisa é além do espaço desta seção, mas é descrita em detalhe na página
      de manual &man.login.conf.5;. É suficiente dizer que cada usuário está atribuído a uma
      classe do início de uma sessão (<literal>default</literal> por padrão), e que cada classe
      do início de uma sessão tem um jogo das potencialidades do início de uma sessão associadas
      com ela. Uma potencialidade do início de uma sessão é um par <literal><replaceable>nome</replaceable>
      =<replaceable>valor</replaceable></literal>, onde <replaceable>nome</replaceable> é
      previamente conhecido e <replaceable>valor</replaceable> é uma string arbitrária processada
      conformemente dependendo do nome. Ajustando classe de login e as potencialidades são
      descritas também em &man.login.conf.5;</para>
      
    <para>Os limites de recurso são diferentes das potencialidades de login de uma
     sessão do vanilla em duas maneiras. Primeira, para cada limite, há um limite macio
    (atual) e duro. Um limite macio pode ser ajustado pelo usuário ou pela aplicação, mas pode
    ser não mais altamente do que o limite duro. O último pode ser abaixado pelo usuário, mas
    nunca ser levantado. Em segundo, a maioria de limites de recursos aplicam-se por processo
    a um usuário específico, não usuário ao todo. Nota, entretanto, que estas diferenças estão
    exijidas pela manipulação específica dos limites, não pela execução da estrutura da potencialidade
    no login de uma sessão (isto é, não são <emphasis>realmente</emphasis> um exemplo especial 
    de potencialidades de login).</para>

    <para>E assim, sem mais nada adicional, estão abaixo os limites mais comums 
      usando limite de recursos (o resto, junto com todas as potencialidades restantes
      de login de uma sessão, podem ser encontradas em &man.login.conf.5;).</para>

    <variablelist>
      <varlistentry>
        <term><literal>coredumpsize</literal></term>

	<listitem>
    <indexterm><primary>coredumpsize</primary></indexterm>
    <indexterm>
      <primary>limitando usuários</primary>
      <secondary>coredumpsize</secondary>
    </indexterm>
   
          <para>O limite em tamanho de um arquivo core gerado pelo um programa, por
            razões óbvias, subordinado a outros limites no uso do disco (ex: 
            <literal>filesize</literal>, ou quota de disco). Não obstante, é usado
            frequentemente como um método menos severo de controlar o consumo do espaço
            de disco:uma vez que usuários não geram os arquivos de core eles mesmo, e logo
            não os deletam (por não saber que existem) fazer esta configuração pode evitar 
            que eles fiquem sem espaço em disco devido o crash de uma aplicação com grande 
            consumo de memória por exemplo o (ex: <application>emacs</application>.</para>

	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>cputime</literal></term>

	<listitem>
    <indexterm><primary>cputime</primary></indexterm>
    <indexterm>
      <primary>limitando usuários</primary>
      <secondary>cputime</secondary>
    </indexterm>
          <para>Esta é a quantidade máxima de tempo do processador central 
           que o processo de um usuário pode consumir. Os processos que 
           desrespeitarem serão matados pelo kernel.
	    <note>
	  
              <para>Este é um limite de <emphasis>tempo</emphasis> no processador central,
              não porcentagem do processador central como indicado em alguns campos por &man.top.1;
              e &man.ps.1;. Um limite no último é, na altura deste documento, não possível, e seria 
              inútil: um compilador&mdash; pode legitamente usa facilmente quase 100% de um 
              processador central por algum tempo.</para>
	    </note>
	  </para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>filesize</literal></term>

	<listitem>
    <indexterm><primary>filesize</primary></indexterm>
    <indexterm>
      <primary>limitando usuários</primary>
      <secondary>filesize</secondary>
    </indexterm>
          <para>Este é o tamanho máximo de um arquivo que um usuário pode 
           possuir. Ao contrário da  <link linkend="quotas">quota de disco</link>,
           este limite é reforçado em arquivos individuais, não de todo o conjunto 
           de arquivos que um usuário possui.
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>maxproc</literal></term>

	<listitem>
    <indexterm><primary>maxproc</primary></indexterm>
        <indexterm>
      <primary>limitando usuários</primary>
      <secondary>maxproc</secondary>
    </indexterm>
          <para>Este é o número máximo de processos que um usuário pode rodar.
            Isto inclui processos foreground e background igualmente. Por razões
            óbvias, isto não pode ser maior do que o limite do sistema especificado
            por &man.sysctl.8; <varname>kern.maxproc</varname>. Note também que configurando
            isso para um valor pequeno vai prejudicar a produtividade do usuário: é frequentemente
            útil logar multiplas vezes e executar processos. Algumas tarefas, tais como 
            compilar um programa grande, também geram multiplos processos (ex: &man.make.1;, 
            &man.cc.1; e outros intermediários).</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>memorylocked</literal></term>

	<listitem>
    <indexterm><primary>memorylocked</primary></indexterm>
    <indexterm>
      <primary>limitando usuários</primary>
      <secondary>memorylocked</secondary>
    </indexterm>
	  <para>This is the maximum amount a memory a process may have
	    requested to be locked into main memory (e.g., see
	    &man.mlock.2;).  Some system-critical programs, such as
            &man.amd.8;, lock into main memory such that in the event
	    of being swapped out, they do not contribute to
	    a system's trashing in time of trouble.</para>
          <para>Este é a quantidade máxima de memória quem um processo pode 
            requerir para travar na memória principal (ex: veja &man.mlock.2;).
            Alguns programas críticos do sistema, tais como &man.amd.8;, reserva
            na memória principal como evento trocando para fora, FALTAAAAAAAAAAAAA
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>memoryuse</literal></term>

	<listitem>
    <indexterm><primary>memoryuse</primary></indexterm>
    <indexterm>
      <primary>limitando usuários</primary>
      <secondary>memoryuse</secondary>
    </indexterm>
          <para>Está é a quantidade máxima de memória que um processo pode 
            consumir durante todo o tempo. Isso inclue o uso da memória principal e a 
            <foreignphrase>swap</foreignphrase>. Isto não é um controle total de restrição de 
            consumo de memória, mas é um bom começo</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>openfiles</literal></term>

	<listitem>
    <indexterm><primary>openfiles</primary></indexterm>
    <indexterm>
      <primary>limitando usuários</primary>
      <secondary>openfiles</secondary>
    </indexterm>
          <para>Esta é a quantidade máxima de arquivos que um processo pode ter
            aberto. No FreeBSD, arquivos são usados também para representar 
            <foreignphrase>sockets</foreignphrase> e canais IPC; tenha assim cuidado
            para não ajustar este demasiadamente baixo. O limite para este é definido
            por &man.sysctl.8; <varname>kern.maxfiles</varname>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>sbsize</literal></term>

	<listitem>
    <indexterm><primary>sbsize</primary></indexterm>
    <indexterm>
      <primary>limitando usuários</primary>
      <secondary>sbsize</secondary>
    </indexterm>
          <para>Esta é a quantidade máxima de memória da rede, e assim os mbufs,
            um usuário podem consumir. Isto originado como uma resposta a um ataque
            velho de DoS criando muitos dos <foreignphrase>sockets</foreignphrase>,
            mas pode geralmente ser usado para limitar a comunicação da rede.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>stacksize</literal></term>

	<listitem>
    <indexterm><primary>stacksize</primary></indexterm>
    <indexterm>
      <primary>limitando usuários</primary>
      <secondary>stacksize</secondary>
    </indexterm>
          <para>Este é o tamanho máximo que uma pilha dos processos pode vir.
            Este sozinho não é suficiente para limitar a quantidade de memória que
            um programa pode usar, consequentemente, deve ser usado em conjunto com
            outros limites.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Existem outras coisas para recordar ao ajustar limites de recurso.
      Logo em seguinda estão alguns pontos gerais, sugestões, e comentários variados.</para>

    <itemizedlist>
      <listitem>
        <para>Os processos que são iniciados no sistema pelo
          <filename>/etc/rc</filename> são atribuídos à classe de login
          <literal>daemon</literal>.</para>
      </listitem>

      <listitem>
        <para>Embora o <filename>/etc/login.conf</filename> que vem com o 
          sistema é uma fonte boa de valores razoáveis para a maioria dos limites,
          apenas você, administrador, pode saber o que é apropriado para o seu 
          sistema. Ajustar um limite demasiadamente elevado pode abrir seu sistema
          até o abuso, quando o ajustar demasiadamente baixo pode pôr um tensão sobre
          a produtividade.
      </listitem>

      <listitem>
        <para>Os usuários do sistema de janela X (X11)devem provavelmente ser
          concedidos mais recursos do que outros usuários. X11 por si só usa poucos
          recursos, mas incentiva também usuários à rodar programas simultaneos.</para>
      </listitem>

      <listitem>
        <para>Recorde que muitos limites se aplicam aos processos individuais, não
          usuário como um todo. Por exemplo, ajustar <varname>openfiles</varname> para
          50 significa que cada processo que o usuário rodar, pode abrir até 50 arquivos.
          Assim, a quantidade bruta de arquivos que um usuário pode abrir é o valor 
          <literal>openfiles</literal> multiplicado pelo <literal>maxproc</literal>.
          Isto também se aplica ao consumo de memória.</para>
      </listitem>
    </itemizedlist>

    <para>Para uma informação adicional sobre limites de recursos e classes de login 
      e capacidades em geral, consulte por favor as páginas de manuais relevantes: 
      &man.cap.mkdb.1;, &man.getrlimit.2;, &man.login.conf.5;.</para>
  </sect1>

  <sect1 id="users-personalizing">
    <title>Personalizando usuários</title>

    <para>A localização é um ambiente ajustado pelo administrador ou pelo usuário 
      do sistema para acomodar línguas diferentes, conjunto de caracteres, data e padrões
      de tempo diferentes, e assim por diante. Isto é discutido no capítulo sobre 
      <link linkend="l10n">localização</link>.</para>
  </sect1>

  <sect1 id="users-groups">
    <title>Grupos</title>

    <indexterm><primary>grupos</primary></indexterm>
    <indexterm>
      <primary><filename>/etc/groups</filename></primary>
    </indexterm>
    <indexterm>
      <primary>accounts</primary>
      <secondary>groups</secondary>
    </indexterm>
    <para>A group is simply a list of users.  Groups are identified by
      their group name and GID (Group ID).  In FreeBSD (and most other &unix; like
      systems), the two factors the kernel uses to decide whether a process
      is allowed to do something is its user ID and list of groups it
      belongs to.  Unlike a user ID, a process has a list of groups
      associated with it.  You may hear some things refer to the <quote>group ID</quote>
      of a user or process; most of the time, this just means the first
      group in the list.</para>

    <para>The group name to group ID map is in
      <filename>/etc/group</filename>.  This is a plain text file with four
      colon-delimited fields.  The first field is the group name, the
      second is the encrypted password, the third the group ID, and the
      fourth the comma-delimited list of members.  It can safely be edited
      by hand (assuming, of course, that you do not make any syntax
      errors!).  For a more complete description of the syntax, see the
      &man.group.5; manual page.</para>

    <para>If you do not want to edit <filename>/etc/group</filename>
      manually, you can use the &man.pw.8; command to add and edit groups.
      For example, to add a group called <groupname>teamtwo</groupname> and
      then confirm that it exists you can use:</para>

    <example>
      <title>Adding a Group Using &man.pw.8;</title>

      <screen>&prompt.root; <userinput>pw groupadd teamtwo</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:</screen>
    </example>

    <para>The number <literal>1100</literal> above is the group ID of the
      group <groupname>teamtwo</groupname>.  Right now,
      <groupname>teamtwo</groupname> has no members, and is thus rather
      useless.  Let's change that by inviting <username>jru</username> to
      the <groupname>teamtwo</groupname> group.</para>

    <example>
      <title>Adding Somebody to a Group Using &man.pw.8;</title>

      <screen>&prompt.root; <userinput>pw groupmod teamtwo -M jru</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:jru</screen>
    </example>

    <para>The argument to the <option>-M</option> option is a
      comma-delimited list of users who are members of the group.  From the
      preceding sections, we know that the password file also contains a
      group for each user.  The latter (the user) is automatically added to
      the group list by the system; the user will not show up as a member
      when using the <option>groupshow</option> command to &man.pw.8;,
      but will show up when the information is queried via &man.id.1; or
      similar tool.  In other words, &man.pw.8; only manipulates the
      <filename>/etc/group</filename> file; it will never attempt to read
      additionally data from <filename>/etc/passwd</filename>.</para>

    <example>
      <title>Using &man.id.1; to Determine Group Membership</title>

      <screen>&prompt.user; <userinput>id jru</userinput>
uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)</screen>
    </example>

    <para>As you can see, <username>jru</username> is a member of the
      groups <groupname>jru</groupname> and
      <groupname>teamtwo</groupname>.</para>

    <para>For more information about &man.pw.8;, see its manual page, and
      for more information on the format of
      <filename>/etc/group</filename>, consult the &man.group.5; manual
      page.</para>
  </sect1>
</chapter>

<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
