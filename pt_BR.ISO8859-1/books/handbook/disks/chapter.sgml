<!--
     The FreeBSD Documentation Project

     $FreeBSD: doc/en_US.ISO8859-1/books/handbook/disks/chapter.sgml,v 1.184 2004/04/02 13:05:54 eksffa Exp $
-->

<chapter id="disks">
  <title>Armazenamento</title>

  <sect1 id="disks-synopsis">
    <title>Sin&oacute;pse</title>


    <para>Este cap&iacute;tulo demonstra como fazer uso de discos no FreeBSD.
	  Incluindo discos de mem&oacute;ria, conectados atrav&eacute;s da rede e os
	  dispositivos de armazenamento dos padr&otilde;es SCSI/IDE.</para>

    <para>Ap&oacute;s ler este cap&iacute;tulo voc&ecirc; saber&aacute;:</para>
    <itemizedlist>
      <listitem><para>A terminologia utilizada pelo FreeBSD para descrever
	  a organiza&ccedil;&atilde;o dos dados num disco r&iacute;gido
	  (parti&ccedil;&otilde;es, e slices ou
	  fatias).</para>
      </listitem>
      <listitem><para>Como adicionar um disco r&iacute;gido ao seu sistema.</para>
      </listitem>
      <listitem><para>Como configurar um sistema
	  de arquivos virtual, como
	  os alocados em mem&oacute;ria.</para></listitem>
      <listitem>
	<para>Como fazer utiliza&ccedil;&atilde;o de cotas para
	  limitar o uso do espa&ccedil;o de
      armazenamento em disco.</para>
      </listitem>
      <listitem>
	<para>Como criptografar discos para assegurar contra
		poss&iacute;veis ataques.</para>
      </listitem>
      <listitem>
	<para>Como criar e gravar CDs e DVDs no FreeBSD.</para>
      </listitem>
      <listitem>
        <para>As v&aacute;rias op&ccedil;&otilde;es de
		m&iacute;dias para c&oacute;pias
		de seguran&ccedil;a(Backup).</para>
      </listitem>
      <listitem>
        <para>Como utilizar os programas dispon&iacute;veis no FreeBSD para
		realizar c&oacute;pias de seguran&ccedil;a(Backup).</para>
      </listitem>
      <listitem>
        <para>Como fazer c&oacute;pias de seguran&ccedil;a em disquetes.</para>
      </listitem>
      <listitem>
        <para>O que s&atilde;o <foreignphrase>snapshots</foreignphrase> e
		como fazer uso deles de maneira eficiente.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="disks-naming">
    <title>Nomes de Dispositivos</title>

    <para>Temos aqui uma lista dos dispositivos f&iacute;sicos de
	  armazenamento suportados pelo FreeBSD, e os nomes
	  associados a eles.</para>

    <table id="disk-naming-physical-table">
      <title>Conven&ccedil;&otilde;es de Nomenclatura de Discos F&iacute;sicos</title>

      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Tipo de Controladora</entry>
	    <entry>Nome do Dispositivo</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry>Discos r&iacute;gidos IDE</entry>
	    <entry><literal>ad</literal></entry>
	  </row>
	  <row>
	    <entry>CDROM IDE</entry>
	    <entry><literal>acd</literal></entry>
	  </row>
	  <row>
	    <entry>Discos r&iacute;gidos SCSI e dispositivos de armazenamento
		em massa USB</entry>
	    <entry><literal>da</literal></entry>
	  </row>
	  <row>
	    <entry>CDROM SCSI</entry>
	    <entry><literal>cd</literal></entry>
	  </row>
	  <row>
	    <entry>Controladores de CDROM fora de padr&otilde;es</entry>
	    <entry><literal>mcd</literal> para CD-ROM Mitsumi,
	      <literal>scd</literal> para CD-ROM Sony,
	      <literal>matcd</literal> para CD-ROM Matsushita/Panasonic
		<footnote>
		  <para>O suporte a controladora &man.matcd.4; foi removido no
		    FreeBSD&nbsp;4.X desde 5 de outubro de 2002 e n&atilde;o &eacute;
			suportada no FreeBSD&nbsp;5.0 e 5.1.  Entretanto,
			o suporte foi novamente adicionado no FreeBSD&nbsp;5.X
			desde 16 de junho de 2003.</para>
		</footnote>
	    </entry>
	  </row>
	  <row>
	    <entry>Controladoras de disquete</entry>
	    <entry><literal>fd</literal></entry>
	  </row>
	  <row>
	    <entry>Controladoras de tape SCSI</entry>
	    <entry><literal>sa</literal></entry>
            </row>
	  <row>
	    <entry>Controladoras de tape IDE</entry>
	    <entry><literal>ast</literal></entry>
	  </row>
	  <row>
	    <entry>Controladoras de Flash</entry>
	    <entry><literal>fla</literal> para dispositivos
		de Flash &diskonchip;</entry>
	  </row>
	  <row>
	    <entry>Controladoras RAID</entry>
	    <entry><literal>aacd</literal> para &adaptec; AdvancedRAID,
	      <literal>mlxd</literal> e <literal>mlyd</literal>
	      para &mylex;,
	      <literal>amrd</literal> para AMI &megaraid;,
	      <literal>idad</literal> para Compaq Smart RAID,
	      <literal>twed</literal> para &tm.3ware; RAID.</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>
  </sect1>

  <sect1 id="disks-adding">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>David</firstname>
	  <surname>O'Brien</surname>
	  <contrib>Contribui&ccedil;&atilde;o original de </contrib>
	</author>
      </authorgroup>
      <!-- 26 Abr 1998 -->
    </sect1info>

    <title>Adicionando Discos</title>

    <indexterm>
      <primary>disks</primary>
      <secondary>adding</secondary>
    </indexterm>

    <para>Vamos supor que desejamos adicionar um novo disco SCSI
	  numa m&aacute;quina que atualmente possui apenas um. Primeiro
	  desligamos o computador e conectamos o novo disco ao
	  computador seguindo as instru&ccedil;&otilde;es fornecidas pelos
	  fabricantes do computador, da controladora e do disco.
	  Devido a este procedimento variar bastante, os detalhes
	  desta opera&ccedil;&atilde;o estar&atilde;o fora do escopo deste documento.</para>

    <para>Realize login como usu&aacute;rio <username>root</username>.
	  Ap&oacute;s voc&ecirc; ter instalado o disco, verifique o arquivo
	  <filename>/var/run/dmesg.boot</filename> para certificar-se
	  de que o novo disco foi encontrado.  Continuando com o nosso
	  exemplo, o novo disco adicionado ser&aacute; o
	  <devicename>da1</devicename> e n&oacute;s vamos mont&aacute;-lo em
      <filename>/1</filename> (se voc&ecirc; estiver adicionando um disco
	  IDE, o nome do dispositivo ser&aacute; <devicename>wd1</devicename>
	  em sistemas pre-4.0, ou <devicename>ad1</devicename>
	  ma maioria dos sistemas 4.X).</para>

    <indexterm><primary>partitions</primary></indexterm>
    <indexterm><primary>slices</primary></indexterm>
    <indexterm>
      <primary><command>fdisk</command></primary>
    </indexterm>

    <para>Devido ao FreeBSD rodar em computadores compat&iacute;veis com
	  IBM-PC, ele ter&aacute; que respeitar o particionamento
	  especificado pela BIOS do PC.  Estas por sua vez s&atilde;o diferentes
	  das parti&ccedil;&otilde;es tradicionais BSD. Um disco de um PC pode ter
	  quatro entradas de parti&ccedil;&otilde;es na BIOS. Se o disco ser&aacute; totalmente
      dedicado ao FreeBSD voc&ecirc; ter&aacute; a op&ccedil;&atilde;o de usar o modo
      <emphasis>dedicated</emphasis>.  Ou ent&atilde;o, o FreeBSD
	  ter&aacute; de viver como uma das parti&ccedil;&otilde;es da BIOS do PC.  O FreeBSD
      chama as parti&ccedil;&otilde;es da BIOS do PC de <emphasis>slices</emphasis>
	  ou <emphasis>fatias</emphasis>, ent&atilde;o n&atilde;o as confunda com as
	  parti&ccedil;&otilde;es BSD tradicionaiso.  Voc&ecirc; tamb&eacute;m pode usar fatias num
	  disco dedicado ao FreeBSD, mas us&aacute;-las em um computador que
	  possua um outro sistema operacional instalado. Isso para n&atilde;o
      causar confus&otilde;es com o utilit&aacute;rio <command>fdisk</command>
	  de outros sistemas operativos.</para>

    <para>In the slice case the drive will be added as
      <filename>/dev/da1s1e</filename>.  This is read as: SCSI disk,
      unit number 1 (second SCSI disk), slice 1 (PC BIOS partition 1),
      and <filename>e</filename> BSD partition.  In the dedicated
      case, the drive will be added simply as
      <filename>/dev/da1e</filename>.</para>

    <sect2>
      <title>Utilizando o &man.sysinstall.8;</title>
      <indexterm>
        <primary><application>sysinstall</application></primary>
        <secondary>adding disks</secondary>
      </indexterm>
      <indexterm>
	<primary>su</primary>
      </indexterm>
      <procedure>
	<step>
	  <title>Navegando no <application>Sysinstall</application></title>
	  <para>Voc&ecirc; pode utilizar o <command>/stand/sysinstall</command>
	    para particionar e definir os r&oacute;tulos ou
		<foreignphrase>label</foreignphrase>
	    que ser&atilde;o utilizados no novo disco de maneira facilitada
		atrav&eacute;s de seus menus.  Estando logado como usu&aacute;rio
		<username>root</username> ou utilizando o comando
	    <command>su</command>.  Execute
	    <command>/stand/sysinstall</command> e entre no menu
	    <literal>Configure</literal>.  Estando em
	    <literal>FreeBSD Configuration Menu</literal>, v&aacute; descendo nas
		op&ccedil;&otilde;es e abaixo selecione a op&ccedil;&atilde;o <literal>Fdisk</literal>.</para>
	</step>
	<step>
	  <title><application>fdisk</application> Editor de Parti&ccedil;&otilde;es</title>
	  <para>Uma vez no <application>fdisk</application>, n&oacute;s podemos
	    teclar <userinput>A</userinput> para usar todo o disco
		para o FreeBSD.  Quando for perguntado se voc&ecirc; quer
		<quote>manter a possibilidade de uso cooperativo com
		outro sistema operacional no futuro</quote> responda
		<literal>YES</literal>.  Grave as altera&ccedil;&otilde;es feitas
		no disco teclando <userinput>W</userinput>.  Agora
		saia do FDISK teclando <userinput>q</userinput>.  Em
		seguida, voc&ecirc; ser&aacute; perguntado sobre o Registro Mestre de
		Inicializa&ccedil;&atilde;o(MBR, Master Boot Record). Desde que voc&ecirc; esteja
		adicionando um disco num sistema em execu&ccedil;&atilde;o, selecione
	    <literal>None</literal>.</para>
	</step>

	<step>
	  <title>Editor de R&oacute;tulo(Label) de Disco</title>
	  <indexterm><primary>BSD partitions</primary></indexterm>

	  <para>Em seguida, voc&ecirc; precisar&aacute; sair do
	    <application>sysinstall</application> e inici&aacute;-lo
		novamente.  Siga a mesma dire&ccedil;&atilde;o citada nos menus, por&eacute;m
		agora selecione a op&ccedil;&atilde;o <literal>Label</literal>. Voc&ecirc;
		entrar&aacute; ent&atilde;o no <literal>Disk Label Editor</literal>
		(Editor de R&oacute;tulos de Discos).  Onde s&atilde;o criadas as
		parti&ccedil;&otilde;es BSD tradicionais.  Um disco pode ter oito
		parti&ccedil;&otilde;es, rotuladas de
	    <literal>a-h</literal>.
	    Alguns r&oacute;tulos de parti&ccedil;&otilde;es tem um uso especial.  A
	    parti&ccedil;&atilde;o <literal>a</literal> &eacute; utilizada para a parti&ccedil;&atilde;o
		raiz ou root (<filename>/</filename>).  Somente o disco
		do sistema (e.g, o disco de onde seu sistema realiza o boot)
	    deve ter uma parti&ccedil;&atilde;o<literal>a</literal>.
	    A parti&ccedil;&atilde;o <literal>b</literal> &eacute; utilizada para parti&ccedil;&otilde;es
		de mem&oacute;ria virtual(swap), e voc&ecirc; pode ter v&aacute;rios discos com
		parti&ccedil;&otilde;es swap.  A parti&ccedil;&atilde;o <literal>c</literal> endere&ccedil;a todo
		o disco no modo dedicado, ou toda a slice do FreeBSD no
		modo slice.  As outras parti&ccedil;&otilde;es s&atilde;o para uso geral.</para>

	  <para>O editor de r&oacute;tulos do
	    <application>sysinstall</application>
	    prefere usar a parti&ccedil;&atilde;o <literal>e</literal> quando esta
		n&atilde;o for uma parti&ccedil;&atilde;o raiz ou swap.  Uma vez no Editor de
		R&oacute;tulos, crie um sistema de arquivos simples teclando
        <userinput>C</userinput>.  Quando perguntado se
		este ser&aacute; um Sistema de Arquivos(FS, file system) ou
		swap, escolha <literal>FS</literal> e digite um
		ponto de montagem (e.g, <filename>/mnt</filename>).  Quando
		voc&ecirc; estiver adicionando um disco ap&oacute;s ter instalado,
	    o <application>sysinstall</application> n&atilde;o criar&aacute; as entradas
		no <filename>/etc/fstab</filename> para voc&ecirc;, ent&atilde;o o ponto
		de montagem definido n&atilde;o tem muita import&acirc;ncia.</para>

	  <para>Voc&ecirc; agora est&aacute; pronto para gravar o novo r&oacute;tulo
	    no disco e criar o sistema de arquivos. Fa&ccedil;a isso
		teclando <userinput>W</userinput>.  Ignore qualquer erro do
	    <application>sysinstall</application> que n&atilde;o poder&aacute;
		montar a nova parti&ccedil;&atilde;o.  Saia do Editor de R&oacute;tulos e do
        <application>sysinstall</application>.</para>
	</step>

	<step>
	  <title>Finalizando</title>

	  <para>Como &uacute;ltimo passo, edite o <filename>/etc/fstab</filename>
	    para adicionar a entrada referente ao novo disco.</para>
	</step>
      </procedure>
    </sect2>

    <sect2>
      <title>Utilizando utilit&aacute;rios da linha de comando</title>

      <sect3>
	<title>Utilizando Slices ou Fatias</title>

	<para>Esta configura&ccedil;&atilde;o permitir&aacute; que ao seu disco funcionar
	  corretamente com um outro sistema operacional que possa estar
	  estar instalado em seu computador e n&atilde;o se confundir&aacute; com
	  com o utilit&aacute;rio <command>fdisk</command> de outros
	  sistemas.  &Eacute; recomendado o uso deste m&eacute;todo para instalar
	  novos discos.  Somente use o modo <literal>dedicated</literal>
	  se voc&ecirc; tiver uma boa raz&atilde;o!</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/da1 bs=1k count=1</userinput>
&prompt.root; <userinput>fdisk -BI da1</userinput> #Inicializa seu novo disco
&prompt.root; <userinput>disklabel -B -w -r da1s1 auto</userinput> #Rotula ele
&prompt.root; <userinput>disklabel -e da1s1</userinput> #Edita o r&oacute;tulo do disco somente para criar e adicionar alguma parti&ccedil;&atilde;o
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>newfs /dev/da1s1e</userinput> #Repita isso em cada uma das parti&ccedil;&otilde;es criadas
&prompt.root; <userinput>mount /dev/da1s1e /1</userinput> #Monta a parti&ccedil;&atilde;o
&prompt.root; <userinput>vi /etc/fstab</userinput> #Adiciona uma entrada apropriada no seu <filename>/etc/fstab</filename>.</screen>

	<para>Se voc&ecirc; possuir um disco IDE, substitua o
	  <filename>ad</filename>
	  por <filename>da</filename>.  Nos sistemas pre-4.X use
	  <filename>wd</filename>.</para>
      </sect3>

      <sect3>
	<title>Dedicado</title>
	<indexterm><primary>OS/2</primary></indexterm>

	<para>Caso voc&ecirc; n&atilde;o v&aacute; compartilhar este novo disco com outros
	  sistemas operacionais, voc&ecirc; poder&aacute; usar o modo
	  <literal>dedicated</literal> ou dedicado.  Lembre-se que
	  este modo pode causar confus&atilde;o nos sistemas operacionais
	  Microsoft; entretanto, este n&atilde;o causar&aacute; danos.  O &os2;
	  da IBM, entretanto, ir&aacute; tornar qualquer parti&ccedil;&atilde;o que ele
	  n&atilde;o entenda numa parti&ccedil;&atilde;o <quote>apropriada</quote>.</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/da1 bs=1k count=1</userinput>
&prompt.root; <userinput>disklabel -Brw da1 auto</userinput>
&prompt.root; <userinput>disklabel -e da1</userinput>				#Cria a parti&ccedil;&atilde;o `e'
&prompt.root; <userinput>newfs -d0 /dev/da1e</userinput>
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>vi /etc/fstab</userinput>				#Adicione a entrada para /dev/da1e
&prompt.root; <userinput>mount /1</userinput></screen>

	<para>Um met&oacute;do alternativo &eacute;:</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/da1 count=2</userinput>
&prompt.root; <userinput>disklabel /dev/da1 | disklabel -BrR da1 /dev/stdin</userinput>
&prompt.root; <userinput>newfs /dev/da1e</userinput>
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>vi /etc/fstab</userinput>					#Adicione a entrada para /dev/da1e
&prompt.root; <userinput>mount /1</userinput></screen>

	<note><para>Desde o &os;&nbsp;5.1-RELEASE, o utilit&aacute;rio
	  &man.bsdlabel.8; substitui o velho programa
	  &man.disklabel.8;.  No &man.bsdlabel.8; algumas op&ccedil;&otilde;es
	  e par&acirc;metros obsoletos foram retirados; no exemplo abaixo
	  temos a op&ccedil;&atilde;o <option>-r</option> que deve ser removida
	  com o &man.bsdlabel.8;.
	  Para ter mais informa&ccedil;&otilde;es, por favor, visite a p&aacute;gina de manual
	  do &man.bsdlabel.8;.</para></note>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="raid">
    <title>RAID</title>

    <sect2 id="raid-soft">
      <title>RAID feito em Software</title>

      <sect3 id="ccd">
	<sect3info>
	  <authorgroup>
	    <author>
	      <firstname>Christopher</firstname>
	      <surname>Shumway</surname>
	      <contrib>Trabalho original de </contrib>
	    </author>
	  </authorgroup>
	  <authorgroup>
	    <author>
	      <firstname>Jim</firstname>
	      <surname>Brown</surname>
	      <contrib>Revisado por </contrib>
	    </author>
	  </authorgroup>
	</sect3info>

<indexterm><primary>RAID</primary><secondary>software</secondary></indexterm>
<indexterm>
  <primary>RAID</primary><secondary>CCD</secondary>
</indexterm>

	<title>Configura&ccedil;&atilde;o do Controlador de Discos Concatenados(CCD)</title>
	<para>Quando estiver escolhendo uma solu&ccedil;&atilde;o de armazenamento em massa
	  os fatores mais importantes a considerar s&atilde;o a velocidade, a
	  confian&ccedil;a e o custo.  &Eacute; raro ter todos os tr&ecirc;s num
	  equil&iacute;brio; normalmente um r&aacute;pido e confi&aacute;vel dispositivo
	  de armazenamento em massa &eacute; caro, e para baixar o pre&ccedil;o tanto
	  a velocidade como a confi&aacute;n&ccedil;a do dispositivo podem ser
	  sacrificadas.</para>

          <para>No desenvolvimento do sistema descrito abaixo, o
		  custo &eacute; escolhido como o fator mais importante, seguido da
		  velocidade e ent&atilde;o a confian&ccedil;a.
          A velocidade da tranfer&ecirc;ncia de dados deste sistema
		  determinada &eacute; relacionada pela rede.  E enquanto
		  a confian&ccedil;a &eacute; muito importante, o controlador CCD
		  descrito abaixo disponibiliza dados que j&aacute; tiveram
		  c&oacute;pias de seguran&ccedil;a geradas em CD-Rs e que
		  podem facilmente ser substitu&iacute;dos.</para>

          <para>Definir seus pr&oacute;prios requerimentos &eacute; o
		  primeiro passo
		  na escolha de uma solu&ccedil;&atilde;o de armazenamento
		  em massa.  Se suas
		  necessidades preferirem a velocidade
		  e a confian&ccedil;a ao inv&eacute;s do
		  custo, sua solu&ccedil;&atilde;o ir&aacute; ser diferente
		  do sistema descrito nesta se&ccedil;&atilde;o.</para>


	<sect4 id="ccd-installhw">
	  <title>Instalando o Hardware</title>

	  <para>Em rela&ccedil;&atilde;o ao sistema de discos IDE, temos
	    tr&ecirc;s discos IDE Western Digital 30GB de 5400 RPM
		para o n&uacute;cleo do disco CCD descrito abaixo,
		disponibilizando aproximadamente 90GB de
		armazenamento.  De maneira ideal, cada disco IDE
		teria sua pr&oacute;pria controladora e cabo, mas para
		minimizar custos n&atilde;o utilizaremos controladoras
		IDEs adicionais.  Uma vez que os discos s&atilde;o configurados
		com jumpers, temos que cada controladora IDE possui
		um mestre(master) e um escravo(slave).</para>

	  <para>Ao reciniciar, a BIOS do sistema ter&aacute; que
	    detectar automaticamente os discos conectados.  Ainda
		mais importante,  o FreeBSD ter&aacute; que
		detectar os discos ao reiniciar:</para>

	  <programlisting>ad0: 19574MB &lt;WDC WD205BA&gt; [39770/16/63] at ata0-master UDMA33
ad1: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata0-slave UDMA33
ad2: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata1-master UDMA33
ad3: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata1-slave UDMA33</programlisting>

 	  <note><para>Se o FreeBSD n&atilde;o detectar todos os discos, confira
	    se os discos foram jumpeados corretamente.  A maioria das
		controladores tamb&eacute;m possuem a
		op&ccedil;&atilde;o de jumpeamento <quote>Cable Select</quote>.  Este
		<emphasis>n&atilde;o</emphasis> &eacute; o jumper
		para a rela&ccedil;&atilde;o master/slave.  Consulte a documenta&ccedil;&atilde;o da controladora
		para ter ajuda de como identificar a maneira correta de
		configurar.</para></note>

 	  <para>Em seguida, consideraremos como ser&atilde;o conectados
	    como parte do sistema de arquivos.  Voc&ecirc; deve realizar uma
		pesquisa entre o &man.vinum.8; (<xref
 	    linkend="vinum-vinum">) e o &man.ccd.4;.  Nesta configura&ccedil;&atilde;o
		em particular, o &man.ccd.4; foi o escolhido.</para>
	</sect4>

	<sect4 id="ccd-setup">
	  <title>Configurando o CCD</title>

 	  <para>O controlador &man.ccd.4; permite que voc&ecirc;
	    pegue diversos discos iguais e concaten&ecirc;-os em
		um sistema de arquivos l&oacute;gico.  Para fazer o uso do
 	    &man.ccd.4; voc&ecirc; precisar&aacute; de um kernel contru&iacute;do
		com o suporte ao &man.ccd.4;. Adicione esta linha no seu
		arquivos de configura&ccedil;&atilde;o do kernel, recompile e
		reinstale o kernel:</para>

	  <programlisting>pseudo-device   ccd     4</programlisting>

	  <para>Nos sistemas 5.X voc&ecirc; deve usar a linha &agrave; seguir:</para>

	  <programlisting>device   ccd</programlisting>

	  <note><para>No FreeBSD&nbsp;5.X n&atilde;o &eacute; necess&aacute;rio especificar
	    um n&uacute;mero de dispositivos &man.ccd.4;, como o dispositivo
		do controlador &man.ccd.4; agora se auto-replica
	    &mdash; novas inst&acirc;ncias do dispositivo
		ser&atilde;o criadas automaticamente
		sobre demanda.</para></note>

	  <para>O suporte ao &man.ccd.4; pode tamb&eacute;m ser carregado como um
	    m&oacute;dulo de kernel carreg&aacute;vel no FreeBSD 3.0 ou anterior.</para>

 	  <para>Para configurar o &man.ccd.4; voc&ecirc; deve primeiro usar o
 	    &man.disklabel.8; para rotular os discos:</para>

	  <programlisting>disklabel -r -w ad1 auto
disklabel -r -w ad2 auto
disklabel -r -w ad3 auto</programlisting>

 	  <para>Isto criar&aacute; um r&oacute;tulo de
	    disco para o <devicename>ad1c</devicename>,
	    <devicename>ad2c</devicename> e
		<devicename>ad3c</devicename> que
		far&atilde;o uso do disco todo.</para>

	  <note><para>Desde o &os;&nbsp;5.1-RELEASE, o
	    utilit&aacute;rio &man.bsdlabel.8;
	    substitui o antigo programa &man.disklabel.8;.  No
	    &man.bsdlabel.8; algumas op&ccedil;&otilde;es e par&acirc;metros obsoletos foram
		retirados; no exemplo que segue temos
		a op&ccedil;&atilde;o <option>-r</option> que deve ser retirada.  Para mais
		informa&ccedil;&otilde;es, visite a p&aacute;gina
		de manual do &man.bsdlabel.8;.</para></note>

 	  <para>O pr&oacute;ximo passo &eacute; mudar o tipo do r&oacute;tulo.  Voc&ecirc;
	    pode usar o &man.disklabel.8; para editar os discos:</para>

	  <programlisting>disklabel -e ad1
disklabel -e ad2
disklabel -e ad3</programlisting>

 	  <para>Isto abre o r&oacute;tulo atual de cada disco com o editor
	    especificado pela vari&aacute;vel de ambiente <envar>EDITOR</envar>,
		que geralmente &eacute; o &man.vi.1;.</para>

	  <para>Um r&oacute;tulo de disco n&atilde;o modificado
	    parecer&aacute; com algo como isto:</para>

	  <programlisting>8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)</programlisting>

 	  <para>Adicione uma nova parti&ccedil;&atilde;o <literal>e</literal> para
	    que o &man.ccd.4; use. Isto pode usualmente ser copiado da
		parti&ccedil;&atilde;o <literal>c</literal>, mas a op&ccedil;&atilde;o
		<option>fstype</option> <emphasis>tem de</emphasis>
 	    ser <userinput>4.2BSD</userinput>.  O r&oacute;tulo do disco
		agora deve parecer com algo como isto:</para>

	  <programlisting>8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)
  e: 60074784        0    4.2BSD        0     0     0   # (Cyl.    0 - 59597)</programlisting>

	</sect4>

	<sect4 id="ccd-buildingfs">
	  <title>Construindo o Sistema de Arquivos</title>

            <para>O dispositivo <devicename>ccd0c</devicename> pode
			  n&atilde;o existir ainda, para cri&aacute;-lo execute os
			  seguintes comandos:</para>

	  <programlisting>cd /dev
sh MAKEDEV ccd0</programlisting>

	  <note><para>No FreeBSD 5.0, o &man.devfs.5; gerenciar&aacute;
	    automaticamente os dispositivos listados em
		<filename>/dev</filename>, o que dispensa o uso do
	    <command>MAKEDEV</command>.</para></note>

	  <para>Agora que voc&ecirc; tem todos os discos rotulados voc&ecirc; deve
	    contruir o &man.ccd.4;.  Para fazer isso, use
		o &man.ccdconfig.8; com op&ccedil;&otilde;es similares as que seguem:</para>

	    <programlisting>ccdconfig ccd0<co id="co-ccd-dev"> 32<co id="co-ccd-interleave"> 0<co id="co-ccd-flags"> /dev/ad1e<co id="co-ccd-devs"> /dev/ad2e /dev/ad3e</programlisting>

	  <para>O uso e o significado de cada op&ccedil;&atilde;o est&aacute; listado abaixo:</para>

          <calloutlist>
            <callout arearefs="co-ccd-dev">
	    <para>O primeiro argumento &eacute; o dispositivo que
		    ser&aacute; configurado, neste caso, o
			<devicename>/dev/ccd0c</devicename>. A por&ccedil;&atilde;o
			<filename>/dev/</filename> &eacute; opcional.</para>
            </callout>

            <callout arearefs="co-ccd-interleave">

	    <para>O intercalamento para o sistema de arquivos.  O
		intercalamento define o tamanho da faixa(stripe) em
		blocos de disco, que &eacute; normalmente 512 bytes.
	    Ebnt&atilde;o, um intercalamento de 32 seria 16,384 bytes.</para>
            </callout>

            <callout arearefs="co-ccd-flags">
	    <para>Par&acirc;metros para o &man.ccdconfig.8;.  Se
		voc&ecirc; deseja ativar
		o controle de espelhamento voc&ecirc; pode especificar
		o par&acirc;metro aqui. Esta configura&ccedil;&atilde;o n&atilde;o prov&ecirc;
		espelhamento para o &man.ccd.4;, ent&atilde;o
		esta est&aacute; sendo definida por 0 (zero).</para>
            </callout>

            <callout arearefs="co-ccd-devs">
	    <para>As argumentos finais para o &man.ccdconfig.8;
	    s&atilde;o os dispositivos para colocar na matriz.  Utilize
		o caminho e nome completo para cada dispositivo.</para>
            </callout>
          </calloutlist>


	  <para>Ap&oacute;s executar o &man.ccdconfig.8; o &man.ccd.4;
	      &eacute; configurado. Um sistema de arquivo
		  pode ser instalado.  Use o &man.newfs.8;
          para mais op&ccedil;&otilde;es, ou simplesmente execute: </para>

	  <programlisting>newfs /dev/ccd0c</programlisting>


	</sect4>

	<sect4 id="ccd-auto">
	  <title>Fazendo tudo automaticamente</title>

	  <para>Geralmente, voc&ecirc; ir&aacute; querer montar o &man.ccd.4;
	    em cada rein&iacute;cio do sistema. Para fazer isso voc&ecirc; deve
		configurar isso primeiro.  Escreva sua configura&ccedil;&atilde;o
		corrente no <filename>/etc/ccd.conf</filename>
		utilizando os seguintes comandos:</para>

	  <programlisting>ccdconfig -g &gt; /etc/ccd.conf</programlisting>

	  <para>Durante o rein&iacute;cio do sistema o script
	    <command>/etc/rc</command>
	    executa <command>ccdconfig -C</command> caso
		exista o <filename>/etc/ccd.conf</filename>. Isto
		automaticamente configura o &man.ccd.4; e ent&atilde;o
		este poder&aacute; ser montado.</para>

	  <note><para>Se voc&ecirc; estiver inicializando o sistema
	    em modo monousu&aacute;rio, antes voc&ecirc; poder dar &man.mount.8;
		no &man.ccd.4;, voc&ecirc; precisa definir os seguintes
		comandos para configurar a matriz:</para>

	  <programlisting>ccdconfig -C</programlisting>
          </note>

	  <para>Para montar automaticamente o &man.ccd.4; coloque
	    uma entrada para o &man.ccd.4; em
		<filename>/etc/fstab</filename> e ent&atilde;o este ser&aacute;
		montado no in&iacute;cio do sistema:</para>

	  <programlisting>/dev/ccd0c              /media       ufs     rw      2       2</programlisting>
	</sect4>
      </sect3>

      <sect3 id="vinum">
	<title>O gerenciador de volumes Vinum</title>

<indexterm><primary>RAID</primary><secondary>software</secondary></indexterm>
<indexterm>
  <primary>RAID</primary>
  <secondary>Vinum</secondary>
</indexterm>

	<para>O gerenciador de volumes Vinum &eacute; um controlador
	  de dispositivo de bloco que implementa controladores de
	  discos virtuais.  Este isola o disco f&iacute;sico da interface
	  de dispositivos de bloco e mapeia os dados em meios
	  que resultam num aimento de flexibilidade, performance e
	  confian&ccedil;a compar&aacute;veis as tradicionais slices de
	  armazenamento em disco. O &man.vinum.8; implementa os modelos RAID-0, RAID-1 e
	  RAID-5, tanto individualmente como combinando.</para>

	<para>Visite <xref linkend="vinum-vinum"> para mais
	  informa&ccedil;&otilde;es sobre &man.vinum.8;.</para>
      </sect3>
    </sect2>

    <sect2 id="raid-hard">
      <title>RAID feito em Hardware</title>

      <indexterm>
	<primary>RAID</primary>
	<secondary>hardware</secondary>
      </indexterm>

      <para>O FreeBSD tamb&eacute;m suporta uma variedade de
	    controladoras <acronym>RAID</acronym>.  Estes
		dispositivos controlam um subsistema <acronym>RAID</acronym>
        sem precisar de um software espec&iacute;fico
		do FreeBSD para gerenciar
		a matriz.</para>

      <para>Utilizando uma <acronym>BIOS</acronym> na placa, a placa
        controla a maioria das opera&ccedil;&otilde;es em disco.  &Agrave; seguir temos uma
		configura&ccedil;&atilde;o descrevendo o uso de uma controladora
		<acronym>Promise IDE RAID</acronym>.  Quando esta placa &eacute;
		instalada e o sistema &eacute; iniciado, &eacute; apresentado um prompt
		pedindo informa&ccedil;&otilde;es.  Siga as instru&ccedil;&otilde;es para entrar na tela
		de configura&ccedil;&atilde;o da placa.  Daqui, voc&ecirc; tem a habilidade
	    para combinar todos os discos conectados.  Ap&oacute;s ter feito
		a configura&ccedil;&atilde;o os disco parecer&atilde;o um &uacute;nico disco para o
		FreeBSD.  Outros n&iacute;veis de <acronym>RAID</acronym> podem ser
		configurados como descrito.
      </para>
    </sect2>

    <sect2>
      <title>Reconstruindo Matrizes de ATA RAID1</title>

      <para>O FreeBSD permite que voc&ecirc; troque um disco falhando em
	  uma matriz. Isto requere que voc&ecirc; pegue-o antes de reiniciar
	  o sistema.</para>

      <para>Voc&ecirc; provavelmente ver&aacute; algo como o seguinte
	  em <filename>/var/log/messages</filename> ou na sa&iacute;da do &man.dmesg.8;:</para>

      <programlisting>ad6 on monster1 suffered a hard error.
ad6: READ command timeout tag=0 serv=0 - resetting
ad6: trying fallback to PIO mode
ata3: resetting devices .. done
ad6: hard error reading fsbn 1116119 of 0-7 (ad6 bn 1116119; cn 1107 tn 4 sn 11) status=59 error=40
ar0: WARNING - mirror lost</programlisting>

      <para>Utilizando o &man.atacontrol.8;, busque por informa&ccedil;&otilde;es:</para>

      <screen>&prompt.root; <userinput>atacontrol list</userinput>
ATA channel 0:
	Master:      no device present
	Slave:   acd0 &lt;HL-DT-ST CD-ROM GCR-8520B/1.00&gt; ATA/ATAPI rev 0

ATA channel 1:
	Master:      no device present
	Slave:       no device present

ATA channel 2:
	Master:  ad4 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
	Slave:       no device present

ATA channel 3:
	Master:  ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
	Slave:       no device present

&prompt.root; <userinput>atacontrol status ar0</userinput>
ar0: ATA RAID1 subdisks: ad4 ad6 status: DEGRADED</screen>

      <procedure>
	<step>
	  <para>Voc&ecirc; primeiramente precisar&aacute; desconectar o disco
	  da matriz para ent&atilde;o poder remov&ecirc;-lo seguramente:</para>

	  <screen>&prompt.root; <userinput>atacontrol detach 3</userinput></screen>
	</step>

	<step>
	  <para>Substitua o disco.</para>
	</step>

	<step>
	  <para>Reconecte o disco como um reserva:</para>

	  <screen>&prompt.root; <userinput>atacontrol attach 3</userinput>
Master:  ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
Slave:   no device present</screen>
	</step>

	<step>
	  <para>Reconstrua a matriz:</para>

	  <screen>&prompt.root; <userinput>atacontrol rebuild ar0</userinput></screen>
	</step>

	<step>
	  <para>O comando de reconstru&ccedil;&atilde;o executar&aacute;
	      at&eacute; estar completo.  Entretanto, &eacute; poss&iacute;vel
	      abrir outro terminal (utilizando <keycombo action="simul">
		  <keycap>Alt</keycap> <keycap>F<replaceable>n</replaceable>
		  </keycap></keycombo>)
          e checar o progresso da
		  reconstrui&ccedil;&atilde;o com o seguinte comando:</para>

	  <screen>&prompt.root; <userinput>dmesg | tail -10</userinput>
[output removed]
ad6: removed from configuration
ad6: deleted from ar0 disk1
ad6: inserted into ar0 disk1 as spare

&prompt.root; <userinput>atacontrol status ar0</userinput>
ar0: ATA RAID1 subdisks: ad4 ad6 status: REBUILDING 0% completed</screen>
	</step>

	<step>
	  <para>Espere at&eacute; que esta opera&ccedil;&atilde;o esteja completa.</para>
	</step>
      </procedure>
    </sect2>
  </sect1>

  <sect1 id="creating-cds">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Mike</firstname>
	  <surname>Meyer</surname>
	  <contrib>Comtribui&ccedil;&atilde;o de </contrib>
	  <!-- mwm@mired.org -->
	</author>
      </authorgroup>
      <!-- Apr 2001 -->
    </sect1info>

    <title>Criando e utilizando m&iacute;dias &oacute;pticas (CDs &amp; DVDs)</title>
    <indexterm>
      <primary>CDROMs</primary>
      <secondary>creating</secondary>
    </indexterm>

    <sect2>
      <title>Introdu&ccedil;&atilde;o</title>

      <para>Os CDs tem um n&uacute;mero diferenciado de funcionalidades dos
	    discos convencionais. Inicialmente, eles n&atilde;o s&atilde;o grav&aacute;veis aos
		usu&aacute;rios. Eles s&atilde;o criados o que permite serem
		lidos continuamente sem esperas para mover o cabe&ccedil;ote entre
		trilhas. Eles tamb&eacute;m s&atilde;o facilitadores no transporte
		de informa&ccedil;&otilde;es entre sistemas com tamanhos de m&iacute;dias similares
		e podendo ser feitas ao mesmo tempo.</para>

      <para>Os CDs tem trilhas, mas isto se refere a uma se&ccedil;&atilde;o de
	    dados que s&atilde;o lidos continuamente e n&atilde;o s&atilde;o uma propriedade
		f&iacute;sica do disco. Para produzir um CD no FreeBSD, voc&ecirc; deve
		preparar os arquivos de dados que compor&atilde;o as trilhas,
		para que ent&atilde;o sejam escritas como trilhas do CD.</para>

      <indexterm><primary>ISO 9660</primary></indexterm>
      <indexterm>
        <primary>file systems</primary>
        <secondary>ISO 9660</secondary>
      </indexterm>
      <para>O sistema de arquivos ISO 9660 foi desenvolvido para criar
	    um acordo nestas diferen&ccedil;as. Isto infelizmente codifica
		o sistema de arquivos com limites inerentes ao padr&atilde;o.
		Afortunadamente, este prov&ecirc; um mecanismo de extens&otilde;es que
		permite gravar CDs apropriadamente para exceder estes
		limites enquanto estiver trabalhando com sistemas que
		que n&atilde;o suportam estas extens&otilde;es.</para>

      <indexterm>
        <primary><filename role="package">sysutils/mkisofs</filename></primary>
      </indexterm>
      <para>O programa <filename role="package">sysutils/mkisofs</filename>
	     &eacute; utilizado para produzir um arquivo contendo um
		 sistema de arquivos ISO 9660. Este possui op&ccedil;&otilde;es que
		 suportam diversas extens&otilde;es, estas est&atilde;o descritas
		 abaixo. Voc&ecirc; pode instalar o port <filename role="package">sysutils/mkisofs</filename>.</para>

      <indexterm>
        <primary>CD burner</primary>
        <secondary>ATAPI</secondary>
      </indexterm>
      <para>Qual utilit&aacute;rio usar para gravar o CD depender&aacute; se
	    seu gravador de CD &eacute; ATAPI ou algum outro. Gravadores
		de CD ATAPI usam o programa <command><link
	    linkend="burncd">burncd</link></command> que &eacute; uma parte
	    do sistema. Os gravadores SCSI e USB devem usar o
	    <command><link linkend="cdrecord">cdrecord</link>
		</command> do port <filename role="package">
		sysutils/cdrtools</filename>.</para>

      <para><command>burncd</command> has a limited number of
	supported drives. To find out if a drive is supported, see the
	<ulink url="http://www.freebsd.dk/ata/">CD-R/RW supported
	  drives</ulink> list.</para>

      <note>
      <indexterm>
	<primary>CD burner</primary>
	<secondary>ATAPI/CAM driver</secondary>
      </indexterm>
	<para>Se voc&ecirc; usa a vers&atilde;o &os;&nbsp;5.X, &os;&nbsp;4.8-RELEASE ou
	  acima, ser&aacute; poss&iacute;vel utilizar o <command><link
	  linkend="cdrecord">cdrecord</link></command> e
	  outros utilit&aacute;rios para controladores SCSI
	  em controladores ATAPI com o <link
	  linkend="atapicam">ATAPI/CAM module</link>.</para>
      </note>
    </sect2>

    <sect2 id="mkisofs">
      <title>mkisofs</title>

      <para>O <filename role="package">sysutils/mkisofs</filename>
	    produz um sistema de arquivos ISO 9660 que &eacute; uma imagem
		da &aacute;rvore de diret&oacute;rios no espa&ccedil;o de nomes do sistema
		de arquivos &unix;. A maneira mais simples de us&aacute;-lo &eacute;:</para>

      <screen>&prompt.root; <userinput>mkisofs -o <replaceable>imagefile.iso</replaceable> <replaceable>/path/to/tree</replaceable></userinput></screen>

      <indexterm>
        <primary>file systems</primary>
        <secondary>ISO 9660</secondary>
      </indexterm>
      <para>Este comando criar&aacute; o arquivo <replaceable>imagefile.iso</replaceable>
	    contendo um sistema de arquivos ISO 9660 que &eacute; uma c&oacute;pia da
		&aacute;rvore de diret&oacute;rios e arquivos em <replaceable>/path/to/tree
		</replaceable>. No processo, ser&atilde;o mapeados os nomes de arquivos
		de acordo com as limita&ccedil;&otilde;es do padr&atilde;o ISO 9660, e ser&atilde;o exclu&iacute;dos
		os arquivos que tiverem nomes n&atilde;o caracter&iacute;sticos de
		sistemas de arquivos ISO.</para>

      <indexterm>
        <primary>file systems</primary>
        <secondary>HFS</secondary>
      </indexterm>
      <indexterm>
        <primary>file systems</primary>
        <secondary>Joliet</secondary>
      </indexterm>
      <para>Algumas op&ccedil;&otilde;es est&atilde;o dispon&iacute;veis para exceder
	    as restri&ccedil;&otilde;es. Em particular, a op&ccedil;&atilde;o <option>-R</option>
		ativa as extens&otilde;es Rock Ridge, que s&atilde;o comuns aos sistemas
		&unix;, a op&ccedil;&atilde;o <option>-J</option> ativa o uso de extens&otilde;es
		Joliet, que s&atilde;o utilizadas em sistemas da Microsoft, e a
		op&ccedil;&atilde;o <option>-hfs</option> pode ser utilizada na cria&ccedil;&atilde;o de
		sistemas de arquivis HFS, que s&atilde;o utilizados no &macos;.</para>

      <para>Para CDs que v&atilde;o ser utilizados apenas em sistemas FreeBSD
	  a op&ccedil;&atilde;o <option>-U</option> pode ser utilizada para desativar
	  todas a limita&ccedil;&otilde;es de nomes de arquivos. Quando utilizada com
	  a op&ccedil;&atilde;o <option>-R</option>, esta produz um sistema de arquivos
	  id&ecirc;ntico &agrave; &aacute;rvore de diret&oacute;rios do FreeBSD que voc&ecirc; utilizou
	  na cria&ccedil;&atilde;o da imagem. Por&eacute;m isso viola de diversas maneiras
	  o padr&atilde;o ISO 9660.</para>

      <indexterm>
        <primary>CDROMs</primary>
        <secondary>creating bootable</secondary>
      </indexterm>
      <para>A &uacute;ltima op&ccedil;&atilde;o de uso geral &eacute; a <option>-b</option>. Ela
	    &eacute; utilizada para especificar o local de uma imagem de boot
		que ser&aacute; utilizada na gera&ccedil;&atilde;o de um CD boot&aacute;vel
		<quote>El Torito</quote>. Esta op&ccedil;&atilde;o pede um argumento que &eacute;
		o caminho da imagem de boot do topo da &aacute;rvore de diret&oacute;rios
		que ser&aacute; escrita no CD.  Ent&atilde;o, fornecer
		<filename>/tmp/myboot</filename> cria um sistema FreeBSD
		boot&aacute;vel com a imagem de boot em
		<filename>/tmp/myboot/boot/cdboot</filename>, voc&ecirc; poderia
		produzir a imagem de um sistema de arquivos ISO 9660 em
	    <filename>/tmp/bootable.iso</filename> como:</para>

      <screen>&prompt.root; <userinput>mkisofs -U -R -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot</userinput></screen>

      <para>Ap&oacute;s ter feito o indicado, se voc&ecirc; possuir um dispositivo
	    <devicename>vn</devicename>	(FreeBSD&nbsp;4.X), ou
		<devicename>md</devicename>	(FreeBSD&nbsp;5.X) configurado
		em seu kernel, voc&ecirc; poder&aacute; monta o sistema de arquivos com:</para>

      <screen>&prompt.root; <userinput>vnconfig -e vn0c /tmp/bootable.iso</userinput>
&prompt.root; <userinput>mount -t cd9660 /dev/vn0c /mnt</userinput></screen>

      <para>Isso no FreeBSD&nbsp;4.X, j&aacute; no FreeBSD&nbsp;5.X fa&ccedil;a:</para>

      <screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /tmp/bootable.iso -u 0</userinput>
&prompt.root; <userinput>mount -t cd9660 /dev/md0 /mnt</userinput></screen>

      <para>At&eacute; agora voc&ecirc; pode verificar que o <filename>/mnt</filename>
	    e o <filename>/tmp/myboot</filename> s&atilde;o id&ecirc;nticos.</para>

      <para>Existem diversas outras op&ccedil;&otilde;es que podem ser utilizadas
	    com o <filename role="package">sysutils/mkisofs</filename>
		para ajustar seu comportamento.  Em particular, modifica&ccedil;&otilde;es
		para um layout ISO 9660 e na cria&ccedil;&atilde;o de discos Joliet e
		HFS.  Visite a p&aacute;gina de manual do &man.mkisofs.8; para
		ter mais detalhes.</para>
    </sect2>

    <sect2 id="burncd">
      <title>burncd</title>
      <indexterm>
        <primary>CDROMs</primary>
        <secondary>burning</secondary>
      </indexterm>
      <para>Se voc&ecirc; tiver um gravador de CD ATAPI, voc&ecirc; poder&aacute;
	  utilizar o comando <command>burncd</command> para gravar
	  uma imagem ISO num CD. O <command>burncd</command> &eacute; parte
	  do sistema, &eacute; instalado em <filename>/usr/sbin/burncd
	  </filename>.  Us&aacute;-lo &eacute; muito simples, e este
	  possui poucas op&ccedil;&otilde;es:</para>

      <screen>&prompt.root; <userinput>burncd -f <replaceable>cddevice</replaceable> data <replaceable>imagefile.iso</replaceable> fixate</userinput></screen>

      <para>Isto ir&aacute; gravar uma c&oacute;pia do <replaceable>imagefile.iso
	   </replaceable> no <replaceable>cddevice</replaceable>. O
	   dispositivo padr&atilde;o &eacute; o <filename>/dev/acd0c</filename>. Visite
	   a p&aacute;gina de manual do See &man.burncd.8; para ter mais
	   op&ccedil;&otilde;es de como definir a velocidade de grava&ccedil;&atilde;o, para
	   ejetar o CD ap&oacute;s a grava&ccedil;&atilde;o e para gravar CDs de &aacute;udio.</para>
    </sect2>

    <sect2 id="cdrecord">
      <title>cdrecord</title>

      <para>Se voc&ecirc; n&atilde;o possuir um gravador de CDs ATAPI, voc&ecirc; ter&aacute;
	    que usar o <command>cdrecord</command> para gravar seus CDs. O
        <command>cdrecord</command> n&atilde;o faz parte do sistema; voc&ecirc;
		deve instal&aacute;-lo atrav&eacute;s do port <filename role="package">
		sysutils/cdrtools</filename> ou pelo pacote apropriado.
		Mudan&ccedil;as no sistema podem fazer que algumas vers&otilde;es bin&aacute;rias
		deste programa venham resultar em falhas. Voc&ecirc; deve
		atualizar este port quando atualizar o seu sistema, ou
		se voc&ecirc; j&aacute; estiver <link linkend="stable">tracking -STABLE
		</link>, atualize o port quando uma nova vers&atilde;o estiver
		dispon&iacute;vel.</para>

      <para>Enquanto o <command>cdrecord</command> tem diversas
	    op&ccedil;&otilde;es, o uso b&aacute;sico dele &eacute; mais simples do que o uso do
		<command>burncd</command>. Para gravar uma imagem ISO 9660
	    basta:</para>

      <screen>&prompt.root; <userinput>cdrecord dev=<replaceable>device</replaceable> <replaceable>imagefile.iso</replaceable></userinput></screen>

      <para>O segredo da utiliza&ccedil;&atilde;o do <command>cdrecord</command>
	    &eacute; encontrar a op&ccedil;&atilde;o <option>dev</option> que deve ser
		utilizada. Para encontrar a configura&ccedil;&atilde;o correta, use o
		par&acirc;metro <option>-scanbus</option> do <command>cdrecord</command>,
	    que podruzir&aacute; um resultado parecido com este:</para>
      <indexterm>
        <primary>CDROMs</primary>
        <secondary>burning</secondary>
      </indexterm>
      <screen>&prompt.root; <userinput>cdrecord -scanbus</userinput>
Cdrecord 1.9 (i386-unknown-freebsd4.2) Copyright (C) 1995-2000 J&ouml;rg Schilling
Using libscg version 'schily-0.1'
scsibus0:
        0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk
        0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk
        0,2,0     2) *
        0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk
        0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM
        0,5,0     5) *
        0,6,0     6) *
        0,7,0     7) *
scsibus1:
        1,0,0   100) *
        1,1,0   101) *
        1,2,0   102) *
        1,3,0   103) *
        1,4,0   104) *
        1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM
        1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner
        1,7,0   107) *</screen>

      <para>Esta listagem demonstra qual o valor apropriado que a
	    op&ccedil;&atilde;o <option>dev</option> dever&aacute; ter. Localize seu
		gravador de CDs, e use os tr&ecirc;s n&uacute;meros separados por
		v&iacute;rgulas como valor para a op&ccedil;&atilde;o <option>dev</option>.
		Neste caso, o dispositivo CRW &eacute; o 1,5,0, ent&atilde;o o
		valor apropriado seria <option>dev=1,5,0</option>. H&aacute;
		maneiras mais f&aacute;ceis de especificar este valor; visite
		a p&aacute;gina de manual do  &man.cdrecord.1; para mais detalhes.
        Que &eacute; onde est&atilde;o descritas as informa&ccedil;&otilde;es de como gravar
		trilhas de &aacute;udio, controlar a velocidade entre
		outras possibilidades.</para>
    </sect2>

    <sect2 id="duplicating-audiocds">
      <title>Duplica&ccedil;&atilde;o de CDs de &Aacute;udio</title>

      <para>Voc&ecirc; pode duplicar um CD de &aacute;udio extraindo
	    seus dados do CD em uma s&eacute;rie de arquivos, e ent&atilde;o
		gravar estes arquivos num CD virgem.  Este processo
		&eacute; um pouco diferente entre controladores ATAPI e SCSI.</para>

      <procedure>
	<title>Controladores SCSI</title>

	<step>
	  <para>Utilize o <command>cdda2wav</command> para extrair o &aacute;udio.</para>

	  <screen>&prompt.user; <userinput>cdda2wav -v255 -D2,0 -B -Owav</userinput></screen>
	</step>

	<step>
	  <para>Utilize o <command>cdrecord</command> para gravar os
	     arquivos <filename>.wav</filename>.</para>

	  <screen>&prompt.user; <userinput>cdrecord -v dev=<replaceable>2,0</replaceable> -dao -useinfo  *.wav</userinput></screen>

	  <para>Certifique-se que o <replaceable>2,0</replaceable> &eacute;
	    a configura&ccedil;&atilde;o apropriada como descrito em
		<xref linkend="cdrecord">.</para>
	</step>
      </procedure>

      <procedure>
	<title>Controladores ATAPI</title>

	<step>
	  <para>A controladora de CD ATAPI torna cada trilha dispon&iacute;vel como
	    <filename>/dev/acd<replaceable>d</replaceable>t<replaceable>nn</replaceable></filename>,
	    onde <replaceable>d</replaceable> &eacute; o n&uacute;mero da controladora, e
	    <replaceable>nn</replaceable> &eacute; o n&uacute;mero da trilha escrita em
		dois d&iacute;gitos decimais, precedidos com zero quando preciso.
	    Ent&atilde;o a primeira trilha no disco &eacute; a
	    <filename>/dev/acd0t01</filename>, a segunda &eacute; a
	    <filename>/dev/acd0t02</filename>, a terceira &eacute; a
	    <filename>/dev/acd0t03</filename>, e assim segue.</para>

	  <para>Certifique-se de que os arquivos apropriados existam em
	    <filename>/dev</filename>.</para>

	  <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV acd0t99</userinput></screen>

	  <note><para>No FreeBSD 5.0, &man.devfs.5; criar&aacute; automaticamente
	    e gerenciar&aacute; as entradas em <filename>/dev</filename>
	    para voc&ecirc;, portanto, n&atilde;o &eacute; necess&aacute;rio utilizar o
	    <command>MAKEDEV</command>.</para></note>
	</step>

	<step>
	  <para>Extraia cada trilha utilizando o &man.dd.1;.  Voc&ecirc; deve
	    especificar tamb&eacute;m um tamanho espec&iacute;fico de bloco quando
		estiver extraindo os arquivos.</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/acd0t01 of=track1.cdr bs=2352</userinput>
&prompt.root; <userinput>dd if=/dev/acd0t02 of=track2.cdr bs=2352</userinput>
...
</screen>
	</step>

	<step>
	  <para>Grave os arquivos extra&iacute;dos para o disco utilizando o
	    <command>burncd</command>.  Voc&ecirc; deve especificar que s&atilde;o arquivos
		de &aacute;udio, e que o <command>burncd</command> deve executar o
		<option>fixate</option> no disco quando terminar a grava&ccedil;&atilde;o.</para>

	  <screen>&prompt.root; <userinput>burncd -f <replaceable>/dev/acd0c</replaceable> audio track1.cdr track2.cdr <replaceable>...</replaceable> fixate</userinput></screen>
	</step>
      </procedure>
    </sect2>

    <sect2 id="imaging-cd">
      <title>Duplicando CDs de Dados</title>

      <para>Voc&ecirc; pode copiar um CD de dados em um arquivo de imagem
	  que funcionalmente &eacute; equivalente a uma imagem criada com o
	  <filename role="package">sysutils/mkisofs</filename>, e voc&ecirc;
	  usar este recurso para duplicar qualquer CD de dados.  O
	  exemplo a seguir assume que o seu dispositivo de CDROM
	  &eacute; o <devicename>acd0</devicename>.  Substitua pelo dispositivo
	  de CDROM correto no seu sistema.  Um <literal>c</literal> deve
	  ser adicionado ao final do nome do dispositivo para indicar
	  a parti&ccedil;&atilde;o toda, ou, no caso de CDROMs, o disco inteiro.</para>

      <screen>&prompt.root; <userinput>dd if=/dev/acd0c of=file.iso bs=2048</userinput></screen>

      <para>Agora que voc&ecirc; possui a imagem, voc&ecirc; pode grav&aacute;-la num CD como
	  descrito anteriormente.</para>
    </sect2>

    <sect2 id="mounting-cd">
      <title>Utilizando CDs de Dados</title>

      <para>Agora que voc&ecirc; criou um CD de dados padr&atilde;o, voc&ecirc;
	  provavelmente ir&aacute; querer montar a unidade e ler dados dele.
	  Por padr&atilde;o, o &man.mount.8; ir&aacute; assumir que o tipo de sistema
	  de arquivos &eacute; o <literal>ufs</literal>.
	  Se voc&ecirc; tentar algo como:</para>

      <screen>&prompt.root; <userinput>mount /dev/cd0c /mnt</userinput></screen>

      <para>Voc&ecirc; conseguir&aacute; a seguinte mensagem<errorname>Incorrect super
	  block</errorname>, e o disco n&atilde;o ser&aacute; montado. O CDROM n&atilde;o &eacute; um
	  sistema de arquivos <literal>UFS</literal>, portanto, tentar
	  mont&aacute;-lo com esta configura&ccedil;&atilde;o ocasionar&aacute; em falha.  Voc&ecirc; s&oacute;
	  precisa indicar ao &man.mount.8; que o sistema de arquivos &eacute; do
	  tipo <literal>ISO9660</literal>, e tudo funcionar&aacute;.  Voc&ecirc; faz isso
	  especificando a op&ccedil;&atilde;o <option>-t cd9660</option> ao &man.mount.8;. Por
	  exemplo, se voc&ecirc; quer montar o dispositivo de CDROM
	  <devicename>/dev/cd0c</devicename>, sob o <filename>/mnt</filename>,
	  voc&ecirc; deve executar:</para>

          <screen>&prompt.root; <userinput>mount -t cd9660 /dev/cd0c /mnt</userinput></screen>

      <para>Note que seu nome de dispositivo
	  (<devicename>/dev/cd0c</devicename> neste exemplo) poder&aacute;
	  ser diferente, dependendo da interface que seu CDROM utilizar.
	  Tamb&eacute;m, a op&ccedil;&atilde;o <option>-t cd9660</option> apenas executa
	  o &man.mount.cd9660.8;. O exemplo acima pode ser reduzido para:</para>

<screen>&prompt.root; <userinput>mount_cd9660 /dev/cd0c /mnt</userinput></screen>

      <para>Voc&ecirc; geralmente pode utilizar CDROMs de dados de qualquer
	  fabricante com este m&eacute;todo.  Entretanto, discos com
	  algumas extens&otilde;es do ISO 9660 podem ter um comportamente &iacute;mpar.
	  Por exemplo, disco com extens&atilde;o Joliet armazenam todos os
	  nomes de arquivos em caracteres Unicode de dois bytes.
	  O kernel do FreeBSD n&atilde;o entende Unicode (ainda!), ent&atilde;o
	  os caracteres que n&atilde;o pertencerem ao idioma Ingl&ecirc;s ser&atilde;o
	  mostrados como sinais de interroga&ccedil;&atilde;o.  (Se voc&ecirc; estiver
	  rodando o FreeBSD 4.3 ou superior, o driver CD9660
	  inclui ganchos para carregar uma tabela de convers&atilde;o
	  Unicode dinamicamente.  M&oacute;dulos para algumas das codifica&ccedil;&otilde;es
	  comuns est&atilde;o dispon&iacute;veis no port
	  <filename role="package">sysutils/cd9660_unicode</filename>.)</para>

      <para>Ocasionalmente, voc&ecirc; poder&aacute; receber um <errorname>Device not
	configured</errorname> quando tentar montar um CDROM.  Isto
	geralmente significa que o drive de CDROM acha que n&atilde;o h&aacute; um disco, ou
	este drive n&atilde;o &eacute; vis&iacute;vel no barramento. Pode levar alguns segundos
	para que um drive de CDROM detectar que est&aacute; com um disco, portanto
	seja paciente.</para>

      <para>Algumas vezes, um CDROM SCSI pode n&atilde;o ser inicializado devido
	  a n&atilde;o haver tempo suficiente para responder durante um rein&iacute;cio do
	  barramento. Se voc&ecirc; possui um CDROM SCSI, por favor, adicione
	  a seguinte op&ccedil;&atilde;o ao seu arquivo de configura&ccedil;&atilde;o do kernel e
      e <link linkend="kernelconfig-building">recompile-o</link>.</para>

      <programlisting>options SCSI_DELAY=15000</programlisting>

      <para>Isto diz para o barramento SCSI pausar durante 15 segundos
	  durante a inicializa&ccedil;&atilde;o, para dar chance de resposta ao seu
	  drive de CDROM durante o rein&iacute;cio do barramento SCSI.</para>
    </sect2>

    <sect2 id="rawdata-cd">
      <title>Gravando CDs de Dados em modo Raw</title>

      <para>Voc&ecirc; pode querer gravar um arquivo diretamente no CD,
	  sem criar um sistema de arquivos ISO 9660.  Algumas pessoas
	  fazem isso no prop&oacute;sito de backup.  E este modo de grava&ccedil;&atilde;o
	  &eacute; mais r&aacute;pido:</para>

      <screen>&prompt.root; <userinput>burncd -f /dev/acd1c -s 12 data archive.tar.gz fixate</userinput></screen>

      <para>Para poder acessar os dados que ser&atilde;o gravados no CD voc&ecirc;
	  dever&aacute; ler os dados de um dispositivo raw:</para>

      <screen>&prompt.root; <userinput>tar xzvf /dev/acd1c</userinput></screen>

      <para>Voc&ecirc; n&atilde;o pode montar este disco como faria com um
	  CDROM normal. Como um CDROM n&atilde;o poderia ser lido sob nenhum
	  outro sistema operacional, excepto o FreeBSD.
	  Se voc&ecirc; quer estar apto a montar os CDs, ou a compartilhar os dados com
	  outros sistemas operacionais, voc&ecirc; deve usar o
	  <filename role="package">sysutils/mkisofs</filename> como j&aacute; citado.</para>
    </sect2>

    <sect2 id="atapicam">
      <indexterm>
	<primary>CD burner</primary>
	<secondary>ATAPI/CAM driver</secondary>
      </indexterm>
      <title>Utilizando o Driver ATAPI/CAM</title>

      <para>Este driver permite que dispositivos ATAPI (CD-ROM, CD-RW, DVD-ROM, etc...)
	  possam ser acessados atrav&eacute;s do sub-sistema SCSI, permitindo o uso de aplica&ccedil;&otilde;es
	  como o  <filename
	role="package">sysutils/cdrdao</filename> ou o &man.cdrecord.1;.</para>

      <para>Para utilizar este driver, voc&ecirc; precisar&aacute; adicionar as seguintes
	  linhas ao seu arquivo de configura&ccedil;&atilde;o do kernel:</para>

      <programlisting>device atapicam
device scbus
device cd
device pass</programlisting>

      <para>Voc&ecirc; tamb&eacute;m prexisar&aacute; adicionar as seguintes linhas:</para>

      <programlisting>device ata
device atapicd</programlisting>

      <para>Ambas dever&atilde;o estar presentes.</para>

      <para>Ent&atilde;o recompile, instale o novo kernel e reinicie seu sistema.
	  Durante o processo de inicializa&ccedil;&atilde;o, seu gravador de CDs dever&aacute;
	  retornar algo como:</para>

      <screen>acd0: CD-RW &lt;MATSHITA CD-RW/DVD-ROM UJDA740&gt; at ata1-master PIO4
cd0 at ata1 bus 0 target 0 lun 0
cd0: &lt;MATSHITA CDRW/DVD UJDA740 1.00&gt; Removable CD-ROM SCSI-0 device
cd0: 16.000MB/s transfers
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed</screen>

      <para>O drive agora pode ser acessado atrav&eacute;s do nome
	  de dispositivo <filename>/dev/cd0</filename>, por
	  exemplo, para montar o CDROM em <filename>/mnt</filename>
	  fa&ccedil;a o seguinte:</para>

      <screen>&prompt.root; <userinput>mount -t cd9660 <replaceable>/dev/cd0c</replaceable> /mnt</userinput></screen>

      <para>Como usu&aacute;rio <username>root</username> voc&ecirc;
	  pode executar o seguinte comando para saber o endere&ccedil;o
	  SCSI do gravador:</para>

      <screen>&prompt.root; <userinput>camcontrol devlist</userinput>
&lt;MATSHITA CDRW/DVD UJDA740 1.00&gt;   at scbus1 target 0 lun 0 (pass0,cd0)</screen>

      <para>Temos que o <literal>1,0,0</literal> ser&aacute; o endere&ccedil;o
	  SCSI para utilizar no &man.cdrecord.1; e para outras
	  aplica&ccedil;&otilde;es SCSI.</para>

      <para>Para maior informa&ccedil;&otilde;es sobre ATAPI/CAM e sistema
	  SCSI, visite as p&aacute;ginas de manual do &man.atapicam.4;
	  e do &man.cam.4;.</para>
    </sect2>
  </sect1>

  <sect1 id="floppies">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Julio</firstname>
	  <surname>Merino</surname>
	  <contrib>Trabalho original de </contrib>
	</author>
      </authorgroup>
      <!-- 24 Dec 2001 -->
      <authorgroup>
	<author>
	  <firstname>Martin</firstname>
	  <surname>Karlsson</surname>
	  <contrib>Reescrito por </contrib>
	</author>
      </authorgroup>
      <!-- 27 Apr 2003 -->
    </sect1info>

    <title>Cria&ccedil;&atilde;o e utiliza&ccedil;&atilde;o de disquetes</title>

    <para>Armazenar dados em disquetes pode ser &uacute;til algumas vezes,
	  por exemplo, quanto voc&ecirc; n&atilde;o tem nenhum outro tipo de m&iacute;dia
	  de armazenamento remov&iacute;vel ou quando voc&ecirc; precisa transferir
	  pequena quantidade de dados para um outro computador.</para>

    <para>Esta se&ccedil;&atilde;o explicar&aacute; com utilizar disquetes no FreeBSD.
      Primeiramente, cobrir&aacute; a formata&ccedil;&atilde;o e o uso de diquetes DOS de
	  3.5 polegadas, mas os conceitos s&atilde;o similares em rela&ccedil;&atilde;o ao
	  uso de outros formatos.</para>

    <sect2>
      <title>Formatando disquetes</title>

      <sect3>
	<title>O Dispositivo</title>

	<para>Disquetes s&atilde;o acessados atrav&eacute;s de entradas
	  em <filename>/dev</filename>, assim como outros dispositivos.
	  Para acessar um disquete gravado em raw no 4.X ou vers&otilde;es
	  anteriores use <filename>/dev/fd<replaceable>N</replaceable>
	  </filename>, onde o <replaceable>N</replaceable> inidica
	  o n&uacute;mero da controladora, usualmente 0, ou
	  <filename>/dev/fd<replaceable>NX</replaceable></filename>,
	  onde <replaceable>X</replaceable> indica a letra do dispositivo.</para>

	<para>Na vers&atilde;o 5.0 ou acima, use simplesmente o
	  <filename>/dev/fd<replaceable>N</replaceable></filename>.</para>

	<sect4>
	  <title>O tamanho do disco no 4.X e nas vers&otilde;es anteriores</title>

	  <para>Estes tamb&eacute;m possuem os dispositivos
	    <filename>/dev/fd<replaceable>N</replaceable>.
	    <replaceable>size</replaceable></filename>,
	    onde <replaceable>size</replaceable> &eacute; o tamanho do disquete
		em kilobytes.  Estas entradas s&atilde;o utilizadas em formata&ccedil;&atilde;o
		de baixo-n&iacute;vel, para determinar o tamanho do disco. 1440kB
		&eacute; o tamanho que ser&aacute; utilizado no exemplo &agrave; seguir.</para>

	  <para>Algumas vezes as entradas no <filename>/dev</filename>
	    ter&atilde;o de ser (re)criadas.  Para fazer isso:</para>

	  <screen>&prompt.root; <userinput>cd /dev && ./MAKEDEV "fd*"</userinput></screen>
	</sect4>

	<sect4>
	  <title>O tamanho do disco na 5.0 e vers&otilde;es superiores</title>

	  <para>Na 5.0, o &man.devfs.5; administrar&aacute; automaticamente os
	    dispositivos em <filename>/dev</filename>, o que torna
		o uso do <command>MAKEDEV</command> desnecess&aacute;rio.</para>

	  <para>O tamanho desejado do disco &eacute; passado para o
	    &man.fdformat.1; atrv&eacute;s da op&ccedil;&atilde;o <option>-f</option>.
		Os tamanhos suportados s&atilde;o listados no
		&man.fdcontrol.8;, mas esteja avisado que o 1440kB
		&eacute; o que funciona melhor.</para>
	</sect4>
      </sect3>

      <sect3>
	<title>Formatando</title>

	<para>Um disquete precisa ser formatado em baixo-n&iacute;vel
	  antes de estar utiliz&aacute;vel.  Isto geralmente &eacute; realizado
	  pelos fabricantes, mas este tipo de formata&ccedil;&atilde;o &eacute; uma &oacute;tima
	  maneira de verificar a integridade da m&iacute;dia.  E ainda
	  &eacute; poss&iacute;vel for&ccedil;ar tamanhos de discos maiores (ou menores),
	  mas a maioria dos discos s&atilde;o desenvolvidos para o tamanho
	  1440kB.</para>

	<para>Para formatar um disquete em baixo-n&iacute;vel voc&ecirc; precisa
	  utilizar o &man.fdformat.1;.  Este utilit&aacute;rio necessita do
	  nome do dispositivo como argumento.</para>

	  <para>Anote qualquer mensagem de erro, isso pode ajudar
	    a determinar se o disco est&aacute; bom ou ruim.</para>

	<sect4>
	  <title>Formatando no 4.X ou vers&otilde;es anteriores</title>

	  <para>Utilize o dispositivo
	    <filename>/dev/fd<replaceable>N</replaceable>.<replaceable>size
		</replaceable></filename> para formatar o disquete. Insira um
		disquete novo de 3.5 polegadas no seu drive e execute:</para>

	  <screen>&prompt.root; <userinput>/usr/sbin/fdformat /dev/fd0.1440</userinput></screen>

	</sect4>

	<sect4>
	  <title>Formatando no 5.0 e vers&otilde;es superiores</title>

	  <para>Utilize o dispositivo
	    <filename>/dev/fd<replaceable>N</replaceable></filename>
	    para formatar o disquete. devices to format the floppy.
		Insira um disquete novo de 3.5 polegadas no seu drive
		e execute:</para>

	  <screen>&prompt.root; <userinput>/usr/sbin/fdformat -f 1440 /dev/fd0</userinput></screen>

	</sect4>
      </sect3>
    </sect2>



    <sect2>
      <title>O r&oacute;tulo do disco</title>

      <para>Depois da formata&ccedil;&atilde;o de baixo-n&iacute;vel voc&ecirc; precisar&aacute;
	   colocar um r&oacute;tulo no disquete.  Este r&oacute;tulo ser&aacute; destru&iacute;do
	   mais tarde, mas &eacute; necess&aacute;rio mais tarde para o sistema
	   determinar o tamanho e a geometria do disco.</para>

      <para>O novo r&oacute;tulo do disco indicar&aacute; o disco todo,
	  e conter&aacute; todas as informa&ccedil;&otilde;es pr&oacute;prias sobre a
	  geometria do disquete. Os valores de geometria
	  para r&oacute;tulos de disquetes est&atilde;o listados em
	  <filename>/etc/disktab</filename>.</para>

      <para>Voc&ecirc; pode executar agora o &man.disklabel.8;:</para>

      <screen>&prompt.root; <userinput>/sbin/disklabel -B -r -w /dev/fd0 fd1440</userinput></screen>

      <note><para>Desde o &os;&nbsp;5.1-RELEASE, o utilit&aacute;rio
	   &man.bsdlabel.8; substitui o velho programa &man.disklabel.8;.
	   Com o &man.bsdlabel.8;, um n&uacute;mero de op&ccedil;&otilde;es e par&acirc;metros
	   obsoletos foram retirados; no exemplo a op&ccedil;&atilde;o
	   <option>-r</option> deveria ser retirada.  Para mais
	   informa&ccedil;&otilde;es, por favor, visite a p&aacute;gina de manual do
	   &man.bsdlabel.8;.</para></note>

    </sect2>

    <sect2>
      <title>O sistema de arquivos</title>

      <para>Agora o disquete est&aacute; pronto para ser
	  formatado em alto-n&iacute;vel. Isto estabelecer&aacute; um novo
	  sistema de arquivos no disquete, que permitir&aacute; ao
	  FreeBSD ler e gravar nele. Depois de criar um novo
	  sistema de arquivos, o r&oacute;tulo do disquete &eacute; destru&iacute;do,
	  portanto, se voc&ecirc; desejar reformatar o disco ser&aacute; necess&aacute;rio
	  recriar o r&oacute;tulo do disquete.</para>

      <para>O sistema de arquivos do disquete pode ser UFS
	  ou FAT. FAT &eacute; geralmente a melhor escolha para disquetes.</para>

      <para>Para estabelecer um novo sistema de arquivos no disquete, fa&ccedil;a:</para>

      <screen>&prompt.root; <userinput>/sbin/newfs_msdos /dev/fd0</userinput></screen>

      <para>O disquete agora est&aacute; pronto para ser utilizado.</para>
    </sect2>


    <sect2>
      <title>Utilizando o disquete</title>

      <para>Para utilizar o disquete, monte-o como &man.mount.msdos.8;
	  (no 4.X e vers&otilde;es anteiores) ou como &man.mount.msdosfs.8;
	  (no 5.0 e vers&otilde;es superiores).  Pode-se tamb&eacute;m utilizar
	  o <filename role="package">emulators/mtools</filename> da
	  cole&ccedil;&atilde;o de ports.</para>
    </sect2>
  </sect1>

  <sect1 id="backups-tapebackups">
    <title>Criando e utilizando fitas DAT</title>

    <indexterm><primary>tape media</primary></indexterm>
    <para>As principais m&iacute;dias de fitas s&atilde;o 4mm, 8mm, QIC, mini-cartucho e
      DLT.</para>

    <sect2 id="backups-tapebackups-4mm">
      <title>4mm (DDS: Digital Data Storage)</title>

      <indexterm>
        <primary>tape media</primary>
	<secondary>DDS (4mm) tapes</secondary>
      </indexterm>
      <indexterm>
        <primary>tape media</primary>
	<secondary>QIC tapes</secondary>
      </indexterm>
      <para>As fitas 4mm est&atilde;o substituindo as QIC na escolha de m&iacute;dias
        para backups em esta&ccedil;&otilde;es de trabalho.  Est&aacute; tend&ecirc;ncia cresce
	de maneira acelerada devido a compra da Archive pela Conner,
	fabricante l&iacute;der de controladoras QIC, e pela parada na produ&ccedil;&atilde;o
	de controladoreas QIC.  As controladoras 4mm s&atilde;o menores e mais
	silenciosas por&eacute;m n&atilde;o possuem a reputa&ccedil;&atilde;o da confiabilidade
	que &eacute; dada as controladoras 8mm.  Os cartuchos s&atilde;o mais baratos
	e menores (3 x 2 x 0.5 polegadas, 76 x 51 x 12 mm)
	que os cartuchos 8mm.  As fitas 4mm, como as 8mm, tem
	comparativamente o mesmo tempo de vida no cabe&ccedil;ote de
	leitura e grava&ccedil;&atilde;o, ambas usam <foreignphrase>helical
	scan</foreignphrase>.</para>

      <para>As taxas de transfer&ecirc;ncias nestas controladoras iniciam em
      	~150&nbsp;kB/s, chegando a ~500&nbsp;kB/s.
	Sua capacidade inicia em 1.3&nbsp;GB chegando at&eacute; 2.0&nbsp;GB.  Compress&atilde;o
	de Hardware est&aacute; dispon&iacute;vel para a maioria destas controladoras,
	o que chega a aproximadamente dobrar a capacidade.  Uma controladora
	com m&uacute;ltiplas unidades pode ter at&eacute; 6 controladoras em um &uacute;nico gabinete
	com mudan&ccedil;a de fita autom&aacute;tica.  Tendo capacidade no alcance de
	240&nbsp;GB.</para>

      <para>O padr&atilde;o DDS-3 agora suporta fitas com capacidade
        maiores que 12&nbsp;GB (ou 24&nbsp;GB com compress&atilde;o).</para>

      <para>As controladoras 4mm, assim  como as 8mm, utilizam <foreignphrase>
        helical-scan</foreignphrase>.  Todos os benef&iacute;cios e desvatangens disso
	est&atilde;o aplicados em ambas as controladoras, 4mm e 8mm.</para>

      <para>As fitas devem ser inutilizadas ap&oacute;s 2,000 passagens ou
        100 backups completos.</para>
    </sect2>

    <sect2 id="backups-tapebackups-8mm">
      <title>8mm (Exabyte)</title>
      <indexterm>
        <primary>tape media</primary>
	<secondary>Exabyte (8mm) tapes</secondary>
      </indexterm>

      <para>As fitas 8mm s&atilde;o as mais comuns em controladoras de fita
        SCSI; s&atilde;o a melhor escolha para as trocas de fitas.  Quase
	todos possuem uma controladora de fitas Exabyte 2&nbsp;GB 8mm.
	As controladoras 8mm s&atilde;o confi&aacute;veis, convenientes e silenciosas.
	Os cartuchos n&atilde;o s&atilde;o caros e s&atilde;o pequenos (4.8 x 3.3 x 0.6 polegadas;
	122 x 84 x 15 mm).  Um ponto negativo para as controladoras 8mm &eacute;
	a vida curta do cabe&ccedil;ote de leitura e grava&ccedil;&atilde;o e das fitas devido
	a alta frequ&ecirc;ncia de movimenta&ccedil;&atilde;o da fita sobre o cabe&ccedil;ote.</para>

      <para>As taxas de transfer&ecirc;ncias v&atilde;o de ~250&nbsp;kB/s at&eacute; ~500&nbsp;kB/s.
        Tendo capacidade iniciando em 300&nbsp;MB indo at&eacute; 7&nbsp;GB.  Compress&atilde;o
	de Hardware esta dispon&iacute;vel na maioria das controladoras, o que
	aproximadamente dobra a capacidade delas.  Estas controladoras est&atilde;o
	dispon&iacute;veis em unidades ou em multi-controladoras com 6 controladoras e
	120 fitas num &uacute;nico gabinete.  A mudan&ccedil;a de fita &eacute; autom&aacute;tica por unidade.
	Chegando a capacidades no alcance de 840+&nbsp;GB.</para>

      <para>O modelo Exabyte <quote>Mammoth</quote> suporta 12&nbsp;GB em uma
        fita (24&nbsp;GB with compression) e custa aproximadamente duas vezes mais
	que as fitas convencionais.</para>

      <para>Os dados s&atilde;o gravados na fita utilizando <foreignphrase>helical-scan
        </foreignphrase>, as cabe&ccedil;as de leitura e grava&ccedil;&atilde;o s&atilde;o posicionadas
	em um &acirc;ngulo para a m&iacute;dia (aproximadamente 6 graus).  O env&oacute;lucro da fita
	est&aacute; a 270 graus do carretel que segura a cabe&ccedil;a de leitura e grava&ccedil;&atilde;o.  O
	carretel gira enquanto a fita desliza sobre ele.  O resultado &eacute; uma alta
	densidade de dados e trilhas empacotadas bem pr&oacute;ximas na fita de uma
	borda at&eacute; a outra.</para>
    </sect2>

    <sect2 id="backups-tapebackups-qic">
      <title>QIC</title>
      <indexterm>
        <primary>tape media</primary>
	<secondary>QIC-150</secondary>
      </indexterm>

      <para>As fitas e controladoras QIC-150 s&atilde;o, talvez, as mais comuns por ai.
        As controladoras QIC s&atilde;o as mais baratas controladoras de backup consideradas
	<quote>s&eacute;rias</quote>.  O ponto negativo &eacute; o pre&ccedil;o das m&iacute;dias.  Fitas QIC
	s&atilde;o caras se comparadas as 8mm ou 4mm, mais ou menos 5 vezes o pre&ccedil;o
	por GB de dados armazenados.  Mas, se suas necessidades podem ser satisfeitas
	com metade das fitas, QIC pode ser a escolha certa.  QIC &eacute; o tipo
	<emphasis>mais</emphasis> comum de controladora de fitas.  Cada localidade
	possui uma controladora QIC de alguma densidade ou de outra.  Nisso est&aacute;
	a vantagem, QIC tem um n&uacute;mero grande de densidades de fitas fisicamente
	similares (algumas vezes id&ecirc;nticas).  As controladoras QIC n&atilde;o s&atilde;o
	silenciosas.  Estas controladoras buscam audivelmente antes de iniciar
	a grava&ccedil;&atilde;o dos dados e s&atilde;o aud&iacute;veis enquanto est&atilde;o lendo, escrevendo e
	buscando os dados.  As medidas das fitas QIC(6 x 4 x 0.7 polegadas; 15.2 x
	10.2 x 1.7 mm).  <link
	  linkend="backups-tapebackups-mini">Mini-cartridges</link>, que tamb&eacute;m
	  fazem vasto uso de ditas de 1/4" s&atilde;o discutidas separadamente.  N&atilde;o
	  est&atilde;o dispon&iacute;veis multi-controladoras ou troca de fitas autom&aacute;tica.</para>

      <para>As taxas de transfer&ecirc;ncia de dados v&atilde;o de ~150&nbsp;kB/s at&eacute; ~500&nbsp;kB/s.
        A capacidade de armazenamento vai de 40&nbsp;MB at&eacute; 15&nbsp;GB.  Compress&atilde;o
	de Hardware est&aacute; dispon&iacute;vel na maioria das novas controladoras QIC.  As
	controladoras QIC s&atilde;o menos frequentemente instaladas; elas est&atilde;o sendo
	substitu&iacute;das pelas controladoras DAT.</para>

      <para>Os dados s&atilde;o gravados nas fitas em trilhas. As trilhas giram em torno
        da linha central da fita de um final ao outro.  O n&uacute;mero de
	trilhas e consequentemente a largura delas variam com a capacidade
	de armazenamento da fita. A maioria sen&atilde;o todas as controladoras
	prov&ecirc;m compatibilidade com as antigas, pelo menos para leitura (
	e frequentemente para grava&ccedil;&atilde;o tamb&eacute;m).  QIC tem uma boa reputa&ccedil;&atilde;o
	considerando a seguran&ccedil;a dos dados (a mec&acirc;nica &eacute; simples e mais
	robusta que as controladoras com <foreignphrase>helical scan
	</foreignphrase>).</para>

      <para>As fitas devem ser inutilizadas ap&oacute;s 5,000 backups.</para>
    </sect2>

    <sect2 id="backups-tapebackups-mini">
      <title>XXX* Mini-Cartridge ou Mini-Cartucho</title>

      <para></para>
    </sect2>

    <sect2 id="backups-tapebackups-dlt">
      <title>DLT</title>
      <indexterm>
        <primary>tape media</primary>
	<secondary>DLT</secondary>
      </indexterm>

      <para>DLT tem a mais r&aacute;pida taxa de transfer&ecirc;ncia de dados
        de todas as controladoras listadas aqui.  A fita de 1/2" (12.5mm) &eacute; colocada em
	um cartucho de carretel &uacute;nico (4 x 4 x 1 polegadas; 100 x 100 x 25 mm).  O
	cartucho tem uma porta balan&ccedil;ante sobre uma lado todo.  O mecanismo da
	controladora abre esta porta para extrair o l&iacute;der.  O l&iacute;der da fita
	tem um buraco oval que a controladora usa para <quote>enganchar</quote>
	a fita. O carretel auxiliar &eacute; localizado dentro da controladora de fita.
	Todos os outros cartuchos de fita listados aqui (9 fitas de trilhas
	s&atilde;o as &uacute;nicas exce&ccedil;&otilde;es) tem ambos, o carretel de fornecimento e o
	carretel auxiliar localizado dentro do pr&oacute;prio cartucho da fita.</para>

      <para>As taxas de transfer&ecirc;ncia s&atilde;o aproximadamente 1.5&nbsp;MB/s,
        tr&ecirc;s vezes a das controladoras 4mm, 8mm, ou QIC.  A capacidade
	vai de 10&nbsp;GB at&eacute; 20&nbsp;GB para uma &uacute;nica controladora.
	Controladoras multi-fitas e com troca autom&aacute;tica est&atilde;o dispon&iacute;veis
	contendo de 5 a 900 fitas sobre 1 a 20 controladoras, disponibilizando
	de 50&nbsp;GB a 9&nbsp;TB de armazenamento.</para>

      <para>Com compress&atilde;o, o formato DLT Type IV suporta a capacidade de
        70&nbsp;GB.</para>

      <para>Os dados s&atilde;o gravados na fita em trilhas paralelas na dire&ccedil;&atilde;o de viagem
        (assim como em fitas QIC).  Duas trilhas s&atilde;o escritas de uma vez.
	As vida &uacute;til das cabe&ccedil;as de leitura e grava&ccedil;&atilde;o s&atilde;o relativamente longas;
	uma vez que a fita para de mover, n&atilde;o h&aacute; movimenta&ccedil;&atilde;o entre a fita e
	a cabe&ccedil;a de leitura e grava&ccedil;&atilde;o.</para>
    </sect2>

    <sect2>
      <title id="backups-tapebackups-ait">AIT</title>
      <indexterm>
        <primary>tape media</primary>
	<secondary>AIT</secondary>
      </indexterm>

      <para>AIT &eacute; um novo formato da Sony, e pode armazenar 50&nbsp;GB (com
	compress&atilde;o) por fita.  Estas fitas possuem chips de mem&oacute;ria que armazenam
	&iacute;ndices do conte&uacute;do da fita.  Este &iacute;ndice pode ser rapidamente lido
	pela controladora para determinar a posi&ccedil;&atilde;o dos arquivos na fita,
	ao inv&eacute;s dos v&aacute;rios minutos exigidos por outros tipos de controladoras
	de fitas.  Programas como <application>SAMS:Alexandria</application>
	podem opertar quarenta ou mais controladoras AIT, comunicando
	diretamente com os chips de mem&oacute;ria das fitas e apresentando o conte&uacute;do
	na tela, permitindo determinar em que fita os arquivos est&atilde;o,
	localizando a fita correta, carregando ela, e restaurando os dados
	da fita.</para>

      <para>Multi-controladoras como a citada acima custam por volta de
        $20,000, um pre&ccedil;o um pouco fora do mercado hobbista.</para>
    </sect2>

    <sect2>
      <title>Utilizando uma fita nova pela primeira vez</title>

      <para>A primeira vez que voc&ecirc; tenta ler ou escrever em uma
        fita nova, completamente vazia, a opera&ccedil;&atilde;o ir&aacute; falhar. A
	mensagem que voc&ecirc; receber&aacute; ser&aacute; similar a:</para>

      <screen>sa0(ncr1:4:0): NOT READY asc:4,1
sa0(ncr1:4:0):  Logical unit is in process of becoming ready</screen>

      <para>A fita n&atilde;o cont&eacute;m um Bloco Identificador (bloco n&uacute;mero 0).
	Todas as controladoras de fita QIC desde que adotaram o padr&atilde;o
	QIC-525 escrevem um Bloco Identificador na fita.
	H&aacute; duas solu&ccedil;&otilde;es:</para>

      <itemizedlist>
	<listitem>
	  <para><command>mt fsf 1</command> faz a escrita do Bloco Identificador
	  na fita.</para>
	</listitem>

	<listitem>
	  <para>Utilize o bot&atilde;o na frente do painel para ejetar a fita.</para>

	  <para>Reinsira a fita e fa&ccedil;a o <command>dump</command> dos dados
	   para a fita.</para>

	  <para><command>dump</command> reportar&aacute;  <errorname>DUMP: End of tape
	    detected</errorname> e a console mostrar&aacute;: <errorname>HARDWARE
	    FAILURE info:280 asc:80,96</errorname>.</para>

	  <para>Rebobine a fita usando: <command>mt rewind</command>.</para>

	  <para>As opera&ccedil;&otilde;es subsequentes resultar&atilde;o em sucesso.</para>
	</listitem>
      </itemizedlist>

    </sect2>
  </sect1>

  <sect1 id="backups-floppybackups">
    <title>Backups em Disquetes</title>

    <sect2 id="floppies-using">
      <title>Posso utilizar disquetes para realizar backup
      dos meus dados?</title>
      <indexterm><primary>backup floppies</primary></indexterm>
      <indexterm><primary>floppy disks</primary></indexterm>

      <para>Disquetes n&atilde;o s&atilde;o realmente boas m&iacute;dias para backup
	    devido a:</para>

      <itemizedlist>
	<listitem>
	  <para>A m&iacute;dia n&atilde;o &eacute; confi&aacute;vel, especialmente se tem longo
	    tempo de uso.</para>
	</listitem>

	<listitem>
	  <para>Realizar o backup e restaurar os dados &eacute; um
	    processo muito lento.</para>
	</listitem>

	<listitem>
	  <para>Eles tem uma capacidade de armazenamento muito limitada
	    (os dias de realizar um backup de um disco r&iacute;gido inteiro podem
		somar uma d&uacute;zia e uma quantidade enorme de disquetes a medida que
		este tempo passar).</para>
	</listitem>
      </itemizedlist>

      <para>Entretanto, se voc&ecirc; n&atilde;o tiver outra maneira
	   de realizar backup dos seus dados, disquetes
	   s&atilde;o melhores do que nada, ou nenhum backup.</para>

      <para>Se voc&ecirc; tiver que fazer uso de disquetes tenha
	   certeza da boa qualidade deles. Disquetes que foram
	   utilizados por anos no escrit&oacute;rio s&atilde;o uma p&eacute;ssima escolha.
	   Idealmente, use disquetes novos de um fabricante com
	   boa reputa&ccedil;&atilde;o.</para>
    </sect2>

    <sect2 id="floppies-creating">
      <title>Mas, como eu realizo backup dos meus dados em disquetes?</title>

      <para>A melhor maneira de realizar backups em disquetes
	   &eacute; utilizando o &man.tar.1; com a op&ccedil;&atilde;o <option>-M</option> (multi
	   volume), que permitir&aacute; que o backup ocupe m&uacute;ltiplos disquetes.</para>

      <para>Para realizar backup de todos os arquivos no diret&oacute;rio
	    corrente e subdiret&oacute;rios deste, fa&ccedil;a isso
	    (como <username>root</username>):</para>

      <screen>&prompt.root; <userinput>tar Mcvf /dev/fd0 *</userinput></screen>

      <para>Qando o primeiro disquete estiver cheio o &man.tar.1; pedir&aacute;
	  para que voc&ecirc; insira o pr&oacute;ximo volume (devido ao &man.tar.1;
	  fazer com que as m&iacute;dias sejam independentes referindo-se a um
	  volume; neste contexto, volumes s&atilde;o os disquetes).</para>

      <screen>Prepare volume #2 for /dev/fd0 and hit return:</screen>

      <para>Isto se repetir&aacute; (com o n&uacute;mero do volume sendo
	  incrementado) at&eacute; que todos os arquivos especificados
	  estejam arquivados.</para>
    </sect2>

    <sect2 id="floppies-compress">
      <title>Eu posso usar compress&atilde;o em meus backups?</title>
      <indexterm>
        <primary><command>tar</command></primary>
      </indexterm>
      <indexterm>
        <primary><command>gzip</command></primary>
      </indexterm>
      <indexterm><primary>compression</primary></indexterm>

      <para>Desafortunadamente, o &man.tar.1; n&atilde;o permitir&aacute;
	  o uso da op&ccedil;&atilde;o <option>-z</option> com a especifica&ccedil;&atilde;o
	  de arquivos sendo gerados com volumes m&uacute;ltiplos.
	  Voc&ecirc; poderia, claro, usar o &man.gzip.1; em todos
	  os arquivos, e ent&atilde;o usar o &man.tar.1;
	  para arqui&aacute;-los nos disquetes, e ent&atilde;o ao restaurar
	  utilizar o &man.gunzip.1; para obter os arquivos
	  novamente!</para>
    </sect2>

    <sect2 id="floppies-restoring">
      <title>Como eu restauro os dados dos meus backups?</title>

      <para>Para restaurar o arquivo todo use:</para>

      <screen>&prompt.root; <userinput>tar Mxvf /dev/fd0</userinput></screen>

      <para>H&aacute; duas maneiras que podem ser utilizadas
	  para a restaura&ccedil;&atilde;o de um arquivos em espec&iacute;fico.
	  Primeiro, voc&ecirc; precisar iniciar com o primeiro
	  disquete e executar:</para>

      <screen>&prompt.root; <userinput>tar Mxvf /dev/fd0 <replaceable>filename</replaceable></userinput></screen>

      <para>O utilit&aacute;rio &man.tar.1; ir&aacute; pedir a inser&ccedil;&atilde;o
	  dos disquetes subsequentes at&eacute; encontrar o arquivo requerido.</para>

      <para>Alternativamente, se voc&ecirc; sabe em qual disquete o arquivo
	  est&aacute;, voc&ecirc; pode simplesmente inseri-lo na unidade de disquetes
	  e utilizar o comando citado anteriormente. Note que
	  se o arquivo for o primeiro e este ocupar outro disquete o
      &man.tar.1; ir&aacute; alert&aacute;-lo que este n&atilde;o pode ser restaurado,
	  mesmo se voc&ecirc; n&atilde;o tenha pedido para que ele fizesse isso!</para>
    </sect2>
  </sect1>

  <sect1 id="backup-basics">
    <title>Considera&ccedil;&otilde;es b&aacute;sicas sobre backup</title>

    <para>Os tr&ecirc;s mais utilizados programas de backup s&atilde;o
	&man.dump.8;,
	&man.tar.1;,
      e
	&man.cpio.1;.</para>

    <sect2>
      <title>Dump e Restore</title>
      <indexterm>
        <primary>backup software</primary>
	<secondary>dump / restore</secondary>
      </indexterm>
      <indexterm><primary><command>dump</command></primary></indexterm>
      <indexterm><primary><command>restore</command></primary></indexterm>

      <para>Os programas tradicionais de backup do &unix;
	   s&atilde;o o <command>dump</command> e o <command>restore</command>.
	   Eles operam a controladora como se esta fosse uma cole&ccedil;&atilde;o
	   de blocos de discos, abaixo da abstra&ccedil;&atilde;o de arquivos, links
	   e diret&oacute;rios que s&atilde;o criadas pelos sistemas de arquivos. O
	   <command>dump</command> realiza o backup de todo um sistema
	   de arquivos em um dispositivo.  Ele n&atilde;o tem habilidade de
	   realizar backup somente de uma parte de um sistema de arquivos
	   ou uma &aacute;rvore de diret&oacute;rios que envolva mais de um sistema de
	   arquivos.  O <command>dump</command> n&atilde;o grava os arquivos
	   em diret&oacute;rios numa fita, ele grava tudo de maneira direta
	   (raw) em blocos de dados que comp&otilde;e os arquivos e diret&oacute;rios.</para>

      <note><para>Se voc&ecirc; utilizar o <command>dump</command> no
	    seu diret&oacute;rio root, voc&ecirc; n&atilde;o realizaria o backup
		do <filename>/home</filename>,
        <filename>/usr</filename> e muitos outros subdiret&oacute;rios
		desde que estes sejam tipicamente pontos de montagem
		para outros sistemas de arquivos, ou ainda links
		entre estes sistemas de arquivos.</para></note>

      <para>O <command>dump</command> tem uma artimanha que
	  vem desde primeiros dias na Vers&atilde;o 6 do AT&amp;T UNIX
	  (aproximadamente 1975).  Os par&acirc;metros padr&otilde;es s&atilde;o
	  adequados para fitas de 9 trilhas (6250 bpi), n&atilde;o para
	  as m&iacute;dias de alta-densidade dispon&iacute;veis hoje em dia
	  (up to 62,182 ftpi).  Estes padr&otilde;es devem ser
	  sobreescritos na linha de comando para que seja
	  utilizada a capacidade das atuais controladoras
	  de fita.</para>

      <indexterm><primary><filename>.rhosts</filename></primary></indexterm>
      <para>Tamb&eacute;m &eacute; poss&iacute;vel realizar backup dos dados
	    atrav&eacute;s da rede para um dispositivo de backup conectado
		em um outro computador com o <command>rdump</command>
		e o <command>rrestore</command>.  Ambos os programas
		tem sua confian&ccedil;a baseadas no <command>rcmd</command> e
        no <command>ruserok</command> para o acesso
		&agrave; controladora de fita remota.  Portanto,
	    o usu&aacute;rio que ir&aacute; realizar o backup dever&aacute;
		estar listado no arquivo <filename>.rhosts</filename>
		no computador remoto.  Os argumentos para o <command>
		rdump</command> e para o <command>rrestore</command>
		devem ser adequados para o computador remoto.  Quando
		estiver fazendo o <command>rdump</command> de um
		computador com FreeBSD para uma controladora de fita
		Exabyte conectada numa esta&ccedil;&atilde;o Sun chamada
        <hostid>komodo</hostid>, use:</para>

      <screen>&prompt.root; <userinput>/sbin/rdump 0dsbfu 54000 13000 126 komodo:/dev/nsa8 /dev/da0a 2>&amp;1</userinput></screen>

      <para>Cuidado: h&aacute; implica&ccedil;&otilde;es na seguran&ccedil;a do sistema
	    permitir a autentica&ccedil;&atilde;o pelo <filename>.rhosts</filename>.
		Avalie a sua situa&ccedil;&atilde;o cuidadosamente.</para>

      <para>Tamb&eacute;m &eacute; poss&iacute;vel utilizar o <command>dump</command> e o
        <command>restore</command> numa confec&ccedil;&atilde;o mais segura
		atrav&eacute;s do <command>ssh</command>.</para>

      <example>
	<title>Utilizando o <command>dump</command> sobre o <application>ssh</application></title>

	<screen>&prompt.root; <userinput>/sbin/dump -0uan -f - /usr | gzip -2 | ssh1 -c blowfish \
          targetuser@targetmachine.example.com dd of=/mybigfiles/dump-usr-l0.gz</userinput></screen>

      </example>
    </sect2>

    <sect2>
      <title><command>tar</command></title>
      <indexterm>
        <primary>backup software</primary>
        <secondary><command>tar</command></secondary>
      </indexterm>

      <para>O &man.tar.1; tamb&eacute;m tem sua data de volta a Vers&atilde;o
	  6 of AT&amp;T UNIX (aproximadamente 1975).  O <command>tar</command>
	  opera em coopera&ccedil;&atilde;o com o sistema de arquivos; o <command>tar</command>
	  grava os arquivos e diret&oacute;rios na fita. O <command>tar</command>
	  n&atilde;o suporta a gama enorme de op&ccedil;&otilde;es dispon&iacute;veis no &man.cpio.1;, mas
	  o	<command>tar</command> n&atilde;o requere o pouco usual esquema
	  de comandos com redirecionamento
	  que o <command>cpio</command> usa.</para>

      <indexterm><primary><command>tar</command></primary></indexterm>
      <para>A maioria das vers&otilde;es do <command>tar</command>
	  n&atilde;o suportam backups atrav&eacute;s da rede.  A vers&atilde;o GNU do
	  <command>tar</command>, que &eacute; a vers&atilde;o utilizada pelo FreeBSD,
	  suporta dispositivos remotos utilizando a mesma sintaxe
	  do <command>rdump</command>.  Para utilizar o
	  <command>tar</command> de um computador com FreeBSD
	  para uma controladora de fita
	  Exabyte conectada numa esta&ccedil;&atilde;o Sun chamada
	  <hostid>komodo</hostid>, use:</para>

      <screen>&prompt.root; <userinput>/usr/bin/tar cf komodo:/dev/nsa8 . 2>&amp;1</userinput></screen>

      <para>Para as vers&otilde;es sem suporte a dispositivos remotos,
	   &eacute; poss&iacute;vel usar um redirecionamento com o
	   <command>rsh</command> para enviar os dados
	   para uma controladora de fita remota.</para>

      <screen>&prompt.root; <userinput>tar cf - . | rsh <replaceable>hostname</replaceable> dd of=<replaceable>tape-device</replaceable> obs=20b</userinput></screen>

      <para>Se voc&ecirc; est&aacute; preocupado com a seguran&ccedil;a
	    no que envolve realizar backups atrav&eacute;s da rede
		voc&ecirc; deveria utilizar o <command>ssh</command>
	    ao inv&eacute;s do <command>rsh</command>.</para>
    </sect2>

    <sect2>
      <title><command>cpio</command></title>
      <indexterm>
        <primary>backup software</primary>
        <secondary><command>cpio</command></secondary>
      </indexterm>

      <para>O &man.cpio.1; &eacute; o programa original do &unix;
	  para a troca de arquivos entre m&aacute;quinas por meio
	  de m&iacute;dias magn&eacute;ticas. O <command>cpio</command>
	  tem op&ccedil;&otilde;es (entre muitas outras) de realizar
	  <foreignphrase>byte-swapping</foreignphrase>, gravando
	  um bom n&uacute;mero de sistemas de arquivos de diferentes
	  formatos, e permitindo o redirecionamento dos dados
	  para outros programas. Esta &uacute;ltima funcionalidade
	  faz do <command>cpio</command> uma excelente escolha
	  para criar m&iacute;dias de instala&ccedil;&otilde;es. O <command>cpio
	  </command> n&atilde;o sabe como andar nos diret&oacute;rios da
	  &aacute;rvore de diret&oacute;rios e uma lista dos arquivos
	  deve ser passada atrav&eacute;s da <filename>stdin</filename>.</para>
      <indexterm><primary><command>cpio</command></primary></indexterm>

      <para>O<command>cpio</command> n&atilde;o suporta a
	   realiza&ccedil;&atilde;o de backups atrav&eacute;s da rede. Voc&ecirc; pode utilizar
	   um redirecionamento e o <command>rsh</command>
	   para enviar os dados para uma controladora de fita remota.</para>

      <screen>&prompt.root; <userinput>for f in <replaceable>directory_list; do</replaceable></userinput>
<userinput>find $f >> backup.list</userinput>
<userinput>done</userinput>
&prompt.root; <userinput>cpio -v -o --format=newc < backup.list | ssh <replaceable>user</replaceable>@<replaceable>host</replaceable> "cat > <replaceable>backup_device</replaceable>"</userinput></screen>

      <para>Onde o <replaceable>directory_list</replaceable> &eacute; a lista de
	  diret&oacute;rios que voc&ecirc; quer adicionar ao seu backup,
	  <replaceable>user</replaceable>@<replaceable>host</replaceable> &eacute;
	  a combina&ccedil;&atilde;o usu&aacute;rio/computador que ir&aacute; realizar o backup,
	  e <replaceable>backup_device</replaceable> &eacute; onde os
	  backups devem ser escritos (e.g., <filename>/dev/nsa0</filename>).</para>
    </sect2>

    <sect2>
      <title><command>pax</command></title>
      <indexterm>
        <primary>backup software</primary>
        <secondary><command>pax</command></secondary>
      </indexterm>
      <indexterm><primary><command>pax</command></primary></indexterm>
      <indexterm><primary>POSIX</primary></indexterm>
      <indexterm><primary>IEEE</primary></indexterm>

      <para>O &man.pax.1; &eacute; a resposta do IEEE/&posix; para o
	   <command>tar</command> e o <command>cpio</command>.
	   Sobre os anos de v&aacute;rias vers&otilde;es do
	   <command>tar</command> e do <command>cpio</command>
	   est&atilde;o algumas incompatibilidades.  Ent&atilde;o para
	   sair da briga pela padroniza&ccedil;&atilde;o completa deles,
	   o &posix; criou um novo utilit&aacute;rio de arquiva&ccedil;&atilde;o.
	   O <command>pax</command> tenta ler e gravar nos mais
       mais variados formatos tanto do <command>cpio</command>
	   quanto do <command>tar</command>, adicionado novos
	   formatos por si, inclusive. Sua maneira de
	   comandar &eacute; mais semelhante ao <command>cpio</command>
	   que ao <command>tar</command>.</para>
    </sect2>

    <sect2 id="backups-programs-amanda">
      <title><application>Amanda</application></title>
      <indexterm>
        <primary>backup software</primary>
        <secondary><application>Amanda</application></secondary>
      </indexterm>
      <indexterm><primary><application>Amanda</application></primary></indexterm>

      <!-- Remove link until <port> tag is available -->
      <para>O <application>Amanda</application> (Advanced Maryland
        Network Disk Archiver) &eacute; um sistema de backup cliente/servidor,
        melhor que um &uacute;nico programa.  Um servidor <application>Amanda</application>
		ir&aacute; realizar numa &uacute;nica controladora de fita o backup de qualquer n&uacute;mero
		de computadores que tenham o cliente do <application>Amanda</application>
        e uma conex&atilde;o de com o servidor<application>Amanda</application>.
		Um problema comum em locais com um grande n&uacute;mero de discos &eacute; que
		a quantidade de tempo requerida para o backup dos dados
		diretamente na fita excede a quantidade de tempo para a tarefa.
		O <application>Amanda</application> resolve este problema. O
        <application>Amanda</application> pode utilizar um disco auxiliar
		para realizar o backup de diversos sistemas de arquivos ao mesmo tempo.
        O <application>Amanda</application> cria <quote>conjuntos de arquivos
		</quote>: um grupo de fitas utilizadas sobre o tempo para criar
		os bsackups completos de todos os sistemas de arquivos listados
		no arquivo de configura&ccedil;&atilde;o do <application>Amanda</application>.
		O <quote>conjunto de arquivos</quote> tamb&eacute;m pode conter
		backups incrementais (ou diferenciais) noturnos de todos os sistemas
		de arquivos. Para restaurar um sistema de arquivos &eacute; necess&aacute;rio
		o backup completo mais recente e os incrementais.</para>

      <para>O arquivo de configura&ccedil;&otilde;es prov&ecirc; um controle total
	   da realiza&ccedil;&atilde;o dos backups e do tr&aacute;fico de rede que o
       <application>Amanda</application> gera.  O
	   <application>Amanda</application> utilizar&aacute; qualquer
	   um dos programas de backup citados para gravar os dados nas
	   fitas.  O <application>Amanda</application> est&aacute; dispon&iacute;vel tamb&eacute;m
	   como um port ou como pacote, por&eacute;m ele n&atilde;o &eacute; instalado por padr&atilde;o.</para>
      </sect2>

    <sect2>
      <title>N&atilde;o fazer nada</title>

      <para><quote>N&atilde;o fazer nada</quote> n&atilde;o &eacute; um programa de computador
	    mas sim a mais utilizada estrat&eacute;gia de backup.  N&atilde;o h&aacute; custos
		iniciais. N&atilde;o h&aacute; um agendamento de backup a ser cumprido.
		Apenas diga n&atilde;o.  Se alguma coisa acontecer aos seus dados
		d&ecirc; um sorriso malicioso e d&ecirc; cria neles!</para>

      <para>Se seu tempo e seus dados s&atilde;o um pouquinho mais que nada,
	    ent&atilde;o <quote>N&atilde;o fazer nada</quote> &eacute; o mais adequado programa
		de backup para o seus computados.  Mas cuidado,
		o &unix; &eacute; uma ferramenta &uacute;til, voc&ecirc; deve encontrar
		num intervalo de seis meses uma cole&ccedil;&atilde;o de arquivos
		que tenham valor para voc&ecirc;.</para>

      <para><quote>N&atilde;o fazer nada</quote> &eacute; o m&eacute;todo de backup
	    correto para <filename>/usr/obj</filename>
		e outras &aacute;rvores de diret&oacute;rios que podem ser criadas
		exatamente como eram no seu computador.  Um exemplo
		s&atilde;o os arquivos HTML ou &postscript; das vers&otilde;es
		deste Handbook.  Estes documentos foram criados de arquivos
		no formato SGML.  Criar backups deles n&atilde;o &eacute; necess&aacute;rio.
		Os arquivos SGML tem backups realizados regularmente.</para>
    </sect2>

    <sect2>
      <title>Qual o melhor programa de backup?</title>
      <indexterm>
        <primary>LISA</primary>
      </indexterm>

      <para>A <emphasis>vez</emphasis> &eacute; do &man.dump.8;, pelos
	   resultados obtidos do torturantes testes que
	   Elizabeth D. Zwicky fez a todos os programas discutidos aqui.
	   A escolha limpa para preservar todos os seus dados e suas peculiaridades
	   do sistema de arquivos &unix; &eacute; o <command>dump</command>.  Elizabeth
	   criou um sistema de arquivos contendo uma grande variedade de condi&ccedil;&otilde;es
	   n&atilde;o usuais (e algumas nem t&atilde;o pouco usuais assim) e realizou testes
	   em cada um dos programas realizando backup e restaurando o
	   sistema de arquivos criado.  As peculiaridades inclu&iacute;das:
	   arquivos com buracos, arquivos buracos e blocos nulos, arquivos com
	   caracteres engra&ccedil;ados e estranhos em seus nomes, arquivos que
	   n&atilde;o podem ser lidos ou gravados, arquivos de dispositivos,
	   arquivos que mudam de tamanho durante o backup, arquivos que s&atilde;o
	   criados e apagados durante o backup entre outros.  Ela apresentou
	   os resultados na LISA V em outubro de 1991.
	   Visite <ulink
	  url="http://berdmann.dyndns.org/zwicky/testdump.doc.html">torture-testing
	  Backup and Archive Programs</ulink>.</para>
    </sect2>

    <sect2>
      <title>Procedimento de restaura&ccedil;&atilde;o de emerg&ecirc;ncia</title>

      <sect3>
	<title>Antes do disastre</title>

	<para>Existem pelo menos quatro passos que s&atilde;o
	  necess&aacute;rios para preparar caso ocorra
	  um desastre..</para>
	<indexterm>
    <primary><command>disklabel</command></primary>
  </indexterm>

	<para>Primeiro, imprima os r&oacute;tulos de discos de cada um
	  dos discos que voc&ecirc; possui (e.g. <command>disklabel
	  da0 | lpr</command>), sua tabela de sistemas de arquivos
	  (<filename>/etc/fstab</filename>) e todas as
	  mensagens de inicializa&ccedil;&atilde;o, isso tudo em duas c&oacute;pias.</para>

	<indexterm><primary>fix-it floppies</primary></indexterm>
	<para>Segundo, determine quais ser&atilde;o os disquetes de boot
	  e de manuten&ccedil;&atilde;o (<filename>boot.flp</filename>
	  e <filename>fixit.flp</filename>), tendo todos os arquivos
	  para os seus dispositivos.  A maneira mais f&aacute;cil de verificar
	  &eacute; reiniciar sua m&aacute;quina com o disquete de boot na unidade
	  e checar as mensagens emitidas.  Se todos os arquivos
	  de dispositivos s&atilde;o listados e funcionais, passe ao
	  passo tr&ecirc;s.</para>

	<para>Sen&atilde;o, voc&ecirc; ter&aacute; que criar dois disquetes de boot
	  personalizados contendo um kernel que possa montar
	  todos os seus discos e acessar a fita de backup na controladora.
	  Este disquetes devem conter:
	  <command>fdisk</command>, <command>disklabel</command>,
	  <command>newfs</command>, <command>mount</command>, e
	  qualquer programa de backup, de prefer&ecirc;ncia o que voc&ecirc; usa.
	  Este programas dever&atilde;o ser gerados de maneira est&aacute;tica.
	  Se voc&ecirc; utilizar o <command>dump</command>, o disquete dever&aacute;
	  conter o <command>restore</command>.</para>

	<para>Terceiro, crie backups nas fitas regularmente.
	  Qualquer mudan&ccedil;a que for feita ap&oacute;s o &uacute;ltimo backup
	  ser&aacute; perdida. Proteja as fitas de backup ativando
	  a trava contra grava&ccedil;&atilde;o.</para>

	<para>Quanto, teste os disquetes (mesmo o <filename>boot.flp</filename>
	  e o <filename>fixit.flp</filename> ou od dois disquetes de boot
	  personalizados que voc&ecirc; fez no segundo passo.) e as fitas de backup.
	  Tome nota do processo.  Guarde estas notas com o disquete boot&aacute;vel,
	  as etiquetas e as fitas de backup.  Voc&ecirc; poder&aacute; estar t&atilde;o
	  perturbado no momento da restaura&ccedil;&atilde;o que as notas ir&atilde;o prevenir que
	  voc&ecirc; destrua as fitas de backup (Como? no lugar de <command>tar
	  xvf /dev/sa0</command>, voc&ecirc; acidentalmente digita
	  <command>tar cvf /dev/sa0</command> e sobreescreve sua fita de
      backup).</para>

	<para>Para adicionar seguran&ccedil;a ao processo, fa&ccedil;a disquetes
	  inicializ&aacute;veis e duas fitas de backup por vez.  Armazene
	  cada uma delas em locais remotos diferentes.  Um local remoto
	  n&atilde;o &eacute; no subsolo do mesmo pr&eacute;dio.  Um certo n&uacute;mero de empresas
	  no World Trade Center aprendeu esta li&ccedil;&atilde;o do modo mais dif&iacute;cil.
	  Um local remoto deve ser fisicamente separado de computadores
	  e discos por uma dist&acirc;ncia significante.</para>

	<example>
	  <title>Um Script para a cria&ccedil;&atilde;o de disquetes de inicializa&ccedil;&atilde;o</title>

	<programlisting><![ CDATA [#!/bin/sh
#
# Criar um disquete para restaura&ccedil;&atilde;o
#
# Formatar o disquete
#
PATH=/bin:/sbin:/usr/sbin:/usr/bin

fdformat -q fd0
if [ $? -ne 0 ]
then
	 echo "Disquete problem&aacute;tico, insira um novo"
	 exit 1
fi

# Colocar os blocos de boot no disquete
#
disklabel -w -B /dev/fd0c fd1440

#
# Criar a parti&ccedil;&atilde;o no disquete
#
newfs -t 2 -u 18 -l 1 -c 40 -i 5120 -m 5 -o space /dev/fd0a

#
# Montar o novo disquete
#
mount /dev/fd0a /mnt

#
# Criar diret&oacute;rios necess&aacute;rios
#
mkdir /mnt/dev
mkdir /mnt/bin
mkdir /mnt/sbin
mkdir /mnt/etc
mkdir /mnt/root
mkdir /mnt/mnt			# Para a parti&ccedil;&atilde;o root
mkdir /mnt/tmp
mkdir /mnt/var

#
# Popular os diret&oacute;rios
#
if [ ! -x /sys/compile/MINI/kernel ]
then
	 cat << EOM
O kernel MINI n&atilde;o existe, por favor, crie um.
Veja aqui um exemplo para o arquivo de configura&ccedil;&atilde;o:
#
# MINI -- Um kernel para usar o FreeBSD num disquete.
#
machine         "i386"
cpu             "I486_CPU"
ident           MINI
maxusers        5

options         INET                    # needed for _tcp _icmpstat _ipstat
                                        #            _udpstat _tcpstat _udb
options         FFS                     #Berkeley Fast File System
options         FAT_CURSOR              #block cursor in syscons or pccons
options         SCSI_DELAY=15           #Be pessimistic about Joe SCSI device
options         NCONS=2                 #1 virtual consoles
options         USERCONFIG              #Allow user configuration with -c XXX

config          kernel	root on da0 swap on da0 and da1 dumps on da0

device          isa0
device          pci0

device          fdc0	at isa? port "IO_FD1" bio irq 6 drq 2 vector fdintr
device          fd0	at fdc0 drive 0

device          ncr0

device          scbus0

device          sc0	at isa? port "IO_KBD" tty irq 1 vector scintr
device          npx0	at isa? port "IO_NPX" irq 13 vector npxintr

device          da0
device          da1
device          da2

device          sa0

pseudo-device   loop            # required by INET
pseudo-device   gzip            # Exec gzipped a.out's
EOM
	 exit 1
fi

cp -f /sys/compile/MINI/kernel /mnt

gzip -c -best /sbin/init > /mnt/sbin/init
gzip -c -best /sbin/fsck > /mnt/sbin/fsck
gzip -c -best /sbin/mount > /mnt/sbin/mount
gzip -c -best /sbin/halt > /mnt/sbin/halt
gzip -c -best /sbin/restore > /mnt/sbin/restore

gzip -c -best /bin/sh > /mnt/bin/sh
gzip -c -best /bin/sync > /mnt/bin/sync

cp /root/.profile /mnt/root

cp -f /dev/MAKEDEV /mnt/dev
chmod 755 /mnt/dev/MAKEDEV

chmod 500 /mnt/sbin/init
chmod 555 /mnt/sbin/fsck /mnt/sbin/mount /mnt/sbin/halt
chmod 555 /mnt/bin/sh /mnt/bin/sync
chmod 6555 /mnt/sbin/restore

#
# Criar os n&oacute;s de dispositivos
#
cd /mnt/dev
./MAKEDEV std
./MAKEDEV da0
./MAKEDEV da1
./MAKEDEV da2
./MAKEDEV sa0
./MAKEDEV pty0
cd /

#
# Criar a tabela de sistema de arquivos m&iacute;nimo
#
cat > /mnt/etc/fstab <<EOM
/dev/fd0a    /    ufs    rw  1  1
EOM

#
# Criar um arquivo passwd m&iacute;nimo
#
cat > /mnt/etc/passwd <<EOM
root:*:0:0:Charlie &:/root:/bin/sh
EOM

cat > /mnt/etc/master.passwd <<EOM
root::0:0::0:0:Charlie &:/root:/bin/sh
EOM

chmod 600 /mnt/etc/master.passwd
chmod 644 /mnt/etc/passwd
/usr/sbin/pwd_mkdb -d/mnt/etc /mnt/etc/master.passwd

#
# Desmontar o disquete e informar ao usu&aacute;rio
#
/sbin/umount /mnt
echo "O disquete foi desmontado e esta pronto para o uso."]]></programlisting>

        </example>

      </sect3>

      <sect3>
	<title>Ap&oacute;s o disastre</title>

	<para>A quest&atilde;o chave &eacute;: seu equipamento sobreviveu?  Voc&ecirc; tem
	  realizado backups regulares para n&atilde;o se preocupar com
	  problemas de software.</para>

	<para>Se o equipamento foi danificado,
	  as partes danificadas devem ser trocadas
	  antes de tentar usar o computador.</para>

	<para>Se seu equipamento est&aacute; funcional, verifique
	  seus disquetes. Caso voc&ecirc; esteja utilizando um
	  disquete inicializ&aacute;vel personalizado, entre no sistema em modo
	  mono-usu&aacute;rio (digite <literal>-s</literal>
	  no prompt <prompt>boot:</prompt>).  Passe adiante no pr&oacute;ximo
	  par&aacute;grafo.</para>

	<para>Se voc&ecirc; estiver utilizando os disquetes
	  <filename>boot.flp</filename> e <filename>fixit.flp</filename>,
	  continue lendo.  Insira o disquete <filename>boot.flp</filename>
	  na primeira unidade de disquetes e realize o boot
	  no computador.  O menu de instala&ccedil;&atilde;o original
	  aparecer&aacute; na tela.  Selecione  a op&ccedil;&atilde;o <literal>Fixit--Repair mode with CDROM or
	    floppy.</literal>.  Insera o disquete
	  <filename>fixit.flp</filename> quando for solicitado.
	  O <command>restore</command> e outros programas
	  que voc&ecirc; precisa est&atilde;o localizados em <filename>/mnt2/stand</filename>.</para>

	<para>Restaurar cada sistema de arquivos separadamente.</para>

	<indexterm>
    <primary><command>mount</command></primary>
  </indexterm>
	<indexterm><primary>root partition</primary></indexterm>
	<indexterm>
    <primary><command>disklabel</command></primary>
  </indexterm>
	<indexterm>
    <primary><command>newfs</command></primary>
  </indexterm>
	<para>Tente o <command>mount</command> (e.g. <command>mount /dev/da0a
	    /mnt</command>) na parti&ccedil;&atilde;o raiz do seu primeiro disco
		Se o seu r&oacute;tulo de dsico foi danificado, use o
		<command>disklabel</command> para reparticionar
		e rotular o disco da mesma maneira que voc&ecirc; tem salva e
		impressa.  Use o <command>newfs</command> para recriar
		os sistemas de arquivos.  Remonte a parti&ccedil;&atilde;o raiz do
		disquete com direitos de grava&ccedil;&atilde;o(<command>mount -u -o rw
	    /mnt</command>).  Utilize seu programa e fitas de backup
		para restaurar os dados dos sistemas de arquivos
		(e.g. <command>restore vrf
	    /dev/sa0</command>).  Desmonte o sistema de arquivos (e.g. <command>umount
	    /mnt</command>). Repita o processo para cada um dos sistemas
		de arquivos danificados.</para>

	<para>Uma vez que seu sistema est&aacute; em execu&ccedil;&atilde;o,
	  realize backup dos seus dados em novas fitas.
	  Qualquer parada ou perda
	  de dados pode acontecer novamente sem que a causa seja conhecida.
	  Gastar mais uma hora agora pode salv&aacute;-lo do estresse mais
	  tarde.</para>
      </sect3>

<![ %not.published; [

      <sect3>
	<title>* Eu n&atilde;o me preparei para o disastre, e agora?</title>

	<para></para>
      </sect3>
]]>

    </sect2>
  </sect1>

  <sect1 id="disks-virtual">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Marc</firstname>
	  <surname>Fonvieille</surname>
	  <contrib>Reorganizado e melhorado por </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Rede, Mem&oacute;ria, e Sistemas de Arquivos restaurados</title>
    <indexterm><primary>virtual disks</primary></indexterm>
    <indexterm>
      <primary>disks</primary>
      <secondary>virtual</secondary>
    </indexterm>

    <para>Al&eacute;m dos discos que voc&ecirc; insere fisicamente ao seu computador:
      disqutetes, CDs, discos r&iacute;gidos, ou qual seja; outras formas
	  de discos s&atilde;o entendidas pelo FreeBSD - os <firstterm>discos
      virtuais</firstterm>.</para>

    <indexterm><primary>NFS</primary></indexterm>
    <indexterm><primary>Coda</primary></indexterm>
    <indexterm>
      <primary>disks</primary>
      <secondary>memory</secondary>
    </indexterm>
    <para>Insto inclui sistemas de arquivos em rede como o <link
	  linkend="network-nfs">Network File System</link> e o Coda,
	  sistemas de arquivos baseados em mem&oacute;ria e sistema
	  de arquivos em imagens.</para>

    <para>Dependendo da vers&atilde;o de FreeBSD que voc&ecirc; usa, voc&ecirc;
	  ter&aacute; que utilizar ferramentas diferentes para
	  criar e utilizar sistemas de arquivos em imagens
	  e baseados em mem&oacute;ria.</para>

    <note>
      <para>O usu&aacute;rios do FreeBSD&nbsp;4.X utilizar&atilde;oo &man.MAKEDEV.8;
	    para criar os dispositivos necess&aacute;rios. O FreeBSD&nbsp;5.0
		e vers&otilde;es superiores utilizar&atilde;o o &man.devfs.5;
		para alocar os n&oacute;s de dispositivos de maneira
		transparente para o usu&aacute;rio.</para>
    </note>

    <sect2 id="disks-vnconfig">
      <title>Sistemas de arquivos em arquivo de imagem no FreeBSD&nbsp;4.X</title>
      <indexterm>
        <primary>disks</primary>
        <secondary>file-backed (4.X)</secondary>
      </indexterm>

      <para>O utilit&aacute;rio &man.vnconfig.8; configura e disponibiliza
	    o vnode que &eacute; um dispositivo para pseudo-discos.
		Um <firstterm>vnode</firstterm> &eacute; uma representa&ccedil;&atilde;o de um arquivo
		e &eacute; o foco para a atividade com os arquivos. Isto significa
		que o &man.vnconfig.8; utiliza arquivos arquivos
		para criar e operar sistemas de arquivos.
		Uma das utiliza&ccedil;&otilde;es poss&iacute;veis seria a montagem
		de arquivos de imagens de CDs ou de disquetes.</para>

      <para>Para utilizar o &man.vnconfig.8; voc&ecirc; precisa do
	    suporte &man.vn.4;, para adicion&aacute;-lo ao seu arquivo de
		configura&ccedil;&atilde;o de kernel coloque:</para>

      <programlisting>pseudo-device vn</programlisting>

      <para>Para montar uma imagem de um sistema de arquivos:</para>

      <example>
	<title>Utilizando o vnconfig para montar uma imagem de
	  um sistema de arquivos no FreeBSD&nbsp;4.X</title>

	<screen>&prompt.root; <userinput>vnconfig vn<replaceable>0</replaceable> <replaceable>diskimage</replaceable></userinput>
&prompt.root; <userinput>mount /dev/vn<replaceable>0</replaceable>c <replaceable>/mnt</replaceable></userinput></screen>
      </example>

      <para>Para criar uma nova imagem de sistema de arquivos
	  com o &man.vnconfig.8;:</para>

      <example>
	<title>Criando uma nova imagem de disco com o <command>vnconfig</command></title>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>newimage</replaceable> bs=1k count=<replaceable>5</replaceable>k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>vnconfig -s labels -c vn<replaceable>0</replaceable> <replaceable>newimage</replaceable></userinput>
&prompt.root; <userinput>disklabel -r -w vn<replaceable>0</replaceable> auto</userinput>
&prompt.root; <userinput>newfs vn<replaceable>0</replaceable>c</userinput>
Warning: 2048 sector(s) in last cylinder unallocated
/dev/vn0c:     10240 sectors in 3 cylinders of 1 tracks, 4096 sectors
        5.0MB in 1 cyl groups (16 c/g, 32.00MB/g, 1280 i/g)
super-block backups (for fsck -b #) at:
 32
&prompt.root; <userinput>mount /dev/vn<replaceable>0</replaceable>c <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/vn0c        4927        1     4532     0%    /mnt</screen>
      </example>
    </sect2>

    <sect2 id="disks-mdconfig">
      <title>Sistemas de arquivos em imagem no FreeBSD&nbsp;5.X</title>
      <indexterm>
        <primary>disks</primary>
        <secondary>file-backed (5.X)</secondary>
      </indexterm>

      <para>O utilit&aacute;rio &man.mdconfig.8; &eacute; utilizado para
	    configurar e ativar discos em mem&oacute;ria, &man.md.4; no FreeBSD&nbsp;5.X.
		Para usar o &man.mdconfig.8; voc&ecirc; ter&aacute; que carregar o
		m&oacute;dulo &man.md.4; ou adicionar o suporte no arquivo de
		configura&ccedil;&atilde;o do kernel:</para>

      <programlisting>device md</programlisting>

      <para>O comando &man.mdconfig.8; suporta
	    tr&ecirc;s tipos de discos em mem&oacute;ria: discos de mem&oacute;ria
		alocados com o &man.malloc.9;, discos de mem&oacute;ria utilizando
		um arquivo e espa&ccedil;os de troca.  Um poss&iacute;vel uso &eacute; a montagem
		de arquivos de imagens de disquetes e CDs.</para>

      <para>Para montar um sistema de arquivos existente em
	    um arquivo de imagem:</para>

      <example>
	<title>Usando o <command>mdconfig</command> para montar um
	  arquivo de imagem de um sistema de arquivos no FreeBSD&nbsp;5.X</title>

	<screen>&prompt.root; <userinput>mdconfig -a -t vnode -f <replaceable>diskimage</replaceable> -u <replaceable>0</replaceable></userinput>
&prompt.root; <userinput>mount /dev/md<replaceable>0</replaceable>c <replaceable>/mnt</replaceable></userinput></screen>
      </example>

      <para>Para criar uma nova imagem de sistema de arquivos com o &man.mdconfig.8;:</para>

      <example>
	<title>Criando um novo disco em arquivo de imagem com o <command>mdconfig</command></title>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>newimage</replaceable> bs=1k count=<replaceable>5</replaceable>k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mdconfig -a -t vnode -f <replaceable>newimage</replaceable> -u <replaceable>0</replaceable></userinput>
&prompt.root; <userinput>disklabel -r -w md<replaceable>0</replaceable> auto</userinput>
&prompt.root; <userinput>newfs md<replaceable>0</replaceable>c</userinput>
/dev/md0c: 5.0MB (10240 sectors) block size 16384, fragment size 2048
	using 4 cylinder groups of 1.27MB, 81 blks, 256 inodes.
super-block backups (for fsck -b #) at:
 32, 2624, 5216, 7808
&prompt.root; <userinput>mount /dev/md<replaceable>0</replaceable>c <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/md0c        4846        2     4458     0%    /mnt</screen>
      </example>

      <para>Se voc&ecirc; n&atilde;o especificar o n&uacute;mero da unidade com a
	    op&ccedil;&atilde;o <option>-u</option>, o &man.mdconfig.8;
		utilizar&aacute; o &man.md.4; para selecionar automaticamente
		um dispositivo n&atilde;o utilizado.
	    O nome da unidade alocada ser&aacute; impresso
		na sa&iacute;da padr&atilde;o como o <devicename>md4</devicename>.  Para
		mais detalhes sobre o &man.mdconfig.8;
		visite a p&aacute;gina de manual dele.</para>

      <note><para>Desde o &os;&nbsp;5.1-RELEASE, o
	   utilit&aacute;rio &man.bsdlabel.8; substituiu o
	   velho programa &man.disklabel.8;.  Com o
	   &man.bsdlabel.8; algumas op&ccedil;&otilde;es e par&acirc;metros
	   obsoletos foram retirados; no exemplo
	   que foi dado a op&ccedil;&atilde;o <option>-r</option>
	   deveria ser removida.  Para mais informa&ccedil;&otilde;es, por favor,
	   visite a p&aacute;gina de manual do &man.bsdlabel.8;.</para></note>

      <para>O utilit&aacute;rio &man.mdconfig.8; &eacute; muito &uacute;til, entretanto
	   ele precisa de diversas linhas de comando para criar um
	   arqivo de imagem de um sistema de arquivos. O
	   FreeBSD&nbsp;5.0 tamb&eacute;m vem com uma ferramenta
	   chamada &man.mdmfs.8;, este programa configura
	   um disco &man.md.4; utilizando o &man.mdconfig.8;,
	   e coloca um sistema de arquivos UFS em uso com o
	   &man.newfs.8;, e monta-o utilizando o &man.mount.8;.
	   Por exemplo, se voc&ecirc; quer criar e montar a mesma imagem
	   de sistema de arquivos citada anteriormente, simplesmente
	   digite como segue abaixo:</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>newimage</replaceable> bs=1k count=<replaceable>5</replaceable>k</userinput>
5120+0 records in
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mdmfs -F <replaceable>newimage</replaceable> -s <replaceable>5</replaceable>m md<replaceable>0</replaceable> <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0        4846    2  4458     0%    /mnt</screen>

      <para>Se voc&ecirc; usar a op&ccedil;&atilde;o <option>md</option> sem um n&uacute;mnero
	  de unidade, o &man.mdmfs.8; utilizar&aacute; o &man.md.4;
	  que com suas funcionalidades selecionar&aacute; automaticamente um
	  dispositivo n&atilde;o utilizado.  Para mais detalhes sobre
	  o &man.mdmfs.8;, por favor, visitem a p&aacute;gina de manual dele.</para>

    </sect2>

    <sect2 id="disks-md-freebsd4">
      <title>Sistemas de arquivos baseados em mem&oacute;ria no FreeBSD&nbsp;4.X</title>
      <indexterm>
        <primary>disks</primary>
        <secondary>memory file system (4.X)</secondary>
      </indexterm>

      <para>O controlador &man.md.4; &eacute; simples, eficiente
	  o suficiente para criar sistemas de arquivos em mem&oacute;ria
	  no FreeBSD&nbsp;4.X. O &man.malloc.9; &eacute; utilizado para
	  alocar mem&oacute;ria.</para>

      <para>Simplesmente, pegue um sistema de arquivos que voc&ecirc; tenha preparado
	  como, por exemplo, o &man.vnconfig.8;, e:</para>

      <example>
	<title>Discos de mem&oacute;ria md no FreeBSD&nbsp;4.X</title>

	<screen>&prompt.root; <userinput>dd if=<replaceable>newimage</replaceable> of=/dev/md<replaceable>0</replaceable></userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mount /dev/md<replaceable>0c</replaceable> <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/md0c        4927        1     4532     0%    /mnt</screen>
      </example>

      <para>Para mais detalhes, por favor, visitem a p&aacute;gina de manual do &man.md.4;.</para>
    </sect2>

    <sect2 id="disks-md-freebsd5">
      <title>Sistemas de arquivos baseados em mem&oacute;ria no FreeBSD&nbsp;5.X</title>
      <indexterm>
        <primary>disks</primary>
        <secondary>memory file system (5.X)</secondary>
      </indexterm>

      <para>As mesmas ferramentas s&atilde;o utilizadas para
	    os discos baseados em mem&oacute;ria e os baseados em arquivos de imagem:
	    &man.mdconfig.8; ou &man.mdmfs.8;.  O armazenamento
		para os sistemas de arquivos baseados em mem&oacute;ria &eacute; alocado
		com o &man.malloc.9;.</para>

      <example>
	<title>Criando um novo disco baseado em mem&oacute;ria com o
	  <command>mdconfig</command></title>

	<screen>&prompt.root; <userinput>mdconfig -a -t malloc -s <replaceable>5</replaceable>m -u <replaceable>1</replaceable></userinput>
&prompt.root; <userinput>newfs -U md<replaceable>1</replaceable></userinput>
/dev/md1: 5.0MB (10240 sectors) block size 16384, fragment size 2048
	using 4 cylinder groups of 1.27MB, 81 blks, 256 inodes.
	with soft updates
super-block backups (for fsck -b #) at:
 32, 2624, 5216, 7808
&prompt.root; <userinput>mount /dev/md<replaceable>1</replaceable> <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4846    2  4458     0%    /mnt</screen>
      </example>

      <example>
	<title>Criando um novo disco baseado em mem&oacute;ria com o
	  <command>mdmfs</command></title>
	<screen>&prompt.root; <userinput>mdmfs -M -s <replaceable>5</replaceable>m md<replaceable>2</replaceable> <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md2        4846    2  4458     0%    /mnt</screen>
      </example>

      <para>Ao inv&eacute;s de utilizar o sistema de arquivos alocado
	  com o &man.malloc.9; &eacute; poss&iacute;vel utilizar swap, para isso
	  apenas substitua a op&ccedil;&atilde;o <option>malloc</option>
	  com <option>swap</option> na linha de comando do
	  &man.mdconfig.8;.  O utilit&aacute;rio &man.mdmfs.8;
	  por padr&atilde;o (sem a op&ccedil;&atilde;o <option>-M</option>) cria um disco
	  baseado em swap.  Para mais detalhes, por favor,
	  visitem a p&aacute;gina de manual do &man.mdconfig.8;
	  e do &man.mdmfs.8;.</para>
    </sect2>

    <sect2>
      <title>Desconectando um disco de mem&oacute;ria do sistema</title>
      <indexterm>
        <primary>disks</primary>
        <secondary>detaching a memory disk</secondary>
      </indexterm>

      <para>Quando um disco baseado em mem&oacute;ria ou um baseado em
	    um arquivo de imagem n&atilde;o &eacute; utilizado, voc&ecirc; deve
		liberar todos os recursos para o sistema.
		A primeira coisa a fazer &eacute; desmontar o sistema de arquivos,
		ent&atilde;o use o &man.mdconfig.8; para desconectar o disco
		do sistema e os recursos ser&atilde;o liberados.</para>

      <para>Por exemplo, para desconectar e liberar os recursos
	     utilizados pelo <filename>/dev/md4</filename>, fa&ccedil;a:</para>

      <screen>&prompt.root; <userinput>mdconfig -d -u <replaceable>4</replaceable></userinput></screen>

      <para>&Eacute; poss&iacute;vel listar informa&ccedil;&otilde;es sobre o dispositivo &man.md.4;
	  configurado utilizando o comando <command>mdconfig
	-l</command>.</para>

      <para>Para o FreeBSD&nbsp;4.X, o &man.vnconfig.8; &eacute; utilizado para
	    desconectar os dispositivos.  Por exemplo, para desconectar
		e liberar todos os recursos utilizados pelo
		<filename>/dev/vn4</filename>, fa&ccedil;a:</para>

      <screen>&prompt.root; <userinput>vnconfig -u vn<replaceable>4</replaceable></userinput></screen>


    </sect2>
  </sect1>

  <sect1 id="snapshots">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Contribui&ccedil;&atilde;o de </contrib>
	</author>
      </authorgroup>
      <!-- 15 JUL 2002 -->
    </sect1info>

    <title>Snapshots de sistemas de arquivos</title>

    <indexterm>
      <primary>file systems</primary>
      <secondary>snapshots</secondary>
    </indexterm>

      <para>O FreeBSD&nbsp;5.0 oferece uma nova funcionalidade
	     em conjunto com o <link linkend="soft-updates">Soft
		 Updates</link>: snapshots de sistemas de arquivos.</para>

      <para>O snapshots permitem ao usu&aacute;rio criar imagens de
	   um sistema de arquivos especificado.
	   Os arquivos de snapshot devem ser criados no
	   sistema de arquivos em que foi executada a a&ccedil;&atilde;o, e um usu&aacute;rio
	   n&atilde;o pode criar mais de 20 snapshots por sistema de arquivos.
	   Snapshots ativos s&atilde;o gravados em superbloco, tornando-os
	   persistentes sobre as opera&ccedil;&otilde;es de desmontar e remontar
	   que ocorrem nas reinicializa&ccedil;&otilde;es do sistema.  Quando um
	   snapshot n&atilde;o &eacute; mais necess&aacute;rio ele pode ser removido com o
	   comando padr&atilde;o &man.rm.1;.  Os snapshots podem ser removidos
	   em qualquer ordem, entretanto, nem todo o espa&ccedil;o deles ser&aacute;
	   adquirido pois outros snapshots possivelmente utilizar&atilde;o
	   parte dos blocos que seriam liberados.</para>

      <para>During initial creation, the <option>schg</option> flag (see the &man.chflags.1; manual page)
	is set to ensure that even <username>root</username> cannot write to the snapshot.
	The &man.unlink.1; command makes an exception for snapshot files
	since it allows them to be removed
	with the <option>schg</option> flag set, so it is not necessary to
	clear the <option>schg</option> flag before removing a snapshot file.</para>

      <para>Snapshots are created with the &man.mount.8; command.  To place
	a snapshot of <filename>/var</filename> in the file
	<filename>/var/snapshot/snap</filename> use the following
	command:</para>

<screen>&prompt.root; <userinput>mount -u -o snapshot /var/snapshot/snap /var</userinput></screen>

      <para>Once a snapshot has been created, they have several
	uses:</para>

      <itemizedlist>
	<listitem>
	  <para>Some administrators will use a snapshot file for backup purposes,
	    because the snapshot can be transfered to CDs or tape.</para>
	</listitem>
	
	<listitem>
	  <para>File integrity, &man.fsck.8; may be ran on the snapshot.
	    Assuming that the file system was clean when it was mounted, you
	    should always get a clean (and unchanging) result.
	    This is essentially what the
	    background &man.fsck.8; process does.</para>
	</listitem>

	<listitem>
	  <para>Run the &man.dump.8; utility on the snapshot.
	    A dump will be returned that is consistent with the
	    file system and the timestamp of the snapshot.  &man.dump.8;
	    can also take a snapshot, create a dump image and then
	    remove the snapshot in one command using the
	    <option>-L</option> flag.</para>
	</listitem>

	<listitem>
	  <para>&man.mount.8; the snapshot as a frozen image of the file system.
	    To &man.mount.8; the snapshot
	    <filename>/var/snapshot/snap</filename> run:</para>

<screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /var/snapshot/snap -u 4</userinput></screen>
<screen>&prompt.root; <userinput>mount -r /dev/md4 /mnt</userinput></screen>

	</listitem>
      </itemizedlist>

      <para>You can now walk the hierarchy of your frozen <filename>/var</filename>
	file system mounted at <filename>/mnt</filename>.  Everything will
	be in the same state it was during the snapshot creation time.
	The only exception is that any earlier snapshots will appear
	as zero length files.  When the use of a snapshot has delimited,
	it can be unmounted with:</para>

<screen>&prompt.root; <userinput>umount /mnt</userinput></screen>
<screen>&prompt.root; <userinput>mdconfig -d -u 4</userinput></screen>

      <para>For more information about <option>softupdates</option> and
	file system snapshots, including technical papers, you can visit
	Marshall Kirk McKusick's website at
	<ulink url="http://www.mckusick.com/">http://www.mckusick.com.</ulink></para>
  </sect1>
  
  <sect1 id="quotas">
    <title>File System Quotas</title>
    <indexterm>
      <primary>accounting</primary>
      <secondary>disk space</secondary>
    </indexterm>
    <indexterm><primary>disk quotas</primary></indexterm>

    <para>Quotas are an optional feature of the operating system that
      allow you to limit the amount of disk space and/or the number of
      files a user or members of a group may allocate on a per-file
      system basis. This is used most often on timesharing systems where
      it is desirable to limit the amount of resources any one user or
      group of users may allocate.  This will prevent one user or group
      of users from consuming all of the available disk space.</para>

    <sect2>
      <title>Configuring Your System to Enable Disk Quotas</title>

      <para>Before attempting to use disk quotas, it is necessary to make
	sure that quotas are configured in your kernel.  This is done by
	adding the following line to your kernel configuration
	file:</para>

      <programlisting>options QUOTA</programlisting>

      <para>The stock <filename>GENERIC</filename> kernel does not have
	this enabled by default, so you will have to configure, build and
	install a custom kernel in order to use disk quotas.  Please refer
	to <xref linkend="kernelconfig"> for more information on kernel
	configuration.</para>

      <para>Next you will need to enable disk quotas in
	<filename>/etc/rc.conf</filename>.  This is done by adding the
	line:</para>

      <programlisting>enable_quotas="YES"</programlisting>
      <indexterm>
        <primary>disk quotas</primary>
        <secondary>checking</secondary>
      </indexterm>
      <para>For finer control over your quota startup, there is an
	additional configuration variable available. Normally on bootup,
	the quota integrity of each file system is checked by the
	&man.quotacheck.8; program.  The
	&man.quotacheck.8; facility insures that the data in
	the quota database properly reflects the data on the file system.
	This is a very time consuming process that will significantly
	affect the time your system takes to boot. If you would like to
	skip this step, a variable in <filename>/etc/rc.conf</filename>
	is made available for the purpose:</para>

      <programlisting>check_quotas="NO"</programlisting>

      <para>If you are running FreeBSD prior to 3.2-RELEASE, the
	configuration is simpler, and consists of only one variable.  Set
	the following in your <filename>/etc/rc.conf</filename>:</para>

      <programlisting>check_quotas="YES"</programlisting>

      <para>Finally you will need to edit <filename>/etc/fstab</filename>
	to enable disk quotas on a per-file system basis.  This is where
	you can either enable user or group quotas or both for all of your
	file systems.</para>

      <para>To enable per-user quotas on a file system, add the
	<option>userquota</option> option to the options field in the
	<filename>/etc/fstab</filename> entry for the file system you want
	to enable quotas on.  For example:</para>

      <programlisting>/dev/da1s2g   /home    ufs rw,userquota 1 2</programlisting>

      <para>Similarly, to enable group quotas, use the
	<option>groupquota</option> option instead of
	<option>userquota</option>.  To enable both user and
	group quotas, change the entry as follows:</para>

      <programlisting>/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2</programlisting>

      <para>By default, the quota files are stored in the root directory of
	the file system with the names <filename>quota.user</filename> and
	<filename>quota.group</filename> for user and group quotas
	respectively.  See &man.fstab.5; for more
	information.  Even though the &man.fstab.5; manual page says that
	you can specify
	an alternate location for the quota files, this is not recommended
	because the various quota utilities do not seem to handle this
	properly.</para>

      <para>At this point you should reboot your system with your new
	kernel.  <filename>/etc/rc</filename> will automatically run the
	appropriate commands to  create the initial quota files for all of
	the quotas you enabled in <filename>/etc/fstab</filename>, so
	there is no need to manually create any zero length quota
	files.</para>

      <para>In the normal course of operations you should not be required
	to run the &man.quotacheck.8;,
	&man.quotaon.8;, or &man.quotaoff.8;
	commands manually.  However, you may want to read their manual pages
	just to be familiar with their operation.</para>
    </sect2>

    <sect2>
      <title>Setting Quota Limits</title>
      <indexterm>
        <primary>disk quotas</primary>
        <secondary>limits</secondary>
      </indexterm>

      <para>Once you have configured your system to enable quotas, verify
	that they really are enabled.  An easy way to do this is to
	run:</para>

      <screen>&prompt.root; <userinput>quota -v</userinput></screen>

      <para>You should see a one line summary of disk usage and current
	quota limits for each file system that quotas are enabled
	on.</para>

      <para>You are now ready to start assigning quota limits with the
	&man.edquota.8; command.</para>

      <para>You have several options on how to enforce limits on the
	amount of disk space a user or group may allocate, and how many
	files they may create.  You may limit allocations based on disk
	space (block quotas) or number of files (inode quotas) or a
	combination of both.  Each of these limits are further broken down
	into two categories: hard and soft limits.</para>

      <indexterm><primary>hard limit</primary></indexterm>
      <para>A hard limit may not be exceeded.  Once a user reaches his
	hard limit he may not make any further allocations on the file
	system in question.  For example, if the user has a hard limit of
	500 blocks on a file system and is currently using 490 blocks, the
	user can only allocate an additional 10 blocks.  Attempting to
	allocate an additional 11 blocks will fail.</para>

      <indexterm><primary>soft limit</primary></indexterm>
      <para>Soft limits, on the other hand, can be exceeded for a limited
	amount of time.  This period of time is known as the grace period,
	which is one week by default.  If a user stays over his or her
	soft limit longer than the grace period, the soft limit will
	turn into a hard limit and no further allocations will be allowed.
	When the user drops back below the soft limit, the grace period
	will be reset.</para>

      <para>The following is an example of what you might see when you run
	the &man.edquota.8; command.  When the
	&man.edquota.8; command is invoked, you are placed into
	the editor specified by the <envar>EDITOR</envar> environment
	variable, or in the <application>vi</application> editor if the
	<envar>EDITOR</envar> variable is not set, to allow you to edit
	the quota limits.</para>

      <screen>&prompt.root; <userinput>edquota -u test</userinput></screen>

      <programlisting>Quotas for user test:
/usr: blocks in use: 65, limits (soft = 50, hard = 75)
        inodes in use: 7, limits (soft = 50, hard = 60)
/usr/var: blocks in use: 0, limits (soft = 50, hard = 75)
        inodes in use: 0, limits (soft = 50, hard = 60)</programlisting>

      <para>You will normally see two lines for each file system that has
	quotas enabled.  One line for the block limits, and one line for
	inode limits.  Simply change the value you want updated to modify
	the quota limit.  For example, to raise this user's block limit
	from a soft limit of 50 and a hard limit of 75 to a soft limit of
	500 and a hard limit of 600, change:</para>

      <programlisting>/usr: blocks in use: 65, limits (soft = 50, hard = 75)</programlisting>

      <para>to:</para>

      <programlisting> /usr: blocks in use: 65, limits (soft = 500, hard = 600)</programlisting>

      <para>The new quota limits will be in place when you exit the
	editor.</para>

      <para>Sometimes it is desirable to set quota limits on a range of
	UIDs.  This can be done by use of the <option>-p</option> option
	on the &man.edquota.8; command.  First, assign the
	desired quota limit to a user, and then run
	<command>edquota -p protouser startuid-enduid</command>.  For
	example, if user <username>test</username> has the desired quota
	limits, the following command can be used to duplicate those quota
	limits for UIDs 10,000 through 19,999:</para>

      <screen>&prompt.root; <userinput>edquota -p test 10000-19999</userinput></screen>
	  
      <para>For more information see &man.edquota.8; manual page.</para>
    </sect2>

    <sect2>
      <title>Checking Quota Limits and Disk Usage</title>
      <indexterm>
        <primary>disk quotas</primary>
        <secondary>checking</secondary>
      </indexterm>

      <para>You can use either the &man.quota.1; or the
	&man.repquota.8; commands to check quota limits and
	disk usage.  The &man.quota.1; command can be used to
	check individual user or group quotas and disk usage.  A user
	may only examine his own quota, and the quota of a group he
	is a member of. Only the super-user may view all user and group
	quotas.  The
	&man.repquota.8; command can be used to get a summary
	of all quotas and disk usage for file systems with quotas
	enabled.</para>

      <para>The following is some sample output from the
	<command>quota -v</command> command for a user that has quota
	limits on two file systems.</para>

      <programlisting>Disk quotas for user test (uid 1002):
     Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60</programlisting>

      <indexterm><primary>grace period</primary></indexterm>
      <para>On the <filename>/usr</filename> file system in the above
	example, this user is currently 15 blocks over the soft limit of
	50 blocks and has 5 days of the grace period left.  Note the
	asterisk <literal>*</literal> which indicates that the user is
	currently over his quota limit.</para>

      <para>Normally file systems that the user is not using any disk
	space on will not show up in the output from the
	&man.quota.1; command, even if he has a quota limit
	assigned for that file system.  The <option>-v</option> option
	will display those file systems, such as the
	<filename>/usr/var</filename> file system in the above
	example.</para>
    </sect2>

    <sect2>
      <title>Quotas over NFS</title>
      <indexterm><primary>NFS</primary></indexterm>

      <para>Quotas are enforced by the quota subsystem on the NFS server.
	The &man.rpc.rquotad.8; daemon makes quota information available
	to the &man.quota.1; command on NFS clients, allowing users on
	those machines to see their quota statistics.</para>

      <para>Enable <command>rpc.rquotad</command> in
	<filename>/etc/inetd.conf</filename> like so:</para>

      <programlisting>rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad</programlisting>

      <para>Now restart <command>inetd</command>:</para>

      <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/inetd.pid`</userinput></screen>
    </sect2>
  </sect1>


  <sect1 id="disks-encrypting">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Lucky</firstname>
	  <surname>Green</surname>
	  <contrib>Contributed by </contrib>
	  <affiliation>
	    <address><email>shamrock@cypherpunks.to</email></address>
	  </affiliation>
	</author>
      </authorgroup>
      <!-- 11 MARCH 2003 -->
    </sect1info>

    <title>Encrypting Disk Partitions</title>
    <indexterm>
      <primary>disks</primary>
      <secondary>encrypting</secondary></indexterm>

    <para>FreeBSD offers excellent online protections against
      unauthorized data access.  File permissions and Mandatory
      Access Control (MAC) (see <xref linkend="mac">) help prevent
      unauthorized third-parties from accessing data while the operating
      system is active and the computer is powered up. However,
      the permissions enforced by the operating system are irrelevant if an
      attacker has physical access to a computer and can simply move
      the computer's hard drive to another system to copy and analyze
      the sensitive data.</para>

    <para>Regardless of how an attacker may have come into possession of
      a hard drive or powered-down computer, <application>GEOM Based Disk
      Encryption (gbde)</application> can protect the data on the
      computer's file systems against even highly-motivated attackers
      with significant resources. Unlike cumbersome encryption methods
      that encrypt only individual files, <application>gbde</application>
      transparently encrypts entire file systems. No cleartext ever
      touches the hard drive's platter.</para>

    <sect2>
      <title>Enabling gbde in the Kernel</title>

      <procedure>
	<step>
	  <title>Become <username>root</username></title>

	  <para>Configuring <application>gbde</application> requires
	    super-user privileges.</para>

	  <screen>&prompt.user; <userinput>su -</userinput>
Password:</screen>
	</step>
	
	<step>
	  <title>Verify the Operating System Version</title>

	  <para>&man.gbde.4; requires FreeBSD 5.0 or higher.</para>

	  <screen>&prompt.root; <userinput>uname -r</userinput>
5.0-RELEASE</screen>
	</step>

	<step>
	  <title>Add &man.gbde.4; Support to the Kernel Configuration File</title>

	  <para>Using your favorite text editor, add the following
	    line to your kernel configuration file:</para>

	  <para><literal>options GEOM_BDE</literal></para>

	  <para>Configure, recompile, and install the FreeBSD kernel.
	    This process is described in <xref
	    linkend="kernelconfig">.</para>

	  <para>Reboot into the new kernel.</para>
	</step>
      </procedure>
    </sect2>


    <sect2>
      <title>Preparing the Encrypted Hard Drive</title>

      <para>The following example assumes that you are adding a new hard
	drive to your system that will hold a single encrypted partition.
	This partition will be mounted as <filename>/private</filename>.
	<application>gbde</application> can also be used to encrypt
	<filename>/home</filename> and <filename>/var/mail</filename>, but
	this requires more complex instructions which exceed the scope of
	this introduction.</para>

      <procedure>
	<step>
	  <title>Add the New Hard Drive</title>

	  <para>Install the new drive to the system as explained in <xref
	    linkend="disks-adding">. For the purposes of this example,
	    a new hard drive partition has been added as
	    <devicename>/dev/ad4s1c</devicename>. The
	    <devicename>/dev/ad0s1<replaceable>*</replaceable></devicename>
	    devices represent existing standard FreeBSD partitions on
	    the example system.</para>

	  <screen>&prompt.root; <userinput>ls /dev/ad*</userinput>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4</screen>
	</step>

	<step>
	  <title>Create a Directory to Hold gbde Lock Files</title>

	  <screen>&prompt.root; <userinput>mkdir /etc/gbde</userinput></screen>

	  <para>The <application>gbde</application> lock file contains
	    information that <application>gbde</application> requires to
	    access encrypted partitions. Without access to the lock file,
	    <application>gbde</application> will not be able to decrypt
	    the data contained in the encrypted partition without
	    significant manual intervention which is not supported by the
	    software. Each encrypted partition uses a separate lock
	    file.</para>
	</step>

	<step>
	  <title>Initialize the gbde Partition</title>

	  <para>A <application>gbde</application> partition must be
	    initialized before it can be used. This initialization needs to
	    be performed only once:</para>

	  <screen>&prompt.root; <userinput>gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c</userinput></screen>

	  <para>&man.gbde.8; will open your editor, permitting you to set
	    various configuration options in a template. For use with UFS1
	    or UFS2, set the sector_size to 2048:</para>

	  <programlisting>$<!-- This is not the space you are looking
for-->FreeBSD: src/sbin/gbde/template.txt,v 1.1 2002/10/20 11:16:13 phk Exp $
#
# Sector size is the smallest unit of data which can be read or written.
# Making it too small decreases performance and decreases available space.
# Making it too large may prevent filesystems from working.  512 is the
# minimum and always safe.  For UFS, use the fragment size
#
sector_size     =       2048
[...]
</programlisting>

	  <para>&man.gbde.8; will ask you twice to type the passphrase that
	    should be used to secure the data. The passphrase must be the
	    same both times. <application>gbde</application>'s ability to
	    protect your data depends entirely on the quality of the
	    passphrase that you choose.
	  <footnote>
          <para>For tips on how to select a secure passphrase that is easy
	    to remember, see the <ulink
	    url="http://world.std.com/~reinhold/diceware.html">Diceware
	    Passphrase</ulink> website.</para></footnote></para>

	  <para>The <command>gbde init</command> command creates a lock
	    file for your <application>gbde</application> partition that in
	    this example is stored as
	    <filename>/etc/gbde/ad4s1c</filename>.</para>

	  <caution>
	    <para><application>gbde</application> lock files
	      <emphasis>must</emphasis> be backed up together with the
	      contents of any encrypted partitions. While deleting a lock
	      file alone cannot prevent a determined attacker from
	      decrypting a <application>gbde</application> partition,
	      without the lock file, the legitimate owner will be unable
	      to access the data on the encrypted partition without a
	      significant amount of work that is totally unsupported by
	      &man.gbde.8; and its designer.</para>
	  </caution>
	</step>

	<step>
	  <title>Attach the Encrypted Partition to the Kernel</title>

	  <screen>&prompt.root; <userinput>gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c</userinput></screen>

	  <para> You will be asked to provide the passphrase that you
	    selected during the initialization of the encrypted partition.
	    The new encrypted device will show up in
	    <filename>/dev</filename> as
	    <filename>/dev/device_name.bde</filename>:</para>

	  <screen>&prompt.root; <userinput>ls /dev/ad*</userinput>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde</screen>
	</step>

	<step>
	  <title>Create a File System on the Encrypted Device</title>

	  <para>Once the encrypted device has been attached to the kernel,
	    you can create a file system on the device. To create a file
	    system on the encrypted device, use &man.newfs.8;. Since it is
	    much faster to initialize a new UFS2 file system than it is to
	    initialize the old UFS1 file system, using &man.newfs.8; with
	    the <option>-O2</option> option is recommended.</para>

	  <note><para>The <option>-O2</option> option is the default
	  with &os;&nbsp;5.1-RELEASE and later.</para></note>

	  <screen>&prompt.root; <userinput>newfs -U -O2 /dev/ad4s1c.bde</userinput></screen>

	  <note>
	    <para>The &man.newfs.8; command must be performed on an
	      attached <application>gbde</application> partition which
	      is identified by a
	      <filename><replaceable>*</replaceable>.bde</filename>
	      extension to the device name.</para>
	  </note>
	</step>

	<step>
	  <title>Mount the Encrypted Partition</title>

	  <para>Create a mount point for the encrypted file system.</para>

	  <screen>&prompt.root; <userinput>mkdir /private</userinput></screen>

	  <para>Mount the encrypted file system.</para>

	  <screen>&prompt.root; <userinput>mount /dev/ad4s1c.bde /private</userinput></screen>
	</step>

	<step>
	  <title>Verify That the Encrypted File System is Available</title>

	  <para>The encrypted file system should now be visible to
	    &man.df.1; and be available for use.</para>

	  <screen>&prompt.user; <userinput>df -H</userinput>
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8%    /
/devfs            1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0%    /home
/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private</screen>
	</step>
      </procedure>
    </sect2>

    <sect2>
      <title>Mounting Existing Encrypted File Systems</title>

      <para>After each boot, any encrypted file systems must be
	re-attached to the kernel, checked for errors, and mounted, before
	the file systems can be used. The required commands must be
	executed as user <username>root</username>.</para>

      <procedure>
	<step>
	  <title>Attach the gbde Partition to the Kernel</title>

	  <screen>&prompt.root; <userinput>gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c</userinput></screen>
	  
	  <para>You will be asked to provide the passphrase that you
	    selected during initialization of the encrypted gbde
	    partition.</para>
	</step>

	<step>
	  <title>Check the File System for Errors</title>

	  <para>Since encrypted file systems cannot yet be listed in
	    <filename>/etc/fstab</filename> for automatic mounting, the
	    file systems must be checked for errors by running &man.fsck.8;
	    manually before mounting.</para>

	  <screen>&prompt.root; <userinput>fsck -p -t ffs /dev/ad4s1c.bde</userinput></screen>
	</step>

	<step>
	  <title>Mount the Encrypted File System</title>

	  <screen>&prompt.root; <userinput>mount /dev/ad4s1c.bde /private</userinput></screen>
	  
	  <para>The encrypted file system is now available for use.</para>
	</step>
      </procedure>

      <sect3>
	<title>Automatically Mounting Encrypted Partitions</title>

	<para>It is possible to create a script to automatically attach,
	  check, and mount an encrypted partition, but for security reasons
	  the script should not contain the &man.gbde.8; password. Instead,
	  it is recommended that such scripts be run manually while
	  providing the password via the console or &man.ssh.1;.</para>
      </sect3>
    </sect2>

      <sect2>
	<title>Cryptographic Protections Employed by gbde</title>

	<para>&man.gbde.8; encrypts the sector payload using 128-bit AES in
	  CBC mode.  Each sector on the disk is encrypted with a different
	  AES key. For more information on <application>gbde</application>'s
	  cryptographic design, including how the sector keys are derived
	  from the user-supplied passphrase, see &man.gbde.4;.</para>
      </sect2>

      <sect2>
	<title>Compatibility Issues</title>

	<para>&man.sysinstall.8; is incompatible with
	  <application>gbde</application>-encrypted devices. All
	  <devicename><replaceable>*</replaceable>.bde</devicename> devices must be detached from the
	  kernel before starting &man.sysinstall.8; or it will crash during
	  its initial probing for devices. To detach the encrypted device
	  used in our example, use the following command:</para>
	<screen>&prompt.root; <userinput>gbde detach /dev/ad4s1c</userinput></screen>

      <para>Also note that, as &man.vinum.4; does not use the
	&man.geom.4; subsystem, you cannot use
	<application>gbde</application> with
	<application>vinum</application> volumes.</para>
      </sect2>

  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
